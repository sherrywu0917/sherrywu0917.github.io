{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/image/autobind_console.png","path":"image/autobind_console.png","modified":0,"renderable":0},{"_id":"source/image/callstack.png","path":"image/callstack.png","modified":0,"renderable":0},{"_id":"source/image/codesplit_after1.png","path":"image/codesplit_after1.png","modified":0,"renderable":0},{"_id":"source/image/ch-negotiation.png","path":"image/ch-negotiation.png","modified":0,"renderable":0},{"_id":"source/image/codesplit_before1.png","path":"image/codesplit_before1.png","modified":0,"renderable":0},{"_id":"source/image/debounce_meta.png","path":"image/debounce_meta.png","modified":0,"renderable":0},{"_id":"source/image/deviceTiming.png","path":"image/deviceTiming.png","modified":0,"renderable":0},{"_id":"source/image/heap_1.png","path":"image/heap_1.png","modified":0,"renderable":0},{"_id":"source/image/heap_2_content.png","path":"image/heap_2_content.png","modified":0,"renderable":0},{"_id":"source/image/readonly_console.png","path":"image/readonly_console.png","modified":0,"renderable":0},{"_id":"source/image/rechargeCode.png","path":"image/rechargeCode.png","modified":0,"renderable":0},{"_id":"source/image/memory_0.png","path":"image/memory_0.png","modified":0,"renderable":0},{"_id":"source/image/jsobj_full.jpg","path":"image/jsobj_full.jpg","modified":0,"renderable":0},{"_id":"source/image/rechargeProcess.png","path":"image/rechargeProcess.png","modified":0,"renderable":0},{"_id":"source/image/sitespeed_assets.png","path":"image/sitespeed_assets.png","modified":0,"renderable":0},{"_id":"source/image/sitespeed_coach.png","path":"image/sitespeed_coach.png","modified":0,"renderable":0},{"_id":"source/image/rechargeItem.png","path":"image/rechargeItem.png","modified":0,"renderable":0},{"_id":"source/image/sitespeed_result.png","path":"image/sitespeed_result.png","modified":0,"renderable":0},{"_id":"source/image/sitespeed_domains.png","path":"image/sitespeed_domains.png","modified":0,"renderable":0},{"_id":"source/image/sitespeed_details.png","path":"image/sitespeed_details.png","modified":0,"renderable":0},{"_id":"source/image/sitespeed_pages.png","path":"image/sitespeed_pages.png","modified":0,"renderable":0},{"_id":"source/image/sitespeed_summary.png","path":"image/sitespeed_summary.png","modified":0,"renderable":0},{"_id":"source/image/webp_caniuse.png","path":"image/webp_caniuse.png","modified":0,"renderable":0},{"_id":"source/image/sitespeed_toplist.png","path":"image/sitespeed_toplist.png","modified":0,"renderable":0},{"_id":"source/image/sitespeed_waterfall.png","path":"image/sitespeed_waterfall.png","modified":0,"renderable":0},{"_id":"source/image/微信图片_20181226155821.png","path":"image/微信图片_20181226155821.png","modified":0,"renderable":0},{"_id":"source/image/微信图片_20181226155854.png","path":"image/微信图片_20181226155854.png","modified":0,"renderable":0},{"_id":"source/image/微信图片_20181226162719.png","path":"image/微信图片_20181226162719.png","modified":0,"renderable":0},{"_id":"source/image/微信图片_20181226162712.png","path":"image/微信图片_20181226162712.png","modified":0,"renderable":0},{"_id":"source/image/codesplit_before.png","path":"image/codesplit_before.png","modified":0,"renderable":0},{"_id":"source/image/codesplit_after.png","path":"image/codesplit_after.png","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.2d7529.css","path":"main.2d7529.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.d238ee.js","path":"mobile.d238ee.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.885efe.js","path":"slider.885efe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.2d7529.js","path":"main.2d7529.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.ca3627.woff","path":"fonts/iconfont.ca3627.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b7ae25.ttf","path":"fonts/iconfont.b7ae25.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.59e68b.eot","path":"fonts/iconfont.59e68b.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.dba24b.svg","path":"fonts/iconfont.dba24b.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/ES6-学习.md","hash":"3582f76008e74df56a26e46c2aea4496388e5a52","modified":1552876034359},{"_id":"source/_posts/H5开发遇到的坑.md","hash":"4dcd037f7c8b1d110400f2f4de00d9aa6df07eac","modified":1552876034360},{"_id":"source/_posts/Hello-bingxin.md","hash":"7b1ce8fb94b9ee93eebf145286403a3e23134f16","modified":1552876034360},{"_id":"source/_posts/IOS微信内二维码无法识别问题.md","hash":"9aef3f1a8c60cf3716d7b01e6fba6f00f415a97b","modified":1552876034360},{"_id":"source/_posts/JS函数式编程笔记(上).md","hash":"abbe923b8d52f9a75e6ca798125b9b1891feabae","modified":1552876034360},{"_id":"source/_posts/cmd小工具开发.md","hash":"794bc83442a127adcd79101259e83692e3f91b24","modified":1552876034361},{"_id":"source/_posts/JS函数式编程笔记(下).md","hash":"19763e43f68318401a286111e5f66612f266330b","modified":1552876034360},{"_id":"source/_posts/core-decorators源码简析——debounce.md","hash":"8711e5669f80c9b1b0bc73d28c565c4f43cea61c","modified":1552876034361},{"_id":"source/_posts/core-decorators源码简析——autobind.md","hash":"e786e8b6f2afd9259c356794bb967c76f17f796f","modified":1552876034361},{"_id":"source/_posts/core-decorators源码简析——lazyInitialize.md","hash":"82f68d584df9ce48e28f9b12c96884d6ad50f6c9","modified":1552876034361},{"_id":"source/_posts/core-decorators源码简析——readonly.md","hash":"4b9a71408b56b178a52180c0fb0b53445df35da8","modified":1552876034361},{"_id":"source/_posts/core-decorators源码简析——throttle.md","hash":"77d47d76f9a47e204c521f7dc72749d9a7340e05","modified":1552876034362},{"_id":"source/_posts/css效果.md","hash":"f00f75fcbe1258c1830892e7015b2ff0026d5255","modified":1552876034362},{"_id":"source/_posts/decorator.md","hash":"8886165cfa9640b7b7ffa1bd7b6b978485c030aa","modified":1552876034362},{"_id":"source/_posts/font-face-引入外部字体.md","hash":"df3a56ceaa2f623be93c72b7fe0c12a85e8edfd5","modified":1552876034362},{"_id":"source/_posts/form表单实现文件的下载.md","hash":"39501be698b0a23c1754b75aab9d3bf5e08d2d9c","modified":1552876034362},{"_id":"source/_posts/lottie实践.md","hash":"8ae9bf01496ada5ca6b6af838aaeda2e0f1de32e","modified":1552876034362},{"_id":"source/_posts/hello-world.md","hash":"389b395f2099a4fd4cfe34e52ed14ca41f97de29","modified":1552876034362},{"_id":"source/_posts/npm转盘组件开发.md","hash":"d522cfdccd4423f0bac1d99407ad18d754fafad1","modified":1552876034363},{"_id":"source/_posts/react相关问题.md","hash":"1cf79fecedfa4a7beca20de2cc96d11aa5c0cbe6","modified":1552876034363},{"_id":"source/_posts/react高阶组件.md","hash":"51e1298634d725f07dfefa0d8d0e3abea31dad01","modified":1552876034363},{"_id":"source/_posts/reading-record.md","hash":"8bed45edd563509fea177451a2186c01f6a7cb1c","modified":1553245076475},{"_id":"source/_posts/sass应用.md","hash":"aab4232c3d7f47ef5fa373a3265c902df6fb6ad0","modified":1552876034363},{"_id":"source/_posts/webpack配置.md","hash":"879c32660cfd9e024fad96eb5395e6fb00a0e88c","modified":1552876034364},{"_id":"source/_posts/web浏览器兼容性问题.md","hash":"cdb2dc7c8616f102d32bb7c7143d46359e8955a6","modified":1552876034364},{"_id":"source/_posts/函数式编程的应用.md","hash":"81f9ed24485320b71ffc77f63d1ab37c33ea5102","modified":1552876034364},{"_id":"source/_posts/优化之路.md","hash":"7573bf1a260edc467e8aa2fcba1f9d4fc99282e8","modified":1552876034364},{"_id":"source/_posts/打点实践总结.md","hash":"89453e7ef80aa3bf2cbf200b97e706060c6c296b","modified":1552913985640},{"_id":"source/_posts/分站开发总结.md","hash":"a82a3a2d2fd3def5bb054bbf56b862663649dce8","modified":1552898327357},{"_id":"source/_posts/日常经验积累.md","hash":"1bac7f38a066203a4aa2545c37817f836ecbba84","modified":1552876034365},{"_id":"source/_posts/继承-原型链.md","hash":"951a8d93b6a0740b90ec526a0340429716b816d5","modified":1552876034365},{"_id":"source/_posts/菜鸟优化之路-前端性能测试工具.md","hash":"7cac404868c3d330f0d95cdd053f9150a9553e06","modified":1552876034365},{"_id":"source/_posts/菜鸟优化之路-图片webp-lazyload.md","hash":"bcab30a72883f1c493c6a708c869e052d91e4774","modified":1552876034366},{"_id":"source/_posts/菜鸟优化之路.md","hash":"22cdb75cb3a4254b64acce124faa23c8b8e2ec15","modified":1552876034366},{"_id":"source/image/autobind_console.png","hash":"03cfaa8a94506c23378715162a093c85dd57c3e2","modified":1552876034366},{"_id":"source/image/callstack.png","hash":"3dcd07a53e1b10a8214fde996e8d20f2387400a2","modified":1552876034366},{"_id":"source/image/codesplit_after1.png","hash":"c45b8ef377daae1007799e765c7eafb1c28698e6","modified":1552876034368},{"_id":"source/image/ch-negotiation.png","hash":"0f0ef52766a0421f8c0f0b8d304e07630dbd0193","modified":1552876034367},{"_id":"source/image/codesplit_before1.png","hash":"b4718535d56fd0a48ea797d6b6fb020308cf04c2","modified":1552876034369},{"_id":"source/image/debounce_meta.png","hash":"4408de09d2d60f0db30ea3268ccfe07ad384c6ab","modified":1552876034369},{"_id":"source/image/deviceTiming.png","hash":"f8bf005e301680961e49624f2f359df62d430543","modified":1552876034370},{"_id":"source/image/heap_1.png","hash":"da74c713b1e679105cb003a7a0faac7ee7eb982d","modified":1552876034370},{"_id":"source/image/heap_2_content.png","hash":"1eb59e390056d058739cc94b879d736f3926cf32","modified":1552876034371},{"_id":"source/image/readonly_console.png","hash":"e3414df92d173f0518503f7837479ff01e88ed49","modified":1552876034372},{"_id":"source/image/rechargeCode.png","hash":"34c67247b28d5c7d3b73f9c063da3b6c821db7df","modified":1552876034372},{"_id":"source/image/memory_0.png","hash":"d53fad432e688edd84244d27916ef6ba8d588228","modified":1552876034372},{"_id":"source/image/jsobj_full.jpg","hash":"4aee3fc29522654cc51888a2ad55f6db149b765a","modified":1552876034371},{"_id":"source/image/rechargeProcess.png","hash":"aecccf97af623eeefa0d4e900851ac98530b302c","modified":1552876034373},{"_id":"source/image/sitespeed_assets.png","hash":"0d2be980d8c6843fb2c985ff612081f0774611f5","modified":1552876034373},{"_id":"source/image/sitespeed_coach.png","hash":"a17317348a9a45463e2caa942ac912aefb94053a","modified":1552876034374},{"_id":"source/image/rechargeItem.png","hash":"5e8f041102641c6d9a71e7eebf49df8fa3527a6d","modified":1552876034372},{"_id":"source/image/sitespeed_result.png","hash":"884b410076cbbcf26e0f96270265bea56b87ca8b","modified":1552876034375},{"_id":"source/image/sitespeed_domains.png","hash":"c5133c8b5a4b679c1acedb7d847e3b603be3a13f","modified":1552876034374},{"_id":"source/image/sitespeed_details.png","hash":"a8a666e93c4b02c4b4364b50d5bab1fae2680b61","modified":1552876034374},{"_id":"source/image/sitespeed_pages.png","hash":"ae7cc629a25af1b08a06e5daf02adc9160f973b3","modified":1552876034374},{"_id":"source/image/sitespeed_summary.png","hash":"94d9fedec0e2068b0d394952529a54939c969f35","modified":1552876034375},{"_id":"source/image/webp_caniuse.png","hash":"d9fa367ca2f076447559d55648fe4f30380429c0","modified":1552876034376},{"_id":"source/image/sitespeed_toplist.png","hash":"acf83cc639d82bf0ec292940ae0297e150b82bcb","modified":1552876034375},{"_id":"source/image/sitespeed_waterfall.png","hash":"154fe44847d84299bc7e5f4a21d5f49e5fa4ceeb","modified":1552876034376},{"_id":"source/image/微信图片_20181226155821.png","hash":"585c39f8ffe65df15b53790996e11766da227f3a","modified":1552876034376},{"_id":"source/image/微信图片_20181226155854.png","hash":"0da494c92b75a3832a930347389debb1676b9b90","modified":1552876034376},{"_id":"source/image/微信图片_20181226162719.png","hash":"4e76d829c8bacdc51946d2de18d731e592affe4c","modified":1552876034377},{"_id":"source/image/微信图片_20181226162712.png","hash":"d141c53dae1b8a1fae9082cb7a507a116482e73b","modified":1552876034377},{"_id":"source/image/codesplit_before.png","hash":"ce8f0477cee97c1182fbea0184495772daf7ad77","modified":1552876034369},{"_id":"source/image/codesplit_after.png","hash":"f5af4b96f8bee19190843ba0a29647c0a7bbfa4a","modified":1552876034368},{"_id":"public/content.json","hash":"30bbbdbbfd626859bf86e3e2e6d256e60b3af37e","modified":1553247521354},{"_id":"public/2019/03/18/reading-record/index.html","hash":"d9cf0222568a20f5f5e4f83f9b6c2eceff014ff1","modified":1553248195737},{"_id":"public/2019/03/18/hello-world/index.html","hash":"4936ef1cacab16b1c31192f466ce75c5a935dfdf","modified":1553248195737},{"_id":"public/2019/03/07/打点实践总结/index.html","hash":"1dbc6a589394faa81c6f76cd513ef80d9c0276a2","modified":1553248195737},{"_id":"public/2019/01/29/react相关问题/index.html","hash":"722d3d1a0b94eea5949c35f916afd1b87e909ef2","modified":1553248195738},{"_id":"public/2019/01/28/lottie实践/index.html","hash":"05bbd01c03307ab07b4bd37b6a371db788233dcc","modified":1553248195738},{"_id":"public/2018/12/24/优化之路/index.html","hash":"a5413fd35db7c63cb1d76b7e32e9857e67657ec2","modified":1553248195738},{"_id":"public/2018/10/09/菜鸟优化之路-前端性能测试工具/index.html","hash":"69cd05ad84cc44cc7b7c309f77bb5a3da508243b","modified":1553248195738},{"_id":"public/2018/09/27/菜鸟优化之路-图片webp-lazyload/index.html","hash":"9ff8ab0f89a3cbc96f902c581f98669424e2be17","modified":1553248195738},{"_id":"public/2018/08/24/函数式编程的应用/index.html","hash":"f1018aa67b9f79a937bb1d519e5822e848e06a91","modified":1553248195738},{"_id":"public/2018/08/08/菜鸟优化之路/index.html","hash":"629052d25f3a24203aab71c9b948e3eb30ecb501","modified":1553248195738},{"_id":"public/2018/07/13/JS函数式编程笔记(下)/index.html","hash":"b808a4c6577eab6afc7de3d14d2ad562e735c16b","modified":1553248195738},{"_id":"public/2018/07/02/JS函数式编程笔记(上)/index.html","hash":"d003789573dedfa3d7fcc91813f4c0a82e5c15cc","modified":1553248195738},{"_id":"public/2018/06/25/core-decorators源码简析——throttle/index.html","hash":"0096f64d721af25b1878c152a33f7fe9eaf05ce0","modified":1553248195738},{"_id":"public/2018/06/14/core-decorators源码简析——lazyInitialize/index.html","hash":"4016ea51d051bab504e377c1283ad6e82d1d043c","modified":1553248195738},{"_id":"public/2018/06/13/core-decorators源码简析——debounce/index.html","hash":"dd7c72f88bd60e4be13fc1723a76ba8b44a0dcb8","modified":1553248195738},{"_id":"public/2018/05/31/cmd小工具开发/index.html","hash":"93d32a781e4e3eb3119da7a0e04530d7072819ec","modified":1553248195738},{"_id":"public/2018/04/17/core-decorators源码简析——readonly/index.html","hash":"dd52dcbf2b311257c5d64e3dd1adad79beb08fcc","modified":1553248195738},{"_id":"public/2018/04/12/core-decorators源码简析——autobind/index.html","hash":"ab42ed75f350fa4fdba623a4c52dff7be105abe9","modified":1553248195738},{"_id":"public/2018/04/10/继承-原型链/index.html","hash":"6a914270b2059b0d782222745bd6db58b2340ce7","modified":1553248195738},{"_id":"public/2018/02/09/npm转盘组件开发/index.html","hash":"a42ded0ee73d6a726acaf3f2310639de6241f218","modified":1553248195739},{"_id":"public/2018/02/06/IOS微信内二维码无法识别问题/index.html","hash":"3faec2ccf2c0ef085d874f0d03592d10ff8b572a","modified":1553248195739},{"_id":"public/2018/01/16/decorator/index.html","hash":"6f1afdff4b972e3c26ffa3563a4f7a656fe18970","modified":1553248195739},{"_id":"public/2017/10/30/react高阶组件/index.html","hash":"27e8e6f9c4ee82d05ebd7f33c6eb47e120983151","modified":1553248195739},{"_id":"public/2017/10/19/日常经验积累/index.html","hash":"b4b7e8c4e90df5757208ba9f9fc8f8cdc077f9c0","modified":1553248195739},{"_id":"public/2017/08/28/sass应用/index.html","hash":"9b8703b2809d330e91d9cb0eabf924422c67af96","modified":1553248195739},{"_id":"public/2017/07/27/分站开发总结/index.html","hash":"6056e8199adbf7b1eb46fbff321dbfa0bd5146d8","modified":1553248195739},{"_id":"public/2017/06/30/css效果/index.html","hash":"5e87591b000ab2ba609052fe8ea4c521961e9a07","modified":1553248195739},{"_id":"public/2017/06/27/webpack配置/index.html","hash":"56758129a8d8bb36b632121ade38676a97608e57","modified":1553248195739},{"_id":"public/2017/06/15/web浏览器兼容性问题/index.html","hash":"2a7dcd913a03d18e6fcbd07f805efe648a211135","modified":1553248195739},{"_id":"public/2017/06/15/form表单实现文件的下载/index.html","hash":"219bc850de4afcdbaf8f106405da76686a0161f6","modified":1553248195739},{"_id":"public/2017/06/15/font-face-引入外部字体/index.html","hash":"6f30c7cd3d32e71d5f6da3655916491aba9a9375","modified":1553248195740},{"_id":"public/2017/03/20/ES6-学习/index.html","hash":"64796d44c77d13272c3904196452ef69be0126d7","modified":1553248195740},{"_id":"public/2017/03/16/H5开发遇到的坑/index.html","hash":"0c5e647afa6ad2328db2f45b99bfc21fda43e6c9","modified":1553248195740},{"_id":"public/2017/03/16/Hello-bingxin/index.html","hash":"51ce31bb2c22f6f1d7e18f541c90167be24fefaa","modified":1553248195740},{"_id":"public/index.html","hash":"858d31018a38a96f6aa6d3ac074e234d637ec92f","modified":1553248195740},{"_id":"public/page/2/index.html","hash":"60552c316d0f033e80fa8bae1fb198d28d8851c6","modified":1553248195740},{"_id":"public/page/3/index.html","hash":"7bc065957087f3cbccd51e711f91b6d876acad84","modified":1553248195740},{"_id":"public/page/4/index.html","hash":"6222f13386fd87bb12e92b60526b32a3d1e1adcd","modified":1553248195740},{"_id":"public/archives/index.html","hash":"3afca96617fd2d1b6eb3010d2cfea786c574d341","modified":1553248195740},{"_id":"public/archives/page/2/index.html","hash":"708e9a6823dc8a42d75f5c0bb9c0b5671e2e0351","modified":1553248195740},{"_id":"public/archives/page/3/index.html","hash":"a55bc7bc9ee2e267ce8b72a3e781c359b58cdc25","modified":1553248195741},{"_id":"public/archives/page/4/index.html","hash":"b743ef5fa184288d4dbf9dbb0da65de1549351dc","modified":1553248195741},{"_id":"public/archives/2017/index.html","hash":"1b4caa61d93ce606cb9c3cc79f02e59877dfc422","modified":1553248195741},{"_id":"public/archives/2017/page/2/index.html","hash":"af905f20f148a31bf220a2177b6b76db2be71e5e","modified":1553248195741},{"_id":"public/archives/2017/03/index.html","hash":"e3317cae161e4d3ccc6fa67513762ec86a95a612","modified":1553248195741},{"_id":"public/archives/2017/06/index.html","hash":"87f216135d9f972be6ff7dc7bb71b0ac9283e715","modified":1553248195741},{"_id":"public/archives/2017/07/index.html","hash":"5ca27cc62e0e6973f4aa9dc91b2fe8ad587dd6fc","modified":1553248195741},{"_id":"public/archives/2017/08/index.html","hash":"17cb07235999f4e03aee17197ea743c3cb4aba4e","modified":1553248195741},{"_id":"public/archives/2017/10/index.html","hash":"3e22245e123b06b05b8fa60715ff18507d0b1d8b","modified":1553248195741},{"_id":"public/archives/2018/index.html","hash":"1fad00665661c748ecb3b114977265029c9cbcef","modified":1553248195741},{"_id":"public/archives/2018/page/2/index.html","hash":"d015eb2b2829413f41ce9cb8221aaa734cf6c0e4","modified":1553248195741},{"_id":"public/archives/2018/01/index.html","hash":"aafdbcb9b4dedf45d59c2ae0b571794772420223","modified":1553248195741},{"_id":"public/archives/2018/02/index.html","hash":"507837aa5bdc77946e6f4a2d9b5946e4b8d71255","modified":1553248195741},{"_id":"public/archives/2018/04/index.html","hash":"350fc1fb0d9464840c301f34a385cb7457c22ee0","modified":1553248195742},{"_id":"public/archives/2018/05/index.html","hash":"1f1d46c8451a8c2b7b4e88f59e829ce6c695efec","modified":1553248195742},{"_id":"public/archives/2018/06/index.html","hash":"8f229cb40ace6c9e444771671e46b4ecbe8b742b","modified":1553248195742},{"_id":"public/archives/2018/07/index.html","hash":"b31eda7d6f82674d3a59d13f44aecfbc3b4a2cc1","modified":1553248195742},{"_id":"public/archives/2018/08/index.html","hash":"bea8738181ec1bec5ba10c5af0a01e933e645950","modified":1553248195742},{"_id":"public/archives/2018/09/index.html","hash":"6f164c4b5388d71a1911bd5c590ab314532e6ad8","modified":1553248195742},{"_id":"public/archives/2018/10/index.html","hash":"a00c88cfc4dda4d56fe59929c7879b048587b89a","modified":1553248195742},{"_id":"public/archives/2018/12/index.html","hash":"cf58c79da7799cc849bae992400b7089753ba29e","modified":1553248195742},{"_id":"public/archives/2019/index.html","hash":"e44ee91c3228d5897c9ece2f2e040e35dd79cd0f","modified":1553248195742},{"_id":"public/archives/2019/01/index.html","hash":"c6bf2f94fe59b2785dee08b5c49c0660ca08411d","modified":1553248195742},{"_id":"public/archives/2019/03/index.html","hash":"1bc041a4d1194df4970a0a83e48f6465724a4801","modified":1553248195742},{"_id":"public/tags/es6/index.html","hash":"4514fa1556392ced9d6b4c6ce795223eb1b091b5","modified":1553248195742},{"_id":"public/tags/js/index.html","hash":"3e06a14758c79e8757bf2f7b8c6030b6d7faa0f7","modified":1553248195743},{"_id":"public/tags/总结/index.html","hash":"8839dde3874579158fd7068bed610231804e3d7b","modified":1553248195743},{"_id":"public/tags/函数式编程/index.html","hash":"450cf4109e677728989367b074017d840cde8a5e","modified":1553248195743},{"_id":"public/tags/core-decorators/index.html","hash":"efdb87a800cd31c99142ed89697cce46b873d79e","modified":1553248195743},{"_id":"public/tags/decorator/index.html","hash":"a07903e56a23cada25777d08b3390e3264a07866","modified":1553248195743},{"_id":"public/tags/decorators源码简析——debounce/index.html","hash":"d4ca3d03569cfe3f82fb373d0fdc2e04e8cc9f3d","modified":1553248195743},{"_id":"public/tags/lazyInitialize/index.html","hash":"c9a0aff5e068f34d549a7060f79311b97db7782b","modified":1553248195743},{"_id":"public/tags/readonly/index.html","hash":"876e06958ff451ceefe2af54bf86160cdf391637","modified":1553248195743},{"_id":"public/tags/css/index.html","hash":"da920a21cfc9c858599a59953f3c57a0103cf6a8","modified":1553248195743},{"_id":"public/tags/es7/index.html","hash":"9fd39506c5a04828774f36f9b965d64aaa241f6f","modified":1553248195743},{"_id":"public/tags/font-face/index.html","hash":"4ae51c93c6907fe4b251330c6830dd0f937d0ae8","modified":1553248195743},{"_id":"public/tags/下载/index.html","hash":"a2fde5581affb7fba922c4a3d7bc3eb2ed1caba2","modified":1553248195743},{"_id":"public/tags/兼容/index.html","hash":"0b78f7926e12ce52df94516de5f753a73806d615","modified":1553248195743},{"_id":"public/tags/lottie/index.html","hash":"22e5a479c92c85bc39e004da8540ed4cecc35fde","modified":1553248195743},{"_id":"public/tags/npm包/index.html","hash":"ed27bacc07ee2cbb3b1967dbad545ba2cedfc7b3","modified":1553248195743},{"_id":"public/tags/组件开发/index.html","hash":"301929ddae9c77b0c7ab9b2a42c73e57f1f57380","modified":1553248195743},{"_id":"public/tags/webpack/index.html","hash":"a2736060046d9a68e223a61223605f883ea1e27c","modified":1553248195743},{"_id":"public/tags/前端打包/index.html","hash":"6f1a199239eae02133a28dc2867f3dbaad642860","modified":1553248195743},{"_id":"public/tags/require/index.html","hash":"ae99afbf077dc62213329356cf8e13f63887e2cf","modified":1553248195743},{"_id":"public/tags/继承/index.html","hash":"c59c78070a25edb9ae65f4fbdcbe784913ee8ea9","modified":1553248195743},{"_id":"public/tags/原型链/index.html","hash":"2020d46071bbda6a8936b27673e833bf4463905a","modified":1553248195743},{"_id":"public/tags/autobind/index.html","hash":"b5abcc24fc9ea161698f223eae83a533f578367e","modified":1553248195744},{"_id":"public/tags/react/index.html","hash":"0ca11e4a08ce1a794552d450b43a865fceb8f759","modified":1553248195744},{"_id":"public/tags/高阶组件/index.html","hash":"db4e556ca383bff73892db4d4901f3821404faf2","modified":1553248195744},{"_id":"public/tags/sass/index.html","hash":"59443ae2dff0a50c68cd01155ec4c10c9677702e","modified":1553248195744},{"_id":"public/tags/前端性能优化/index.html","hash":"944e05666315ab08b9fd34e795040a8eadc68abd","modified":1553248195744},{"_id":"public/tags/webp/index.html","hash":"bdb529392df28e450665a247a774a82988870652","modified":1553248195744},{"_id":"public/tags/sitespeed-io/index.html","hash":"1b1638b158e3cfda843a2be41c8b136989564dfc","modified":1553248195744},{"_id":"public/image/autobind_console.png","hash":"03cfaa8a94506c23378715162a093c85dd57c3e2","modified":1553247521384},{"_id":"public/image/callstack.png","hash":"3dcd07a53e1b10a8214fde996e8d20f2387400a2","modified":1553247521384},{"_id":"public/image/codesplit_after1.png","hash":"c45b8ef377daae1007799e765c7eafb1c28698e6","modified":1553247521384},{"_id":"public/image/ch-negotiation.png","hash":"0f0ef52766a0421f8c0f0b8d304e07630dbd0193","modified":1553247521384},{"_id":"public/image/codesplit_before1.png","hash":"b4718535d56fd0a48ea797d6b6fb020308cf04c2","modified":1553247521384},{"_id":"public/image/debounce_meta.png","hash":"4408de09d2d60f0db30ea3268ccfe07ad384c6ab","modified":1553247521384},{"_id":"public/image/readonly_console.png","hash":"e3414df92d173f0518503f7837479ff01e88ed49","modified":1553247521384},{"_id":"public/image/heap_2_content.png","hash":"1eb59e390056d058739cc94b879d736f3926cf32","modified":1553247521384},{"_id":"public/image/rechargeCode.png","hash":"34c67247b28d5c7d3b73f9c063da3b6c821db7df","modified":1553247521385},{"_id":"public/image/heap_1.png","hash":"da74c713b1e679105cb003a7a0faac7ee7eb982d","modified":1553247521385},{"_id":"public/image/rechargeProcess.png","hash":"aecccf97af623eeefa0d4e900851ac98530b302c","modified":1553247521385},{"_id":"public/image/rechargeItem.png","hash":"5e8f041102641c6d9a71e7eebf49df8fa3527a6d","modified":1553247521385},{"_id":"public/image/sitespeed_details.png","hash":"a8a666e93c4b02c4b4364b50d5bab1fae2680b61","modified":1553247521385},{"_id":"public/image/sitespeed_pages.png","hash":"ae7cc629a25af1b08a06e5daf02adc9160f973b3","modified":1553247521385},{"_id":"public/image/sitespeed_summary.png","hash":"94d9fedec0e2068b0d394952529a54939c969f35","modified":1553247521385},{"_id":"public/image/sitespeed_toplist.png","hash":"acf83cc639d82bf0ec292940ae0297e150b82bcb","modified":1553247521385},{"_id":"public/image/webp_caniuse.png","hash":"d9fa367ca2f076447559d55648fe4f30380429c0","modified":1553247521385},{"_id":"public/image/微信图片_20181226155821.png","hash":"585c39f8ffe65df15b53790996e11766da227f3a","modified":1553247521385},{"_id":"public/image/微信图片_20181226155854.png","hash":"0da494c92b75a3832a930347389debb1676b9b90","modified":1553247521385},{"_id":"public/image/微信图片_20181226162719.png","hash":"4e76d829c8bacdc51946d2de18d731e592affe4c","modified":1553247521385},{"_id":"public/image/微信图片_20181226162712.png","hash":"d141c53dae1b8a1fae9082cb7a507a116482e73b","modified":1553247521385},{"_id":"public/image/deviceTiming.png","hash":"f8bf005e301680961e49624f2f359df62d430543","modified":1553247521391},{"_id":"public/image/memory_0.png","hash":"d53fad432e688edd84244d27916ef6ba8d588228","modified":1553247521391},{"_id":"public/image/jsobj_full.jpg","hash":"4aee3fc29522654cc51888a2ad55f6db149b765a","modified":1553247521391},{"_id":"public/image/sitespeed_assets.png","hash":"0d2be980d8c6843fb2c985ff612081f0774611f5","modified":1553247521391},{"_id":"public/image/sitespeed_result.png","hash":"884b410076cbbcf26e0f96270265bea56b87ca8b","modified":1553247521391},{"_id":"public/image/sitespeed_coach.png","hash":"a17317348a9a45463e2caa942ac912aefb94053a","modified":1553247521391},{"_id":"public/image/sitespeed_domains.png","hash":"c5133c8b5a4b679c1acedb7d847e3b603be3a13f","modified":1553247521391},{"_id":"public/image/sitespeed_waterfall.png","hash":"154fe44847d84299bc7e5f4a21d5f49e5fa4ceeb","modified":1553247521391},{"_id":"public/image/codesplit_before.png","hash":"ce8f0477cee97c1182fbea0184495772daf7ad77","modified":1553247521407},{"_id":"public/image/codesplit_after.png","hash":"f5af4b96f8bee19190843ba0a29647c0a7bbfa4a","modified":1553247521407},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1489751064000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1489751064000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1489751064000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1489751064000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1489751064000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1489751066000},{"_id":"themes/yilia/_config.yml","hash":"22f40aa04144fa5270d9ca6ce58e29237ae40c24","modified":1539248944000},{"_id":"themes/yilia/README.md","hash":"0becd9c18f9d44fc364788a34a4f3ec82ca7940a","modified":1489751066000},{"_id":"themes/yilia/package.json","hash":"946b26ae0dff42c590068f0a58ecd326ed059b68","modified":1489751066000},{"_id":"themes/yilia/webpack.config.js","hash":"c4dca5c60822c90359e48fad373be768ae9fb43d","modified":1489751068000},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"928f6e340894af80a5070c167b82cac69bb0ea95","modified":1489753120000},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"16c9033891e94fe5e58ea0af0d925519a76eb2c1","modified":1489751160000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1489751064000},{"_id":"themes/yilia/.git/config","hash":"24300cece9d72967ea63724bdb2a8e3c2ac2cc52","modified":1489751064000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1489751034000},{"_id":"themes/yilia/.git/index","hash":"657efd2ae93673e91e76fafa458294b444a1474c","modified":1489751068000},{"_id":"themes/yilia/.git/packed-refs","hash":"ce0fffa24e8426ff1d3cdd215fc2af90b9c41a37","modified":1489751064000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1489751066000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1489751066000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1489751066000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1489751066000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1489751066000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1489751066000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1489751066000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1489751066000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1489751066000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1489751066000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1489751066000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1489751066000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1489751066000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1489751066000},{"_id":"themes/yilia/source/main.2d7529.css","hash":"2eef112e365f9b00664302ba98b517662c75d411","modified":1489751068000},{"_id":"themes/yilia/source/mobile.d238ee.js","hash":"a054884092af1cc5c2c14e5e11a4dac6d9254481","modified":1489751068000},{"_id":"themes/yilia/source/slider.885efe.js","hash":"1f1a6548c6016cc132bf65a1701cc8421a1f8414","modified":1489751068000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1489751066000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1489751068000},{"_id":"themes/yilia/source/main.2d7529.js","hash":"988c141a741441812bcf4c408ef530d7a01522f3","modified":1489751068000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1489751034000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"86b9655a9ebbde13ac8dd5795eb4d5b539edab0f","modified":1489751034000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1489751034000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"42fa41564917b44183a50c4d94bb03e1768ddad8","modified":1489751034000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1489751034000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"b4ad74c989616b7395dc6c9fce9871bb1e86dfb5","modified":1489751034000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1489751034000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1489751034000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1489751034000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1489751034000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"93382152511e40d5cbcd92d2e352134199b6ca6d","modified":1489751064000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"143710485f734c5a997e0b1c26192bbba2982bcc","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"aadab85a35042afdcbce768a32bb9121b0ad1831","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"db8c42ab7e339c240b7044896a3987555ea9b5b8","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2387d91cf94b0b36e8a36841992a5fce63ebd069","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"f5e98b6013c968afb867626ed6617cd1cedc3d3a","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"8c295469bd1602e9d3bbf2fee81ff84cacb1d701","modified":1489751066000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1489751068000},{"_id":"themes/yilia/source/fonts/iconfont.ca3627.woff","hash":"cda0ea1dc25dc3d329d7637afe2cd6aec37e351b","modified":1489751068000},{"_id":"themes/yilia/source/fonts/iconfont.b7ae25.ttf","hash":"697449e7790edd12e208706ecaa8d5d0eed44cde","modified":1489751068000},{"_id":"themes/yilia/source/fonts/iconfont.59e68b.eot","hash":"b7f28dc802d6e32281e8fe7930d4dd2022d00717","modified":1489751068000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1489751068000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1489751068000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1489751068000},{"_id":"themes/yilia/source/fonts/iconfont.dba24b.svg","hash":"3313bf984fbee56b022942a5d19c916b4734fd60","modified":1489751068000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1489751068000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1489751066000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1489751066000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"b750499d5120f963b683d0c96ac3f345c714e448","modified":1489751066000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"ce24ab7049be634c17a163e2db39f1f0b1f7c119","modified":1489751066000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1489751066000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"b68772aa2b47d0ed89ce95d4e9d3d27931fe885c","modified":1489751066000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1489751066000},{"_id":"themes/yilia/source-src/css/duoshuo.scss","hash":"5e3feefbbba70d8da0ec2c75db41762dd4762a81","modified":1489751066000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1489751068000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"d9c1a22a561dc6072833a2f049b3639c0007283d","modified":1489751066000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1489751066000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1489751068000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1489751068000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"40c055e8360973a75db7c13f3280a4f465f9e5e3","modified":1489751068000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0ce6345a86c44e3fea5a4aa439614541112538f3","modified":1489751068000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1489751068000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1489751068000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"12abb65289eed5391d657b963a20f96a473b1cbd","modified":1489751068000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1489751068000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1489751068000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1489751068000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a14f37a57ce7a720a36196f6469d8be955284f8c","modified":1489751068000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1489751068000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1489751068000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1489751068000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1489751068000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"61917c928d09783a3bc8a91503a59ab3a8696e90","modified":1489751068000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1489751068000},{"_id":"themes/yilia/source-src/js/main.js","hash":"d665f4cf30450984591bc8ad2348a1baf720d04b","modified":1489751068000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1489751068000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"17be4f27eb8951835c29dafd0f6ba1b18e47cc6b","modified":1489751068000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1489751068000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1489751068000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1489751068000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"3bf0d70ae171404a0dc73c33ec48927fc2521a54","modified":1489751068000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1489751068000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"808a2e1ed407984cfdc929b827d3638f70ec9a2a","modified":1489751068000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"16c9033891e94fe5e58ea0af0d925519a76eb2c1","modified":1489751064000},{"_id":"themes/yilia/.git/objects/pack/pack-534ed087cd03ab863ae65ee95a84a8f360c77409.idx","hash":"dbd1613680bd52d8b9b532571b41b083dcf3e23a","modified":1489751064000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"c2dccf1a95ec09ceeee5004293ac7edb7e1c9a66","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1489751066000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"341103df70d0b476e3acd0afbc507a4a120d8f5f","modified":1489751066000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1489751066000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1489751066000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1489751066000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1489751066000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1489751066000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"b7f28dc802d6e32281e8fe7930d4dd2022d00717","modified":1489751066000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"cda0ea1dc25dc3d329d7637afe2cd6aec37e351b","modified":1489751066000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"697449e7790edd12e208706ecaa8d5d0eed44cde","modified":1489751066000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1489751068000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1489751068000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1489751068000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"3313bf984fbee56b022942a5d19c916b4734fd60","modified":1489751066000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1489751064000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"93382152511e40d5cbcd92d2e352134199b6ca6d","modified":1489751064000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"93382152511e40d5cbcd92d2e352134199b6ca6d","modified":1489751064000},{"_id":"themes/yilia/.git/objects/pack/pack-534ed087cd03ab863ae65ee95a84a8f360c77409.pack","hash":"b1b64a710e09ed260b4ea2a4c4655e5b7922db77","modified":1489751064000},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1553248195749},{"_id":"public/fonts/iconfont.ca3627.woff","hash":"cda0ea1dc25dc3d329d7637afe2cd6aec37e351b","modified":1553248195749},{"_id":"public/fonts/iconfont.b7ae25.ttf","hash":"697449e7790edd12e208706ecaa8d5d0eed44cde","modified":1553248195749},{"_id":"public/fonts/iconfont.59e68b.eot","hash":"b7f28dc802d6e32281e8fe7930d4dd2022d00717","modified":1553248195749},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1553248195749},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1553248195749},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1553248195749},{"_id":"public/fonts/iconfont.dba24b.svg","hash":"3313bf984fbee56b022942a5d19c916b4734fd60","modified":1553248195749},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1553248195749},{"_id":"public/mobile.d238ee.js","hash":"a054884092af1cc5c2c14e5e11a4dac6d9254481","modified":1553248195769},{"_id":"public/slider.885efe.js","hash":"1f1a6548c6016cc132bf65a1701cc8421a1f8414","modified":1553248195771},{"_id":"public/main.2d7529.css","hash":"2eef112e365f9b00664302ba98b517662c75d411","modified":1553248195771},{"_id":"public/main.2d7529.js","hash":"988c141a741441812bcf4c408ef530d7a01522f3","modified":1553248195771}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"ES6 学习","date":"2017-03-20T11:40:59.000Z","_content":"> from: http://es6.ruanyifeng.com\n\n## let命令\n  - let取代var, let仅在代码块中有效\n  - for循环计数器适合用let\n  - let不存在变量提升\n  - 暂时性死区\n  - 不允许重复声明\n  - 块级作用域（全局作用域、函数作用域）\n\n## const命令\n  - 声明常量\n\n## 顶层对象，在浏览器中指的是window对象\n  - es6的var命令和function命令声明的全局变量依然是顶层对象的属性\n  - let、const、class命令声明的全局变量不属于顶层对象的属性\n\n<!-- more -->\n\n## 数组的解构赋值\n  - 只要某种数据结构有Iterator接口，都可以采用数组形式的解构赋值\n  - 解构可以设置默认值\n  - 对象也可以解构，数组的解构是按次序排列，对象的解构要求变量名必须和对象的属性名相同\n  - 数值和布尔值的解构赋值比较特别，转为了对象\n  - 函数参数也可以解构赋值\n  - 用处：\n      - 交换变量的值\n      - 从函数返回多个值\n      - 函数参数的定义\n      - 提取JSON对象中的数据\n      - 函数参数的默认值\n      - 遍历map解构 ：任何部署了Iterator接口的对象，都可以用for…of循环遍历（Array,String,Set,Map）\n      - 输入模块的指定方法\n\n## Unicode表示字符，可以使用{}\n  - 模板字符串${}\n  - includes, startsWith, endsWith, repeat, padStart, padEnd\n\n## 数值的扩展\n  - isFinite()  isNaN()\n  - 将parseInt()和parseFloat()方法移植到Number对象上，目的是减少全局性方法，使语言逐步模块化\n  - isInteger()\n  - 新增了极小的常量Number.EPSILON\n  - 最大值Number.MAX_SAFE_INTEGER， 最小值Number.MAX_SAFE_INTEGER Number.isSafeInteger()\n\n## 数组的扩展\n  - from方法将类似数组的对象和可遍历的对象转为真正的数组\n``` javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。\n``` javascript\n// NodeList对象\nlet ps = document.querySelectorAll('p');\nArray.from(ps).forEach(function (p) {\n  console.log(p);\n});\n\n// arguments对象\nfunction foo() {\n  var args = Array.from(arguments);\n  // ...\n}\n```\n  - of方法将一组值转换为数组\n\n## 函数的扩展\n  - 可以设置参数的默认值\n  - 函数的length属性返回没有指定默认值的参数个数\n  - reset参数：用于获取函数的多余参数，形式为…变量名，代表一个数组\n``` javascript\n// arguments变量的写法\nfunction sortNumbers() {\n  return Array.prototype.slice.call(arguments).sort();\n}\n\n// rest参数的写法\nconst sortNumbers = (...numbers) => numbers.sort();\n```\n  - 扩展运算符…：好比reset参数的逆运算，将一个数组转为用逗号分隔的参数序列\n    - 替代数组的apply方法\n    ``` javascript\n    // ES5的写法\n    function f(x, y, z) {\n      // ...\n    }\n    var args = [0, 1, 2];\n    f.apply(null, args);\n    \n    // ES6的写法\n    function f(x, y, z) {\n      // ...\n    }\n    var args = [0, 1, 2];\n    f(...args);\n    ```\n    - 合并数组\n    - 与解构赋值结合\n    - 函数的返回值\n    - 任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。\n    ``` javascript\n    var obj = {a: 1, b: 2};\n    let arr = [...obj]; // TypeError: Cannot spread non-iterable object\n    ```\n    - 对于没有iterator接口的对象，使用...语法会报错\n    - 与React中的JSX扩展语法不同\n  - 函数的name属性\n  - 箭头函数=>\n  - 函数绑定运算符是并排的两个双冒号（::），左边是对象，右边是一个函数，返回的还是原对象，可以采用链式写法\n  - “尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存\n\n## 对象的扩展\n\n## Proxy和Refelct\n``` javascript\nvar proxy = new Proxy(target, handler);\n```\nnew Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler也是一个对象，用来定制拦截行为\n``` javascript\nvar proxy = new Proxy({}, {\n  get: function(target, property) {\n    return 35;\n  }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\n```\n### 用处\n1. 属性拦截\n2. 拦截过滤各种操作，如new/defineProperty/delete/getPrototypeOf等\n2. 私有属性模拟\nhas方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。\n``` javascript\nvar handler = {\n  has (target, key) {\n    if (key[0] === '_') {\n      return false;\n    }\n    return key in target;\n  }\n};\nvar target = { _prop: 'foo', prop: 'foo' };\nvar proxy = new Proxy(target, handler);\n'_prop' in proxy // false\n```\n\n## Promise对象\n``` javascript\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\nresolve将Promise对象从Pending变成Resolved\nreject将Promise对象从Pending变成Rejected\n``` javascript\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\nresolve和reject可以将参数传递给then方法里面的回调函数\n\n## Symbol对象属性\n``` javascript\nvar isMoving = Symbol(\"isMoving\");\n...\nif (element[isMoving]) {\n  smoothAnimations(element);\n}\nelement[isMoving] = true;\n```\n- symbol-keyed属性不能通过.操作符来访问，必须使用方括号的方式\n- 判断：if (isMoving in element)\n- 删除：delete element[isMoving]\n- for…in、Object.keys(obj) 和 Object.getOwnPropertyNames(obj)只会遍历到以字符串作为键的属性\n- Object.getOwnPropertySymbols(obj)只会遍历所有的Symbol键\n- Reflect.ownKeys(obj)会返回对象的所有字符串和Symbol键\n\n## Class\n``` javascript\n//定义类\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\nthis关键字代表实例对象。类的方法都是定义在prototype上，与传统的prototype实现的类一致。\n\n``` javascript\nclass Point {\n  // ...\n}\n\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor // true\n```\n上面代码表明，类的数据类型就是function，类本身就指向构造函数。\n\n``` javascript\nclass B {}\nlet b = new B();\n\nb.constructor === B.prototype.constructor // true\nB.prototype.constructor === B //true\n```\n在类的实例上调用方法，其实就是调用原型上的方法。所以b实例的constructor方法就是B类原型的constructor方法。\nprototype对象的constructor属性，直接指向“类”的本身。\n\n``` javascript\nclass Point {\n  \n}\n\nObject.assign(Point.prototype, {\n  toString(){},\n  toValue(){}\n});\n```\n通过Object的assign方法可以一次向Point添加多个方法。\n\n``` javascript\nclass Point {\n  constructor(x, y) {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n}\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。Object.keys这儿用来判断是否可枚举。\n\n## Set集合\n用最简洁的代码实现数组去重：\nES6实现：\n``` javascript\n[...new Set([1,2,3,1,'a',1,'a'])]\n```\nES5实现：\n``` javascript\n[1,2,3,1,'a',1,'a'].filter(function(ele,index,array){\n    return index===array.indexOf(ele)\n})\n```\n","source":"_posts/ES6-学习.md","raw":"---\ntitle: ES6 学习\ndate: 2017-03-20 19:40:59\ntags: [es6, js]\n---\n> from: http://es6.ruanyifeng.com\n\n## let命令\n  - let取代var, let仅在代码块中有效\n  - for循环计数器适合用let\n  - let不存在变量提升\n  - 暂时性死区\n  - 不允许重复声明\n  - 块级作用域（全局作用域、函数作用域）\n\n## const命令\n  - 声明常量\n\n## 顶层对象，在浏览器中指的是window对象\n  - es6的var命令和function命令声明的全局变量依然是顶层对象的属性\n  - let、const、class命令声明的全局变量不属于顶层对象的属性\n\n<!-- more -->\n\n## 数组的解构赋值\n  - 只要某种数据结构有Iterator接口，都可以采用数组形式的解构赋值\n  - 解构可以设置默认值\n  - 对象也可以解构，数组的解构是按次序排列，对象的解构要求变量名必须和对象的属性名相同\n  - 数值和布尔值的解构赋值比较特别，转为了对象\n  - 函数参数也可以解构赋值\n  - 用处：\n      - 交换变量的值\n      - 从函数返回多个值\n      - 函数参数的定义\n      - 提取JSON对象中的数据\n      - 函数参数的默认值\n      - 遍历map解构 ：任何部署了Iterator接口的对象，都可以用for…of循环遍历（Array,String,Set,Map）\n      - 输入模块的指定方法\n\n## Unicode表示字符，可以使用{}\n  - 模板字符串${}\n  - includes, startsWith, endsWith, repeat, padStart, padEnd\n\n## 数值的扩展\n  - isFinite()  isNaN()\n  - 将parseInt()和parseFloat()方法移植到Number对象上，目的是减少全局性方法，使语言逐步模块化\n  - isInteger()\n  - 新增了极小的常量Number.EPSILON\n  - 最大值Number.MAX_SAFE_INTEGER， 最小值Number.MAX_SAFE_INTEGER Number.isSafeInteger()\n\n## 数组的扩展\n  - from方法将类似数组的对象和可遍历的对象转为真正的数组\n``` javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES5的写法\nvar arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n```\n实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。\n``` javascript\n// NodeList对象\nlet ps = document.querySelectorAll('p');\nArray.from(ps).forEach(function (p) {\n  console.log(p);\n});\n\n// arguments对象\nfunction foo() {\n  var args = Array.from(arguments);\n  // ...\n}\n```\n  - of方法将一组值转换为数组\n\n## 函数的扩展\n  - 可以设置参数的默认值\n  - 函数的length属性返回没有指定默认值的参数个数\n  - reset参数：用于获取函数的多余参数，形式为…变量名，代表一个数组\n``` javascript\n// arguments变量的写法\nfunction sortNumbers() {\n  return Array.prototype.slice.call(arguments).sort();\n}\n\n// rest参数的写法\nconst sortNumbers = (...numbers) => numbers.sort();\n```\n  - 扩展运算符…：好比reset参数的逆运算，将一个数组转为用逗号分隔的参数序列\n    - 替代数组的apply方法\n    ``` javascript\n    // ES5的写法\n    function f(x, y, z) {\n      // ...\n    }\n    var args = [0, 1, 2];\n    f.apply(null, args);\n    \n    // ES6的写法\n    function f(x, y, z) {\n      // ...\n    }\n    var args = [0, 1, 2];\n    f(...args);\n    ```\n    - 合并数组\n    - 与解构赋值结合\n    - 函数的返回值\n    - 任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。\n    ``` javascript\n    var obj = {a: 1, b: 2};\n    let arr = [...obj]; // TypeError: Cannot spread non-iterable object\n    ```\n    - 对于没有iterator接口的对象，使用...语法会报错\n    - 与React中的JSX扩展语法不同\n  - 函数的name属性\n  - 箭头函数=>\n  - 函数绑定运算符是并排的两个双冒号（::），左边是对象，右边是一个函数，返回的还是原对象，可以采用链式写法\n  - “尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存\n\n## 对象的扩展\n\n## Proxy和Refelct\n``` javascript\nvar proxy = new Proxy(target, handler);\n```\nnew Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler也是一个对象，用来定制拦截行为\n``` javascript\nvar proxy = new Proxy({}, {\n  get: function(target, property) {\n    return 35;\n  }\n});\n\nproxy.time // 35\nproxy.name // 35\nproxy.title // 35\n```\n### 用处\n1. 属性拦截\n2. 拦截过滤各种操作，如new/defineProperty/delete/getPrototypeOf等\n2. 私有属性模拟\nhas方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。\n``` javascript\nvar handler = {\n  has (target, key) {\n    if (key[0] === '_') {\n      return false;\n    }\n    return key in target;\n  }\n};\nvar target = { _prop: 'foo', prop: 'foo' };\nvar proxy = new Proxy(target, handler);\n'_prop' in proxy // false\n```\n\n## Promise对象\n``` javascript\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\nresolve将Promise对象从Pending变成Resolved\nreject将Promise对象从Pending变成Rejected\n``` javascript\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\nresolve和reject可以将参数传递给then方法里面的回调函数\n\n## Symbol对象属性\n``` javascript\nvar isMoving = Symbol(\"isMoving\");\n...\nif (element[isMoving]) {\n  smoothAnimations(element);\n}\nelement[isMoving] = true;\n```\n- symbol-keyed属性不能通过.操作符来访问，必须使用方括号的方式\n- 判断：if (isMoving in element)\n- 删除：delete element[isMoving]\n- for…in、Object.keys(obj) 和 Object.getOwnPropertyNames(obj)只会遍历到以字符串作为键的属性\n- Object.getOwnPropertySymbols(obj)只会遍历所有的Symbol键\n- Reflect.ownKeys(obj)会返回对象的所有字符串和Symbol键\n\n## Class\n``` javascript\n//定义类\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\nthis关键字代表实例对象。类的方法都是定义在prototype上，与传统的prototype实现的类一致。\n\n``` javascript\nclass Point {\n  // ...\n}\n\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor // true\n```\n上面代码表明，类的数据类型就是function，类本身就指向构造函数。\n\n``` javascript\nclass B {}\nlet b = new B();\n\nb.constructor === B.prototype.constructor // true\nB.prototype.constructor === B //true\n```\n在类的实例上调用方法，其实就是调用原型上的方法。所以b实例的constructor方法就是B类原型的constructor方法。\nprototype对象的constructor属性，直接指向“类”的本身。\n\n``` javascript\nclass Point {\n  \n}\n\nObject.assign(Point.prototype, {\n  toString(){},\n  toValue(){}\n});\n```\n通过Object的assign方法可以一次向Point添加多个方法。\n\n``` javascript\nclass Point {\n  constructor(x, y) {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n}\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。Object.keys这儿用来判断是否可枚举。\n\n## Set集合\n用最简洁的代码实现数组去重：\nES6实现：\n``` javascript\n[...new Set([1,2,3,1,'a',1,'a'])]\n```\nES5实现：\n``` javascript\n[1,2,3,1,'a',1,'a'].filter(function(ele,index,array){\n    return index===array.indexOf(ele)\n})\n```\n","slug":"ES6-学习","published":1,"updated":"2019-03-18T02:27:14.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx5j0000qmhfilnk8jpj","content":"<blockquote>\n<p>from: <a href=\"http://es6.ruanyifeng.com\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com</a></p>\n</blockquote>\n<h2 id=\"let命令\"><a href=\"#let命令\" class=\"headerlink\" title=\"let命令\"></a>let命令</h2><ul>\n<li>let取代var, let仅在代码块中有效</li>\n<li>for循环计数器适合用let</li>\n<li>let不存在变量提升</li>\n<li>暂时性死区</li>\n<li>不允许重复声明</li>\n<li>块级作用域（全局作用域、函数作用域）</li>\n</ul>\n<h2 id=\"const命令\"><a href=\"#const命令\" class=\"headerlink\" title=\"const命令\"></a>const命令</h2><ul>\n<li>声明常量</li>\n</ul>\n<h2 id=\"顶层对象，在浏览器中指的是window对象\"><a href=\"#顶层对象，在浏览器中指的是window对象\" class=\"headerlink\" title=\"顶层对象，在浏览器中指的是window对象\"></a>顶层对象，在浏览器中指的是window对象</h2><ul>\n<li>es6的var命令和function命令声明的全局变量依然是顶层对象的属性</li>\n<li>let、const、class命令声明的全局变量不属于顶层对象的属性</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h2><ul>\n<li>只要某种数据结构有Iterator接口，都可以采用数组形式的解构赋值</li>\n<li>解构可以设置默认值</li>\n<li>对象也可以解构，数组的解构是按次序排列，对象的解构要求变量名必须和对象的属性名相同</li>\n<li>数值和布尔值的解构赋值比较特别，转为了对象</li>\n<li>函数参数也可以解构赋值</li>\n<li>用处：<ul>\n<li>交换变量的值</li>\n<li>从函数返回多个值</li>\n<li>函数参数的定义</li>\n<li>提取JSON对象中的数据</li>\n<li>函数参数的默认值</li>\n<li>遍历map解构 ：任何部署了Iterator接口的对象，都可以用for…of循环遍历（Array,String,Set,Map）</li>\n<li>输入模块的指定方法</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Unicode表示字符，可以使用\"><a href=\"#Unicode表示字符，可以使用\" class=\"headerlink\" title=\"Unicode表示字符，可以使用{}\"></a>Unicode表示字符，可以使用{}</h2><ul>\n<li>模板字符串${}</li>\n<li>includes, startsWith, endsWith, repeat, padStart, padEnd</li>\n</ul>\n<h2 id=\"数值的扩展\"><a href=\"#数值的扩展\" class=\"headerlink\" title=\"数值的扩展\"></a>数值的扩展</h2><ul>\n<li>isFinite()  isNaN()</li>\n<li>将parseInt()和parseFloat()方法移植到Number对象上，目的是减少全局性方法，使语言逐步模块化</li>\n<li>isInteger()</li>\n<li>新增了极小的常量Number.EPSILON</li>\n<li>最大值Number.MAX_SAFE_INTEGER， 最小值Number.MAX_SAFE_INTEGER Number.isSafeInteger()</li>\n</ul>\n<h2 id=\"数组的扩展\"><a href=\"#数组的扩展\" class=\"headerlink\" title=\"数组的扩展\"></a>数组的扩展</h2><ul>\n<li>from方法将类似数组的对象和可遍历的对象转为真正的数组<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5的写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [].slice.call(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6的写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NodeList对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ps = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'p'</span>);</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(ps).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(p);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// arguments对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>of方法将一组值转换为数组</li>\n</ul>\n<h2 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h2><ul>\n<li>可以设置参数的默认值</li>\n<li>函数的length属性返回没有指定默认值的参数个数</li>\n<li><p>reset参数：用于获取函数的多余参数，形式为…变量名，代表一个数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arguments变量的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortNumbers</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>).sort();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// rest参数的写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sortNumbers = <span class=\"function\">(<span class=\"params\">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>扩展运算符…：好比reset参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>\n<ul>\n<li><p>替代数组的apply方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y, z</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">f.apply(<span class=\"literal\">null</span>, args);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y, z</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">f(...args);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>合并数组</p>\n</li>\n<li>与解构赋值结合</li>\n<li>函数的返回值</li>\n<li><p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...obj]; <span class=\"comment\">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于没有iterator接口的对象，使用…语法会报错</p>\n</li>\n<li>与React中的JSX扩展语法不同</li>\n</ul>\n</li>\n<li>函数的name属性</li>\n<li>箭头函数=&gt;</li>\n<li>函数绑定运算符是并排的两个双冒号（::），左边是对象，右边是一个函数，返回的还是原对象，可以采用链式写法</li>\n<li>“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存</li>\n</ul>\n<h2 id=\"对象的扩展\"><a href=\"#对象的扩展\" class=\"headerlink\" title=\"对象的扩展\"></a>对象的扩展</h2><h2 id=\"Proxy和Refelct\"><a href=\"#Proxy和Refelct\" class=\"headerlink\" title=\"Proxy和Refelct\"></a>Proxy和Refelct</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>\n<p>new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler也是一个对象，用来定制拦截行为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function(target, property) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">35</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.time <span class=\"comment\">// 35</span></span><br><span class=\"line\">proxy.name <span class=\"comment\">// 35</span></span><br><span class=\"line\">proxy.title <span class=\"comment\">// 35</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"用处\"><a href=\"#用处\" class=\"headerlink\" title=\"用处\"></a>用处</h3><ol>\n<li>属性拦截</li>\n<li>拦截过滤各种操作，如new/defineProperty/delete/getPrototypeOf等</li>\n<li>私有属性模拟<br>has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handler = &#123;</span><br><span class=\"line\">  has (target, key) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key[<span class=\"number\">0</span>] === <span class=\"string\">'_'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> target;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> target = &#123; <span class=\"attr\">_prop</span>: <span class=\"string\">'foo'</span>, <span class=\"attr\">prop</span>: <span class=\"string\">'foo'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\"><span class=\"string\">'_prop'</span> <span class=\"keyword\">in</span> proxy <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Promise对象\"><a href=\"#Promise对象\" class=\"headerlink\" title=\"Promise对象\"></a>Promise对象</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... some code</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>resolve将Promise对象从Pending变成Resolved<br>reject将Promise对象从Pending变成Rejected<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>resolve和reject可以将参数传递给then方法里面的回调函数</p>\n<h2 id=\"Symbol对象属性\"><a href=\"#Symbol对象属性\" class=\"headerlink\" title=\"Symbol对象属性\"></a>Symbol对象属性</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isMoving = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"isMoving\"</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (element[isMoving]) &#123;</span><br><span class=\"line\">  smoothAnimations(element);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">element[isMoving] = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>symbol-keyed属性不能通过.操作符来访问，必须使用方括号的方式</li>\n<li>判断：if (isMoving in element)</li>\n<li>删除：delete element[isMoving]</li>\n<li>for…in、Object.keys(obj) 和 Object.getOwnPropertyNames(obj)只会遍历到以字符串作为键的属性</li>\n<li>Object.getOwnPropertySymbols(obj)只会遍历所有的Symbol键</li>\n<li>Reflect.ownKeys(obj)会返回对象的所有字符串和Symbol键</li>\n</ul>\n<h2 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>this关键字代表实例对象。类的方法都是定义在prototype上，与传统的prototype实现的类一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> Point <span class=\"comment\">// \"function\"</span></span><br><span class=\"line\">Point === Point.prototype.constructor <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码表明，类的数据类型就是function，类本身就指向构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"></span><br><span class=\"line\">b.constructor === B.prototype.constructor <span class=\"comment\">// true</span></span><br><span class=\"line\">B.prototype.constructor === B <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>在类的实例上调用方法，其实就是调用原型上的方法。所以b实例的constructor方法就是B类原型的constructor方法。<br>prototype对象的constructor属性，直接指向“类”的本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(Point.prototype, &#123;</span><br><span class=\"line\">  toString()&#123;&#125;,</span><br><span class=\"line\">  toValue()&#123;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>通过Object的assign方法可以一次向Point添加多个方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// [\"constructor\",\"toString\"]</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。Object.keys这儿用来判断是否可枚举。</p>\n<h2 id=\"Set集合\"><a href=\"#Set集合\" class=\"headerlink\" title=\"Set集合\"></a>Set集合</h2><p>用最简洁的代码实现数组去重：<br>ES6实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...new <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"string\">'a'</span>,<span class=\"number\">1</span>,<span class=\"string\">'a'</span>])]</span><br></pre></td></tr></table></figure></p>\n<p>ES5实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"string\">'a'</span>,<span class=\"number\">1</span>,<span class=\"string\">'a'</span>].filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele,index,array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index===array.indexOf(ele)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>from: <a href=\"http://es6.ruanyifeng.com\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com</a></p>\n</blockquote>\n<h2 id=\"let命令\"><a href=\"#let命令\" class=\"headerlink\" title=\"let命令\"></a>let命令</h2><ul>\n<li>let取代var, let仅在代码块中有效</li>\n<li>for循环计数器适合用let</li>\n<li>let不存在变量提升</li>\n<li>暂时性死区</li>\n<li>不允许重复声明</li>\n<li>块级作用域（全局作用域、函数作用域）</li>\n</ul>\n<h2 id=\"const命令\"><a href=\"#const命令\" class=\"headerlink\" title=\"const命令\"></a>const命令</h2><ul>\n<li>声明常量</li>\n</ul>\n<h2 id=\"顶层对象，在浏览器中指的是window对象\"><a href=\"#顶层对象，在浏览器中指的是window对象\" class=\"headerlink\" title=\"顶层对象，在浏览器中指的是window对象\"></a>顶层对象，在浏览器中指的是window对象</h2><ul>\n<li>es6的var命令和function命令声明的全局变量依然是顶层对象的属性</li>\n<li>let、const、class命令声明的全局变量不属于顶层对象的属性</li>\n</ul>","more":"<h2 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h2><ul>\n<li>只要某种数据结构有Iterator接口，都可以采用数组形式的解构赋值</li>\n<li>解构可以设置默认值</li>\n<li>对象也可以解构，数组的解构是按次序排列，对象的解构要求变量名必须和对象的属性名相同</li>\n<li>数值和布尔值的解构赋值比较特别，转为了对象</li>\n<li>函数参数也可以解构赋值</li>\n<li>用处：<ul>\n<li>交换变量的值</li>\n<li>从函数返回多个值</li>\n<li>函数参数的定义</li>\n<li>提取JSON对象中的数据</li>\n<li>函数参数的默认值</li>\n<li>遍历map解构 ：任何部署了Iterator接口的对象，都可以用for…of循环遍历（Array,String,Set,Map）</li>\n<li>输入模块的指定方法</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Unicode表示字符，可以使用\"><a href=\"#Unicode表示字符，可以使用\" class=\"headerlink\" title=\"Unicode表示字符，可以使用{}\"></a>Unicode表示字符，可以使用{}</h2><ul>\n<li>模板字符串${}</li>\n<li>includes, startsWith, endsWith, repeat, padStart, padEnd</li>\n</ul>\n<h2 id=\"数值的扩展\"><a href=\"#数值的扩展\" class=\"headerlink\" title=\"数值的扩展\"></a>数值的扩展</h2><ul>\n<li>isFinite()  isNaN()</li>\n<li>将parseInt()和parseFloat()方法移植到Number对象上，目的是减少全局性方法，使语言逐步模块化</li>\n<li>isInteger()</li>\n<li>新增了极小的常量Number.EPSILON</li>\n<li>最大值Number.MAX_SAFE_INTEGER， 最小值Number.MAX_SAFE_INTEGER Number.isSafeInteger()</li>\n</ul>\n<h2 id=\"数组的扩展\"><a href=\"#数组的扩展\" class=\"headerlink\" title=\"数组的扩展\"></a>数组的扩展</h2><ul>\n<li>from方法将类似数组的对象和可遍历的对象转为真正的数组<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayLike = &#123;</span><br><span class=\"line\">    <span class=\"string\">'0'</span>: <span class=\"string\">'a'</span>,</span><br><span class=\"line\">    <span class=\"string\">'1'</span>: <span class=\"string\">'b'</span>,</span><br><span class=\"line\">    <span class=\"string\">'2'</span>: <span class=\"string\">'c'</span>,</span><br><span class=\"line\">    length: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES5的写法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [].slice.call(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6的写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = <span class=\"built_in\">Array</span>.from(arrayLike); <span class=\"comment\">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NodeList对象</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ps = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'p'</span>);</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(ps).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(p);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// arguments对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>of方法将一组值转换为数组</li>\n</ul>\n<h2 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h2><ul>\n<li>可以设置参数的默认值</li>\n<li>函数的length属性返回没有指定默认值的参数个数</li>\n<li><p>reset参数：用于获取函数的多余参数，形式为…变量名，代表一个数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// arguments变量的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortNumbers</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>).sort();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// rest参数的写法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> sortNumbers = <span class=\"function\">(<span class=\"params\">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>扩展运算符…：好比reset参数的逆运算，将一个数组转为用逗号分隔的参数序列</p>\n<ul>\n<li><p>替代数组的apply方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y, z</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">f.apply(<span class=\"literal\">null</span>, args);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ES6的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x, y, z</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\">f(...args);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>合并数组</p>\n</li>\n<li>与解构赋值结合</li>\n<li>函数的返回值</li>\n<li><p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...obj]; <span class=\"comment\">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于没有iterator接口的对象，使用…语法会报错</p>\n</li>\n<li>与React中的JSX扩展语法不同</li>\n</ul>\n</li>\n<li>函数的name属性</li>\n<li>箭头函数=&gt;</li>\n<li>函数绑定运算符是并排的两个双冒号（::），左边是对象，右边是一个函数，返回的还是原对象，可以采用链式写法</li>\n<li>“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存</li>\n</ul>\n<h2 id=\"对象的扩展\"><a href=\"#对象的扩展\" class=\"headerlink\" title=\"对象的扩展\"></a>对象的扩展</h2><h2 id=\"Proxy和Refelct\"><a href=\"#Proxy和Refelct\" class=\"headerlink\" title=\"Proxy和Refelct\"></a>Proxy和Refelct</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>\n<p>new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler也是一个对象，用来定制拦截行为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function(target, property) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">35</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">proxy.time <span class=\"comment\">// 35</span></span><br><span class=\"line\">proxy.name <span class=\"comment\">// 35</span></span><br><span class=\"line\">proxy.title <span class=\"comment\">// 35</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"用处\"><a href=\"#用处\" class=\"headerlink\" title=\"用处\"></a>用处</h3><ol>\n<li>属性拦截</li>\n<li>拦截过滤各种操作，如new/defineProperty/delete/getPrototypeOf等</li>\n<li>私有属性模拟<br>has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handler = &#123;</span><br><span class=\"line\">  has (target, key) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key[<span class=\"number\">0</span>] === <span class=\"string\">'_'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> target;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> target = &#123; <span class=\"attr\">_prop</span>: <span class=\"string\">'foo'</span>, <span class=\"attr\">prop</span>: <span class=\"string\">'foo'</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> proxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target, handler);</span><br><span class=\"line\"><span class=\"string\">'_prop'</span> <span class=\"keyword\">in</span> proxy <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"Promise对象\"><a href=\"#Promise对象\" class=\"headerlink\" title=\"Promise对象\"></a>Promise对象</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... some code</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>resolve将Promise对象从Pending变成Resolved<br>reject将Promise对象从Pending变成Rejected<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>resolve和reject可以将参数传递给then方法里面的回调函数</p>\n<h2 id=\"Symbol对象属性\"><a href=\"#Symbol对象属性\" class=\"headerlink\" title=\"Symbol对象属性\"></a>Symbol对象属性</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isMoving = <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"isMoving\"</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (element[isMoving]) &#123;</span><br><span class=\"line\">  smoothAnimations(element);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">element[isMoving] = <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>symbol-keyed属性不能通过.操作符来访问，必须使用方括号的方式</li>\n<li>判断：if (isMoving in element)</li>\n<li>删除：delete element[isMoving]</li>\n<li>for…in、Object.keys(obj) 和 Object.getOwnPropertyNames(obj)只会遍历到以字符串作为键的属性</li>\n<li>Object.getOwnPropertySymbols(obj)只会遍历所有的Symbol键</li>\n<li>Reflect.ownKeys(obj)会返回对象的所有字符串和Symbol键</li>\n</ul>\n<h2 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//定义类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'('</span> + <span class=\"keyword\">this</span>.x + <span class=\"string\">', '</span> + <span class=\"keyword\">this</span>.y + <span class=\"string\">')'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>this关键字代表实例对象。类的方法都是定义在prototype上，与传统的prototype实现的类一致。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> Point <span class=\"comment\">// \"function\"</span></span><br><span class=\"line\">Point === Point.prototype.constructor <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>上面代码表明，类的数据类型就是function，类本身就指向构造函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"></span><br><span class=\"line\">b.constructor === B.prototype.constructor <span class=\"comment\">// true</span></span><br><span class=\"line\">B.prototype.constructor === B <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>在类的实例上调用方法，其实就是调用原型上的方法。所以b实例的constructor方法就是B类原型的constructor方法。<br>prototype对象的constructor属性，直接指向“类”的本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(Point.prototype, &#123;</span><br><span class=\"line\">  toString()&#123;&#125;,</span><br><span class=\"line\">  toValue()&#123;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>通过Object的assign方法可以一次向Point添加多个方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x, y) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.keys(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class=\"line\"><span class=\"comment\">// [\"constructor\",\"toString\"]</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。Object.keys这儿用来判断是否可枚举。</p>\n<h2 id=\"Set集合\"><a href=\"#Set集合\" class=\"headerlink\" title=\"Set集合\"></a>Set集合</h2><p>用最简洁的代码实现数组去重：<br>ES6实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...new <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"string\">'a'</span>,<span class=\"number\">1</span>,<span class=\"string\">'a'</span>])]</span><br></pre></td></tr></table></figure></p>\n<p>ES5实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"string\">'a'</span>,<span class=\"number\">1</span>,<span class=\"string\">'a'</span>].filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ele,index,array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> index===array.indexOf(ele)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>"},{"title":"H5开发踩到的坑","date":"2017-03-16T12:42:41.000Z","_content":"\n### 某些安卓机上tap事件会触发两次\n\n### 某些安卓微信缓存严重，reload事件会失效\n#### 解决方法\n- location.reload(forcedReload): 当取值为 true 时，将强制浏览器从服务器重新获取当前页面资源，而不是从浏览器的缓存中读取，如果取值为 false 或不传该参数时，浏览器则可能会从缓存中读取当前页面。\n- 加时间戳\n\n### ios微信内音乐不能自动播放\n微信屏蔽了音乐自动播放，使用微信API：**WeixinJSBridge**，当getNetworkType事件被触发时去播放音乐。\n解决方法：\n``` javascript\nif((/MicroMessenger/ig).test(window.navigator.userAgent) && (typeof WeixinJSBridge != \"undefined\")) {\n    WeixinJSBridge.invoke('getNetworkType', {}, function(e) {\n        $('.j-audio')[0].play();\n    });\n}\n```\n此外，在手机chrome和safiri中都不支持音乐自动播放，需要用户操作才能触发，基于节省流量的考虑。\n\n<!-- more -->\n\n### ios 客户端内某些样式异常，导致图片没有展示\n本质上图片是被覆盖了，应该是z-index的异常\n\n### android软键盘弹出后遮住文本框\n解决办法是使用scrollIntoViewIfNeeded()\n``` javascript\n//通用型\nif(/Android [4-6]/.test(navigator.appVersion)) {\n    window.addEventListener(\"resize\", function() {\n        if(document.activeElement.tagName==\"INPUT\" || document.activeElement.tagName==\"TEXTAREA\") {\n            window.setTimeout(function() {\n                document.activeElement.scrollIntoViewIfNeeded();\n            }, 0);\n        }\n    })\n}\n\n//直接针对某个元素\ndocument.getElementById('/*元素id*/').onclick = function(e) {\n    setTimeout(() => {\n        e.target.scrollIntoViewIfNeeded();\n    }, 400);\n}\n```","source":"_posts/H5开发遇到的坑.md","raw":"---\ntitle: H5开发踩到的坑\n\ndate: 2017-03-16 20:42:41\ntags: [总结]\n---\n\n### 某些安卓机上tap事件会触发两次\n\n### 某些安卓微信缓存严重，reload事件会失效\n#### 解决方法\n- location.reload(forcedReload): 当取值为 true 时，将强制浏览器从服务器重新获取当前页面资源，而不是从浏览器的缓存中读取，如果取值为 false 或不传该参数时，浏览器则可能会从缓存中读取当前页面。\n- 加时间戳\n\n### ios微信内音乐不能自动播放\n微信屏蔽了音乐自动播放，使用微信API：**WeixinJSBridge**，当getNetworkType事件被触发时去播放音乐。\n解决方法：\n``` javascript\nif((/MicroMessenger/ig).test(window.navigator.userAgent) && (typeof WeixinJSBridge != \"undefined\")) {\n    WeixinJSBridge.invoke('getNetworkType', {}, function(e) {\n        $('.j-audio')[0].play();\n    });\n}\n```\n此外，在手机chrome和safiri中都不支持音乐自动播放，需要用户操作才能触发，基于节省流量的考虑。\n\n<!-- more -->\n\n### ios 客户端内某些样式异常，导致图片没有展示\n本质上图片是被覆盖了，应该是z-index的异常\n\n### android软键盘弹出后遮住文本框\n解决办法是使用scrollIntoViewIfNeeded()\n``` javascript\n//通用型\nif(/Android [4-6]/.test(navigator.appVersion)) {\n    window.addEventListener(\"resize\", function() {\n        if(document.activeElement.tagName==\"INPUT\" || document.activeElement.tagName==\"TEXTAREA\") {\n            window.setTimeout(function() {\n                document.activeElement.scrollIntoViewIfNeeded();\n            }, 0);\n        }\n    })\n}\n\n//直接针对某个元素\ndocument.getElementById('/*元素id*/').onclick = function(e) {\n    setTimeout(() => {\n        e.target.scrollIntoViewIfNeeded();\n    }, 400);\n}\n```","slug":"H5开发遇到的坑","published":1,"updated":"2019-03-18T02:27:14.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx5q0001qmhf4jhz38au","content":"<h3 id=\"某些安卓机上tap事件会触发两次\"><a href=\"#某些安卓机上tap事件会触发两次\" class=\"headerlink\" title=\"某些安卓机上tap事件会触发两次\"></a>某些安卓机上tap事件会触发两次</h3><h3 id=\"某些安卓微信缓存严重，reload事件会失效\"><a href=\"#某些安卓微信缓存严重，reload事件会失效\" class=\"headerlink\" title=\"某些安卓微信缓存严重，reload事件会失效\"></a>某些安卓微信缓存严重，reload事件会失效</h3><h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><ul>\n<li>location.reload(forcedReload): 当取值为 true 时，将强制浏览器从服务器重新获取当前页面资源，而不是从浏览器的缓存中读取，如果取值为 false 或不传该参数时，浏览器则可能会从缓存中读取当前页面。</li>\n<li>加时间戳</li>\n</ul>\n<h3 id=\"ios微信内音乐不能自动播放\"><a href=\"#ios微信内音乐不能自动播放\" class=\"headerlink\" title=\"ios微信内音乐不能自动播放\"></a>ios微信内音乐不能自动播放</h3><p>微信屏蔽了音乐自动播放，使用微信API：<strong>WeixinJSBridge</strong>，当getNetworkType事件被触发时去播放音乐。<br>解决方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((<span class=\"regexp\">/MicroMessenger/ig</span>).test(<span class=\"built_in\">window</span>.navigator.userAgent) &amp;&amp; (<span class=\"keyword\">typeof</span> WeixinJSBridge != <span class=\"string\">\"undefined\"</span>)) &#123;</span><br><span class=\"line\">    WeixinJSBridge.invoke(<span class=\"string\">'getNetworkType'</span>, &#123;&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        $(<span class=\"string\">'.j-audio'</span>)[<span class=\"number\">0</span>].play();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此外，在手机chrome和safiri中都不支持音乐自动播放，需要用户操作才能触发，基于节省流量的考虑。</p>\n<a id=\"more\"></a>\n<h3 id=\"ios-客户端内某些样式异常，导致图片没有展示\"><a href=\"#ios-客户端内某些样式异常，导致图片没有展示\" class=\"headerlink\" title=\"ios 客户端内某些样式异常，导致图片没有展示\"></a>ios 客户端内某些样式异常，导致图片没有展示</h3><p>本质上图片是被覆盖了，应该是z-index的异常</p>\n<h3 id=\"android软键盘弹出后遮住文本框\"><a href=\"#android软键盘弹出后遮住文本框\" class=\"headerlink\" title=\"android软键盘弹出后遮住文本框\"></a>android软键盘弹出后遮住文本框</h3><p>解决办法是使用scrollIntoViewIfNeeded()<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通用型</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"regexp\">/Android [4-6]/</span>.test(navigator.appVersion)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"resize\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.activeElement.tagName==<span class=\"string\">\"INPUT\"</span> || <span class=\"built_in\">document</span>.activeElement.tagName==<span class=\"string\">\"TEXTAREA\"</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">document</span>.activeElement.scrollIntoViewIfNeeded();</span><br><span class=\"line\">            &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接针对某个元素</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'/*元素id*/'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        e.target.scrollIntoViewIfNeeded();</span><br><span class=\"line\">    &#125;, <span class=\"number\">400</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"某些安卓机上tap事件会触发两次\"><a href=\"#某些安卓机上tap事件会触发两次\" class=\"headerlink\" title=\"某些安卓机上tap事件会触发两次\"></a>某些安卓机上tap事件会触发两次</h3><h3 id=\"某些安卓微信缓存严重，reload事件会失效\"><a href=\"#某些安卓微信缓存严重，reload事件会失效\" class=\"headerlink\" title=\"某些安卓微信缓存严重，reload事件会失效\"></a>某些安卓微信缓存严重，reload事件会失效</h3><h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><ul>\n<li>location.reload(forcedReload): 当取值为 true 时，将强制浏览器从服务器重新获取当前页面资源，而不是从浏览器的缓存中读取，如果取值为 false 或不传该参数时，浏览器则可能会从缓存中读取当前页面。</li>\n<li>加时间戳</li>\n</ul>\n<h3 id=\"ios微信内音乐不能自动播放\"><a href=\"#ios微信内音乐不能自动播放\" class=\"headerlink\" title=\"ios微信内音乐不能自动播放\"></a>ios微信内音乐不能自动播放</h3><p>微信屏蔽了音乐自动播放，使用微信API：<strong>WeixinJSBridge</strong>，当getNetworkType事件被触发时去播放音乐。<br>解决方法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>((<span class=\"regexp\">/MicroMessenger/ig</span>).test(<span class=\"built_in\">window</span>.navigator.userAgent) &amp;&amp; (<span class=\"keyword\">typeof</span> WeixinJSBridge != <span class=\"string\">\"undefined\"</span>)) &#123;</span><br><span class=\"line\">    WeixinJSBridge.invoke(<span class=\"string\">'getNetworkType'</span>, &#123;&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        $(<span class=\"string\">'.j-audio'</span>)[<span class=\"number\">0</span>].play();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此外，在手机chrome和safiri中都不支持音乐自动播放，需要用户操作才能触发，基于节省流量的考虑。</p>","more":"<h3 id=\"ios-客户端内某些样式异常，导致图片没有展示\"><a href=\"#ios-客户端内某些样式异常，导致图片没有展示\" class=\"headerlink\" title=\"ios 客户端内某些样式异常，导致图片没有展示\"></a>ios 客户端内某些样式异常，导致图片没有展示</h3><p>本质上图片是被覆盖了，应该是z-index的异常</p>\n<h3 id=\"android软键盘弹出后遮住文本框\"><a href=\"#android软键盘弹出后遮住文本框\" class=\"headerlink\" title=\"android软键盘弹出后遮住文本框\"></a>android软键盘弹出后遮住文本框</h3><p>解决办法是使用scrollIntoViewIfNeeded()<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通用型</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"regexp\">/Android [4-6]/</span>.test(navigator.appVersion)) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"resize\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">document</span>.activeElement.tagName==<span class=\"string\">\"INPUT\"</span> || <span class=\"built_in\">document</span>.activeElement.tagName==<span class=\"string\">\"TEXTAREA\"</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">window</span>.setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">document</span>.activeElement.scrollIntoViewIfNeeded();</span><br><span class=\"line\">            &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接针对某个元素</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'/*元素id*/'</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        e.target.scrollIntoViewIfNeeded();</span><br><span class=\"line\">    &#125;, <span class=\"number\">400</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"Hello bingxin","date":"2017-03-16T12:42:41.000Z","_content":"\n## cmd小工具开发总结\n\n","source":"_posts/Hello-bingxin.md","raw":"---\ntitle: Hello bingxin\ndate: 2017-03-16 20:42:41\ntags:\n---\n\n## cmd小工具开发总结\n\n","slug":"Hello-bingxin","published":1,"updated":"2019-03-18T02:27:14.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx5w0003qmhfanlznjjv","content":"<h2 id=\"cmd小工具开发总结\"><a href=\"#cmd小工具开发总结\" class=\"headerlink\" title=\"cmd小工具开发总结\"></a>cmd小工具开发总结</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"cmd小工具开发总结\"><a href=\"#cmd小工具开发总结\" class=\"headerlink\" title=\"cmd小工具开发总结\"></a>cmd小工具开发总结</h2>"},{"title":"IOS微信内二维码无法识别问题","date":"2018-02-06T03:41:42.000Z","_content":"","source":"_posts/IOS微信内二维码无法识别问题.md","raw":"---\ntitle: IOS微信内二维码无法识别问题\ndate: 2018-02-06 11:41:42\ntags:\n---\n","slug":"IOS微信内二维码无法识别问题","published":1,"updated":"2019-03-18T02:27:14.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx5y0004qmhfhnb0ki3m","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"JS函数式编程笔记(上)","date":"2018-07-02T11:20:49.000Z","_content":"# 一等公民的函数\n### 为啥说函数是一等公民？\n- 函数和其他对象一样，可以像对待任何其他数据类型一样对待它们——把它们存在数组里，当作参数传递，赋值给变量...等等。\n关键点在于，调用的时候没必要再去包裹一层多余的函数，因为二者是等价的。\n``` js\n\\\\包裹了多余的函数\nvar greeting = function(name) {return hi(name);}\n\\\\ 一等公民式的调用\nvar greeting = hi;\n```\n\n### 一等公民函数调用的好处\n``` js\n//最初的函数\nhttpGet('/post/2', function(json){\n  return renderPost(json);\n});\n\n// 需要增加对err异常的处理，要处理的地方比较多\nhttpGet('/post/2', function(json, err){\n  return renderPost(json, err);\n});\n\n// 如果使用一等公民函数的形式，则其他的改动会少很多\nhttpGet('/post/2', renderPost);\n```\n\n<!-- more -->\n\n# 纯函数的好处\n> 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的**副作用**。\n### 函数的副作用\nslice和splice相比，slice是一种纯函数，splice会修改自身数据，在函数式编程中比较讨厌这种笨函数。\n另外，看这个例子：\n\n``` js\n// 不纯的\nvar minimum = 21;\n\nvar checkAge = function(age) {\n  return age >= minimum;\n};\n```\n\n`checkAge`依赖外部变量`minimum`，`minimum`发生变化的时候，会影响`checkAge`函数的返回结果，增加认知负荷。\n也可以调用`Object.freeze({minimum: 21})`将minimum变成一个不可变对象。\n> 副作用是在计算过程中，系统状态的一种变化，或者是与外部世界进行的可观察的交互。也是滋生bug的温床。\n\n### 追求“纯”的理由\n- 可缓存性（Cacheable）\n可以通过延迟执行的方式把不纯的函数转换为纯函数：\n``` js\nvar pureHttpCall = memoize(function(url, params){\n  return function() { return $.getJSON(url, params); }\n});\n```\n之所以是纯函数，因为总是根据相同的输入返回相同的输出：同一个发送http请求的函数。\n- 可移植性／自文档化（Portable / Self-Documenting）\n与环境无关；注入依赖或者通过参数传递。\n>  Erlang 语言的作者 Joe Armstrong 说的这句话：“面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩...以及整个丛林”。\n- 可测试性（Testable）\n[Quickcheck](http://hackage.haskell.org/package/QuickCheck)——一个为函数式环境量身定制的测试工具\n- 合理性（Reasonable）\n引用透明性:如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。\n- 并行代码\n可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。\n\n\n# 柯里化\n> 在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n另一种理解是：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n### 例子\n``` js\nfunction add(a, b) {\n    return a + b;\n}\n\n// 执行 add 函数，一次传入两个参数即可\nadd(1, 2) // 3\n\n// 函数curry\nvar add = function(a) {\n    return function(b) {\n        return a + b;\n    }\n}\n// 每次传入一个参数\nadd(1)(2) // 3\n```\n### 核心思想\n可以借助Lodash 中的 curry 方法帮我们实现函数柯里化，核心思想是————比较多次接受的参数总数与函数定义时的入参数量，当接受参数的数量大于或等于被 Currying 函数的传入参数数量时，就返回计算结果，否则返回一个继续接受参数的函数。\n``` js\nfunction trueCurrying(fn, ...args) {\n\n    if (args.length >= fn.length) {\n\n        return fn(...args)\n\n    }\n\n    return function (...args2) {\n\n        return trueCurrying(fn, ...args, ...args2)\n\n    }\n}\n```\n### 用处\ncurry的用处十分广泛，给函数传入一些参数后，可以得到一些新的函数。例如下面的`getChildren`函数，传给柯里化后的map函数，会返回一个接收参数类型为数组的新函数。\n```\nvar curry = require('lodash').curry;\nvar map = curry(function(f, ary) {\n  return ary.map(f);\n});\n\nvar getChildren = function(x) {\n  return x.childNodes;\n};\nvar allTheChildren = map(getChildren);\n\n// 返回所有div的子节点\nallTheChildren(document.getElementsByTagName('div'))\n```\n\n# 代码组合\n### 简介\n``` js\nvar compose = function(f,g) {\n  return function(x) {\n    return f(g(x));\n  };\n};\n```\n`f`和`g`是两个函数，通过组合方式返回一个新的函数，`x`就是在两个管道之间传输的值。\n举个例子，如果希望给`send in the clowns`加上`!`，并且转成大写，可以使用函数组合的方法来实现这个功能。\n``` js\nvar toUpperCase = function(x) { return x.toUpperCase(); };\nvar exclaim = function(x) { return x + '!'; };\nvar shout = compose(exclaim, toUpperCase);\n\nshout(\"send in the clowns\");\n//=> \"SEND IN THE CLOWNS!\"\n```\n`compose`使用主要特点有：\n    - 代码的运行顺序是从右向左，创建了一个从右向左的数据流，初始函数一定放到参数的`最右面`；\n    - `compose`的参数是函数，返回的也是一个函数；\n    - 除了第一个函数的接受参数，其他函数的接受参数都是上一个函数的返回值，所以初始函数的参数是多元的，而其他函数的接受值是一元的；\n\n### 结合律\n组合的概念来源于数学课本，满足组合的特性——结合律\n``` js\n// 结合律（associativity）\nvar associative = compose(f, compose(g, h)) == compose(compose(f, g), h);\n// true\n```\n结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。例如可以进行下面的重构：\n``` js\nvar loudLastUpper = compose(exclaim, toUpperCase, head, reverse);\n\n// 或\nvar last = compose(head, reverse);\nvar loudLastUpper = compose(exclaim, toUpperCase, last);\n\n// 或\nvar last = compose(head, reverse);\nvar angry = compose(exclaim, toUpperCase);\nvar loudLastUpper = compose(angry, last);\n\n// 更多变种...\n```\n\n### pointfree\n> Pointfree style means never having to say your data.\n通过管道把数据在接受单个参数的函数间传递，不需要去声明中间的变量。\n``` js\n// 非 pointfree，因为提到了数据：name\nvar initials = function (name) {\n  return name.split(' ').map(compose(toUpperCase, head)).join('. ');\n};\n\n// pointfree\nvar initials = compose(join('. '), map(compose(toUpperCase, head)), split(' '));\n\ninitials(\"hunter stockton thompson\");\n// 'H. S. T'\n```\npointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。\n\n**组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动**——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。\n\nPS: **[Ramda](https://ramdajs.com/)\n- 数据一律放在最后一个参数，理念是\"function first，data last\";\n- 库所有的函数都支持柯里化**，可以很好地实践FP。\n\nREFS:\n[使用JavaScript实现“真·函数式编程”](http://jimliu.net/2015/10/21/real-functional-programming-in-javascript-1/)\n[Ramda 函数库参考教程](http://www.ruanyifeng.com/blog/2017/03/ramda.html)","source":"_posts/JS函数式编程笔记(上).md","raw":"---\ntitle: JS函数式编程笔记(上)\ndate: 2018-07-02 19:20:49\ntags: [函数式编程, js]\n---\n# 一等公民的函数\n### 为啥说函数是一等公民？\n- 函数和其他对象一样，可以像对待任何其他数据类型一样对待它们——把它们存在数组里，当作参数传递，赋值给变量...等等。\n关键点在于，调用的时候没必要再去包裹一层多余的函数，因为二者是等价的。\n``` js\n\\\\包裹了多余的函数\nvar greeting = function(name) {return hi(name);}\n\\\\ 一等公民式的调用\nvar greeting = hi;\n```\n\n### 一等公民函数调用的好处\n``` js\n//最初的函数\nhttpGet('/post/2', function(json){\n  return renderPost(json);\n});\n\n// 需要增加对err异常的处理，要处理的地方比较多\nhttpGet('/post/2', function(json, err){\n  return renderPost(json, err);\n});\n\n// 如果使用一等公民函数的形式，则其他的改动会少很多\nhttpGet('/post/2', renderPost);\n```\n\n<!-- more -->\n\n# 纯函数的好处\n> 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的**副作用**。\n### 函数的副作用\nslice和splice相比，slice是一种纯函数，splice会修改自身数据，在函数式编程中比较讨厌这种笨函数。\n另外，看这个例子：\n\n``` js\n// 不纯的\nvar minimum = 21;\n\nvar checkAge = function(age) {\n  return age >= minimum;\n};\n```\n\n`checkAge`依赖外部变量`minimum`，`minimum`发生变化的时候，会影响`checkAge`函数的返回结果，增加认知负荷。\n也可以调用`Object.freeze({minimum: 21})`将minimum变成一个不可变对象。\n> 副作用是在计算过程中，系统状态的一种变化，或者是与外部世界进行的可观察的交互。也是滋生bug的温床。\n\n### 追求“纯”的理由\n- 可缓存性（Cacheable）\n可以通过延迟执行的方式把不纯的函数转换为纯函数：\n``` js\nvar pureHttpCall = memoize(function(url, params){\n  return function() { return $.getJSON(url, params); }\n});\n```\n之所以是纯函数，因为总是根据相同的输入返回相同的输出：同一个发送http请求的函数。\n- 可移植性／自文档化（Portable / Self-Documenting）\n与环境无关；注入依赖或者通过参数传递。\n>  Erlang 语言的作者 Joe Armstrong 说的这句话：“面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩...以及整个丛林”。\n- 可测试性（Testable）\n[Quickcheck](http://hackage.haskell.org/package/QuickCheck)——一个为函数式环境量身定制的测试工具\n- 合理性（Reasonable）\n引用透明性:如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。\n- 并行代码\n可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。\n\n\n# 柯里化\n> 在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n另一种理解是：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n### 例子\n``` js\nfunction add(a, b) {\n    return a + b;\n}\n\n// 执行 add 函数，一次传入两个参数即可\nadd(1, 2) // 3\n\n// 函数curry\nvar add = function(a) {\n    return function(b) {\n        return a + b;\n    }\n}\n// 每次传入一个参数\nadd(1)(2) // 3\n```\n### 核心思想\n可以借助Lodash 中的 curry 方法帮我们实现函数柯里化，核心思想是————比较多次接受的参数总数与函数定义时的入参数量，当接受参数的数量大于或等于被 Currying 函数的传入参数数量时，就返回计算结果，否则返回一个继续接受参数的函数。\n``` js\nfunction trueCurrying(fn, ...args) {\n\n    if (args.length >= fn.length) {\n\n        return fn(...args)\n\n    }\n\n    return function (...args2) {\n\n        return trueCurrying(fn, ...args, ...args2)\n\n    }\n}\n```\n### 用处\ncurry的用处十分广泛，给函数传入一些参数后，可以得到一些新的函数。例如下面的`getChildren`函数，传给柯里化后的map函数，会返回一个接收参数类型为数组的新函数。\n```\nvar curry = require('lodash').curry;\nvar map = curry(function(f, ary) {\n  return ary.map(f);\n});\n\nvar getChildren = function(x) {\n  return x.childNodes;\n};\nvar allTheChildren = map(getChildren);\n\n// 返回所有div的子节点\nallTheChildren(document.getElementsByTagName('div'))\n```\n\n# 代码组合\n### 简介\n``` js\nvar compose = function(f,g) {\n  return function(x) {\n    return f(g(x));\n  };\n};\n```\n`f`和`g`是两个函数，通过组合方式返回一个新的函数，`x`就是在两个管道之间传输的值。\n举个例子，如果希望给`send in the clowns`加上`!`，并且转成大写，可以使用函数组合的方法来实现这个功能。\n``` js\nvar toUpperCase = function(x) { return x.toUpperCase(); };\nvar exclaim = function(x) { return x + '!'; };\nvar shout = compose(exclaim, toUpperCase);\n\nshout(\"send in the clowns\");\n//=> \"SEND IN THE CLOWNS!\"\n```\n`compose`使用主要特点有：\n    - 代码的运行顺序是从右向左，创建了一个从右向左的数据流，初始函数一定放到参数的`最右面`；\n    - `compose`的参数是函数，返回的也是一个函数；\n    - 除了第一个函数的接受参数，其他函数的接受参数都是上一个函数的返回值，所以初始函数的参数是多元的，而其他函数的接受值是一元的；\n\n### 结合律\n组合的概念来源于数学课本，满足组合的特性——结合律\n``` js\n// 结合律（associativity）\nvar associative = compose(f, compose(g, h)) == compose(compose(f, g), h);\n// true\n```\n结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。例如可以进行下面的重构：\n``` js\nvar loudLastUpper = compose(exclaim, toUpperCase, head, reverse);\n\n// 或\nvar last = compose(head, reverse);\nvar loudLastUpper = compose(exclaim, toUpperCase, last);\n\n// 或\nvar last = compose(head, reverse);\nvar angry = compose(exclaim, toUpperCase);\nvar loudLastUpper = compose(angry, last);\n\n// 更多变种...\n```\n\n### pointfree\n> Pointfree style means never having to say your data.\n通过管道把数据在接受单个参数的函数间传递，不需要去声明中间的变量。\n``` js\n// 非 pointfree，因为提到了数据：name\nvar initials = function (name) {\n  return name.split(' ').map(compose(toUpperCase, head)).join('. ');\n};\n\n// pointfree\nvar initials = compose(join('. '), map(compose(toUpperCase, head)), split(' '));\n\ninitials(\"hunter stockton thompson\");\n// 'H. S. T'\n```\npointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。\n\n**组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动**——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。\n\nPS: **[Ramda](https://ramdajs.com/)\n- 数据一律放在最后一个参数，理念是\"function first，data last\";\n- 库所有的函数都支持柯里化**，可以很好地实践FP。\n\nREFS:\n[使用JavaScript实现“真·函数式编程”](http://jimliu.net/2015/10/21/real-functional-programming-in-javascript-1/)\n[Ramda 函数库参考教程](http://www.ruanyifeng.com/blog/2017/03/ramda.html)","slug":"JS函数式编程笔记(上)","published":1,"updated":"2019-03-18T02:27:14.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx600005qmhfbrith5ga","content":"<h1 id=\"一等公民的函数\"><a href=\"#一等公民的函数\" class=\"headerlink\" title=\"一等公民的函数\"></a>一等公民的函数</h1><h3 id=\"为啥说函数是一等公民？\"><a href=\"#为啥说函数是一等公民？\" class=\"headerlink\" title=\"为啥说函数是一等公民？\"></a>为啥说函数是一等公民？</h3><ul>\n<li>函数和其他对象一样，可以像对待任何其他数据类型一样对待它们——把它们存在数组里，当作参数传递，赋值给变量…等等。<br>关键点在于，调用的时候没必要再去包裹一层多余的函数，因为二者是等价的。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\\\包裹了多余的函数</span><br><span class=\"line\"><span class=\"keyword\">var</span> greeting = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;<span class=\"keyword\">return</span> hi(name);&#125;</span><br><span class=\"line\">\\\\ 一等公民式的调用</span><br><span class=\"line\"><span class=\"keyword\">var</span> greeting = hi;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"一等公民函数调用的好处\"><a href=\"#一等公民函数调用的好处\" class=\"headerlink\" title=\"一等公民函数调用的好处\"></a>一等公民函数调用的好处</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最初的函数</span></span><br><span class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> renderPost(json);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要增加对err异常的处理，要处理的地方比较多</span></span><br><span class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json, err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> renderPost(json, err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果使用一等公民函数的形式，则其他的改动会少很多</span></span><br><span class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, renderPost);</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h1 id=\"纯函数的好处\"><a href=\"#纯函数的好处\" class=\"headerlink\" title=\"纯函数的好处\"></a>纯函数的好处</h1><blockquote>\n<p>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的<strong>副作用</strong>。</p>\n</blockquote>\n<h3 id=\"函数的副作用\"><a href=\"#函数的副作用\" class=\"headerlink\" title=\"函数的副作用\"></a>函数的副作用</h3><p>slice和splice相比，slice是一种纯函数，splice会修改自身数据，在函数式编程中比较讨厌这种笨函数。<br>另外，看这个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不纯的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> minimum = <span class=\"number\">21</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> checkAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> age &gt;= minimum;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>checkAge</code>依赖外部变量<code>minimum</code>，<code>minimum</code>发生变化的时候，会影响<code>checkAge</code>函数的返回结果，增加认知负荷。<br>也可以调用<code>Object.freeze({minimum: 21})</code>将minimum变成一个不可变对象。</p>\n<blockquote>\n<p>副作用是在计算过程中，系统状态的一种变化，或者是与外部世界进行的可观察的交互。也是滋生bug的温床。</p>\n</blockquote>\n<h3 id=\"追求“纯”的理由\"><a href=\"#追求“纯”的理由\" class=\"headerlink\" title=\"追求“纯”的理由\"></a>追求“纯”的理由</h3><ul>\n<li>可缓存性（Cacheable）<br>可以通过延迟执行的方式把不纯的函数转换为纯函数：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pureHttpCall = memoize(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url, params</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> $.getJSON(url, params); &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>之所以是纯函数，因为总是根据相同的输入返回相同的输出：同一个发送http请求的函数。</p>\n<ul>\n<li>可移植性／自文档化（Portable / Self-Documenting）<br>与环境无关；注入依赖或者通过参数传递。<blockquote>\n<p> Erlang 语言的作者 Joe Armstrong 说的这句话：“面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩…以及整个丛林”。</p>\n</blockquote>\n</li>\n<li>可测试性（Testable）<br><a href=\"http://hackage.haskell.org/package/QuickCheck\" target=\"_blank\" rel=\"noopener\">Quickcheck</a>——一个为函数式环境量身定制的测试工具</li>\n<li>合理性（Reasonable）<br>引用透明性:如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。</li>\n<li>并行代码<br>可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。</li>\n</ul>\n<h1 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h1><blockquote>\n<p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。<br>另一种理解是：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>\n</blockquote>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行 add 函数，一次传入两个参数即可</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数curry</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 每次传入一个参数</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p>可以借助Lodash 中的 curry 方法帮我们实现函数柯里化，核心思想是————比较多次接受的参数总数与函数定义时的入参数量，当接受参数的数量大于或等于被 Currying 函数的传入参数数量时，就返回计算结果，否则返回一个继续接受参数的函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trueCurrying</span>(<span class=\"params\">fn, ...args</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn(...args)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...args2</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> trueCurrying(fn, ...args, ...args2)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"用处\"><a href=\"#用处\" class=\"headerlink\" title=\"用处\"></a>用处</h3><p>curry的用处十分广泛，给函数传入一些参数后，可以得到一些新的函数。例如下面的<code>getChildren</code>函数，传给柯里化后的map函数，会返回一个接收参数类型为数组的新函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = require(&apos;lodash&apos;).curry;</span><br><span class=\"line\">var map = curry(function(f, ary) &#123;</span><br><span class=\"line\">  return ary.map(f);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var getChildren = function(x) &#123;</span><br><span class=\"line\">  return x.childNodes;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var allTheChildren = map(getChildren);</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回所有div的子节点</span><br><span class=\"line\">allTheChildren(document.getElementsByTagName(&apos;div&apos;))</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"代码组合\"><a href=\"#代码组合\" class=\"headerlink\" title=\"代码组合\"></a>代码组合</h1><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,g</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(g(x));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>f</code>和<code>g</code>是两个函数，通过组合方式返回一个新的函数，<code>x</code>就是在两个管道之间传输的值。<br>举个例子，如果希望给<code>send in the clowns</code>加上<code>!</code>，并且转成大写，可以使用函数组合的方法来实现这个功能。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> toUpperCase = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x.toUpperCase(); &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> exclaim = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x + <span class=\"string\">'!'</span>; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> shout = compose(exclaim, toUpperCase);</span><br><span class=\"line\"></span><br><span class=\"line\">shout(<span class=\"string\">\"send in the clowns\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; \"SEND IN THE CLOWNS!\"</span></span><br></pre></td></tr></table></figure></p>\n<p><code>compose</code>使用主要特点有：</p>\n<pre><code>- 代码的运行顺序是从右向左，创建了一个从右向左的数据流，初始函数一定放到参数的`最右面`；\n- `compose`的参数是函数，返回的也是一个函数；\n- 除了第一个函数的接受参数，其他函数的接受参数都是上一个函数的返回值，所以初始函数的参数是多元的，而其他函数的接受值是一元的；\n</code></pre><h3 id=\"结合律\"><a href=\"#结合律\" class=\"headerlink\" title=\"结合律\"></a>结合律</h3><p>组合的概念来源于数学课本，满足组合的特性——结合律<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结合律（associativity）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> associative = compose(f, compose(g, h)) == compose(compose(f, g), h);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。例如可以进行下面的重构：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loudLastUpper = compose(exclaim, toUpperCase, head, reverse);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> last = compose(head, reverse);</span><br><span class=\"line\"><span class=\"keyword\">var</span> loudLastUpper = compose(exclaim, toUpperCase, last);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> last = compose(head, reverse);</span><br><span class=\"line\"><span class=\"keyword\">var</span> angry = compose(exclaim, toUpperCase);</span><br><span class=\"line\"><span class=\"keyword\">var</span> loudLastUpper = compose(angry, last);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更多变种...</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"pointfree\"><a href=\"#pointfree\" class=\"headerlink\" title=\"pointfree\"></a>pointfree</h3><blockquote>\n<p>Pointfree style means never having to say your data.<br>通过管道把数据在接受单个参数的函数间传递，不需要去声明中间的变量。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非 pointfree，因为提到了数据：name</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> initials = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> name.split(<span class=\"string\">' '</span>).map(compose(toUpperCase, head)).join(<span class=\"string\">'. '</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pointfree</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> initials = compose(join(<span class=\"string\">'. '</span>), map(compose(toUpperCase, head)), split(<span class=\"string\">' '</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">initials(<span class=\"string\">\"hunter stockton thompson\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 'H. S. T'</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。</p>\n<p><strong>组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动</strong>——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。</p>\n<p>PS: **<a href=\"https://ramdajs.com/\" target=\"_blank\" rel=\"noopener\">Ramda</a></p>\n<ul>\n<li>数据一律放在最后一个参数，理念是”function first，data last”;</li>\n<li>库所有的函数都支持柯里化**，可以很好地实践FP。</li>\n</ul>\n<p>REFS:<br><a href=\"http://jimliu.net/2015/10/21/real-functional-programming-in-javascript-1/\" target=\"_blank\" rel=\"noopener\">使用JavaScript实现“真·函数式编程”</a><br><a href=\"http://www.ruanyifeng.com/blog/2017/03/ramda.html\" target=\"_blank\" rel=\"noopener\">Ramda 函数库参考教程</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"一等公民的函数\"><a href=\"#一等公民的函数\" class=\"headerlink\" title=\"一等公民的函数\"></a>一等公民的函数</h1><h3 id=\"为啥说函数是一等公民？\"><a href=\"#为啥说函数是一等公民？\" class=\"headerlink\" title=\"为啥说函数是一等公民？\"></a>为啥说函数是一等公民？</h3><ul>\n<li>函数和其他对象一样，可以像对待任何其他数据类型一样对待它们——把它们存在数组里，当作参数传递，赋值给变量…等等。<br>关键点在于，调用的时候没必要再去包裹一层多余的函数，因为二者是等价的。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\\\包裹了多余的函数</span><br><span class=\"line\"><span class=\"keyword\">var</span> greeting = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;<span class=\"keyword\">return</span> hi(name);&#125;</span><br><span class=\"line\">\\\\ 一等公民式的调用</span><br><span class=\"line\"><span class=\"keyword\">var</span> greeting = hi;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"一等公民函数调用的好处\"><a href=\"#一等公民函数调用的好处\" class=\"headerlink\" title=\"一等公民函数调用的好处\"></a>一等公民函数调用的好处</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最初的函数</span></span><br><span class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> renderPost(json);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要增加对err异常的处理，要处理的地方比较多</span></span><br><span class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json, err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> renderPost(json, err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果使用一等公民函数的形式，则其他的改动会少很多</span></span><br><span class=\"line\">httpGet(<span class=\"string\">'/post/2'</span>, renderPost);</span><br></pre></td></tr></table></figure>","more":"<h1 id=\"纯函数的好处\"><a href=\"#纯函数的好处\" class=\"headerlink\" title=\"纯函数的好处\"></a>纯函数的好处</h1><blockquote>\n<p>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的<strong>副作用</strong>。</p>\n</blockquote>\n<h3 id=\"函数的副作用\"><a href=\"#函数的副作用\" class=\"headerlink\" title=\"函数的副作用\"></a>函数的副作用</h3><p>slice和splice相比，slice是一种纯函数，splice会修改自身数据，在函数式编程中比较讨厌这种笨函数。<br>另外，看这个例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不纯的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> minimum = <span class=\"number\">21</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> checkAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> age &gt;= minimum;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>checkAge</code>依赖外部变量<code>minimum</code>，<code>minimum</code>发生变化的时候，会影响<code>checkAge</code>函数的返回结果，增加认知负荷。<br>也可以调用<code>Object.freeze({minimum: 21})</code>将minimum变成一个不可变对象。</p>\n<blockquote>\n<p>副作用是在计算过程中，系统状态的一种变化，或者是与外部世界进行的可观察的交互。也是滋生bug的温床。</p>\n</blockquote>\n<h3 id=\"追求“纯”的理由\"><a href=\"#追求“纯”的理由\" class=\"headerlink\" title=\"追求“纯”的理由\"></a>追求“纯”的理由</h3><ul>\n<li>可缓存性（Cacheable）<br>可以通过延迟执行的方式把不纯的函数转换为纯函数：<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pureHttpCall = memoize(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">url, params</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> $.getJSON(url, params); &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>之所以是纯函数，因为总是根据相同的输入返回相同的输出：同一个发送http请求的函数。</p>\n<ul>\n<li>可移植性／自文档化（Portable / Self-Documenting）<br>与环境无关；注入依赖或者通过参数传递。<blockquote>\n<p> Erlang 语言的作者 Joe Armstrong 说的这句话：“面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩…以及整个丛林”。</p>\n</blockquote>\n</li>\n<li>可测试性（Testable）<br><a href=\"http://hackage.haskell.org/package/QuickCheck\" target=\"_blank\" rel=\"noopener\">Quickcheck</a>——一个为函数式环境量身定制的测试工具</li>\n<li>合理性（Reasonable）<br>引用透明性:如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。</li>\n<li>并行代码<br>可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。</li>\n</ul>\n<h1 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h1><blockquote>\n<p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。<br>另一种理解是：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>\n</blockquote>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行 add 函数，一次传入两个参数即可</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数curry</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 每次传入一个参数</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p>可以借助Lodash 中的 curry 方法帮我们实现函数柯里化，核心思想是————比较多次接受的参数总数与函数定义时的入参数量，当接受参数的数量大于或等于被 Currying 函数的传入参数数量时，就返回计算结果，否则返回一个继续接受参数的函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">trueCurrying</span>(<span class=\"params\">fn, ...args</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (args.length &gt;= fn.length) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn(...args)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...args2</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> trueCurrying(fn, ...args, ...args2)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"用处\"><a href=\"#用处\" class=\"headerlink\" title=\"用处\"></a>用处</h3><p>curry的用处十分广泛，给函数传入一些参数后，可以得到一些新的函数。例如下面的<code>getChildren</code>函数，传给柯里化后的map函数，会返回一个接收参数类型为数组的新函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var curry = require(&apos;lodash&apos;).curry;</span><br><span class=\"line\">var map = curry(function(f, ary) &#123;</span><br><span class=\"line\">  return ary.map(f);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var getChildren = function(x) &#123;</span><br><span class=\"line\">  return x.childNodes;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var allTheChildren = map(getChildren);</span><br><span class=\"line\"></span><br><span class=\"line\">// 返回所有div的子节点</span><br><span class=\"line\">allTheChildren(document.getElementsByTagName(&apos;div&apos;))</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"代码组合\"><a href=\"#代码组合\" class=\"headerlink\" title=\"代码组合\"></a>代码组合</h1><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,g</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(g(x));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>f</code>和<code>g</code>是两个函数，通过组合方式返回一个新的函数，<code>x</code>就是在两个管道之间传输的值。<br>举个例子，如果希望给<code>send in the clowns</code>加上<code>!</code>，并且转成大写，可以使用函数组合的方法来实现这个功能。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> toUpperCase = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x.toUpperCase(); &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> exclaim = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x + <span class=\"string\">'!'</span>; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> shout = compose(exclaim, toUpperCase);</span><br><span class=\"line\"></span><br><span class=\"line\">shout(<span class=\"string\">\"send in the clowns\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; \"SEND IN THE CLOWNS!\"</span></span><br></pre></td></tr></table></figure></p>\n<p><code>compose</code>使用主要特点有：</p>\n<pre><code>- 代码的运行顺序是从右向左，创建了一个从右向左的数据流，初始函数一定放到参数的`最右面`；\n- `compose`的参数是函数，返回的也是一个函数；\n- 除了第一个函数的接受参数，其他函数的接受参数都是上一个函数的返回值，所以初始函数的参数是多元的，而其他函数的接受值是一元的；\n</code></pre><h3 id=\"结合律\"><a href=\"#结合律\" class=\"headerlink\" title=\"结合律\"></a>结合律</h3><p>组合的概念来源于数学课本，满足组合的特性——结合律<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 结合律（associativity）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> associative = compose(f, compose(g, h)) == compose(compose(f, g), h);</span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。例如可以进行下面的重构：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> loudLastUpper = compose(exclaim, toUpperCase, head, reverse);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> last = compose(head, reverse);</span><br><span class=\"line\"><span class=\"keyword\">var</span> loudLastUpper = compose(exclaim, toUpperCase, last);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> last = compose(head, reverse);</span><br><span class=\"line\"><span class=\"keyword\">var</span> angry = compose(exclaim, toUpperCase);</span><br><span class=\"line\"><span class=\"keyword\">var</span> loudLastUpper = compose(angry, last);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更多变种...</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"pointfree\"><a href=\"#pointfree\" class=\"headerlink\" title=\"pointfree\"></a>pointfree</h3><blockquote>\n<p>Pointfree style means never having to say your data.<br>通过管道把数据在接受单个参数的函数间传递，不需要去声明中间的变量。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 非 pointfree，因为提到了数据：name</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> initials = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> name.split(<span class=\"string\">' '</span>).map(compose(toUpperCase, head)).join(<span class=\"string\">'. '</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pointfree</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> initials = compose(join(<span class=\"string\">'. '</span>), map(compose(toUpperCase, head)), split(<span class=\"string\">' '</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">initials(<span class=\"string\">\"hunter stockton thompson\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 'H. S. T'</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。</p>\n<p><strong>组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动</strong>——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。</p>\n<p>PS: **<a href=\"https://ramdajs.com/\" target=\"_blank\" rel=\"noopener\">Ramda</a></p>\n<ul>\n<li>数据一律放在最后一个参数，理念是”function first，data last”;</li>\n<li>库所有的函数都支持柯里化**，可以很好地实践FP。</li>\n</ul>\n<p>REFS:<br><a href=\"http://jimliu.net/2015/10/21/real-functional-programming-in-javascript-1/\" target=\"_blank\" rel=\"noopener\">使用JavaScript实现“真·函数式编程”</a><br><a href=\"http://www.ruanyifeng.com/blog/2017/03/ramda.html\" target=\"_blank\" rel=\"noopener\">Ramda 函数库参考教程</a></p>"},{"title":"cmd小工具开发","date":"2018-05-31T02:02:52.000Z","_content":"### cmd项目初始化\n首先新建一个文件夹，并且初始化package.json，同时在bin文件夹下面创建入口文件index.js。\n``` bash\n    npm init #初始化'package.json'文件\n```\nindex.js文件头部有`#!/usr/bin/env node`，叫做[shebang](https://en.wikipedia.org/wiki/Shebang_(Unix))，指定脚本解释程序为`node`。\npackage.json文件中bin字段配置了cmd命令将执行的js文件，如下所示：\n``` js\n{\n  \"name\": \"mkfile-cli\",\n  \"version\": \"1.0.7\",\n  \"main\": \"index.js\",\n  \"bin\": {\n    \"mk\": \"bin/index.js\"\n  },\n  \"repository\": {\n    \"type\" : \"git\",\n    \"url\" : \"https://xxx\"\n  },\n  \"author\": \"sherrywu\",\n  \"license\": \"ISC\",\n}\n```\n#### 运行\n- 可以运行`node bin/index.js`命令\n- 通过`npm link`的方式\n- 还可以通过`npm install . -g`安装到全局\n\n### cmd命令行工具开发\n#### commander.js\n[Commander](https://github.com/tj/commander.js)是一个轻量级、强大的命令行开发框架，提供了封装好的API，帮助用户快速开发命令行工具。\n##### 安装：\n``` bash\nnpm install commander --save\n```\n\n#### option\noption()方法的定义\n\n- option(flags, description, fn, defaultValue)\n\n  - flags <String> : 自定义参数，格式为\"-shortFlag, --longFlag null|`<value>`|[value]|`<value>`..`<value>`\"\n\n1. -shortFlag：\"-\"后面跟的是自定义参数的短标志，一般用longFlag的第一个字母(区分大小写)\n2. --longFlag ：\"--\"后面跟的是自定义参数的长标志，shortFlag和longFlag必须同时存在，\n3. null|`<value>`|[value]：有3种情况\n  - null——可以不带参数\n  - `<value>`——“<>”修饰，参数必须。\n  - [value]——”[]“修饰, 参数可选。\n4. description <String> : 对flags参数的描述\n5. fn <Function|Mixed> : 自定义处理参数的方法，如果传入的不是一个方法，会先判断是否为一个正则表达式，如果不是，则视为defaultValue（默认值），\n6. defaultValue <Mixed> ：自定义参数默认值\n7. 返回值 <Object>：commander对象\n\n``` js\nprogram\n    .version('1.0.1')\n    .option('-n, --new <filename>', '创建文件')\n    .parse(process.argv);\nif(program.new || program.n) {\n  console.log('文件名：' + (program.new || program.n))\n}\n```\n通过`mk -h`可以查看帮助文档，-h 和 -V都是commander封装好的命令:\n``` bash\n$ mk -h\n\n  Usage: index [options]\n\n  Options:\n\n    -V, --version         output the version number\n    -n, --new <filename>  创建文件\n    -h, --help            output usage information\n```\n\n#### on事件监听\n此外还可以自定义help文档，通过监听--help触发定义的回调方法。\n``` bash\nprogram.on('--help', function () {\n    console.log('  自定义的例子:')\n    console.log('')\n    console.log('    输出命令  mk -n test -k activityList')\n    console.log('    输出命令  mk --new test')\n    console.log('')\n})\n.parse(process.argv);\n```\n`program.parse` 会解析命令行参数以及触发回调方法，因为nodejs的emit会立刻触发事件，所以将该方法放在命令及事件监听的最后面。\n\n\n#### 参数\n运行`mk -n test -k activityList`命令，可以通过program.n和program.k分别获得文件名'test'和模板key值'activityList'。\n\n#### 主要流程\n运行`mk -n test -k activityList`，读取`mk.json`文件中定义的模板,根据key值读取此次创建文件的模板来源：\n- dir: 创建文件的目标位置\n- suffix: 文件后缀\n- tpl: 文件模板，模板内容可以自定义，使用的模板语法是[nunjucks](https://mozilla.github.io/nunjucks/)。\n``` json\n{\n    \"fileList\" : [\n        {\"dir\": \"test/js\", \"suffix\": \"js\", \"tpl\": \"tpl/js.tpl\"},\n        {\"dir\": \"test/css\", \"suffix\": \"css\", \"tpl\": \"tpl/css.tpl\"}\n    ],\n    \"activityList\" : [\n        {\"dir\": \"activity/js\", \"suffix\": \"js\", \"tpl\": \"tpl/js.tpl\"}\n    ]\n}\n```\n\n### npm包开发\n首先要`npm adduser`来注册个npm账号，如果已经有账号，可以使用`npm login`来登录。\n通过`npm version <update_type>`对版本进行管理，更新了版本号后发布：\n```\nnpm publish\n```\n最终发布的npm包见[mkfile-cli](https://www.npmjs.com/package/mkfile-cli)\n","source":"_posts/cmd小工具开发.md","raw":"---\ntitle: cmd小工具开发\ndate: 2018-05-31 10:02:52\ntags:\n---\n### cmd项目初始化\n首先新建一个文件夹，并且初始化package.json，同时在bin文件夹下面创建入口文件index.js。\n``` bash\n    npm init #初始化'package.json'文件\n```\nindex.js文件头部有`#!/usr/bin/env node`，叫做[shebang](https://en.wikipedia.org/wiki/Shebang_(Unix))，指定脚本解释程序为`node`。\npackage.json文件中bin字段配置了cmd命令将执行的js文件，如下所示：\n``` js\n{\n  \"name\": \"mkfile-cli\",\n  \"version\": \"1.0.7\",\n  \"main\": \"index.js\",\n  \"bin\": {\n    \"mk\": \"bin/index.js\"\n  },\n  \"repository\": {\n    \"type\" : \"git\",\n    \"url\" : \"https://xxx\"\n  },\n  \"author\": \"sherrywu\",\n  \"license\": \"ISC\",\n}\n```\n#### 运行\n- 可以运行`node bin/index.js`命令\n- 通过`npm link`的方式\n- 还可以通过`npm install . -g`安装到全局\n\n### cmd命令行工具开发\n#### commander.js\n[Commander](https://github.com/tj/commander.js)是一个轻量级、强大的命令行开发框架，提供了封装好的API，帮助用户快速开发命令行工具。\n##### 安装：\n``` bash\nnpm install commander --save\n```\n\n#### option\noption()方法的定义\n\n- option(flags, description, fn, defaultValue)\n\n  - flags <String> : 自定义参数，格式为\"-shortFlag, --longFlag null|`<value>`|[value]|`<value>`..`<value>`\"\n\n1. -shortFlag：\"-\"后面跟的是自定义参数的短标志，一般用longFlag的第一个字母(区分大小写)\n2. --longFlag ：\"--\"后面跟的是自定义参数的长标志，shortFlag和longFlag必须同时存在，\n3. null|`<value>`|[value]：有3种情况\n  - null——可以不带参数\n  - `<value>`——“<>”修饰，参数必须。\n  - [value]——”[]“修饰, 参数可选。\n4. description <String> : 对flags参数的描述\n5. fn <Function|Mixed> : 自定义处理参数的方法，如果传入的不是一个方法，会先判断是否为一个正则表达式，如果不是，则视为defaultValue（默认值），\n6. defaultValue <Mixed> ：自定义参数默认值\n7. 返回值 <Object>：commander对象\n\n``` js\nprogram\n    .version('1.0.1')\n    .option('-n, --new <filename>', '创建文件')\n    .parse(process.argv);\nif(program.new || program.n) {\n  console.log('文件名：' + (program.new || program.n))\n}\n```\n通过`mk -h`可以查看帮助文档，-h 和 -V都是commander封装好的命令:\n``` bash\n$ mk -h\n\n  Usage: index [options]\n\n  Options:\n\n    -V, --version         output the version number\n    -n, --new <filename>  创建文件\n    -h, --help            output usage information\n```\n\n#### on事件监听\n此外还可以自定义help文档，通过监听--help触发定义的回调方法。\n``` bash\nprogram.on('--help', function () {\n    console.log('  自定义的例子:')\n    console.log('')\n    console.log('    输出命令  mk -n test -k activityList')\n    console.log('    输出命令  mk --new test')\n    console.log('')\n})\n.parse(process.argv);\n```\n`program.parse` 会解析命令行参数以及触发回调方法，因为nodejs的emit会立刻触发事件，所以将该方法放在命令及事件监听的最后面。\n\n\n#### 参数\n运行`mk -n test -k activityList`命令，可以通过program.n和program.k分别获得文件名'test'和模板key值'activityList'。\n\n#### 主要流程\n运行`mk -n test -k activityList`，读取`mk.json`文件中定义的模板,根据key值读取此次创建文件的模板来源：\n- dir: 创建文件的目标位置\n- suffix: 文件后缀\n- tpl: 文件模板，模板内容可以自定义，使用的模板语法是[nunjucks](https://mozilla.github.io/nunjucks/)。\n``` json\n{\n    \"fileList\" : [\n        {\"dir\": \"test/js\", \"suffix\": \"js\", \"tpl\": \"tpl/js.tpl\"},\n        {\"dir\": \"test/css\", \"suffix\": \"css\", \"tpl\": \"tpl/css.tpl\"}\n    ],\n    \"activityList\" : [\n        {\"dir\": \"activity/js\", \"suffix\": \"js\", \"tpl\": \"tpl/js.tpl\"}\n    ]\n}\n```\n\n### npm包开发\n首先要`npm adduser`来注册个npm账号，如果已经有账号，可以使用`npm login`来登录。\n通过`npm version <update_type>`对版本进行管理，更新了版本号后发布：\n```\nnpm publish\n```\n最终发布的npm包见[mkfile-cli](https://www.npmjs.com/package/mkfile-cli)\n","slug":"cmd小工具开发","published":1,"updated":"2019-03-18T02:27:14.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx620007qmhfzsv1eoum","content":"<h3 id=\"cmd项目初始化\"><a href=\"#cmd项目初始化\" class=\"headerlink\" title=\"cmd项目初始化\"></a>cmd项目初始化</h3><p>首先新建一个文件夹，并且初始化package.json，同时在bin文件夹下面创建入口文件index.js。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init <span class=\"comment\">#初始化'package.json'文件</span></span><br></pre></td></tr></table></figure></p>\n<p>index.js文件头部有<code>#!/usr/bin/env node</code>，叫做<a href=\"https://en.wikipedia.org/wiki/Shebang_(Unix\" target=\"_blank\" rel=\"noopener\">shebang</a>)，指定脚本解释程序为<code>node</code>。<br>package.json文件中bin字段配置了cmd命令将执行的js文件，如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"mkfile-cli\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.7\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"main\"</span>: <span class=\"string\">\"index.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"bin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"mk\"</span>: <span class=\"string\">\"bin/index.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"repository\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span> : <span class=\"string\">\"git\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span> : <span class=\"string\">\"https://xxx\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"author\"</span>: <span class=\"string\">\"sherrywu\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"license\"</span>: <span class=\"string\">\"ISC\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><ul>\n<li>可以运行<code>node bin/index.js</code>命令</li>\n<li>通过<code>npm link</code>的方式</li>\n<li>还可以通过<code>npm install . -g</code>安装到全局</li>\n</ul>\n<h3 id=\"cmd命令行工具开发\"><a href=\"#cmd命令行工具开发\" class=\"headerlink\" title=\"cmd命令行工具开发\"></a>cmd命令行工具开发</h3><h4 id=\"commander-js\"><a href=\"#commander-js\" class=\"headerlink\" title=\"commander.js\"></a>commander.js</h4><p><a href=\"https://github.com/tj/commander.js\" target=\"_blank\" rel=\"noopener\">Commander</a>是一个轻量级、强大的命令行开发框架，提供了封装好的API，帮助用户快速开发命令行工具。</p>\n<h5 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install commander --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"option\"><a href=\"#option\" class=\"headerlink\" title=\"option\"></a>option</h4><p>option()方法的定义</p>\n<ul>\n<li><p>option(flags, description, fn, defaultValue)</p>\n<ul>\n<li>flags <string> : 自定义参数，格式为”-shortFlag, –longFlag null|<code>&lt;value&gt;</code>|[value]|<code>&lt;value&gt;</code>..<code>&lt;value&gt;</code>“</string></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>-shortFlag：”-“后面跟的是自定义参数的短标志，一般用longFlag的第一个字母(区分大小写)</li>\n<li>–longFlag ：”–”后面跟的是自定义参数的长标志，shortFlag和longFlag必须同时存在，</li>\n<li>null|<code>&lt;value&gt;</code>|[value]：有3种情况<ul>\n<li>null——可以不带参数</li>\n<li><code>&lt;value&gt;</code>——“&lt;&gt;”修饰，参数必须。</li>\n<li>[value]——”[]“修饰, 参数可选。</li>\n</ul>\n</li>\n<li>description <string> : 对flags参数的描述</string></li>\n<li>fn &lt;Function|Mixed&gt; : 自定义处理参数的方法，如果传入的不是一个方法，会先判断是否为一个正则表达式，如果不是，则视为defaultValue（默认值），</li>\n<li>defaultValue <mixed> ：自定义参数默认值</mixed></li>\n<li>返回值 <object>：commander对象</object></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">program</span><br><span class=\"line\">    .version(<span class=\"string\">'1.0.1'</span>)</span><br><span class=\"line\">    .option(<span class=\"string\">'-n, --new &lt;filename&gt;'</span>, <span class=\"string\">'创建文件'</span>)</span><br><span class=\"line\">    .parse(process.argv);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(program.new || program.n) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'文件名：'</span> + (program.new || program.n))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>mk -h</code>可以查看帮助文档，-h 和 -V都是commander封装好的命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mk -h</span><br><span class=\"line\"></span><br><span class=\"line\">  Usage: index [options]</span><br><span class=\"line\"></span><br><span class=\"line\">  Options:</span><br><span class=\"line\"></span><br><span class=\"line\">    -V, --version         output the version number</span><br><span class=\"line\">    -n, --new &lt;filename&gt;  创建文件</span><br><span class=\"line\">    -h, --<span class=\"built_in\">help</span>            output usage information</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"on事件监听\"><a href=\"#on事件监听\" class=\"headerlink\" title=\"on事件监听\"></a>on事件监听</h4><p>此外还可以自定义help文档，通过监听–help触发定义的回调方法。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">program.on(<span class=\"string\">'--help'</span>, <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'  自定义的例子:'</span>)</span><br><span class=\"line\">    console.log(<span class=\"string\">''</span>)</span><br><span class=\"line\">    console.log(<span class=\"string\">'    输出命令  mk -n test -k activityList'</span>)</span><br><span class=\"line\">    console.log(<span class=\"string\">'    输出命令  mk --new test'</span>)</span><br><span class=\"line\">    console.log(<span class=\"string\">''</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.parse(process.argv);</span><br></pre></td></tr></table></figure></p>\n<p><code>program.parse</code> 会解析命令行参数以及触发回调方法，因为nodejs的emit会立刻触发事件，所以将该方法放在命令及事件监听的最后面。</p>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>运行<code>mk -n test -k activityList</code>命令，可以通过program.n和program.k分别获得文件名’test’和模板key值’activityList’。</p>\n<h4 id=\"主要流程\"><a href=\"#主要流程\" class=\"headerlink\" title=\"主要流程\"></a>主要流程</h4><p>运行<code>mk -n test -k activityList</code>，读取<code>mk.json</code>文件中定义的模板,根据key值读取此次创建文件的模板来源：</p>\n<ul>\n<li>dir: 创建文件的目标位置</li>\n<li>suffix: 文件后缀</li>\n<li>tpl: 文件模板，模板内容可以自定义，使用的模板语法是<a href=\"https://mozilla.github.io/nunjucks/\" target=\"_blank\" rel=\"noopener\">nunjucks</a>。<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"fileList\"</span> : [</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"dir\"</span>: <span class=\"string\">\"test/js\"</span>, <span class=\"attr\">\"suffix\"</span>: <span class=\"string\">\"js\"</span>, <span class=\"attr\">\"tpl\"</span>: <span class=\"string\">\"tpl/js.tpl\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"dir\"</span>: <span class=\"string\">\"test/css\"</span>, <span class=\"attr\">\"suffix\"</span>: <span class=\"string\">\"css\"</span>, <span class=\"attr\">\"tpl\"</span>: <span class=\"string\">\"tpl/css.tpl\"</span>&#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">\"activityList\"</span> : [</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"dir\"</span>: <span class=\"string\">\"activity/js\"</span>, <span class=\"attr\">\"suffix\"</span>: <span class=\"string\">\"js\"</span>, <span class=\"attr\">\"tpl\"</span>: <span class=\"string\">\"tpl/js.tpl\"</span>&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"npm包开发\"><a href=\"#npm包开发\" class=\"headerlink\" title=\"npm包开发\"></a>npm包开发</h3><p>首先要<code>npm adduser</code>来注册个npm账号，如果已经有账号，可以使用<code>npm login</code>来登录。<br>通过<code>npm version &lt;update_type&gt;</code>对版本进行管理，更新了版本号后发布：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure></p>\n<p>最终发布的npm包见<a href=\"https://www.npmjs.com/package/mkfile-cli\" target=\"_blank\" rel=\"noopener\">mkfile-cli</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"cmd项目初始化\"><a href=\"#cmd项目初始化\" class=\"headerlink\" title=\"cmd项目初始化\"></a>cmd项目初始化</h3><p>首先新建一个文件夹，并且初始化package.json，同时在bin文件夹下面创建入口文件index.js。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init <span class=\"comment\">#初始化'package.json'文件</span></span><br></pre></td></tr></table></figure></p>\n<p>index.js文件头部有<code>#!/usr/bin/env node</code>，叫做<a href=\"https://en.wikipedia.org/wiki/Shebang_(Unix\" target=\"_blank\" rel=\"noopener\">shebang</a>)，指定脚本解释程序为<code>node</code>。<br>package.json文件中bin字段配置了cmd命令将执行的js文件，如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"mkfile-cli\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"version\"</span>: <span class=\"string\">\"1.0.7\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"main\"</span>: <span class=\"string\">\"index.js\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"bin\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"mk\"</span>: <span class=\"string\">\"bin/index.js\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"repository\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span> : <span class=\"string\">\"git\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"url\"</span> : <span class=\"string\">\"https://xxx\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"author\"</span>: <span class=\"string\">\"sherrywu\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"license\"</span>: <span class=\"string\">\"ISC\"</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h4><ul>\n<li>可以运行<code>node bin/index.js</code>命令</li>\n<li>通过<code>npm link</code>的方式</li>\n<li>还可以通过<code>npm install . -g</code>安装到全局</li>\n</ul>\n<h3 id=\"cmd命令行工具开发\"><a href=\"#cmd命令行工具开发\" class=\"headerlink\" title=\"cmd命令行工具开发\"></a>cmd命令行工具开发</h3><h4 id=\"commander-js\"><a href=\"#commander-js\" class=\"headerlink\" title=\"commander.js\"></a>commander.js</h4><p><a href=\"https://github.com/tj/commander.js\" target=\"_blank\" rel=\"noopener\">Commander</a>是一个轻量级、强大的命令行开发框架，提供了封装好的API，帮助用户快速开发命令行工具。</p>\n<h5 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install commander --save</span><br></pre></td></tr></table></figure>\n<h4 id=\"option\"><a href=\"#option\" class=\"headerlink\" title=\"option\"></a>option</h4><p>option()方法的定义</p>\n<ul>\n<li><p>option(flags, description, fn, defaultValue)</p>\n<ul>\n<li>flags <string> : 自定义参数，格式为”-shortFlag, –longFlag null|<code>&lt;value&gt;</code>|[value]|<code>&lt;value&gt;</code>..<code>&lt;value&gt;</code>“</string></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>-shortFlag：”-“后面跟的是自定义参数的短标志，一般用longFlag的第一个字母(区分大小写)</li>\n<li>–longFlag ：”–”后面跟的是自定义参数的长标志，shortFlag和longFlag必须同时存在，</li>\n<li>null|<code>&lt;value&gt;</code>|[value]：有3种情况<ul>\n<li>null——可以不带参数</li>\n<li><code>&lt;value&gt;</code>——“&lt;&gt;”修饰，参数必须。</li>\n<li>[value]——”[]“修饰, 参数可选。</li>\n</ul>\n</li>\n<li>description <string> : 对flags参数的描述</string></li>\n<li>fn &lt;Function|Mixed&gt; : 自定义处理参数的方法，如果传入的不是一个方法，会先判断是否为一个正则表达式，如果不是，则视为defaultValue（默认值），</li>\n<li>defaultValue <mixed> ：自定义参数默认值</mixed></li>\n<li>返回值 <object>：commander对象</object></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">program</span><br><span class=\"line\">    .version(<span class=\"string\">'1.0.1'</span>)</span><br><span class=\"line\">    .option(<span class=\"string\">'-n, --new &lt;filename&gt;'</span>, <span class=\"string\">'创建文件'</span>)</span><br><span class=\"line\">    .parse(process.argv);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(program.new || program.n) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'文件名：'</span> + (program.new || program.n))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>mk -h</code>可以查看帮助文档，-h 和 -V都是commander封装好的命令:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mk -h</span><br><span class=\"line\"></span><br><span class=\"line\">  Usage: index [options]</span><br><span class=\"line\"></span><br><span class=\"line\">  Options:</span><br><span class=\"line\"></span><br><span class=\"line\">    -V, --version         output the version number</span><br><span class=\"line\">    -n, --new &lt;filename&gt;  创建文件</span><br><span class=\"line\">    -h, --<span class=\"built_in\">help</span>            output usage information</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"on事件监听\"><a href=\"#on事件监听\" class=\"headerlink\" title=\"on事件监听\"></a>on事件监听</h4><p>此外还可以自定义help文档，通过监听–help触发定义的回调方法。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">program.on(<span class=\"string\">'--help'</span>, <span class=\"function\"><span class=\"title\">function</span></span> () &#123;</span><br><span class=\"line\">    console.log(<span class=\"string\">'  自定义的例子:'</span>)</span><br><span class=\"line\">    console.log(<span class=\"string\">''</span>)</span><br><span class=\"line\">    console.log(<span class=\"string\">'    输出命令  mk -n test -k activityList'</span>)</span><br><span class=\"line\">    console.log(<span class=\"string\">'    输出命令  mk --new test'</span>)</span><br><span class=\"line\">    console.log(<span class=\"string\">''</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.parse(process.argv);</span><br></pre></td></tr></table></figure></p>\n<p><code>program.parse</code> 会解析命令行参数以及触发回调方法，因为nodejs的emit会立刻触发事件，所以将该方法放在命令及事件监听的最后面。</p>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>运行<code>mk -n test -k activityList</code>命令，可以通过program.n和program.k分别获得文件名’test’和模板key值’activityList’。</p>\n<h4 id=\"主要流程\"><a href=\"#主要流程\" class=\"headerlink\" title=\"主要流程\"></a>主要流程</h4><p>运行<code>mk -n test -k activityList</code>，读取<code>mk.json</code>文件中定义的模板,根据key值读取此次创建文件的模板来源：</p>\n<ul>\n<li>dir: 创建文件的目标位置</li>\n<li>suffix: 文件后缀</li>\n<li>tpl: 文件模板，模板内容可以自定义，使用的模板语法是<a href=\"https://mozilla.github.io/nunjucks/\" target=\"_blank\" rel=\"noopener\">nunjucks</a>。<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"fileList\"</span> : [</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"dir\"</span>: <span class=\"string\">\"test/js\"</span>, <span class=\"attr\">\"suffix\"</span>: <span class=\"string\">\"js\"</span>, <span class=\"attr\">\"tpl\"</span>: <span class=\"string\">\"tpl/js.tpl\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"dir\"</span>: <span class=\"string\">\"test/css\"</span>, <span class=\"attr\">\"suffix\"</span>: <span class=\"string\">\"css\"</span>, <span class=\"attr\">\"tpl\"</span>: <span class=\"string\">\"tpl/css.tpl\"</span>&#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">\"activityList\"</span> : [</span><br><span class=\"line\">        &#123;<span class=\"attr\">\"dir\"</span>: <span class=\"string\">\"activity/js\"</span>, <span class=\"attr\">\"suffix\"</span>: <span class=\"string\">\"js\"</span>, <span class=\"attr\">\"tpl\"</span>: <span class=\"string\">\"tpl/js.tpl\"</span>&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"npm包开发\"><a href=\"#npm包开发\" class=\"headerlink\" title=\"npm包开发\"></a>npm包开发</h3><p>首先要<code>npm adduser</code>来注册个npm账号，如果已经有账号，可以使用<code>npm login</code>来登录。<br>通过<code>npm version &lt;update_type&gt;</code>对版本进行管理，更新了版本号后发布：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm publish</span><br></pre></td></tr></table></figure></p>\n<p>最终发布的npm包见<a href=\"https://www.npmjs.com/package/mkfile-cli\" target=\"_blank\" rel=\"noopener\">mkfile-cli</a></p>\n"},{"title":"core-decorators源码简析——debounce","date":"2018-06-13T12:37:05.000Z","_content":"### @debounce\n防抖动函数：当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数则将取消前一次并重新计算执行时间。\n\n### 使用实例\n``` js\nimport { debounce } from 'core-decorators';\n\nclass Editor {\n\n  content = '';\n\n  @debounce(500)\n  updateContent(content) {\n    this.content = content;\n  }\n\n  bindEvent() {\n    document.getElementById('editor').oninput = e => {\n      this.updateContent(e.target.value)\n    }\n  }\n}\n```\n``` html\n<textarea id=\"editor\"></textarea>\n```\n例如在监听id为editor的编辑器输入时，每次输入都会触发`oninput`事件，调用`this.updateContent`方法。为了防止频繁地更新content，可以对`updateContent`装饰debounce方法，在输入的过程中不会去更新`this.content`，直到输入完成500毫秒后，再去一次性更新content内容。\n\n### 源码\n``` js\nimport { metaFor } from './private/utils';\n\nconst DEFAULT_TIMEOUT = 300;\n\nfunction handleDescriptor(target, key, descriptor, [wait = DEFAULT_TIMEOUT, immediate = false]) {\n  const callback = descriptor.value;\n\n  if (typeof callback !== 'function') {\n    throw new SyntaxError('Only functions can be debounced');\n  }\n\n  return {\n    ...descriptor,\n    value() {\n      //返回this的Symbol('__core_decorators__')属性: 为Meta实例\n      const { debounceTimeoutIds } = metaFor(this);\n      //已有的防抖函数调用\n      const timeout = debounceTimeoutIds[key];\n      //immediate为true且当前无timeout对象，多次调用的时候只在第一次调用时才去执行\n      const callNow = immediate && !timeout;\n      const args = arguments;\n\n      clearTimeout(timeout);\n      // 每次都覆盖之前的防抖函数，执行最后一次传入的callback函数\n      debounceTimeoutIds[key] = setTimeout(() => {\n        delete debounceTimeoutIds[key];\n        if (!immediate) {\n          callback.apply(this, args);\n        }\n      }, wait);\n\n      if (callNow) { //先执行再等待\n        callback.apply(this, args);\n      }\n    }\n  };\n}\n```\n\n#### 调用参数\n在调用的时候支持传入wait和options.immediate两个参数：\n- wait: 等待执行的时间，单位ms，默认值300\n- {immediate}: 绑定的函数是否先执行，默认值false，等待wait时间后再执行；传递的参数为true时先执行\n\n#### Meta对象\n``` js\n    const { debounceTimeoutIds } = metaFor(this);\n    //这个时候只有debounceTimeoutIds被初始化了哦，因为用了lazyInitialize\n    console.log(metaFor(this))\n```\n`metaFor`方法给当前实例增加了`Symbol('__core_decorators__')`属性，值为一个Meta对象。\nMeta类如下所示，包括debounce和throttle用到的一些属性：\n``` js\nclass Meta {\n  @lazyInitialize\n  debounceTimeoutIds = {};\n\n  @lazyInitialize\n  throttleTimeoutIds = {};\n\n  @lazyInitialize\n  throttlePreviousTimestamps = {};\n\n  @lazyInitialize\n  throttleTrailingArgs = null;\n\n  @lazyInitialize\n  profileLastRan = null;\n}\n```\n使用了`@lazyInitialize`标记，可以使得每次只初始化被用到的属性，像debounce的时候只用到debounceTimeoutIds属性。console输出Meta对象，结构如图所示，可以看到只初始化了debounceTimeoutIds属性：\n<img src=\"/image/debounce_meta.png\" width=\"360px\">\n\n#### debounceTimeout存储\n> 当调用被`@debounce`标记的方法时：\n1 . setTimeout会延迟执行该函数，返回一个timeout对象；\n2 . 返回的timeout对象会被存储在`debounceTimeoutIds[key]`中（以`updateContent`方法为例，`debounceTimeoutIds[key]`这里的key值就是`updateContent`）；\n3 . 重复调用该方法会重新创建timeout对象，并覆盖之前的`debounceTimeoutIds[key]`（这里每次调用`updateContent`都会重新给`debounceTimeoutIds['updateContent']`赋值）；\n\n``` js\nsetTimeout(() => {\n    delete debounceTimeoutIds[key];\n    if (!immediate) {\n      callback.apply(this, args);\n    }\n  }, wait);\n```\n执行的结果就是：**每次都重新等待wait时间，再去执行callback方法，callback即是key值对应的方法**。\n\n\n\n","source":"_posts/core-decorators源码简析——debounce.md","raw":"---\ntitle: core-decorators源码简析——debounce\ndate: 2018-06-13 20:37:05\ntags: [core-decorators, decorator, decorators源码简析——debounce, js]\n---\n### @debounce\n防抖动函数：当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数则将取消前一次并重新计算执行时间。\n\n### 使用实例\n``` js\nimport { debounce } from 'core-decorators';\n\nclass Editor {\n\n  content = '';\n\n  @debounce(500)\n  updateContent(content) {\n    this.content = content;\n  }\n\n  bindEvent() {\n    document.getElementById('editor').oninput = e => {\n      this.updateContent(e.target.value)\n    }\n  }\n}\n```\n``` html\n<textarea id=\"editor\"></textarea>\n```\n例如在监听id为editor的编辑器输入时，每次输入都会触发`oninput`事件，调用`this.updateContent`方法。为了防止频繁地更新content，可以对`updateContent`装饰debounce方法，在输入的过程中不会去更新`this.content`，直到输入完成500毫秒后，再去一次性更新content内容。\n\n### 源码\n``` js\nimport { metaFor } from './private/utils';\n\nconst DEFAULT_TIMEOUT = 300;\n\nfunction handleDescriptor(target, key, descriptor, [wait = DEFAULT_TIMEOUT, immediate = false]) {\n  const callback = descriptor.value;\n\n  if (typeof callback !== 'function') {\n    throw new SyntaxError('Only functions can be debounced');\n  }\n\n  return {\n    ...descriptor,\n    value() {\n      //返回this的Symbol('__core_decorators__')属性: 为Meta实例\n      const { debounceTimeoutIds } = metaFor(this);\n      //已有的防抖函数调用\n      const timeout = debounceTimeoutIds[key];\n      //immediate为true且当前无timeout对象，多次调用的时候只在第一次调用时才去执行\n      const callNow = immediate && !timeout;\n      const args = arguments;\n\n      clearTimeout(timeout);\n      // 每次都覆盖之前的防抖函数，执行最后一次传入的callback函数\n      debounceTimeoutIds[key] = setTimeout(() => {\n        delete debounceTimeoutIds[key];\n        if (!immediate) {\n          callback.apply(this, args);\n        }\n      }, wait);\n\n      if (callNow) { //先执行再等待\n        callback.apply(this, args);\n      }\n    }\n  };\n}\n```\n\n#### 调用参数\n在调用的时候支持传入wait和options.immediate两个参数：\n- wait: 等待执行的时间，单位ms，默认值300\n- {immediate}: 绑定的函数是否先执行，默认值false，等待wait时间后再执行；传递的参数为true时先执行\n\n#### Meta对象\n``` js\n    const { debounceTimeoutIds } = metaFor(this);\n    //这个时候只有debounceTimeoutIds被初始化了哦，因为用了lazyInitialize\n    console.log(metaFor(this))\n```\n`metaFor`方法给当前实例增加了`Symbol('__core_decorators__')`属性，值为一个Meta对象。\nMeta类如下所示，包括debounce和throttle用到的一些属性：\n``` js\nclass Meta {\n  @lazyInitialize\n  debounceTimeoutIds = {};\n\n  @lazyInitialize\n  throttleTimeoutIds = {};\n\n  @lazyInitialize\n  throttlePreviousTimestamps = {};\n\n  @lazyInitialize\n  throttleTrailingArgs = null;\n\n  @lazyInitialize\n  profileLastRan = null;\n}\n```\n使用了`@lazyInitialize`标记，可以使得每次只初始化被用到的属性，像debounce的时候只用到debounceTimeoutIds属性。console输出Meta对象，结构如图所示，可以看到只初始化了debounceTimeoutIds属性：\n<img src=\"/image/debounce_meta.png\" width=\"360px\">\n\n#### debounceTimeout存储\n> 当调用被`@debounce`标记的方法时：\n1 . setTimeout会延迟执行该函数，返回一个timeout对象；\n2 . 返回的timeout对象会被存储在`debounceTimeoutIds[key]`中（以`updateContent`方法为例，`debounceTimeoutIds[key]`这里的key值就是`updateContent`）；\n3 . 重复调用该方法会重新创建timeout对象，并覆盖之前的`debounceTimeoutIds[key]`（这里每次调用`updateContent`都会重新给`debounceTimeoutIds['updateContent']`赋值）；\n\n``` js\nsetTimeout(() => {\n    delete debounceTimeoutIds[key];\n    if (!immediate) {\n      callback.apply(this, args);\n    }\n  }, wait);\n```\n执行的结果就是：**每次都重新等待wait时间，再去执行callback方法，callback即是key值对应的方法**。\n\n\n\n","slug":"core-decorators源码简析——debounce","published":1,"updated":"2019-03-18T02:27:14.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx640008qmhf7llyoe6y","content":"<h3 id=\"debounce\"><a href=\"#debounce\" class=\"headerlink\" title=\"@debounce\"></a>@debounce</h3><p>防抖动函数：当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数则将取消前一次并重新计算执行时间。</p>\n<h3 id=\"使用实例\"><a href=\"#使用实例\" class=\"headerlink\" title=\"使用实例\"></a>使用实例</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; debounce &#125; <span class=\"keyword\">from</span> <span class=\"string\">'core-decorators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Editor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  content = <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  @debounce(<span class=\"number\">500</span>)</span><br><span class=\"line\">  updateContent(content) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.content = content;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  bindEvent() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'editor'</span>).oninput = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.updateContent(e.target.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">id</span>=<span class=\"string\">\"editor\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>例如在监听id为editor的编辑器输入时，每次输入都会触发<code>oninput</code>事件，调用<code>this.updateContent</code>方法。为了防止频繁地更新content，可以对<code>updateContent</code>装饰debounce方法，在输入的过程中不会去更新<code>this.content</code>，直到输入完成500毫秒后，再去一次性更新content内容。</p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; metaFor &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./private/utils'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> DEFAULT_TIMEOUT = <span class=\"number\">300</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleDescriptor</span>(<span class=\"params\">target, key, descriptor, [wait = DEFAULT_TIMEOUT, immediate = false]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> callback = descriptor.value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">SyntaxError</span>(<span class=\"string\">'Only functions can be debounced'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ...descriptor,</span><br><span class=\"line\">    value() &#123;</span><br><span class=\"line\">      <span class=\"comment\">//返回this的Symbol('__core_decorators__')属性: 为Meta实例</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; debounceTimeoutIds &#125; = metaFor(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"comment\">//已有的防抖函数调用</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> timeout = debounceTimeoutIds[key];</span><br><span class=\"line\">      <span class=\"comment\">//immediate为true且当前无timeout对象，多次调用的时候只在第一次调用时才去执行</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      clearTimeout(timeout);</span><br><span class=\"line\">      <span class=\"comment\">// 每次都覆盖之前的防抖函数，执行最后一次传入的callback函数</span></span><br><span class=\"line\">      debounceTimeoutIds[key] = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> debounceTimeoutIds[key];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!immediate) &#123;</span><br><span class=\"line\">          callback.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callNow) &#123; <span class=\"comment\">//先执行再等待</span></span><br><span class=\"line\">        callback.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"调用参数\"><a href=\"#调用参数\" class=\"headerlink\" title=\"调用参数\"></a>调用参数</h4><p>在调用的时候支持传入wait和options.immediate两个参数：</p>\n<ul>\n<li>wait: 等待执行的时间，单位ms，默认值300</li>\n<li>{immediate}: 绑定的函数是否先执行，默认值false，等待wait时间后再执行；传递的参数为true时先执行</li>\n</ul>\n<h4 id=\"Meta对象\"><a href=\"#Meta对象\" class=\"headerlink\" title=\"Meta对象\"></a>Meta对象</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; debounceTimeoutIds &#125; = metaFor(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"comment\">//这个时候只有debounceTimeoutIds被初始化了哦，因为用了lazyInitialize</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(metaFor(<span class=\"keyword\">this</span>))</span><br></pre></td></tr></table></figure>\n<p><code>metaFor</code>方法给当前实例增加了<code>Symbol(&#39;__core_decorators__&#39;)</code>属性，值为一个Meta对象。<br>Meta类如下所示，包括debounce和throttle用到的一些属性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span> </span>&#123;</span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  debounceTimeoutIds = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  throttleTimeoutIds = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  throttlePreviousTimestamps = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  throttleTrailingArgs = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  profileLastRan = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用了<code>@lazyInitialize</code>标记，可以使得每次只初始化被用到的属性，像debounce的时候只用到debounceTimeoutIds属性。console输出Meta对象，结构如图所示，可以看到只初始化了debounceTimeoutIds属性：<br><img src=\"/image/debounce_meta.png\" width=\"360px\"></p>\n<h4 id=\"debounceTimeout存储\"><a href=\"#debounceTimeout存储\" class=\"headerlink\" title=\"debounceTimeout存储\"></a>debounceTimeout存储</h4><blockquote>\n<p>当调用被<code>@debounce</code>标记的方法时：<br>1 . setTimeout会延迟执行该函数，返回一个timeout对象；<br>2 . 返回的timeout对象会被存储在<code>debounceTimeoutIds[key]</code>中（以<code>updateContent</code>方法为例，<code>debounceTimeoutIds[key]</code>这里的key值就是<code>updateContent</code>）；<br>3 . 重复调用该方法会重新创建timeout对象，并覆盖之前的<code>debounceTimeoutIds[key]</code>（这里每次调用<code>updateContent</code>都会重新给<code>debounceTimeoutIds[&#39;updateContent&#39;]</code>赋值）；</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> debounceTimeoutIds[key];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!immediate) &#123;</span><br><span class=\"line\">      callback.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, wait);</span><br></pre></td></tr></table></figure>\n<p>执行的结果就是：<strong>每次都重新等待wait时间，再去执行callback方法，callback即是key值对应的方法</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"debounce\"><a href=\"#debounce\" class=\"headerlink\" title=\"@debounce\"></a>@debounce</h3><p>防抖动函数：当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数则将取消前一次并重新计算执行时间。</p>\n<h3 id=\"使用实例\"><a href=\"#使用实例\" class=\"headerlink\" title=\"使用实例\"></a>使用实例</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; debounce &#125; <span class=\"keyword\">from</span> <span class=\"string\">'core-decorators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Editor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  content = <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  @debounce(<span class=\"number\">500</span>)</span><br><span class=\"line\">  updateContent(content) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.content = content;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  bindEvent() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'editor'</span>).oninput = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.updateContent(e.target.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">id</span>=<span class=\"string\">\"editor\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>例如在监听id为editor的编辑器输入时，每次输入都会触发<code>oninput</code>事件，调用<code>this.updateContent</code>方法。为了防止频繁地更新content，可以对<code>updateContent</code>装饰debounce方法，在输入的过程中不会去更新<code>this.content</code>，直到输入完成500毫秒后，再去一次性更新content内容。</p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; metaFor &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./private/utils'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> DEFAULT_TIMEOUT = <span class=\"number\">300</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleDescriptor</span>(<span class=\"params\">target, key, descriptor, [wait = DEFAULT_TIMEOUT, immediate = false]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> callback = descriptor.value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">SyntaxError</span>(<span class=\"string\">'Only functions can be debounced'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ...descriptor,</span><br><span class=\"line\">    value() &#123;</span><br><span class=\"line\">      <span class=\"comment\">//返回this的Symbol('__core_decorators__')属性: 为Meta实例</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; debounceTimeoutIds &#125; = metaFor(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"comment\">//已有的防抖函数调用</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> timeout = debounceTimeoutIds[key];</span><br><span class=\"line\">      <span class=\"comment\">//immediate为true且当前无timeout对象，多次调用的时候只在第一次调用时才去执行</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      clearTimeout(timeout);</span><br><span class=\"line\">      <span class=\"comment\">// 每次都覆盖之前的防抖函数，执行最后一次传入的callback函数</span></span><br><span class=\"line\">      debounceTimeoutIds[key] = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> debounceTimeoutIds[key];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!immediate) &#123;</span><br><span class=\"line\">          callback.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callNow) &#123; <span class=\"comment\">//先执行再等待</span></span><br><span class=\"line\">        callback.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"调用参数\"><a href=\"#调用参数\" class=\"headerlink\" title=\"调用参数\"></a>调用参数</h4><p>在调用的时候支持传入wait和options.immediate两个参数：</p>\n<ul>\n<li>wait: 等待执行的时间，单位ms，默认值300</li>\n<li>{immediate}: 绑定的函数是否先执行，默认值false，等待wait时间后再执行；传递的参数为true时先执行</li>\n</ul>\n<h4 id=\"Meta对象\"><a href=\"#Meta对象\" class=\"headerlink\" title=\"Meta对象\"></a>Meta对象</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; debounceTimeoutIds &#125; = metaFor(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"comment\">//这个时候只有debounceTimeoutIds被初始化了哦，因为用了lazyInitialize</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(metaFor(<span class=\"keyword\">this</span>))</span><br></pre></td></tr></table></figure>\n<p><code>metaFor</code>方法给当前实例增加了<code>Symbol(&#39;__core_decorators__&#39;)</code>属性，值为一个Meta对象。<br>Meta类如下所示，包括debounce和throttle用到的一些属性：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span> </span>&#123;</span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  debounceTimeoutIds = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  throttleTimeoutIds = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  throttlePreviousTimestamps = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  throttleTrailingArgs = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  profileLastRan = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用了<code>@lazyInitialize</code>标记，可以使得每次只初始化被用到的属性，像debounce的时候只用到debounceTimeoutIds属性。console输出Meta对象，结构如图所示，可以看到只初始化了debounceTimeoutIds属性：<br><img src=\"/image/debounce_meta.png\" width=\"360px\"></p>\n<h4 id=\"debounceTimeout存储\"><a href=\"#debounceTimeout存储\" class=\"headerlink\" title=\"debounceTimeout存储\"></a>debounceTimeout存储</h4><blockquote>\n<p>当调用被<code>@debounce</code>标记的方法时：<br>1 . setTimeout会延迟执行该函数，返回一个timeout对象；<br>2 . 返回的timeout对象会被存储在<code>debounceTimeoutIds[key]</code>中（以<code>updateContent</code>方法为例，<code>debounceTimeoutIds[key]</code>这里的key值就是<code>updateContent</code>）；<br>3 . 重复调用该方法会重新创建timeout对象，并覆盖之前的<code>debounceTimeoutIds[key]</code>（这里每次调用<code>updateContent</code>都会重新给<code>debounceTimeoutIds[&#39;updateContent&#39;]</code>赋值）；</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> debounceTimeoutIds[key];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!immediate) &#123;</span><br><span class=\"line\">      callback.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, wait);</span><br></pre></td></tr></table></figure>\n<p>执行的结果就是：<strong>每次都重新等待wait时间，再去执行callback方法，callback即是key值对应的方法</strong>。</p>\n"},{"title":"core-decorators源码简析——lazyInitialize","date":"2018-06-14T12:45:45.000Z","_content":"### @lazyInitialize\n`@lazyInitialize`标记的作用是，只有在属性真正使用的时候才会去初始化。适用于一些在未来可能会被用到、也可能不会被用到的属性上。\n\n### 使用实例\n下面是[官网](https://github.com/jayphelps/core-decorators#lazyinitialize)给出的例子，可以帮助我们理解该标记的作用。\n``` js\nimport { lazyInitialize } from 'core-decorators';\n\nfunction createHugeBuffer() {\n  console.log('huge buffer created');\n  return new Array(1000000);\n}\n\nclass Editor {\n  @lazyInitialize\n  hugeBuffer = createHugeBuffer();\n}\n\nvar editor = new Editor();\n// createHugeBuffer() has not been called yet\n\neditor.hugeBuffer;\n// logs 'huge buffer created', now it has been called\n\neditor.hugeBuffer;\n// already initialized and equals our buffer, so\n// createHugeBuffer() is not called again\n```\n\n### 源码\n``` js\nimport { decorate, createDefaultSetter } from './private/utils';\nconst { defineProperty } = Object;\n\nfunction handleDescriptor(target, key, descriptor) {\n  const { configurable, enumerable, initializer, value } = descriptor;\n\n  return {\n    configurable,\n    enumerable,\n\n    get() {\n      // This happens if someone accesses the\n      // property directly on the prototype\n      if (this === target) {\n        return;\n      }\n\n      const ret = initializer ? initializer.call(this) : value;\n\n      defineProperty(this, key, {\n        configurable,\n        enumerable,\n        writable: true,\n        value: ret\n      });\n\n      return ret;\n    },\n\n    set: createDefaultSetter(key)\n  };\n}\n\nexport default function lazyInitialize(...args) {\n  return decorate(handleDescriptor, args);\n}\n```\n\n在第一次调用`editor.hugeBuffer`时，真正的初始化发生在这两步：\n``` js\n    const ret = initializer ? initializer.call(this) : value;\n    defineProperty(this, key, {\n        configurable,\n        enumerable,\n        writable: true,\n        value: ret\n    });\n```\n**step1**\n- 其中`initializer.call(this)`中的`this`是调用该方法的对象，这儿是`Editor`的实例对象`editor`，通过call方法`initializer`方法的this指向`editor`。\n- `initializer`是一个返回`createHugeBuffer()`的函数，`console.log(initializer)`的输出如下所示:（什么情况下initializer不存在，取value值？）\n``` js\nƒ initializer() {\n    return createHugeBuffer();\n}\n```\n\n**step2**\n> - `defineProperty`重新赋值了key值对应的descriptor对象，将初始化后的值ret赋值给对应的value字段，应该是模拟了***在类构造函数执行时，`initializer`返回的值作为属性的值***，***在类构造函数执行后，`initializer`属性被替换为value属性***。\n\n#### 为什么需要`defineProperty`\n如果删除上面get方法的`defineProperty`，则editor.hugeBuffer每次都会调用get()方法，进而执行createHugeBuffer()方法，每次都会去重新初始化，所以在属性初始化完成后，需要对value赋值，替换掉`initializer`。\n```js\n    //defineProperty(this, key, {\n    //  configurable,\n    //  enumerable,\n    //  writable: true,\n    //  value: ret\n    //});\n```\n\n","source":"_posts/core-decorators源码简析——lazyInitialize.md","raw":"---\ntitle: core-decorators源码简析——lazyInitialize\ndate: 2018-06-14 20:45:45\ntags: [core-decorators, decorator, lazyInitialize, js]\n---\n### @lazyInitialize\n`@lazyInitialize`标记的作用是，只有在属性真正使用的时候才会去初始化。适用于一些在未来可能会被用到、也可能不会被用到的属性上。\n\n### 使用实例\n下面是[官网](https://github.com/jayphelps/core-decorators#lazyinitialize)给出的例子，可以帮助我们理解该标记的作用。\n``` js\nimport { lazyInitialize } from 'core-decorators';\n\nfunction createHugeBuffer() {\n  console.log('huge buffer created');\n  return new Array(1000000);\n}\n\nclass Editor {\n  @lazyInitialize\n  hugeBuffer = createHugeBuffer();\n}\n\nvar editor = new Editor();\n// createHugeBuffer() has not been called yet\n\neditor.hugeBuffer;\n// logs 'huge buffer created', now it has been called\n\neditor.hugeBuffer;\n// already initialized and equals our buffer, so\n// createHugeBuffer() is not called again\n```\n\n### 源码\n``` js\nimport { decorate, createDefaultSetter } from './private/utils';\nconst { defineProperty } = Object;\n\nfunction handleDescriptor(target, key, descriptor) {\n  const { configurable, enumerable, initializer, value } = descriptor;\n\n  return {\n    configurable,\n    enumerable,\n\n    get() {\n      // This happens if someone accesses the\n      // property directly on the prototype\n      if (this === target) {\n        return;\n      }\n\n      const ret = initializer ? initializer.call(this) : value;\n\n      defineProperty(this, key, {\n        configurable,\n        enumerable,\n        writable: true,\n        value: ret\n      });\n\n      return ret;\n    },\n\n    set: createDefaultSetter(key)\n  };\n}\n\nexport default function lazyInitialize(...args) {\n  return decorate(handleDescriptor, args);\n}\n```\n\n在第一次调用`editor.hugeBuffer`时，真正的初始化发生在这两步：\n``` js\n    const ret = initializer ? initializer.call(this) : value;\n    defineProperty(this, key, {\n        configurable,\n        enumerable,\n        writable: true,\n        value: ret\n    });\n```\n**step1**\n- 其中`initializer.call(this)`中的`this`是调用该方法的对象，这儿是`Editor`的实例对象`editor`，通过call方法`initializer`方法的this指向`editor`。\n- `initializer`是一个返回`createHugeBuffer()`的函数，`console.log(initializer)`的输出如下所示:（什么情况下initializer不存在，取value值？）\n``` js\nƒ initializer() {\n    return createHugeBuffer();\n}\n```\n\n**step2**\n> - `defineProperty`重新赋值了key值对应的descriptor对象，将初始化后的值ret赋值给对应的value字段，应该是模拟了***在类构造函数执行时，`initializer`返回的值作为属性的值***，***在类构造函数执行后，`initializer`属性被替换为value属性***。\n\n#### 为什么需要`defineProperty`\n如果删除上面get方法的`defineProperty`，则editor.hugeBuffer每次都会调用get()方法，进而执行createHugeBuffer()方法，每次都会去重新初始化，所以在属性初始化完成后，需要对value赋值，替换掉`initializer`。\n```js\n    //defineProperty(this, key, {\n    //  configurable,\n    //  enumerable,\n    //  writable: true,\n    //  value: ret\n    //});\n```\n\n","slug":"core-decorators源码简析——lazyInitialize","published":1,"updated":"2019-03-18T02:27:14.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx66000aqmhfeghmr5my","content":"<h3 id=\"lazyInitialize\"><a href=\"#lazyInitialize\" class=\"headerlink\" title=\"@lazyInitialize\"></a>@lazyInitialize</h3><p><code>@lazyInitialize</code>标记的作用是，只有在属性真正使用的时候才会去初始化。适用于一些在未来可能会被用到、也可能不会被用到的属性上。</p>\n<h3 id=\"使用实例\"><a href=\"#使用实例\" class=\"headerlink\" title=\"使用实例\"></a>使用实例</h3><p>下面是<a href=\"https://github.com/jayphelps/core-decorators#lazyinitialize\" target=\"_blank\" rel=\"noopener\">官网</a>给出的例子，可以帮助我们理解该标记的作用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; lazyInitialize &#125; <span class=\"keyword\">from</span> <span class=\"string\">'core-decorators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createHugeBuffer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'huge buffer created'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Editor</span> </span>&#123;</span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  hugeBuffer = createHugeBuffer();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> editor = <span class=\"keyword\">new</span> Editor();</span><br><span class=\"line\"><span class=\"comment\">// createHugeBuffer() has not been called yet</span></span><br><span class=\"line\"></span><br><span class=\"line\">editor.hugeBuffer;</span><br><span class=\"line\"><span class=\"comment\">// logs 'huge buffer created', now it has been called</span></span><br><span class=\"line\"></span><br><span class=\"line\">editor.hugeBuffer;</span><br><span class=\"line\"><span class=\"comment\">// already initialized and equals our buffer, so</span></span><br><span class=\"line\"><span class=\"comment\">// createHugeBuffer() is not called again</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; decorate, createDefaultSetter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./private/utils'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; defineProperty &#125; = <span class=\"built_in\">Object</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleDescriptor</span>(<span class=\"params\">target, key, descriptor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; configurable, enumerable, initializer, value &#125; = descriptor;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    configurable,</span><br><span class=\"line\">    enumerable,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// This happens if someone accesses the</span></span><br><span class=\"line\">      <span class=\"comment\">// property directly on the prototype</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> === target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> ret = initializer ? initializer.call(<span class=\"keyword\">this</span>) : value;</span><br><span class=\"line\"></span><br><span class=\"line\">      defineProperty(<span class=\"keyword\">this</span>, key, &#123;</span><br><span class=\"line\">        configurable,</span><br><span class=\"line\">        enumerable,</span><br><span class=\"line\">        writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        value: ret</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span>: createDefaultSetter(key)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default function lazyInitialize(...args) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> decorate(handleDescriptor, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在第一次调用<code>editor.hugeBuffer</code>时，真正的初始化发生在这两步：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ret = initializer ? initializer.call(<span class=\"keyword\">this</span>) : value;</span><br><span class=\"line\">defineProperty(<span class=\"keyword\">this</span>, key, &#123;</span><br><span class=\"line\">    configurable,</span><br><span class=\"line\">    enumerable,</span><br><span class=\"line\">    writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    value: ret</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>step1</strong></p>\n<ul>\n<li>其中<code>initializer.call(this)</code>中的<code>this</code>是调用该方法的对象，这儿是<code>Editor</code>的实例对象<code>editor</code>，通过call方法<code>initializer</code>方法的this指向<code>editor</code>。</li>\n<li><code>initializer</code>是一个返回<code>createHugeBuffer()</code>的函数，<code>console.log(initializer)</code>的输出如下所示:（什么情况下initializer不存在，取value值？）<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ƒ initializer() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createHugeBuffer();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>step2</strong></p>\n<blockquote>\n<ul>\n<li><code>defineProperty</code>重新赋值了key值对应的descriptor对象，将初始化后的值ret赋值给对应的value字段，应该是模拟了<strong><em>在类构造函数执行时，<code>initializer</code>返回的值作为属性的值</em></strong>，<strong><em>在类构造函数执行后，<code>initializer</code>属性被替换为value属性</em></strong>。</li>\n</ul>\n</blockquote>\n<h4 id=\"为什么需要defineProperty\"><a href=\"#为什么需要defineProperty\" class=\"headerlink\" title=\"为什么需要defineProperty\"></a>为什么需要<code>defineProperty</code></h4><p>如果删除上面get方法的<code>defineProperty</code>，则editor.hugeBuffer每次都会调用get()方法，进而执行createHugeBuffer()方法，每次都会去重新初始化，所以在属性初始化完成后，需要对value赋值，替换掉<code>initializer</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//defineProperty(this, key, &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//  configurable,</span></span><br><span class=\"line\"><span class=\"comment\">//  enumerable,</span></span><br><span class=\"line\"><span class=\"comment\">//  writable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//  value: ret</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;);</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"lazyInitialize\"><a href=\"#lazyInitialize\" class=\"headerlink\" title=\"@lazyInitialize\"></a>@lazyInitialize</h3><p><code>@lazyInitialize</code>标记的作用是，只有在属性真正使用的时候才会去初始化。适用于一些在未来可能会被用到、也可能不会被用到的属性上。</p>\n<h3 id=\"使用实例\"><a href=\"#使用实例\" class=\"headerlink\" title=\"使用实例\"></a>使用实例</h3><p>下面是<a href=\"https://github.com/jayphelps/core-decorators#lazyinitialize\" target=\"_blank\" rel=\"noopener\">官网</a>给出的例子，可以帮助我们理解该标记的作用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; lazyInitialize &#125; <span class=\"keyword\">from</span> <span class=\"string\">'core-decorators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createHugeBuffer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'huge buffer created'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1000000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Editor</span> </span>&#123;</span><br><span class=\"line\">  @lazyInitialize</span><br><span class=\"line\">  hugeBuffer = createHugeBuffer();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> editor = <span class=\"keyword\">new</span> Editor();</span><br><span class=\"line\"><span class=\"comment\">// createHugeBuffer() has not been called yet</span></span><br><span class=\"line\"></span><br><span class=\"line\">editor.hugeBuffer;</span><br><span class=\"line\"><span class=\"comment\">// logs 'huge buffer created', now it has been called</span></span><br><span class=\"line\"></span><br><span class=\"line\">editor.hugeBuffer;</span><br><span class=\"line\"><span class=\"comment\">// already initialized and equals our buffer, so</span></span><br><span class=\"line\"><span class=\"comment\">// createHugeBuffer() is not called again</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; decorate, createDefaultSetter &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./private/utils'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; defineProperty &#125; = <span class=\"built_in\">Object</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleDescriptor</span>(<span class=\"params\">target, key, descriptor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; configurable, enumerable, initializer, value &#125; = descriptor;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    configurable,</span><br><span class=\"line\">    enumerable,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// This happens if someone accesses the</span></span><br><span class=\"line\">      <span class=\"comment\">// property directly on the prototype</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> === target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> ret = initializer ? initializer.call(<span class=\"keyword\">this</span>) : value;</span><br><span class=\"line\"></span><br><span class=\"line\">      defineProperty(<span class=\"keyword\">this</span>, key, &#123;</span><br><span class=\"line\">        configurable,</span><br><span class=\"line\">        enumerable,</span><br><span class=\"line\">        writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        value: ret</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">set</span>: createDefaultSetter(key)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default function lazyInitialize(...args) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> decorate(handleDescriptor, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在第一次调用<code>editor.hugeBuffer</code>时，真正的初始化发生在这两步：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ret = initializer ? initializer.call(<span class=\"keyword\">this</span>) : value;</span><br><span class=\"line\">defineProperty(<span class=\"keyword\">this</span>, key, &#123;</span><br><span class=\"line\">    configurable,</span><br><span class=\"line\">    enumerable,</span><br><span class=\"line\">    writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    value: ret</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>step1</strong></p>\n<ul>\n<li>其中<code>initializer.call(this)</code>中的<code>this</code>是调用该方法的对象，这儿是<code>Editor</code>的实例对象<code>editor</code>，通过call方法<code>initializer</code>方法的this指向<code>editor</code>。</li>\n<li><code>initializer</code>是一个返回<code>createHugeBuffer()</code>的函数，<code>console.log(initializer)</code>的输出如下所示:（什么情况下initializer不存在，取value值？）<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ƒ initializer() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createHugeBuffer();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>step2</strong></p>\n<blockquote>\n<ul>\n<li><code>defineProperty</code>重新赋值了key值对应的descriptor对象，将初始化后的值ret赋值给对应的value字段，应该是模拟了<strong><em>在类构造函数执行时，<code>initializer</code>返回的值作为属性的值</em></strong>，<strong><em>在类构造函数执行后，<code>initializer</code>属性被替换为value属性</em></strong>。</li>\n</ul>\n</blockquote>\n<h4 id=\"为什么需要defineProperty\"><a href=\"#为什么需要defineProperty\" class=\"headerlink\" title=\"为什么需要defineProperty\"></a>为什么需要<code>defineProperty</code></h4><p>如果删除上面get方法的<code>defineProperty</code>，则editor.hugeBuffer每次都会调用get()方法，进而执行createHugeBuffer()方法，每次都会去重新初始化，所以在属性初始化完成后，需要对value赋值，替换掉<code>initializer</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//defineProperty(this, key, &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//  configurable,</span></span><br><span class=\"line\"><span class=\"comment\">//  enumerable,</span></span><br><span class=\"line\"><span class=\"comment\">//  writable: true,</span></span><br><span class=\"line\"><span class=\"comment\">//  value: ret</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;);</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"core-decorators源码简析——readonly","date":"2018-04-17T07:40:08.000Z","_content":"直接看源码，`readonly.js`代码非常简短，核心函数是`handleDescriptor`，通过修改描述对象descriptor的writable属性为false，将目标属性置为不可修改。\n``` js\nimport { decorate } from './private/utils';\n\nfunction handleDescriptor(target, key, descriptor) {\n  descriptor.writable = false;\n  return descriptor;\n}\n\nexport default function readonly(...args) {\n  return decorate(handleDescriptor, args);\n}\n\n```\n其中`decorate`函数定义在utils文件中，具体如下:\n<!-- more -->\n\n``` js\nexport function isDescriptor(desc) {\n  if (!desc || !desc.hasOwnProperty) {\n    return false;\n  }\n\n  const keys = ['value', 'initializer', 'get', 'set'];\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n    if (desc.hasOwnProperty(keys[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function decorate(handleDescriptor, entryArgs) {\n  if (isDescriptor(entryArgs[entryArgs.length - 1])) {\n    console.log(entryArgs);\n    console.log(entryArgs[entryArgs.length - 1].initializer);\n    return handleDescriptor(...entryArgs, []);\n  } else {\n    return function () {\n      return handleDescriptor(...Array.prototype.slice.call(arguments), entryArgs);\n    };\n  }\n}\n```\n首先判断传过来的最后一个参数是否是descriptor对象，若该参数有`['value', 'initializer', 'get', 'set']`属性中的任一个，则认为是descriptor对象，直接调用`handleDescriptor`去处理。\n若所传最后一个参数不是descriptor对象，则返回一个匿名函数，可以接收额外的参数。\n\n#### descriptor对象\n基本内容如下：\n- configurable控制是否能删、修改descriptor本身。\n- writable控制是否能修改值value。\n- enumerable控制是否能枚举出属性。\n- value是该属性对应的值，可以是任何有效的JavaScript值（数值，对象，函数等）。\n- get和set控制访问属性的读和写逻辑。\n\n其中，前三个属性是一定存在的，`value`和`get/set`属性不会并存。当装饰器作用于类属性时，`descriptor`将变成一个叫“类属性描述符”的东西，其区别在于没有`value`和`get或set`，且多出一个`initializer`属性，类型是函数，***在类构造函数执行时，`initializer`返回的值作为属性的值***，***在类构造函数执行后，`initializer`属性被替换为value属性***。\n\n#### 使用\n``` js\nclass Meal {\n  @readonly // 或者@readonly()\n  entree = 'steak';\n}\n\nvar dinner = new Meal();\nconsole.log('--------对象创建后----------')\nconsole.log(Object.getOwnPropertyDescriptors(dinner));\ndinner.entree = 'salmon';\n```\n输出的descriptor前后对比：\n<img src=\"/image/readonly_console.png\" width=\"400px\">\n其中`initializer`函数内部即为`return 'steak'`。\n同时会报错<font color=#F44336>Uncaught TypeError: Cannot assign to read only property 'entree' of object '#<Meal>'</font>，提示该属性只读。\n","source":"_posts/core-decorators源码简析——readonly.md","raw":"---\ntitle: core-decorators源码简析——readonly\ndate: 2018-04-17 15:40:08\ntags: [core-decorators, decorator, readonly, js]\n---\n直接看源码，`readonly.js`代码非常简短，核心函数是`handleDescriptor`，通过修改描述对象descriptor的writable属性为false，将目标属性置为不可修改。\n``` js\nimport { decorate } from './private/utils';\n\nfunction handleDescriptor(target, key, descriptor) {\n  descriptor.writable = false;\n  return descriptor;\n}\n\nexport default function readonly(...args) {\n  return decorate(handleDescriptor, args);\n}\n\n```\n其中`decorate`函数定义在utils文件中，具体如下:\n<!-- more -->\n\n``` js\nexport function isDescriptor(desc) {\n  if (!desc || !desc.hasOwnProperty) {\n    return false;\n  }\n\n  const keys = ['value', 'initializer', 'get', 'set'];\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n    if (desc.hasOwnProperty(keys[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function decorate(handleDescriptor, entryArgs) {\n  if (isDescriptor(entryArgs[entryArgs.length - 1])) {\n    console.log(entryArgs);\n    console.log(entryArgs[entryArgs.length - 1].initializer);\n    return handleDescriptor(...entryArgs, []);\n  } else {\n    return function () {\n      return handleDescriptor(...Array.prototype.slice.call(arguments), entryArgs);\n    };\n  }\n}\n```\n首先判断传过来的最后一个参数是否是descriptor对象，若该参数有`['value', 'initializer', 'get', 'set']`属性中的任一个，则认为是descriptor对象，直接调用`handleDescriptor`去处理。\n若所传最后一个参数不是descriptor对象，则返回一个匿名函数，可以接收额外的参数。\n\n#### descriptor对象\n基本内容如下：\n- configurable控制是否能删、修改descriptor本身。\n- writable控制是否能修改值value。\n- enumerable控制是否能枚举出属性。\n- value是该属性对应的值，可以是任何有效的JavaScript值（数值，对象，函数等）。\n- get和set控制访问属性的读和写逻辑。\n\n其中，前三个属性是一定存在的，`value`和`get/set`属性不会并存。当装饰器作用于类属性时，`descriptor`将变成一个叫“类属性描述符”的东西，其区别在于没有`value`和`get或set`，且多出一个`initializer`属性，类型是函数，***在类构造函数执行时，`initializer`返回的值作为属性的值***，***在类构造函数执行后，`initializer`属性被替换为value属性***。\n\n#### 使用\n``` js\nclass Meal {\n  @readonly // 或者@readonly()\n  entree = 'steak';\n}\n\nvar dinner = new Meal();\nconsole.log('--------对象创建后----------')\nconsole.log(Object.getOwnPropertyDescriptors(dinner));\ndinner.entree = 'salmon';\n```\n输出的descriptor前后对比：\n<img src=\"/image/readonly_console.png\" width=\"400px\">\n其中`initializer`函数内部即为`return 'steak'`。\n同时会报错<font color=#F44336>Uncaught TypeError: Cannot assign to read only property 'entree' of object '#<Meal>'</font>，提示该属性只读。\n","slug":"core-decorators源码简析——readonly","published":1,"updated":"2019-03-18T02:27:14.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx67000cqmhfek3smpe8","content":"<p>直接看源码，<code>readonly.js</code>代码非常简短，核心函数是<code>handleDescriptor</code>，通过修改描述对象descriptor的writable属性为false，将目标属性置为不可修改。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; decorate &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./private/utils'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleDescriptor</span>(<span class=\"params\">target, key, descriptor</span>) </span>&#123;</span><br><span class=\"line\">  descriptor.writable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> descriptor;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readonly</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> decorate(handleDescriptor, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>decorate</code>函数定义在utils文件中，具体如下:<br><a id=\"more\"></a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isDescriptor</span>(<span class=\"params\">desc</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!desc || !desc.hasOwnProperty) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keys = [<span class=\"string\">'value'</span>, <span class=\"string\">'initializer'</span>, <span class=\"string\">'get'</span>, <span class=\"string\">'set'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (desc.hasOwnProperty(keys[i])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decorate</span>(<span class=\"params\">handleDescriptor, entryArgs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isDescriptor(entryArgs[entryArgs.length - <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(entryArgs);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(entryArgs[entryArgs.length - <span class=\"number\">1</span>].initializer);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handleDescriptor(...entryArgs, []);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> handleDescriptor(...Array.prototype.slice.call(<span class=\"built_in\">arguments</span>), entryArgs);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先判断传过来的最后一个参数是否是descriptor对象，若该参数有<code>[&#39;value&#39;, &#39;initializer&#39;, &#39;get&#39;, &#39;set&#39;]</code>属性中的任一个，则认为是descriptor对象，直接调用<code>handleDescriptor</code>去处理。<br>若所传最后一个参数不是descriptor对象，则返回一个匿名函数，可以接收额外的参数。</p>\n<h4 id=\"descriptor对象\"><a href=\"#descriptor对象\" class=\"headerlink\" title=\"descriptor对象\"></a>descriptor对象</h4><p>基本内容如下：</p>\n<ul>\n<li>configurable控制是否能删、修改descriptor本身。</li>\n<li>writable控制是否能修改值value。</li>\n<li>enumerable控制是否能枚举出属性。</li>\n<li>value是该属性对应的值，可以是任何有效的JavaScript值（数值，对象，函数等）。</li>\n<li>get和set控制访问属性的读和写逻辑。</li>\n</ul>\n<p>其中，前三个属性是一定存在的，<code>value</code>和<code>get/set</code>属性不会并存。当装饰器作用于类属性时，<code>descriptor</code>将变成一个叫“类属性描述符”的东西，其区别在于没有<code>value</code>和<code>get或set</code>，且多出一个<code>initializer</code>属性，类型是函数，<strong><em>在类构造函数执行时，<code>initializer</code>返回的值作为属性的值</em></strong>，<strong><em>在类构造函数执行后，<code>initializer</code>属性被替换为value属性</em></strong>。</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meal</span> </span>&#123;</span><br><span class=\"line\">  @readonly <span class=\"comment\">// 或者@readonly()</span></span><br><span class=\"line\">  entree = <span class=\"string\">'steak'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dinner = <span class=\"keyword\">new</span> Meal();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'--------对象创建后----------'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptors(dinner));</span><br><span class=\"line\">dinner.entree = <span class=\"string\">'salmon'</span>;</span><br></pre></td></tr></table></figure>\n<p>输出的descriptor前后对比：<br><img src=\"/image/readonly_console.png\" width=\"400px\"><br>其中<code>initializer</code>函数内部即为<code>return &#39;steak&#39;</code>。<br>同时会报错<font color=\"#F44336\">Uncaught TypeError: Cannot assign to read only property ‘entree’ of object ‘#<meal>‘</meal></font>，提示该属性只读。</p>\n","site":{"data":{}},"excerpt":"<p>直接看源码，<code>readonly.js</code>代码非常简短，核心函数是<code>handleDescriptor</code>，通过修改描述对象descriptor的writable属性为false，将目标属性置为不可修改。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; decorate &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./private/utils'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleDescriptor</span>(<span class=\"params\">target, key, descriptor</span>) </span>&#123;</span><br><span class=\"line\">  descriptor.writable = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> descriptor;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readonly</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> decorate(handleDescriptor, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>decorate</code>函数定义在utils文件中，具体如下:<br>","more":"</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isDescriptor</span>(<span class=\"params\">desc</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!desc || !desc.hasOwnProperty) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keys = [<span class=\"string\">'value'</span>, <span class=\"string\">'initializer'</span>, <span class=\"string\">'get'</span>, <span class=\"string\">'set'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (desc.hasOwnProperty(keys[i])) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decorate</span>(<span class=\"params\">handleDescriptor, entryArgs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isDescriptor(entryArgs[entryArgs.length - <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(entryArgs);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(entryArgs[entryArgs.length - <span class=\"number\">1</span>].initializer);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handleDescriptor(...entryArgs, []);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> handleDescriptor(...Array.prototype.slice.call(<span class=\"built_in\">arguments</span>), entryArgs);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先判断传过来的最后一个参数是否是descriptor对象，若该参数有<code>[&#39;value&#39;, &#39;initializer&#39;, &#39;get&#39;, &#39;set&#39;]</code>属性中的任一个，则认为是descriptor对象，直接调用<code>handleDescriptor</code>去处理。<br>若所传最后一个参数不是descriptor对象，则返回一个匿名函数，可以接收额外的参数。</p>\n<h4 id=\"descriptor对象\"><a href=\"#descriptor对象\" class=\"headerlink\" title=\"descriptor对象\"></a>descriptor对象</h4><p>基本内容如下：</p>\n<ul>\n<li>configurable控制是否能删、修改descriptor本身。</li>\n<li>writable控制是否能修改值value。</li>\n<li>enumerable控制是否能枚举出属性。</li>\n<li>value是该属性对应的值，可以是任何有效的JavaScript值（数值，对象，函数等）。</li>\n<li>get和set控制访问属性的读和写逻辑。</li>\n</ul>\n<p>其中，前三个属性是一定存在的，<code>value</code>和<code>get/set</code>属性不会并存。当装饰器作用于类属性时，<code>descriptor</code>将变成一个叫“类属性描述符”的东西，其区别在于没有<code>value</code>和<code>get或set</code>，且多出一个<code>initializer</code>属性，类型是函数，<strong><em>在类构造函数执行时，<code>initializer</code>返回的值作为属性的值</em></strong>，<strong><em>在类构造函数执行后，<code>initializer</code>属性被替换为value属性</em></strong>。</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meal</span> </span>&#123;</span><br><span class=\"line\">  @readonly <span class=\"comment\">// 或者@readonly()</span></span><br><span class=\"line\">  entree = <span class=\"string\">'steak'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dinner = <span class=\"keyword\">new</span> Meal();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'--------对象创建后----------'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptors(dinner));</span><br><span class=\"line\">dinner.entree = <span class=\"string\">'salmon'</span>;</span><br></pre></td></tr></table></figure>\n<p>输出的descriptor前后对比：<br><img src=\"/image/readonly_console.png\" width=\"400px\"><br>其中<code>initializer</code>函数内部即为<code>return &#39;steak&#39;</code>。<br>同时会报错<font color=\"#F44336\">Uncaught TypeError: Cannot assign to read only property ‘entree’ of object ‘#<meal>‘</meal></font>，提示该属性只读。</p>"},{"title":"core-decorators源码简析——throttle","date":"2018-06-25T08:14:08.000Z","_content":"### @throttle\n节流函数：函数节流能使得连续的函数执行，变为**固定时间段**间断地执行。\n\n### 使用实例\n例如在监听窗口滚动事件时，稍微滚动一下，就会触发多次onscroll事件，去更新位置信息。如果onscroll事件是去进行dom操作，频繁地更新dom可能会导致低版本浏览器卡死。所以希望可以间隔一段时间，再去执行回调函数。\n应用`throttle`函数，设置wait时间为1000ms，可以保证回调函数至少每隔1000ms执行一次。\n``` js\nimport { throttle } from 'core-decorators';\n\nclass Scroller {\n\n  position = '';\n\n  @throttle(1000, {leading: false})\n  updatePosition() {\n    this.position = window.scrollY;\n  }\n\n  bindEvent() {\n    window.onscroll = () => {\n        this.updatePosition()\n    };\n  }\n}\n```\n\n### 源码实现\n#### 参数\n在调用的时候支持传入wait、options.leading、options.trailing三个参数：\n- wait: 等待执行的时间，单位ms，默认值300\n- {leading}: 绑定的函数在节流开始前执行，默认值true，触发事件刚开始时执行回调\n- {trailing}: 绑定的函数在节流开始后执行，默认值true，触发事件结束时执行回调\n\n#### 具体实现\n``` js\nfunction handleDescriptor(target, key, descriptor, [wait = DEFAULT_TIMEOUT, options = {}]) {\n  const callback = descriptor.value;\n\n  if (typeof callback !== 'function') {\n    throw new SyntaxError('Only functions can be throttled');\n  }\n\n  if (options.leading !== false) {\n    options.leading = true\n  }\n\n  if(options.trailing !== false) {\n    options.trailing = true\n  }\n\n  return {\n    ...descriptor,\n    value() {\n      // 同debounce，会返回this的Symbol('__core_decorators__')属性: 为Meta实例\n      const meta = metaFor(this);\n      const { throttleTimeoutIds, throttlePreviousTimestamps } = meta;\n      const timeout = throttleTimeoutIds[key];\n      // 上次函数执行时的时间戳\n      let previous = throttlePreviousTimestamps[key] || 0;\n      const now = Date.now();\n\n      // options.trailing为true时，将待执行函数callback的参数赋值给meta.throttleTrailingArgs，保证在setTimeout回调函数中可以取到参数\n      if (options.trailing) {\n        meta.throttleTrailingArgs = arguments;\n      }\n\n      // 第一次调用，并且leading参数为false时，将上次执行时间戳设为当前\n      // trailing为true时，leading为false，throttlePreviousTimestamps[key]始终被赋值为0\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n\n      // leading为false的时候，previous=now, remaining时间始终等于wait，始终不会在节流函数开始时执行回调函数\n      // leading为true的时候，第一次调用，previous为0，remaining为负值；再次调用，previous为上次回调执行时间，若距离上次执行时间已经等待了wait毫秒，则remaining<=0\n      const remaining = wait - (now - previous);\n\n      //{leading: true} remaining<=0的时候，会在节流开始前执行callback函数\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        delete throttleTimeoutIds[key];\n        // 更新上次执行时间戳\n        throttlePreviousTimestamps[key] = now;\n        // 执行回调函数\n        callback.apply(this, arguments);\n      } else if (!timeout && options.trailing) {\n        // 当前没有timeout对象，并且trailing为true\n        // {trailing: true, leading: false} 设置remaining = wait毫秒后去执行回调函数\n        // {trailing: true, leading: true} 第二次调用才会设置remaining=wait - (now - previous)毫秒后去执行回调函数\n        throttleTimeoutIds[key] = setTimeout(() => {\n          // 更新上次执行时间戳，leading为false，throttlePreviousTimestamps[key]始终被赋值为0\n          throttlePreviousTimestamps[key] = options.leading === false ? 0 : Date.now();\n          // 删掉timeout对象\n          delete throttleTimeoutIds[key];\n          // 执行回调函数\n          callback.apply(this, meta.throttleTrailingArgs);\n          // 防止内存泄露\n          meta.throttleTrailingArgs = null;\n        }, remaining);\n      }\n    }\n  };\n}\n```\n\n> 结合了时间戳和定时器setTimeout两种方式来实现throttle函数:\n> - leading为true时，主要根据时间戳来记录上次执行时间，每次触发事件时，判断当前时间距离上次执行时间是否已经等待了wait毫秒，如果是，则立即执行\n> - trailing为true时，主要通过setTimeout定时器来设定间隔某个时间段才去执行\n>   * leading为false，定时**wait毫秒(从当前时间算起)**后去执行\n>   * leading为true时，定时**距离上次执行累计wait毫秒**后去执行\n> - 每次执行都会记录下当前执行时间，用来控制时间间隔\n\n\n\n\n","source":"_posts/core-decorators源码简析——throttle.md","raw":"---\ntitle: core-decorators源码简析——throttle\ndate: 2018-06-25 16:14:08\ntags: [core-decorators, decorator, decorators源码简析——debounce, js]\n---\n### @throttle\n节流函数：函数节流能使得连续的函数执行，变为**固定时间段**间断地执行。\n\n### 使用实例\n例如在监听窗口滚动事件时，稍微滚动一下，就会触发多次onscroll事件，去更新位置信息。如果onscroll事件是去进行dom操作，频繁地更新dom可能会导致低版本浏览器卡死。所以希望可以间隔一段时间，再去执行回调函数。\n应用`throttle`函数，设置wait时间为1000ms，可以保证回调函数至少每隔1000ms执行一次。\n``` js\nimport { throttle } from 'core-decorators';\n\nclass Scroller {\n\n  position = '';\n\n  @throttle(1000, {leading: false})\n  updatePosition() {\n    this.position = window.scrollY;\n  }\n\n  bindEvent() {\n    window.onscroll = () => {\n        this.updatePosition()\n    };\n  }\n}\n```\n\n### 源码实现\n#### 参数\n在调用的时候支持传入wait、options.leading、options.trailing三个参数：\n- wait: 等待执行的时间，单位ms，默认值300\n- {leading}: 绑定的函数在节流开始前执行，默认值true，触发事件刚开始时执行回调\n- {trailing}: 绑定的函数在节流开始后执行，默认值true，触发事件结束时执行回调\n\n#### 具体实现\n``` js\nfunction handleDescriptor(target, key, descriptor, [wait = DEFAULT_TIMEOUT, options = {}]) {\n  const callback = descriptor.value;\n\n  if (typeof callback !== 'function') {\n    throw new SyntaxError('Only functions can be throttled');\n  }\n\n  if (options.leading !== false) {\n    options.leading = true\n  }\n\n  if(options.trailing !== false) {\n    options.trailing = true\n  }\n\n  return {\n    ...descriptor,\n    value() {\n      // 同debounce，会返回this的Symbol('__core_decorators__')属性: 为Meta实例\n      const meta = metaFor(this);\n      const { throttleTimeoutIds, throttlePreviousTimestamps } = meta;\n      const timeout = throttleTimeoutIds[key];\n      // 上次函数执行时的时间戳\n      let previous = throttlePreviousTimestamps[key] || 0;\n      const now = Date.now();\n\n      // options.trailing为true时，将待执行函数callback的参数赋值给meta.throttleTrailingArgs，保证在setTimeout回调函数中可以取到参数\n      if (options.trailing) {\n        meta.throttleTrailingArgs = arguments;\n      }\n\n      // 第一次调用，并且leading参数为false时，将上次执行时间戳设为当前\n      // trailing为true时，leading为false，throttlePreviousTimestamps[key]始终被赋值为0\n      if (!previous && options.leading === false) {\n        previous = now;\n      }\n\n      // leading为false的时候，previous=now, remaining时间始终等于wait，始终不会在节流函数开始时执行回调函数\n      // leading为true的时候，第一次调用，previous为0，remaining为负值；再次调用，previous为上次回调执行时间，若距离上次执行时间已经等待了wait毫秒，则remaining<=0\n      const remaining = wait - (now - previous);\n\n      //{leading: true} remaining<=0的时候，会在节流开始前执行callback函数\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        delete throttleTimeoutIds[key];\n        // 更新上次执行时间戳\n        throttlePreviousTimestamps[key] = now;\n        // 执行回调函数\n        callback.apply(this, arguments);\n      } else if (!timeout && options.trailing) {\n        // 当前没有timeout对象，并且trailing为true\n        // {trailing: true, leading: false} 设置remaining = wait毫秒后去执行回调函数\n        // {trailing: true, leading: true} 第二次调用才会设置remaining=wait - (now - previous)毫秒后去执行回调函数\n        throttleTimeoutIds[key] = setTimeout(() => {\n          // 更新上次执行时间戳，leading为false，throttlePreviousTimestamps[key]始终被赋值为0\n          throttlePreviousTimestamps[key] = options.leading === false ? 0 : Date.now();\n          // 删掉timeout对象\n          delete throttleTimeoutIds[key];\n          // 执行回调函数\n          callback.apply(this, meta.throttleTrailingArgs);\n          // 防止内存泄露\n          meta.throttleTrailingArgs = null;\n        }, remaining);\n      }\n    }\n  };\n}\n```\n\n> 结合了时间戳和定时器setTimeout两种方式来实现throttle函数:\n> - leading为true时，主要根据时间戳来记录上次执行时间，每次触发事件时，判断当前时间距离上次执行时间是否已经等待了wait毫秒，如果是，则立即执行\n> - trailing为true时，主要通过setTimeout定时器来设定间隔某个时间段才去执行\n>   * leading为false，定时**wait毫秒(从当前时间算起)**后去执行\n>   * leading为true时，定时**距离上次执行累计wait毫秒**后去执行\n> - 每次执行都会记录下当前执行时间，用来控制时间间隔\n\n\n\n\n","slug":"core-decorators源码简析——throttle","published":1,"updated":"2019-03-18T02:27:14.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6b000fqmhfbnyav5ws","content":"<h3 id=\"throttle\"><a href=\"#throttle\" class=\"headerlink\" title=\"@throttle\"></a>@throttle</h3><p>节流函数：函数节流能使得连续的函数执行，变为<strong>固定时间段</strong>间断地执行。</p>\n<h3 id=\"使用实例\"><a href=\"#使用实例\" class=\"headerlink\" title=\"使用实例\"></a>使用实例</h3><p>例如在监听窗口滚动事件时，稍微滚动一下，就会触发多次onscroll事件，去更新位置信息。如果onscroll事件是去进行dom操作，频繁地更新dom可能会导致低版本浏览器卡死。所以希望可以间隔一段时间，再去执行回调函数。<br>应用<code>throttle</code>函数，设置wait时间为1000ms，可以保证回调函数至少每隔1000ms执行一次。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; throttle &#125; <span class=\"keyword\">from</span> <span class=\"string\">'core-decorators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scroller</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  position = <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  @throttle(<span class=\"number\">1000</span>, &#123;<span class=\"attr\">leading</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\">  updatePosition() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.position = <span class=\"built_in\">window</span>.scrollY;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  bindEvent() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.updatePosition()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"源码实现\"><a href=\"#源码实现\" class=\"headerlink\" title=\"源码实现\"></a>源码实现</h3><h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>在调用的时候支持传入wait、options.leading、options.trailing三个参数：</p>\n<ul>\n<li>wait: 等待执行的时间，单位ms，默认值300</li>\n<li>{leading}: 绑定的函数在节流开始前执行，默认值true，触发事件刚开始时执行回调</li>\n<li>{trailing}: 绑定的函数在节流开始后执行，默认值true，触发事件结束时执行回调</li>\n</ul>\n<h4 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleDescriptor</span>(<span class=\"params\">target, key, descriptor, [wait = DEFAULT_TIMEOUT, options = &#123;&#125;]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> callback = descriptor.value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">SyntaxError</span>(<span class=\"string\">'Only functions can be throttled'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.leading !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    options.leading = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(options.trailing !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    options.trailing = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ...descriptor,</span><br><span class=\"line\">    value() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 同debounce，会返回this的Symbol('__core_decorators__')属性: 为Meta实例</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> meta = metaFor(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; throttleTimeoutIds, throttlePreviousTimestamps &#125; = meta;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> timeout = throttleTimeoutIds[key];</span><br><span class=\"line\">      <span class=\"comment\">// 上次函数执行时的时间戳</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> previous = throttlePreviousTimestamps[key] || <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> now = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// options.trailing为true时，将待执行函数callback的参数赋值给meta.throttleTrailingArgs，保证在setTimeout回调函数中可以取到参数</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (options.trailing) &#123;</span><br><span class=\"line\">        meta.throttleTrailingArgs = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 第一次调用，并且leading参数为false时，将上次执行时间戳设为当前</span></span><br><span class=\"line\">      <span class=\"comment\">// trailing为true时，leading为false，throttlePreviousTimestamps[key]始终被赋值为0</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!previous &amp;&amp; options.leading === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        previous = now;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// leading为false的时候，previous=now, remaining时间始终等于wait，始终不会在节流函数开始时执行回调函数</span></span><br><span class=\"line\">      <span class=\"comment\">// leading为true的时候，第一次调用，previous为0，remaining为负值；再次调用，previous为上次回调执行时间，若距离上次执行时间已经等待了wait毫秒，则remaining&lt;=0</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//&#123;leading: true&#125; remaining&lt;=0的时候，会在节流开始前执行callback函数</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        clearTimeout(timeout);</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> throttleTimeoutIds[key];</span><br><span class=\"line\">        <span class=\"comment\">// 更新上次执行时间戳</span></span><br><span class=\"line\">        throttlePreviousTimestamps[key] = now;</span><br><span class=\"line\">        <span class=\"comment\">// 执行回调函数</span></span><br><span class=\"line\">        callback.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.trailing) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前没有timeout对象，并且trailing为true</span></span><br><span class=\"line\">        <span class=\"comment\">// &#123;trailing: true, leading: false&#125; 设置remaining = wait毫秒后去执行回调函数</span></span><br><span class=\"line\">        <span class=\"comment\">// &#123;trailing: true, leading: true&#125; 第二次调用才会设置remaining=wait - (now - previous)毫秒后去执行回调函数</span></span><br><span class=\"line\">        throttleTimeoutIds[key] = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 更新上次执行时间戳，leading为false，throttlePreviousTimestamps[key]始终被赋值为0</span></span><br><span class=\"line\">          throttlePreviousTimestamps[key] = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">          <span class=\"comment\">// 删掉timeout对象</span></span><br><span class=\"line\">          <span class=\"keyword\">delete</span> throttleTimeoutIds[key];</span><br><span class=\"line\">          <span class=\"comment\">// 执行回调函数</span></span><br><span class=\"line\">          callback.apply(<span class=\"keyword\">this</span>, meta.throttleTrailingArgs);</span><br><span class=\"line\">          <span class=\"comment\">// 防止内存泄露</span></span><br><span class=\"line\">          meta.throttleTrailingArgs = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;, remaining);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>结合了时间戳和定时器setTimeout两种方式来实现throttle函数:</p>\n<ul>\n<li>leading为true时，主要根据时间戳来记录上次执行时间，每次触发事件时，判断当前时间距离上次执行时间是否已经等待了wait毫秒，如果是，则立即执行</li>\n<li>trailing为true时，主要通过setTimeout定时器来设定间隔某个时间段才去执行<ul>\n<li>leading为false，定时<strong>wait毫秒(从当前时间算起)</strong>后去执行</li>\n<li>leading为true时，定时<strong>距离上次执行累计wait毫秒</strong>后去执行</li>\n</ul>\n</li>\n<li>每次执行都会记录下当前执行时间，用来控制时间间隔</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"throttle\"><a href=\"#throttle\" class=\"headerlink\" title=\"@throttle\"></a>@throttle</h3><p>节流函数：函数节流能使得连续的函数执行，变为<strong>固定时间段</strong>间断地执行。</p>\n<h3 id=\"使用实例\"><a href=\"#使用实例\" class=\"headerlink\" title=\"使用实例\"></a>使用实例</h3><p>例如在监听窗口滚动事件时，稍微滚动一下，就会触发多次onscroll事件，去更新位置信息。如果onscroll事件是去进行dom操作，频繁地更新dom可能会导致低版本浏览器卡死。所以希望可以间隔一段时间，再去执行回调函数。<br>应用<code>throttle</code>函数，设置wait时间为1000ms，可以保证回调函数至少每隔1000ms执行一次。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; throttle &#125; <span class=\"keyword\">from</span> <span class=\"string\">'core-decorators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Scroller</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  position = <span class=\"string\">''</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  @throttle(<span class=\"number\">1000</span>, &#123;<span class=\"attr\">leading</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\">  updatePosition() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.position = <span class=\"built_in\">window</span>.scrollY;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  bindEvent() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.updatePosition()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"源码实现\"><a href=\"#源码实现\" class=\"headerlink\" title=\"源码实现\"></a>源码实现</h3><h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>在调用的时候支持传入wait、options.leading、options.trailing三个参数：</p>\n<ul>\n<li>wait: 等待执行的时间，单位ms，默认值300</li>\n<li>{leading}: 绑定的函数在节流开始前执行，默认值true，触发事件刚开始时执行回调</li>\n<li>{trailing}: 绑定的函数在节流开始后执行，默认值true，触发事件结束时执行回调</li>\n</ul>\n<h4 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleDescriptor</span>(<span class=\"params\">target, key, descriptor, [wait = DEFAULT_TIMEOUT, options = &#123;&#125;]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> callback = descriptor.value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> callback !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">SyntaxError</span>(<span class=\"string\">'Only functions can be throttled'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (options.leading !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    options.leading = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(options.trailing !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    options.trailing = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    ...descriptor,</span><br><span class=\"line\">    value() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 同debounce，会返回this的Symbol('__core_decorators__')属性: 为Meta实例</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> meta = metaFor(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> &#123; throttleTimeoutIds, throttlePreviousTimestamps &#125; = meta;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> timeout = throttleTimeoutIds[key];</span><br><span class=\"line\">      <span class=\"comment\">// 上次函数执行时的时间戳</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> previous = throttlePreviousTimestamps[key] || <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> now = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// options.trailing为true时，将待执行函数callback的参数赋值给meta.throttleTrailingArgs，保证在setTimeout回调函数中可以取到参数</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (options.trailing) &#123;</span><br><span class=\"line\">        meta.throttleTrailingArgs = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 第一次调用，并且leading参数为false时，将上次执行时间戳设为当前</span></span><br><span class=\"line\">      <span class=\"comment\">// trailing为true时，leading为false，throttlePreviousTimestamps[key]始终被赋值为0</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!previous &amp;&amp; options.leading === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        previous = now;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// leading为false的时候，previous=now, remaining时间始终等于wait，始终不会在节流函数开始时执行回调函数</span></span><br><span class=\"line\">      <span class=\"comment\">// leading为true的时候，第一次调用，previous为0，remaining为负值；再次调用，previous为上次回调执行时间，若距离上次执行时间已经等待了wait毫秒，则remaining&lt;=0</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> remaining = wait - (now - previous);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//&#123;leading: true&#125; remaining&lt;=0的时候，会在节流开始前执行callback函数</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        clearTimeout(timeout);</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> throttleTimeoutIds[key];</span><br><span class=\"line\">        <span class=\"comment\">// 更新上次执行时间戳</span></span><br><span class=\"line\">        throttlePreviousTimestamps[key] = now;</span><br><span class=\"line\">        <span class=\"comment\">// 执行回调函数</span></span><br><span class=\"line\">        callback.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timeout &amp;&amp; options.trailing) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当前没有timeout对象，并且trailing为true</span></span><br><span class=\"line\">        <span class=\"comment\">// &#123;trailing: true, leading: false&#125; 设置remaining = wait毫秒后去执行回调函数</span></span><br><span class=\"line\">        <span class=\"comment\">// &#123;trailing: true, leading: true&#125; 第二次调用才会设置remaining=wait - (now - previous)毫秒后去执行回调函数</span></span><br><span class=\"line\">        throttleTimeoutIds[key] = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 更新上次执行时间戳，leading为false，throttlePreviousTimestamps[key]始终被赋值为0</span></span><br><span class=\"line\">          throttlePreviousTimestamps[key] = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">          <span class=\"comment\">// 删掉timeout对象</span></span><br><span class=\"line\">          <span class=\"keyword\">delete</span> throttleTimeoutIds[key];</span><br><span class=\"line\">          <span class=\"comment\">// 执行回调函数</span></span><br><span class=\"line\">          callback.apply(<span class=\"keyword\">this</span>, meta.throttleTrailingArgs);</span><br><span class=\"line\">          <span class=\"comment\">// 防止内存泄露</span></span><br><span class=\"line\">          meta.throttleTrailingArgs = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;, remaining);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>结合了时间戳和定时器setTimeout两种方式来实现throttle函数:</p>\n<ul>\n<li>leading为true时，主要根据时间戳来记录上次执行时间，每次触发事件时，判断当前时间距离上次执行时间是否已经等待了wait毫秒，如果是，则立即执行</li>\n<li>trailing为true时，主要通过setTimeout定时器来设定间隔某个时间段才去执行<ul>\n<li>leading为false，定时<strong>wait毫秒(从当前时间算起)</strong>后去执行</li>\n<li>leading为true时，定时<strong>距离上次执行累计wait毫秒</strong>后去执行</li>\n</ul>\n</li>\n<li>每次执行都会记录下当前执行时间，用来控制时间间隔</li>\n</ul>\n</blockquote>\n"},{"title":"css效果","date":"2017-06-30T11:44:13.000Z","_content":"\n### 仿古效果\n> CSS处理图像效果：仿古效果[https://www.w3cplus.com/css3/vintage-washout.html]\n\n冲洗效果: 通过减轻暗色阴影和改变一些阴影的细节（改变暗色的细节），看上去就是在亮度的范围降低颜色对比度。\n- 混合模式：lighten\n将lighten混合模式应用于一个重叠元素或者一个伪元素上。你可以在某个元素上使用background-blend-mode:lighten或者使用多个混合模式，也可以在覆盖元素上使用mix-blend-mode:lighten。建议使用多个背景。\n\n- 应用\n使用@mixin\n```scss\n@mixin fade-it($img, $shadow: #536) {\n  background: url('#{$img}'), $shadow;\n  background-blend-mode: lighten;\n}\n.apply-base {\n  @include fade-it('1.jpg');\n}\n.apply-unique-shade {\n  @include fade-it('2.jpg', #293e78);\n}\n```\n编译后的css\n```css\n.apply-base {\n  background: url('1.jpg'), #536;\n  background-blend-mode: lighten;\n}\n.apply-unique-shade {\n  background: url('2.jpg'), #293e78;\n  background-blend-mode: lighten;\n}\n```\n","source":"_posts/css效果.md","raw":"---\ntitle: css效果\ndate: 2017-06-30 19:44:13\ntags: [css]\n---\n\n### 仿古效果\n> CSS处理图像效果：仿古效果[https://www.w3cplus.com/css3/vintage-washout.html]\n\n冲洗效果: 通过减轻暗色阴影和改变一些阴影的细节（改变暗色的细节），看上去就是在亮度的范围降低颜色对比度。\n- 混合模式：lighten\n将lighten混合模式应用于一个重叠元素或者一个伪元素上。你可以在某个元素上使用background-blend-mode:lighten或者使用多个混合模式，也可以在覆盖元素上使用mix-blend-mode:lighten。建议使用多个背景。\n\n- 应用\n使用@mixin\n```scss\n@mixin fade-it($img, $shadow: #536) {\n  background: url('#{$img}'), $shadow;\n  background-blend-mode: lighten;\n}\n.apply-base {\n  @include fade-it('1.jpg');\n}\n.apply-unique-shade {\n  @include fade-it('2.jpg', #293e78);\n}\n```\n编译后的css\n```css\n.apply-base {\n  background: url('1.jpg'), #536;\n  background-blend-mode: lighten;\n}\n.apply-unique-shade {\n  background: url('2.jpg'), #293e78;\n  background-blend-mode: lighten;\n}\n```\n","slug":"css效果","published":1,"updated":"2019-03-18T02:27:14.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6e000hqmhfqkx8qa0z","content":"<h3 id=\"仿古效果\"><a href=\"#仿古效果\" class=\"headerlink\" title=\"仿古效果\"></a>仿古效果</h3><blockquote>\n<p>CSS处理图像效果：仿古效果[<a href=\"https://www.w3cplus.com/css3/vintage-washout.html]\" target=\"_blank\" rel=\"noopener\">https://www.w3cplus.com/css3/vintage-washout.html]</a></p>\n</blockquote>\n<p>冲洗效果: 通过减轻暗色阴影和改变一些阴影的细节（改变暗色的细节），看上去就是在亮度的范围降低颜色对比度。</p>\n<ul>\n<li><p>混合模式：lighten<br>将lighten混合模式应用于一个重叠元素或者一个伪元素上。你可以在某个元素上使用background-blend-mode:lighten或者使用多个混合模式，也可以在覆盖元素上使用mix-blend-mode:lighten。建议使用多个背景。</p>\n</li>\n<li><p>应用<br>使用@mixin</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> fade-it(<span class=\"variable\">$img</span>, <span class=\"variable\">$shadow</span>: <span class=\"number\">#536</span>) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: url(<span class=\"string\">'#&#123;$img&#125;'</span>), <span class=\"variable\">$shadow</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-blend-mode</span>: lighten;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.apply-base</span> &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">include</span> fade-it(<span class=\"string\">'1.jpg'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.apply-unique-shade</span> &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">include</span> fade-it(<span class=\"string\">'2.jpg'</span>, <span class=\"number\">#293e78</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>编译后的css<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.apply-base</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'1.jpg'</span>), <span class=\"number\">#536</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-blend-mode</span>: lighten;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.apply-unique-shade</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'2.jpg'</span>), <span class=\"number\">#293e78</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-blend-mode</span>: lighten;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"仿古效果\"><a href=\"#仿古效果\" class=\"headerlink\" title=\"仿古效果\"></a>仿古效果</h3><blockquote>\n<p>CSS处理图像效果：仿古效果[<a href=\"https://www.w3cplus.com/css3/vintage-washout.html]\" target=\"_blank\" rel=\"noopener\">https://www.w3cplus.com/css3/vintage-washout.html]</a></p>\n</blockquote>\n<p>冲洗效果: 通过减轻暗色阴影和改变一些阴影的细节（改变暗色的细节），看上去就是在亮度的范围降低颜色对比度。</p>\n<ul>\n<li><p>混合模式：lighten<br>将lighten混合模式应用于一个重叠元素或者一个伪元素上。你可以在某个元素上使用background-blend-mode:lighten或者使用多个混合模式，也可以在覆盖元素上使用mix-blend-mode:lighten。建议使用多个背景。</p>\n</li>\n<li><p>应用<br>使用@mixin</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> fade-it(<span class=\"variable\">$img</span>, <span class=\"variable\">$shadow</span>: <span class=\"number\">#536</span>) &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: url(<span class=\"string\">'#&#123;$img&#125;'</span>), <span class=\"variable\">$shadow</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-blend-mode</span>: lighten;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.apply-base</span> &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">include</span> fade-it(<span class=\"string\">'1.jpg'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.apply-unique-shade</span> &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">include</span> fade-it(<span class=\"string\">'2.jpg'</span>, <span class=\"number\">#293e78</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>编译后的css<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.apply-base</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'1.jpg'</span>), <span class=\"number\">#536</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-blend-mode</span>: lighten;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.apply-unique-shade</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">'2.jpg'</span>), <span class=\"number\">#293e78</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background-blend-mode</span>: lighten;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"decorator","date":"2018-01-16T14:02:37.000Z","_content":"\nREFS: \nhttp://taobaofed.org/blog/2015/11/16/es7-decorator/\nhttp://es6.ruanyifeng.com/#docs/decorator\nhttp://raganwald.com/2015/06/26/decorators-in-es7.html","source":"_posts/decorator.md","raw":"---\ntitle: decorator\ndate: 2018-01-16 22:02:37\ntags: [decorator, es7, js]\n---\n\nREFS: \nhttp://taobaofed.org/blog/2015/11/16/es7-decorator/\nhttp://es6.ruanyifeng.com/#docs/decorator\nhttp://raganwald.com/2015/06/26/decorators-in-es7.html","slug":"decorator","published":1,"updated":"2019-03-18T02:27:14.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6h000jqmhfe9zq8wl2","content":"<p>REFS:<br><a href=\"http://taobaofed.org/blog/2015/11/16/es7-decorator/\" target=\"_blank\" rel=\"noopener\">http://taobaofed.org/blog/2015/11/16/es7-decorator/</a><br><a href=\"http://es6.ruanyifeng.com/#docs/decorator\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/#docs/decorator</a><br><a href=\"http://raganwald.com/2015/06/26/decorators-in-es7.html\" target=\"_blank\" rel=\"noopener\">http://raganwald.com/2015/06/26/decorators-in-es7.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>REFS:<br><a href=\"http://taobaofed.org/blog/2015/11/16/es7-decorator/\" target=\"_blank\" rel=\"noopener\">http://taobaofed.org/blog/2015/11/16/es7-decorator/</a><br><a href=\"http://es6.ruanyifeng.com/#docs/decorator\" target=\"_blank\" rel=\"noopener\">http://es6.ruanyifeng.com/#docs/decorator</a><br><a href=\"http://raganwald.com/2015/06/26/decorators-in-es7.html\" target=\"_blank\" rel=\"noopener\">http://raganwald.com/2015/06/26/decorators-in-es7.html</a></p>\n"},{"title":"@font-face 引入外部字体","date":"2017-06-15T12:16:44.000Z","_content":"字体是在页面中呈现内容不可缺少的重要元素，合适的字体能让内容更能抓住用户的注意力。 我们的追求是在多平台上呈现可预知的一致的文字效果给用户，但限于平台的字体支持，我们在使用一些不常见的字体时畏首畏脚。 长久以来，我们解决这个问题，一般都采用图片替换文字的方法。这个方法虽然简单，但是弊端不少：\n\n1. 图片体积一般比较大，如需半透明处理，体积会进一步增大\n2. 工作量增加不少\n3. 图片放大后可能会失真\n\n随着CSS3的推广，一个通过@font-face自定义字体的技术进入大家的视线中。 这个技术目前正被大量应用于自定义图标的实现。但是很少用来实现自定义字体，尤其是中文字体。\n\n这是因为中文包含很多汉字，所以字体文件的体积一般都比较大。如果用做自定义字体， 页面会先下载字体文件，然后再呈现页面，这会导致加载缓慢，用户的流量被浪费。\n\n然而在我们使用字体时，基本上只用来呈现有限的文字，下载整个字体文件是多余的。 那我们是否可以精简字体文件，让它只包含指定文字的字体信息，来解决问题？答案是可以的。\n\nwebfont-pick就是这样一个工具，它使用起来非常简单：\n\n```\nnpm install webfont-pick -g\n# 更多选项请执行 webfont-pick --help 查看\nwebfont-pick --font=/Library/Fonts/YuppySC-Regular.otf --text=\"你好，世界！\" -o ~/Desktop/webfont\n```\n<!-- more -->\n\n执行上述命令后，只包含你好，世界！这六个汉字的自定义字体文件会出现在指定的目录，并且生成了一个示例页面，用来说明如何使用。 有了webfont-pick之后，不管是微软雅黑还是方正呐喊都可以放心的应用到页面中。\n\n另外webfont-pick不只可以通过命令行调用，还可以通过程序调用，详情请参考[项目主页](https://github.com/anhulife/webfont-pick)。\n\n注1: webfont-pick目前只支持解析WOFF, OTF, TTF格式的字体\n\n注2: webfont-pick的想法来源于[ICONFONT.cn](http://www.iconfont.cn/webfont/#!/webfont/index)\n\n注3: webfont-pick的实现参考[grunt-webfont](https://github.com/sapegin/grunt-webfont)\n\n## 开发中遇到的问题\n\n中文字体应用到英文上会有问题，字体不是期望的那样。解决方案：英文单独使用英文字体，在设置font-family的时候引入中英文两种字体。\n```scss\n@font-face{\n    font-family: \"MS-Mincho\";\n    src: url('../src/font/MS-Mincho.eot'); /* IE9*/\n    src: url('../src/font/MS-Mincho.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('../src/font/MS-Mincho.woff') format('woff'); /* chrome、firefox */\n}\n\n@font-face{\n    font-family: \"ST-Regular\";\n    src: url('../src/font/st-regular.eot'); /* IE9*/\n    src: url('../src/font/st-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('../src/font/st-regular.woff') format('woff'); /* chrome、firefox */\n}\n\n.banner-title {\n    font-size: 64px;\n    color: #fff;\n    line-height: 60px;\n    margin-bottom: 20px;\n    font-family: ST-Regular, MS-Mincho, sans-serif;\n    // font-family: STSongti-SC-Regular;\n    \n    .en {\n        vertical-align: sub;\n        letter-spacing: -28px;\n        margin-right: -6px;\n    }\n}\n```","source":"_posts/font-face-引入外部字体.md","raw":"---\ntitle: '@font-face 引入外部字体'\ndate: 2017-06-15 20:16:44\ntags: [font-face, css]\n---\n字体是在页面中呈现内容不可缺少的重要元素，合适的字体能让内容更能抓住用户的注意力。 我们的追求是在多平台上呈现可预知的一致的文字效果给用户，但限于平台的字体支持，我们在使用一些不常见的字体时畏首畏脚。 长久以来，我们解决这个问题，一般都采用图片替换文字的方法。这个方法虽然简单，但是弊端不少：\n\n1. 图片体积一般比较大，如需半透明处理，体积会进一步增大\n2. 工作量增加不少\n3. 图片放大后可能会失真\n\n随着CSS3的推广，一个通过@font-face自定义字体的技术进入大家的视线中。 这个技术目前正被大量应用于自定义图标的实现。但是很少用来实现自定义字体，尤其是中文字体。\n\n这是因为中文包含很多汉字，所以字体文件的体积一般都比较大。如果用做自定义字体， 页面会先下载字体文件，然后再呈现页面，这会导致加载缓慢，用户的流量被浪费。\n\n然而在我们使用字体时，基本上只用来呈现有限的文字，下载整个字体文件是多余的。 那我们是否可以精简字体文件，让它只包含指定文字的字体信息，来解决问题？答案是可以的。\n\nwebfont-pick就是这样一个工具，它使用起来非常简单：\n\n```\nnpm install webfont-pick -g\n# 更多选项请执行 webfont-pick --help 查看\nwebfont-pick --font=/Library/Fonts/YuppySC-Regular.otf --text=\"你好，世界！\" -o ~/Desktop/webfont\n```\n<!-- more -->\n\n执行上述命令后，只包含你好，世界！这六个汉字的自定义字体文件会出现在指定的目录，并且生成了一个示例页面，用来说明如何使用。 有了webfont-pick之后，不管是微软雅黑还是方正呐喊都可以放心的应用到页面中。\n\n另外webfont-pick不只可以通过命令行调用，还可以通过程序调用，详情请参考[项目主页](https://github.com/anhulife/webfont-pick)。\n\n注1: webfont-pick目前只支持解析WOFF, OTF, TTF格式的字体\n\n注2: webfont-pick的想法来源于[ICONFONT.cn](http://www.iconfont.cn/webfont/#!/webfont/index)\n\n注3: webfont-pick的实现参考[grunt-webfont](https://github.com/sapegin/grunt-webfont)\n\n## 开发中遇到的问题\n\n中文字体应用到英文上会有问题，字体不是期望的那样。解决方案：英文单独使用英文字体，在设置font-family的时候引入中英文两种字体。\n```scss\n@font-face{\n    font-family: \"MS-Mincho\";\n    src: url('../src/font/MS-Mincho.eot'); /* IE9*/\n    src: url('../src/font/MS-Mincho.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('../src/font/MS-Mincho.woff') format('woff'); /* chrome、firefox */\n}\n\n@font-face{\n    font-family: \"ST-Regular\";\n    src: url('../src/font/st-regular.eot'); /* IE9*/\n    src: url('../src/font/st-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */\n    url('../src/font/st-regular.woff') format('woff'); /* chrome、firefox */\n}\n\n.banner-title {\n    font-size: 64px;\n    color: #fff;\n    line-height: 60px;\n    margin-bottom: 20px;\n    font-family: ST-Regular, MS-Mincho, sans-serif;\n    // font-family: STSongti-SC-Regular;\n    \n    .en {\n        vertical-align: sub;\n        letter-spacing: -28px;\n        margin-right: -6px;\n    }\n}\n```","slug":"font-face-引入外部字体","published":1,"updated":"2019-03-18T02:27:14.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6k000kqmhfmpxiupfv","content":"<p>字体是在页面中呈现内容不可缺少的重要元素，合适的字体能让内容更能抓住用户的注意力。 我们的追求是在多平台上呈现可预知的一致的文字效果给用户，但限于平台的字体支持，我们在使用一些不常见的字体时畏首畏脚。 长久以来，我们解决这个问题，一般都采用图片替换文字的方法。这个方法虽然简单，但是弊端不少：</p>\n<ol>\n<li>图片体积一般比较大，如需半透明处理，体积会进一步增大</li>\n<li>工作量增加不少</li>\n<li>图片放大后可能会失真</li>\n</ol>\n<p>随着CSS3的推广，一个通过@font-face自定义字体的技术进入大家的视线中。 这个技术目前正被大量应用于自定义图标的实现。但是很少用来实现自定义字体，尤其是中文字体。</p>\n<p>这是因为中文包含很多汉字，所以字体文件的体积一般都比较大。如果用做自定义字体， 页面会先下载字体文件，然后再呈现页面，这会导致加载缓慢，用户的流量被浪费。</p>\n<p>然而在我们使用字体时，基本上只用来呈现有限的文字，下载整个字体文件是多余的。 那我们是否可以精简字体文件，让它只包含指定文字的字体信息，来解决问题？答案是可以的。</p>\n<p>webfont-pick就是这样一个工具，它使用起来非常简单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webfont-pick -g</span><br><span class=\"line\"># 更多选项请执行 webfont-pick --help 查看</span><br><span class=\"line\">webfont-pick --font=/Library/Fonts/YuppySC-Regular.otf --text=&quot;你好，世界！&quot; -o ~/Desktop/webfont</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>执行上述命令后，只包含你好，世界！这六个汉字的自定义字体文件会出现在指定的目录，并且生成了一个示例页面，用来说明如何使用。 有了webfont-pick之后，不管是微软雅黑还是方正呐喊都可以放心的应用到页面中。</p>\n<p>另外webfont-pick不只可以通过命令行调用，还可以通过程序调用，详情请参考<a href=\"https://github.com/anhulife/webfont-pick\" target=\"_blank\" rel=\"noopener\">项目主页</a>。</p>\n<p>注1: webfont-pick目前只支持解析WOFF, OTF, TTF格式的字体</p>\n<p>注2: webfont-pick的想法来源于<a href=\"http://www.iconfont.cn/webfont/#!/webfont/index\" target=\"_blank\" rel=\"noopener\">ICONFONT.cn</a></p>\n<p>注3: webfont-pick的实现参考<a href=\"https://github.com/sapegin/grunt-webfont\" target=\"_blank\" rel=\"noopener\">grunt-webfont</a></p>\n<h2 id=\"开发中遇到的问题\"><a href=\"#开发中遇到的问题\" class=\"headerlink\" title=\"开发中遇到的问题\"></a>开发中遇到的问题</h2><p>中文字体应用到英文上会有问题，字体不是期望的那样。解决方案：英文单独使用英文字体，在设置font-family的时候引入中英文两种字体。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@font-face&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: <span class=\"string\">\"MS-Mincho\"</span>;</span><br><span class=\"line\">    src: url(<span class=\"string\">'../src/font/MS-Mincho.eot'</span>); <span class=\"comment\">/* IE9*/</span></span><br><span class=\"line\">    src: url(<span class=\"string\">'../src/font/MS-Mincho.eot?#iefix'</span>) format(<span class=\"string\">'embedded-opentype'</span>), /* IE6-IE8 */</span><br><span class=\"line\">    url(<span class=\"string\">'../src/font/MS-Mincho.woff'</span>) format(<span class=\"string\">'woff'</span>); <span class=\"comment\">/* chrome、firefox */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@font-face&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: <span class=\"string\">\"ST-Regular\"</span>;</span><br><span class=\"line\">    src: url(<span class=\"string\">'../src/font/st-regular.eot'</span>); <span class=\"comment\">/* IE9*/</span></span><br><span class=\"line\">    src: url(<span class=\"string\">'../src/font/st-regular.eot?#iefix'</span>) format(<span class=\"string\">'embedded-opentype'</span>), /* IE6-IE8 */</span><br><span class=\"line\">    url(<span class=\"string\">'../src/font/st-regular.woff'</span>) format(<span class=\"string\">'woff'</span>); <span class=\"comment\">/* chrome、firefox */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.banner-title</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">64px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: ST-Regular, MS-Mincho, sans-serif;</span><br><span class=\"line\">    <span class=\"comment\">// font-family: STSongti-SC-Regular;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-class\">.en</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">vertical-align</span>: sub;</span><br><span class=\"line\">        <span class=\"attribute\">letter-spacing</span>: -<span class=\"number\">28px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">margin-right</span>: -<span class=\"number\">6px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>字体是在页面中呈现内容不可缺少的重要元素，合适的字体能让内容更能抓住用户的注意力。 我们的追求是在多平台上呈现可预知的一致的文字效果给用户，但限于平台的字体支持，我们在使用一些不常见的字体时畏首畏脚。 长久以来，我们解决这个问题，一般都采用图片替换文字的方法。这个方法虽然简单，但是弊端不少：</p>\n<ol>\n<li>图片体积一般比较大，如需半透明处理，体积会进一步增大</li>\n<li>工作量增加不少</li>\n<li>图片放大后可能会失真</li>\n</ol>\n<p>随着CSS3的推广，一个通过@font-face自定义字体的技术进入大家的视线中。 这个技术目前正被大量应用于自定义图标的实现。但是很少用来实现自定义字体，尤其是中文字体。</p>\n<p>这是因为中文包含很多汉字，所以字体文件的体积一般都比较大。如果用做自定义字体， 页面会先下载字体文件，然后再呈现页面，这会导致加载缓慢，用户的流量被浪费。</p>\n<p>然而在我们使用字体时，基本上只用来呈现有限的文字，下载整个字体文件是多余的。 那我们是否可以精简字体文件，让它只包含指定文字的字体信息，来解决问题？答案是可以的。</p>\n<p>webfont-pick就是这样一个工具，它使用起来非常简单：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webfont-pick -g</span><br><span class=\"line\"># 更多选项请执行 webfont-pick --help 查看</span><br><span class=\"line\">webfont-pick --font=/Library/Fonts/YuppySC-Regular.otf --text=&quot;你好，世界！&quot; -o ~/Desktop/webfont</span><br></pre></td></tr></table></figure>","more":"<p>执行上述命令后，只包含你好，世界！这六个汉字的自定义字体文件会出现在指定的目录，并且生成了一个示例页面，用来说明如何使用。 有了webfont-pick之后，不管是微软雅黑还是方正呐喊都可以放心的应用到页面中。</p>\n<p>另外webfont-pick不只可以通过命令行调用，还可以通过程序调用，详情请参考<a href=\"https://github.com/anhulife/webfont-pick\" target=\"_blank\" rel=\"noopener\">项目主页</a>。</p>\n<p>注1: webfont-pick目前只支持解析WOFF, OTF, TTF格式的字体</p>\n<p>注2: webfont-pick的想法来源于<a href=\"http://www.iconfont.cn/webfont/#!/webfont/index\" target=\"_blank\" rel=\"noopener\">ICONFONT.cn</a></p>\n<p>注3: webfont-pick的实现参考<a href=\"https://github.com/sapegin/grunt-webfont\" target=\"_blank\" rel=\"noopener\">grunt-webfont</a></p>\n<h2 id=\"开发中遇到的问题\"><a href=\"#开发中遇到的问题\" class=\"headerlink\" title=\"开发中遇到的问题\"></a>开发中遇到的问题</h2><p>中文字体应用到英文上会有问题，字体不是期望的那样。解决方案：英文单独使用英文字体，在设置font-family的时候引入中英文两种字体。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@font-face&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: <span class=\"string\">\"MS-Mincho\"</span>;</span><br><span class=\"line\">    src: url(<span class=\"string\">'../src/font/MS-Mincho.eot'</span>); <span class=\"comment\">/* IE9*/</span></span><br><span class=\"line\">    src: url(<span class=\"string\">'../src/font/MS-Mincho.eot?#iefix'</span>) format(<span class=\"string\">'embedded-opentype'</span>), /* IE6-IE8 */</span><br><span class=\"line\">    url(<span class=\"string\">'../src/font/MS-Mincho.woff'</span>) format(<span class=\"string\">'woff'</span>); <span class=\"comment\">/* chrome、firefox */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@font-face&#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: <span class=\"string\">\"ST-Regular\"</span>;</span><br><span class=\"line\">    src: url(<span class=\"string\">'../src/font/st-regular.eot'</span>); <span class=\"comment\">/* IE9*/</span></span><br><span class=\"line\">    src: url(<span class=\"string\">'../src/font/st-regular.eot?#iefix'</span>) format(<span class=\"string\">'embedded-opentype'</span>), /* IE6-IE8 */</span><br><span class=\"line\">    url(<span class=\"string\">'../src/font/st-regular.woff'</span>) format(<span class=\"string\">'woff'</span>); <span class=\"comment\">/* chrome、firefox */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.banner-title</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">64px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">60px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: ST-Regular, MS-Mincho, sans-serif;</span><br><span class=\"line\">    <span class=\"comment\">// font-family: STSongti-SC-Regular;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-class\">.en</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">vertical-align</span>: sub;</span><br><span class=\"line\">        <span class=\"attribute\">letter-spacing</span>: -<span class=\"number\">28px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">margin-right</span>: -<span class=\"number\">6px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"form表单实现文件的下载","date":"2017-06-15T12:19:22.000Z","_content":"### h5链接a增加download属性\n1. download属性\n\n想到最简单的下载文件的方式是\n```html\n<a href=\"large.jpg\">下载</a>\n```\n但是实际效果是在浏览器直接浏览图片，而不是下载图片。\n如果我们希望点击“下载”链接下载图片，可以增加一个download属性。\n```html\n<a href=\"large.jpg\" download>下载</a>\n```\n通过download属性还可以指定下载图片的文件名，如果后缀一样，可以省略。\n```html\n<a href=\"large.jpg\" download=\"large_down.jpg\">下载</a>\n```\n<!-- more -->\n\n2. download的兼容性\n\n如果下载的资源是跨域的，在chrome浏览器下可以正常下载，在firefox浏览器下不支持跨域下载。\n要判断是否支持download属性，可以使用下面的代码：\n```javascript\nvar isSupportDownload = 'download' in document.createElement('a');\n```\n\n3. 兼容浏览器的下载方法\n\ndownload属性不支持IE，要兼容IE可以通过JS创建一个iframe去下载，如下所示：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n    </head>\n    <body>\n        <a id='trigger' href=\"javascript:;\">下载</a>\n        <a id='download' download='pic.jpg' style=\"display: none;\">下载</a>\n    </body>\n    <script type=\"text/javascript\" src=\"http://yuedust.yuedu.126.net/js/jquery-1.8.1.min.js\"></script>\n    <script type=\"text/javascript\">\n        function download_pic() {\n            var codeurl='https://img4.cache.netease.com/news/2017/6/19/20170619094322c3136.jpg';\n            if(browserIsIe()){//假如是ie浏览器\n              DownLoadReportIMG(codeurl);\n            }else{\n              $(\"#download\").attr('href', codeurl);\n              document.getElementById(\"download\").click();\n            }\n        }\n\n        function DownLoadReportIMG(imgPathURL) {\n            //如果隐藏IFRAME不存在，则添加\n            if (!document.getElementById(\"IframeReportImg\"))\n                $('<iframe style=\"display:none;\" id=\"IframeReportImg\" name=\"IframeReportImg\" onload=\"DoSaveAsIMG();\" width=\"0\" height=\"0\" src=\"about:blank\"></iframe>').appendTo(\"body\");\n\n            if (document.all.IframeReportImg.src != imgPathURL) {\n                //加载图片\n                document.all.IframeReportImg.src = imgPathURL;\n            }\n            else {\n                //图片直接另存为\n                DoSaveAsIMG();\n            }\n        }\n\n        function DoSaveAsIMG() {\n            //跨域的话IE会提示没权限\n            if (document.all.IframeReportImg.src != \"about:blank\")\n                window.frames.IframeReportImg.document.execCommand(\"SaveAs\");\n        }\n        //判断是否为ie浏览器\n        function browserIsIe() {\n            if (!!window.ActiveXObject || \"ActiveXObject\" in window)\n                return true;\n            else\n                return false;\n        }\n\n        document.getElementById(\"trigger\").onclick = function(e) {\n            e.preventDefault();\n            download_pic();\n        };\n    </script>\n</html>\n```\n\n### form表单实现文件的下载\n```javascript\n    handleExport() {\n        const { selectedRowKeys } = this.state;\n        let config  = {\n           action: UserExportUrl,\n           key: 'userIdArray[]'\n        }\n        let iframe = document.createElement('iframe');\n        iframe.style.display = 'none';\n        let form = document.createElement('form');\n        form.action = config.action;\n        form.method = 'post';\n\n        let input = document.createElement('input');\n        input.type = 'hidden';\n        input.name = config.key;\n        input.setAttribute('value', selectedRowKeys.join(','));\n        form.appendChild(input);\n\n        document.body.appendChild(iframe);\n        iframe.contentWindow.document.body.appendChild(form);\n        form.submit();\n        // window.open(UserExportUrl + '?userIdArray[]=' + selectedRowKeys.join(','));\n    }\n```\n\nPS: 移动端H5几乎无法实现保存图片到本地，加download属性和加响应头的方式，微信和浏览器都无法保存图片，手机端的chrome和PC效果一致，真是一股清流。还是提示用户自己长按保存图片吧。","source":"_posts/form表单实现文件的下载.md","raw":"---\ntitle: form表单实现文件的下载\ndate: 2017-06-15 20:19:22\ntags: [下载, 兼容]\n---\n### h5链接a增加download属性\n1. download属性\n\n想到最简单的下载文件的方式是\n```html\n<a href=\"large.jpg\">下载</a>\n```\n但是实际效果是在浏览器直接浏览图片，而不是下载图片。\n如果我们希望点击“下载”链接下载图片，可以增加一个download属性。\n```html\n<a href=\"large.jpg\" download>下载</a>\n```\n通过download属性还可以指定下载图片的文件名，如果后缀一样，可以省略。\n```html\n<a href=\"large.jpg\" download=\"large_down.jpg\">下载</a>\n```\n<!-- more -->\n\n2. download的兼容性\n\n如果下载的资源是跨域的，在chrome浏览器下可以正常下载，在firefox浏览器下不支持跨域下载。\n要判断是否支持download属性，可以使用下面的代码：\n```javascript\nvar isSupportDownload = 'download' in document.createElement('a');\n```\n\n3. 兼容浏览器的下载方法\n\ndownload属性不支持IE，要兼容IE可以通过JS创建一个iframe去下载，如下所示：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\">\n    </head>\n    <body>\n        <a id='trigger' href=\"javascript:;\">下载</a>\n        <a id='download' download='pic.jpg' style=\"display: none;\">下载</a>\n    </body>\n    <script type=\"text/javascript\" src=\"http://yuedust.yuedu.126.net/js/jquery-1.8.1.min.js\"></script>\n    <script type=\"text/javascript\">\n        function download_pic() {\n            var codeurl='https://img4.cache.netease.com/news/2017/6/19/20170619094322c3136.jpg';\n            if(browserIsIe()){//假如是ie浏览器\n              DownLoadReportIMG(codeurl);\n            }else{\n              $(\"#download\").attr('href', codeurl);\n              document.getElementById(\"download\").click();\n            }\n        }\n\n        function DownLoadReportIMG(imgPathURL) {\n            //如果隐藏IFRAME不存在，则添加\n            if (!document.getElementById(\"IframeReportImg\"))\n                $('<iframe style=\"display:none;\" id=\"IframeReportImg\" name=\"IframeReportImg\" onload=\"DoSaveAsIMG();\" width=\"0\" height=\"0\" src=\"about:blank\"></iframe>').appendTo(\"body\");\n\n            if (document.all.IframeReportImg.src != imgPathURL) {\n                //加载图片\n                document.all.IframeReportImg.src = imgPathURL;\n            }\n            else {\n                //图片直接另存为\n                DoSaveAsIMG();\n            }\n        }\n\n        function DoSaveAsIMG() {\n            //跨域的话IE会提示没权限\n            if (document.all.IframeReportImg.src != \"about:blank\")\n                window.frames.IframeReportImg.document.execCommand(\"SaveAs\");\n        }\n        //判断是否为ie浏览器\n        function browserIsIe() {\n            if (!!window.ActiveXObject || \"ActiveXObject\" in window)\n                return true;\n            else\n                return false;\n        }\n\n        document.getElementById(\"trigger\").onclick = function(e) {\n            e.preventDefault();\n            download_pic();\n        };\n    </script>\n</html>\n```\n\n### form表单实现文件的下载\n```javascript\n    handleExport() {\n        const { selectedRowKeys } = this.state;\n        let config  = {\n           action: UserExportUrl,\n           key: 'userIdArray[]'\n        }\n        let iframe = document.createElement('iframe');\n        iframe.style.display = 'none';\n        let form = document.createElement('form');\n        form.action = config.action;\n        form.method = 'post';\n\n        let input = document.createElement('input');\n        input.type = 'hidden';\n        input.name = config.key;\n        input.setAttribute('value', selectedRowKeys.join(','));\n        form.appendChild(input);\n\n        document.body.appendChild(iframe);\n        iframe.contentWindow.document.body.appendChild(form);\n        form.submit();\n        // window.open(UserExportUrl + '?userIdArray[]=' + selectedRowKeys.join(','));\n    }\n```\n\nPS: 移动端H5几乎无法实现保存图片到本地，加download属性和加响应头的方式，微信和浏览器都无法保存图片，手机端的chrome和PC效果一致，真是一股清流。还是提示用户自己长按保存图片吧。","slug":"form表单实现文件的下载","published":1,"updated":"2019-03-18T02:27:14.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6m000mqmhf6k2j9qbi","content":"<h3 id=\"h5链接a增加download属性\"><a href=\"#h5链接a增加download属性\" class=\"headerlink\" title=\"h5链接a增加download属性\"></a>h5链接a增加download属性</h3><ol>\n<li>download属性</li>\n</ol>\n<p>想到最简单的下载文件的方式是<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"large.jpg\"</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>但是实际效果是在浏览器直接浏览图片，而不是下载图片。<br>如果我们希望点击“下载”链接下载图片，可以增加一个download属性。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"large.jpg\"</span> <span class=\"attr\">download</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>通过download属性还可以指定下载图片的文件名，如果后缀一样，可以省略。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"large.jpg\"</span> <span class=\"attr\">download</span>=<span class=\"string\">\"large_down.jpg\"</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<ol start=\"2\">\n<li>download的兼容性</li>\n</ol>\n<p>如果下载的资源是跨域的，在chrome浏览器下可以正常下载，在firefox浏览器下不支持跨域下载。<br>要判断是否支持download属性，可以使用下面的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isSupportDownload = <span class=\"string\">'download'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'a'</span>);</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>兼容浏览器的下载方法</li>\n</ol>\n<p>download属性不支持IE，要兼容IE可以通过JS创建一个iframe去下载，如下所示：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">id</span>=<span class=\"string\">'trigger'</span> <span class=\"attr\">href</span>=<span class=\"string\">\"javascript:;\"</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">id</span>=<span class=\"string\">'download'</span> <span class=\"attr\">download</span>=<span class=\"string\">'pic.jpg'</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display: none;\"</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://yuedust.yuedu.126.net/js/jquery-1.8.1.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">download_pic</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> codeurl=<span class=\"string\">'https://img4.cache.netease.com/news/2017/6/19/20170619094322c3136.jpg'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span>(browserIsIe())&#123;<span class=\"comment\">//假如是ie浏览器</span></span></span><br><span class=\"line\"><span class=\"undefined\">              DownLoadReportIMG(codeurl);</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;<span class=\"keyword\">else</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">              $(<span class=\"string\">\"#download\"</span>).attr(<span class=\"string\">'href'</span>, codeurl);</span></span><br><span class=\"line\"><span class=\"javascript\">              <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"download\"</span>).click();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DownLoadReportIMG</span>(<span class=\"params\">imgPathURL</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//如果隐藏IFRAME不存在，则添加</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"IframeReportImg\"</span>))</span></span><br><span class=\"line\"><span class=\"xml\">                $('<span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display:none;\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"IframeReportImg\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"IframeReportImg\"</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"DoSaveAsIMG();\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"about:blank\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span>').appendTo(\"body\");</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.all.IframeReportImg.src != imgPathURL) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//加载图片</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">document</span>.all.IframeReportImg.src = imgPathURL;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">else</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//图片直接另存为</span></span></span><br><span class=\"line\"><span class=\"undefined\">                DoSaveAsIMG();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DoSaveAsIMG</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//跨域的话IE会提示没权限</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.all.IframeReportImg.src != <span class=\"string\">\"about:blank\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">window</span>.frames.IframeReportImg.document.execCommand(<span class=\"string\">\"SaveAs\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">//判断是否为ie浏览器</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">browserIsIe</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (!!<span class=\"built_in\">window</span>.ActiveXObject || <span class=\"string\">\"ActiveXObject\"</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"trigger\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            e.preventDefault();</span></span><br><span class=\"line\"><span class=\"undefined\">            download_pic();</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"form表单实现文件的下载\"><a href=\"#form表单实现文件的下载\" class=\"headerlink\" title=\"form表单实现文件的下载\"></a>form表单实现文件的下载</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleExport() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; selectedRowKeys &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> config  = &#123;</span><br><span class=\"line\">       action: UserExportUrl,</span><br><span class=\"line\">       key: <span class=\"string\">'userIdArray[]'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> iframe = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">    iframe.style.display = <span class=\"string\">'none'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> form = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'form'</span>);</span><br><span class=\"line\">    form.action = config.action;</span><br><span class=\"line\">    form.method = <span class=\"string\">'post'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> input = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'input'</span>);</span><br><span class=\"line\">    input.type = <span class=\"string\">'hidden'</span>;</span><br><span class=\"line\">    input.name = config.key;</span><br><span class=\"line\">    input.setAttribute(<span class=\"string\">'value'</span>, selectedRowKeys.join(<span class=\"string\">','</span>));</span><br><span class=\"line\">    form.appendChild(input);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.appendChild(iframe);</span><br><span class=\"line\">    iframe.contentWindow.document.body.appendChild(form);</span><br><span class=\"line\">    form.submit();</span><br><span class=\"line\">    <span class=\"comment\">// window.open(UserExportUrl + '?userIdArray[]=' + selectedRowKeys.join(','));</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PS: 移动端H5几乎无法实现保存图片到本地，加download属性和加响应头的方式，微信和浏览器都无法保存图片，手机端的chrome和PC效果一致，真是一股清流。还是提示用户自己长按保存图片吧。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"h5链接a增加download属性\"><a href=\"#h5链接a增加download属性\" class=\"headerlink\" title=\"h5链接a增加download属性\"></a>h5链接a增加download属性</h3><ol>\n<li>download属性</li>\n</ol>\n<p>想到最简单的下载文件的方式是<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"large.jpg\"</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>但是实际效果是在浏览器直接浏览图片，而不是下载图片。<br>如果我们希望点击“下载”链接下载图片，可以增加一个download属性。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"large.jpg\"</span> <span class=\"attr\">download</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>通过download属性还可以指定下载图片的文件名，如果后缀一样，可以省略。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"large.jpg\"</span> <span class=\"attr\">download</span>=<span class=\"string\">\"large_down.jpg\"</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>","more":"<ol start=\"2\">\n<li>download的兼容性</li>\n</ol>\n<p>如果下载的资源是跨域的，在chrome浏览器下可以正常下载，在firefox浏览器下不支持跨域下载。<br>要判断是否支持download属性，可以使用下面的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> isSupportDownload = <span class=\"string\">'download'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'a'</span>);</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>兼容浏览器的下载方法</li>\n</ol>\n<p>download属性不支持IE，要兼容IE可以通过JS创建一个iframe去下载，如下所示：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"utf-8\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">id</span>=<span class=\"string\">'trigger'</span> <span class=\"attr\">href</span>=<span class=\"string\">\"javascript:;\"</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">id</span>=<span class=\"string\">'download'</span> <span class=\"attr\">download</span>=<span class=\"string\">'pic.jpg'</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display: none;\"</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://yuedust.yuedu.126.net/js/jquery-1.8.1.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">download_pic</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> codeurl=<span class=\"string\">'https://img4.cache.netease.com/news/2017/6/19/20170619094322c3136.jpg'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span>(browserIsIe())&#123;<span class=\"comment\">//假如是ie浏览器</span></span></span><br><span class=\"line\"><span class=\"undefined\">              DownLoadReportIMG(codeurl);</span></span><br><span class=\"line\"><span class=\"javascript\">            &#125;<span class=\"keyword\">else</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">              $(<span class=\"string\">\"#download\"</span>).attr(<span class=\"string\">'href'</span>, codeurl);</span></span><br><span class=\"line\"><span class=\"javascript\">              <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"download\"</span>).click();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DownLoadReportIMG</span>(<span class=\"params\">imgPathURL</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//如果隐藏IFRAME不存在，则添加</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (!<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"IframeReportImg\"</span>))</span></span><br><span class=\"line\"><span class=\"xml\">                $('<span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display:none;\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"IframeReportImg\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"IframeReportImg\"</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"DoSaveAsIMG();\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"0\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"about:blank\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span>').appendTo(\"body\");</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.all.IframeReportImg.src != imgPathURL) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//加载图片</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">document</span>.all.IframeReportImg.src = imgPathURL;</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">else</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"comment\">//图片直接另存为</span></span></span><br><span class=\"line\"><span class=\"undefined\">                DoSaveAsIMG();</span></span><br><span class=\"line\"><span class=\"undefined\">            &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DoSaveAsIMG</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"comment\">//跨域的话IE会提示没权限</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.all.IframeReportImg.src != <span class=\"string\">\"about:blank\"</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"built_in\">window</span>.frames.IframeReportImg.document.execCommand(<span class=\"string\">\"SaveAs\"</span>);</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">//判断是否为ie浏览器</span></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">browserIsIe</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">if</span> (!!<span class=\"built_in\">window</span>.ActiveXObject || <span class=\"string\">\"ActiveXObject\"</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"javascript\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"trigger\"</span>).onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            e.preventDefault();</span></span><br><span class=\"line\"><span class=\"undefined\">            download_pic();</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"form表单实现文件的下载\"><a href=\"#form表单实现文件的下载\" class=\"headerlink\" title=\"form表单实现文件的下载\"></a>form表单实现文件的下载</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleExport() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; selectedRowKeys &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> config  = &#123;</span><br><span class=\"line\">       action: UserExportUrl,</span><br><span class=\"line\">       key: <span class=\"string\">'userIdArray[]'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> iframe = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'iframe'</span>);</span><br><span class=\"line\">    iframe.style.display = <span class=\"string\">'none'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> form = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'form'</span>);</span><br><span class=\"line\">    form.action = config.action;</span><br><span class=\"line\">    form.method = <span class=\"string\">'post'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> input = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'input'</span>);</span><br><span class=\"line\">    input.type = <span class=\"string\">'hidden'</span>;</span><br><span class=\"line\">    input.name = config.key;</span><br><span class=\"line\">    input.setAttribute(<span class=\"string\">'value'</span>, selectedRowKeys.join(<span class=\"string\">','</span>));</span><br><span class=\"line\">    form.appendChild(input);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.appendChild(iframe);</span><br><span class=\"line\">    iframe.contentWindow.document.body.appendChild(form);</span><br><span class=\"line\">    form.submit();</span><br><span class=\"line\">    <span class=\"comment\">// window.open(UserExportUrl + '?userIdArray[]=' + selectedRowKeys.join(','));</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PS: 移动端H5几乎无法实现保存图片到本地，加download属性和加响应头的方式，微信和浏览器都无法保存图片，手机端的chrome和PC效果一致，真是一股清流。还是提示用户自己长按保存图片吧。</p>"},{"title":"lottie实践","date":"2019-01-28T02:27:41.000Z","_content":"\n## lottie简介\n> [Lottie](http://airbnb.io/lottie/) is a mobile library for Android and iOS that parses Adobe After Effects animations exported as json with Bodymovin and renders them natively on mobile and on the web!\n\nLottie是一个库，可以解析使用AE制作的动画（需要用bodymovin导出为json格式），支持web、ios、android和react native。\n在web侧，lottie-web库可以解析导出的动画json文件，并将其以svg或者canvas的方式将动画绘制到我们页面中。关于lottie-web的详细信息，也可以参见[https://github.com/airbnb/lottie-web](https://github.com/airbnb/lottie-web)。\n<img src=\"http://imweb-io-1251594266.file.myqcloud.com/FvWDhZoyPK5wVQecu5qFYEDdGuJe\"/>\n\n## lottie-web引用方式\n### npm包\n``` js\nimport lottie from 'lottie-web'\nlottie.loadAnimation({\n  container: element, // the dom element that will contain the animation\n  renderer: 'svg',\n  loop: true,\n  autoplay: true,\n  path: 'data.json' // the path to the animation json\n});\n```\n### js外链\n多个版本的lottie库都可以从[cdnjs-bodymovin](https://cdnjs.com/libraries/bodymovin)找到\n``` html\n<script src=\"https://cdnjs.com/libraries/bodymovin\" />\n<script>\n    bodymovin.loadAnimation({\n      container: element, // the dom element that will contain the animation\n      renderer: 'svg',\n      loop: true,\n      autoplay: true,\n      path: 'data.json' // the path to the animation json\n    });\n</script>\n```\n通过外链引入的方式，既可以通过`bodymovin`去调用，也可以使用`lottie`变量，二者等价，都是js库提供的全局变量。\n\n## lottie-web实践\nlottie库文件比较大，gzip压缩后也有60k，再加上动画对应的json文件，直接引入会给项目代码增大不少体积，影响页面加载速度。\n\n文件 | 大小 | gzip后\n- | :-:| :-:\nlottie.js | 513k  |  92k\nlottie.min.js | 237k  |  60k\nlottie_light.js (lottie_web轻量版，仅支持svg渲染)  |  345k  |  60k\nlottie_lignt.min.js | 144k  |  39k\n\n所以，如果动画只需要支持svg渲染，则可以引入light版本的库文件，gzip压缩后缩减到39k。\n为了进一步降低影响，可以使用code splitting的方式，以async的方式异步加载js，这样就不会阻塞浏览器解析html、执行js脚本以及展示css布局。\n``` js\nimport(/* webpackChunkName: \"lottie-light\" */ '../lib/lottie_light.min.js').then(() => {\n    window.lottie && window.lottie.loadAnimation({\n        container: this.headerDom,\n        renderer: 'svg',\n        loop: true,\n        autoplay: true,\n        animationData: require('../data/ribbon.json')\n    });\n})\n```\n示例demo可以参见codepen上的[ribbon-lottie](https://codepen.io/sherrywu0917/pen/XPNavE)，测试数据`ribbon.json`可以下载[彩带json数据]( https://easyreadfs.nosdn.127.net/1548645419902/ribbon.json)。\n\n","source":"_posts/lottie实践.md","raw":"---\ntitle: lottie实践\ndate: 2019-01-28 10:27:41\ntags: lottie\n---\n\n## lottie简介\n> [Lottie](http://airbnb.io/lottie/) is a mobile library for Android and iOS that parses Adobe After Effects animations exported as json with Bodymovin and renders them natively on mobile and on the web!\n\nLottie是一个库，可以解析使用AE制作的动画（需要用bodymovin导出为json格式），支持web、ios、android和react native。\n在web侧，lottie-web库可以解析导出的动画json文件，并将其以svg或者canvas的方式将动画绘制到我们页面中。关于lottie-web的详细信息，也可以参见[https://github.com/airbnb/lottie-web](https://github.com/airbnb/lottie-web)。\n<img src=\"http://imweb-io-1251594266.file.myqcloud.com/FvWDhZoyPK5wVQecu5qFYEDdGuJe\"/>\n\n## lottie-web引用方式\n### npm包\n``` js\nimport lottie from 'lottie-web'\nlottie.loadAnimation({\n  container: element, // the dom element that will contain the animation\n  renderer: 'svg',\n  loop: true,\n  autoplay: true,\n  path: 'data.json' // the path to the animation json\n});\n```\n### js外链\n多个版本的lottie库都可以从[cdnjs-bodymovin](https://cdnjs.com/libraries/bodymovin)找到\n``` html\n<script src=\"https://cdnjs.com/libraries/bodymovin\" />\n<script>\n    bodymovin.loadAnimation({\n      container: element, // the dom element that will contain the animation\n      renderer: 'svg',\n      loop: true,\n      autoplay: true,\n      path: 'data.json' // the path to the animation json\n    });\n</script>\n```\n通过外链引入的方式，既可以通过`bodymovin`去调用，也可以使用`lottie`变量，二者等价，都是js库提供的全局变量。\n\n## lottie-web实践\nlottie库文件比较大，gzip压缩后也有60k，再加上动画对应的json文件，直接引入会给项目代码增大不少体积，影响页面加载速度。\n\n文件 | 大小 | gzip后\n- | :-:| :-:\nlottie.js | 513k  |  92k\nlottie.min.js | 237k  |  60k\nlottie_light.js (lottie_web轻量版，仅支持svg渲染)  |  345k  |  60k\nlottie_lignt.min.js | 144k  |  39k\n\n所以，如果动画只需要支持svg渲染，则可以引入light版本的库文件，gzip压缩后缩减到39k。\n为了进一步降低影响，可以使用code splitting的方式，以async的方式异步加载js，这样就不会阻塞浏览器解析html、执行js脚本以及展示css布局。\n``` js\nimport(/* webpackChunkName: \"lottie-light\" */ '../lib/lottie_light.min.js').then(() => {\n    window.lottie && window.lottie.loadAnimation({\n        container: this.headerDom,\n        renderer: 'svg',\n        loop: true,\n        autoplay: true,\n        animationData: require('../data/ribbon.json')\n    });\n})\n```\n示例demo可以参见codepen上的[ribbon-lottie](https://codepen.io/sherrywu0917/pen/XPNavE)，测试数据`ribbon.json`可以下载[彩带json数据]( https://easyreadfs.nosdn.127.net/1548645419902/ribbon.json)。\n\n","slug":"lottie实践","published":1,"updated":"2019-03-18T02:27:14.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6n000oqmhf6nr79g2c","content":"<h2 id=\"lottie简介\"><a href=\"#lottie简介\" class=\"headerlink\" title=\"lottie简介\"></a>lottie简介</h2><blockquote>\n<p><a href=\"http://airbnb.io/lottie/\" target=\"_blank\" rel=\"noopener\">Lottie</a> is a mobile library for Android and iOS that parses Adobe After Effects animations exported as json with Bodymovin and renders them natively on mobile and on the web!</p>\n</blockquote>\n<p>Lottie是一个库，可以解析使用AE制作的动画（需要用bodymovin导出为json格式），支持web、ios、android和react native。<br>在web侧，lottie-web库可以解析导出的动画json文件，并将其以svg或者canvas的方式将动画绘制到我们页面中。关于lottie-web的详细信息，也可以参见<a href=\"https://github.com/airbnb/lottie-web\" target=\"_blank\" rel=\"noopener\">https://github.com/airbnb/lottie-web</a>。<br><img src=\"http://imweb-io-1251594266.file.myqcloud.com/FvWDhZoyPK5wVQecu5qFYEDdGuJe\"></p>\n<h2 id=\"lottie-web引用方式\"><a href=\"#lottie-web引用方式\" class=\"headerlink\" title=\"lottie-web引用方式\"></a>lottie-web引用方式</h2><h3 id=\"npm包\"><a href=\"#npm包\" class=\"headerlink\" title=\"npm包\"></a>npm包</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> lottie <span class=\"keyword\">from</span> <span class=\"string\">'lottie-web'</span></span><br><span class=\"line\">lottie.loadAnimation(&#123;</span><br><span class=\"line\">  container: element, <span class=\"comment\">// the dom element that will contain the animation</span></span><br><span class=\"line\">  renderer: <span class=\"string\">'svg'</span>,</span><br><span class=\"line\">  loop: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  autoplay: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  path: <span class=\"string\">'data.json'</span> <span class=\"comment\">// the path to the animation json</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"js外链\"><a href=\"#js外链\" class=\"headerlink\" title=\"js外链\"></a>js外链</h3><p>多个版本的lottie库都可以从<a href=\"https://cdnjs.com/libraries/bodymovin\" target=\"_blank\" rel=\"noopener\">cdnjs-bodymovin</a>找到<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.com/libraries/bodymovin\"</span> /&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br><span class=\"line\"><span class=\"undefined\">    bodymovin.loadAnimation(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      container: element, <span class=\"comment\">// the dom element that will contain the animation</span></span></span><br><span class=\"line\"><span class=\"javascript\">      renderer: <span class=\"string\">'svg'</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      loop: <span class=\"literal\">true</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      autoplay: <span class=\"literal\">true</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      path: <span class=\"string\">'data.json'</span> <span class=\"comment\">// the path to the animation json</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>通过外链引入的方式，既可以通过<code>bodymovin</code>去调用，也可以使用<code>lottie</code>变量，二者等价，都是js库提供的全局变量。</p>\n<h2 id=\"lottie-web实践\"><a href=\"#lottie-web实践\" class=\"headerlink\" title=\"lottie-web实践\"></a>lottie-web实践</h2><p>lottie库文件比较大，gzip压缩后也有60k，再加上动画对应的json文件，直接引入会给项目代码增大不少体积，影响页面加载速度。</p>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th style=\"text-align:center\">大小</th>\n<th style=\"text-align:center\">gzip后</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>lottie.js</td>\n<td style=\"text-align:center\">513k</td>\n<td style=\"text-align:center\">92k</td>\n</tr>\n<tr>\n<td>lottie.min.js</td>\n<td style=\"text-align:center\">237k</td>\n<td style=\"text-align:center\">60k</td>\n</tr>\n<tr>\n<td>lottie_light.js (lottie_web轻量版，仅支持svg渲染)</td>\n<td style=\"text-align:center\">345k</td>\n<td style=\"text-align:center\">60k</td>\n</tr>\n<tr>\n<td>lottie_lignt.min.js</td>\n<td style=\"text-align:center\">144k</td>\n<td style=\"text-align:center\">39k</td>\n</tr>\n</tbody>\n</table>\n<p>所以，如果动画只需要支持svg渲染，则可以引入light版本的库文件，gzip压缩后缩减到39k。<br>为了进一步降低影响，可以使用code splitting的方式，以async的方式异步加载js，这样就不会阻塞浏览器解析html、执行js脚本以及展示css布局。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"lottie-light\" */</span> <span class=\"string\">'../lib/lottie_light.min.js'</span>).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.lottie &amp;&amp; <span class=\"built_in\">window</span>.lottie.loadAnimation(&#123;</span><br><span class=\"line\">        container: <span class=\"keyword\">this</span>.headerDom,</span><br><span class=\"line\">        renderer: <span class=\"string\">'svg'</span>,</span><br><span class=\"line\">        loop: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        autoplay: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        animationData: <span class=\"built_in\">require</span>(<span class=\"string\">'../data/ribbon.json'</span>)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>示例demo可以参见codepen上的<a href=\"https://codepen.io/sherrywu0917/pen/XPNavE\" target=\"_blank\" rel=\"noopener\">ribbon-lottie</a>，测试数据<code>ribbon.json</code>可以下载<a href=\"https://easyreadfs.nosdn.127.net/1548645419902/ribbon.json\" target=\"_blank\" rel=\"noopener\">彩带json数据</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"lottie简介\"><a href=\"#lottie简介\" class=\"headerlink\" title=\"lottie简介\"></a>lottie简介</h2><blockquote>\n<p><a href=\"http://airbnb.io/lottie/\" target=\"_blank\" rel=\"noopener\">Lottie</a> is a mobile library for Android and iOS that parses Adobe After Effects animations exported as json with Bodymovin and renders them natively on mobile and on the web!</p>\n</blockquote>\n<p>Lottie是一个库，可以解析使用AE制作的动画（需要用bodymovin导出为json格式），支持web、ios、android和react native。<br>在web侧，lottie-web库可以解析导出的动画json文件，并将其以svg或者canvas的方式将动画绘制到我们页面中。关于lottie-web的详细信息，也可以参见<a href=\"https://github.com/airbnb/lottie-web\" target=\"_blank\" rel=\"noopener\">https://github.com/airbnb/lottie-web</a>。<br><img src=\"http://imweb-io-1251594266.file.myqcloud.com/FvWDhZoyPK5wVQecu5qFYEDdGuJe\"></p>\n<h2 id=\"lottie-web引用方式\"><a href=\"#lottie-web引用方式\" class=\"headerlink\" title=\"lottie-web引用方式\"></a>lottie-web引用方式</h2><h3 id=\"npm包\"><a href=\"#npm包\" class=\"headerlink\" title=\"npm包\"></a>npm包</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> lottie <span class=\"keyword\">from</span> <span class=\"string\">'lottie-web'</span></span><br><span class=\"line\">lottie.loadAnimation(&#123;</span><br><span class=\"line\">  container: element, <span class=\"comment\">// the dom element that will contain the animation</span></span><br><span class=\"line\">  renderer: <span class=\"string\">'svg'</span>,</span><br><span class=\"line\">  loop: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  autoplay: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  path: <span class=\"string\">'data.json'</span> <span class=\"comment\">// the path to the animation json</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"js外链\"><a href=\"#js外链\" class=\"headerlink\" title=\"js外链\"></a>js外链</h3><p>多个版本的lottie库都可以从<a href=\"https://cdnjs.com/libraries/bodymovin\" target=\"_blank\" rel=\"noopener\">cdnjs-bodymovin</a>找到<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://cdnjs.com/libraries/bodymovin\"</span> /&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span></span><br><span class=\"line\"><span class=\"undefined\">    bodymovin.loadAnimation(&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      container: element, <span class=\"comment\">// the dom element that will contain the animation</span></span></span><br><span class=\"line\"><span class=\"javascript\">      renderer: <span class=\"string\">'svg'</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      loop: <span class=\"literal\">true</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      autoplay: <span class=\"literal\">true</span>,</span></span><br><span class=\"line\"><span class=\"javascript\">      path: <span class=\"string\">'data.json'</span> <span class=\"comment\">// the path to the animation json</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>通过外链引入的方式，既可以通过<code>bodymovin</code>去调用，也可以使用<code>lottie</code>变量，二者等价，都是js库提供的全局变量。</p>\n<h2 id=\"lottie-web实践\"><a href=\"#lottie-web实践\" class=\"headerlink\" title=\"lottie-web实践\"></a>lottie-web实践</h2><p>lottie库文件比较大，gzip压缩后也有60k，再加上动画对应的json文件，直接引入会给项目代码增大不少体积，影响页面加载速度。</p>\n<table>\n<thead>\n<tr>\n<th>文件</th>\n<th style=\"text-align:center\">大小</th>\n<th style=\"text-align:center\">gzip后</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>lottie.js</td>\n<td style=\"text-align:center\">513k</td>\n<td style=\"text-align:center\">92k</td>\n</tr>\n<tr>\n<td>lottie.min.js</td>\n<td style=\"text-align:center\">237k</td>\n<td style=\"text-align:center\">60k</td>\n</tr>\n<tr>\n<td>lottie_light.js (lottie_web轻量版，仅支持svg渲染)</td>\n<td style=\"text-align:center\">345k</td>\n<td style=\"text-align:center\">60k</td>\n</tr>\n<tr>\n<td>lottie_lignt.min.js</td>\n<td style=\"text-align:center\">144k</td>\n<td style=\"text-align:center\">39k</td>\n</tr>\n</tbody>\n</table>\n<p>所以，如果动画只需要支持svg渲染，则可以引入light版本的库文件，gzip压缩后缩减到39k。<br>为了进一步降低影响，可以使用code splitting的方式，以async的方式异步加载js，这样就不会阻塞浏览器解析html、执行js脚本以及展示css布局。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"lottie-light\" */</span> <span class=\"string\">'../lib/lottie_light.min.js'</span>).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.lottie &amp;&amp; <span class=\"built_in\">window</span>.lottie.loadAnimation(&#123;</span><br><span class=\"line\">        container: <span class=\"keyword\">this</span>.headerDom,</span><br><span class=\"line\">        renderer: <span class=\"string\">'svg'</span>,</span><br><span class=\"line\">        loop: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        autoplay: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        animationData: <span class=\"built_in\">require</span>(<span class=\"string\">'../data/ribbon.json'</span>)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>示例demo可以参见codepen上的<a href=\"https://codepen.io/sherrywu0917/pen/XPNavE\" target=\"_blank\" rel=\"noopener\">ribbon-lottie</a>，测试数据<code>ribbon.json</code>可以下载<a href=\"https://easyreadfs.nosdn.127.net/1548645419902/ribbon.json\" target=\"_blank\" rel=\"noopener\">彩带json数据</a>。</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n<!-- more -->\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n<!-- more -->\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2019-03-18T02:27:14.362Z","updated":"2019-03-18T02:27:14.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6o000qqmhfto5yvxmu","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<a id=\"more\"></a>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>","more":"<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"npm转盘组件开发","date":"2018-02-09T06:39:53.000Z","_content":"### 准备工作\n在开始开发之前，首先要准备好node环境和npm账户，nodeJS基本都有安装好，要做的就是注册npm：\n``` bash\n$ npm adduser\nUsername: your name\nPassword: your password\nEmail: (this IS public) your email\n```\n查询当前账号或者登陆别的用户：\n``` bash\n$ npm whoami\n$ npm login\n```\n\n### 包管理工具lerna\n项目组采用了[lerna](https://github.com/lerna/lerna)包管理工具，可以在一个仓库下管理多个npm包，基于monorepo理念。\n> Monorepo is a unified source code repository used by an organisation to host as much of its code as possible.\nMonorepo 它是一种管理 organisation 代码的方式，在这种方式下会摒弃原先一个 module 一个 repo 的方式，取而代之的是把所有的 modules 都放在一个 repo 内来管理。\n\nlerna安装和初始化\n``` bash\nnpm install lerna -g\nlerna init\n```\n初始化后，目录里面会自动生成/packages、lerna.json和package.json。\n执行`lerna bootstrap`会自动为项目进行npm install和npm link操作，npm的作用是边开发边试用，具体使用参考[npm link](http://javascript.ruanyifeng.com/nodejs/npm.html#toc18)。\n<!-- more -->\n执行`lerna publish`可以发布版本。\nlerna有两种模式的管理方式，项目仓库选用默认的Fixed/Locked模式，在lerna.json里的version字段是本仓库版本，packages下的包的版本等于或者小于本仓库的版本\n有两种情况：\n- 如果某个包的版本更新了，原版本是1.0.2，本仓库版本是1.0.9，则这个包的更新后的版本是1.0.10，而不是1.0.3\n- 如果有个包引入了重大改动（BREAKING CHANGE）, 则所有的包的major version都会改变\n其中commit message的编写遵循[Conventional Commits ](https://conventionalcommits.org/)，主要包括fix/feat/BREAKING CHANGE三种类型，以及对文档的修改`docs:`，或者其他`style:, refactor:, perf:, test:, chore:`。\n\n### 组件开发\n#### 定义组件配置项和方法\n组件对外暴露的类是PrizeWheel，该class的构造函数支持传入`rotateSelector`(将要旋转的元素对应的选择器)和`config`(转盘相关配置)两个参数，config中支持对奖项、旋转元素类型、转速等的配置。此外，该class提供了旋转到指定位置和终止旋转两个方法。\n初始化时，_countPrizeAngleMap方法会计算出每个奖项的目标角度。\n``` javascript\n_countPrizeAngleMap() {\n    const {prizeQueue, rotator, inSector} = this.config;\n    let len = prizeQueue.length;\n    prizeQueue.forEach( (level, index) => {\n        let diff = 0, targetAngle = 0;\n        if(inSector) {\n            diff = - 360/len/2;\n        }\n        if(rotator == 'pointer') { //指针旋转\n            targetAngle = 360/len * (index + 0.5) + diff;\n        }\n        else {  //转盘旋转\n            targetAngle = 360 - (360/len * (index + 0.5) + diff);\n        }\n        this.prizeAngleMap.set(level, targetAngle);\n    })\n}\n```\nprizeQueue是一个数组，对应转盘上的奖项队列，按照顺时针方向。rotator是旋转类型：'pointer'(Default) - 指针旋转、'wheel' - 转盘旋转。inSector代表初始位置是否在扇区内：false(Default)、true，false代表与扇区的边缘线重合，true代表在扇区的正中位置。旋转的情况有四种(N从0开始计数)：\n- 旋转的是指针，inSector为false：指针在边缘线，则第N个奖项的目标角度 = 每个扇区的角度 * (N + 0.5)；\n- 旋转的是指针，inSector为true：指针在扇区中央，旋转的角度相对上一种少了半个扇区，则第N个奖项的目标角度 = 每个扇区的角度 * (N + 0.5) - 每个扇区的角度 * 0.5；\n- 旋转的是扇区，inSector为false(或true)：目标角度都是 = 360 - (指针旋转情况下的角度)\n\n具体的转盘效果封装在了WheelEffect类中，该类的关键点是提供了一个缓动函数(参考的网上代码)：\n``` js\nfunction easing(t, b, c, d) { return -c * ((t=t/d-1)*t*t*t - 1) + b; }\n```\n其中参数含义：\n- t: 当前动画已经持续的时间\n- b: 开始的角度\n- c: 一共要旋转的角度和\n- d: 动画要持续的时间\n间隔特定的时间去旋转该方法返回的角度，实现动效。\n\n#### 组件发布\n期望通过`import PrizeWheel from 'nw-prize-wheel'`的方式引入组件，所以在prize-wheel.js中是这样export的：\n``` js\nexport default class PrizeWheel {\n}\n```\n但在打包成js文件时，通过script标签嵌入，发现直接`new PrizeWheel()`报错，提示undefined，在网上找了一圈，发现需要另外新建一个index.js，在index.js中:\n``` js\n    module.exports = require('./src/prize-wheel.js').default;\n```\nwebpack配置添加library和libraryTarget。\n``` js\n  output: {\n      path: __dirname + '/lib',\n      filename: '[name].js',\n      library: 'PrizeWheel',\n      libraryTarget: 'this'\n  }\n```\n期望webpack提供诸如`libraryTarget: 'default'`这样的配置来解决问题，但目前不支持，只能用上述方法来曲线救国。\n\n#### 组件API文档化\n``` bash\njsdoc2md --template readme.hbs --files src/prize-wheel.js > readme.md\n```\n结合了[jsdoc](http://usejsdoc.org/index.html)和jsdoc2md可以将自定义的模板和js注释生成一个API文档，具体的使用方式详见官网。\n\n最终实现的组件详情[nw-prize-wheel](https://www.npmjs.com/package/nw-prize-wheel)\n","source":"_posts/npm转盘组件开发.md","raw":"---\ntitle: npm转盘组件开发\ndate: 2018-02-09 14:39:53\ntags: [npm包, 组件开发]\n---\n### 准备工作\n在开始开发之前，首先要准备好node环境和npm账户，nodeJS基本都有安装好，要做的就是注册npm：\n``` bash\n$ npm adduser\nUsername: your name\nPassword: your password\nEmail: (this IS public) your email\n```\n查询当前账号或者登陆别的用户：\n``` bash\n$ npm whoami\n$ npm login\n```\n\n### 包管理工具lerna\n项目组采用了[lerna](https://github.com/lerna/lerna)包管理工具，可以在一个仓库下管理多个npm包，基于monorepo理念。\n> Monorepo is a unified source code repository used by an organisation to host as much of its code as possible.\nMonorepo 它是一种管理 organisation 代码的方式，在这种方式下会摒弃原先一个 module 一个 repo 的方式，取而代之的是把所有的 modules 都放在一个 repo 内来管理。\n\nlerna安装和初始化\n``` bash\nnpm install lerna -g\nlerna init\n```\n初始化后，目录里面会自动生成/packages、lerna.json和package.json。\n执行`lerna bootstrap`会自动为项目进行npm install和npm link操作，npm的作用是边开发边试用，具体使用参考[npm link](http://javascript.ruanyifeng.com/nodejs/npm.html#toc18)。\n<!-- more -->\n执行`lerna publish`可以发布版本。\nlerna有两种模式的管理方式，项目仓库选用默认的Fixed/Locked模式，在lerna.json里的version字段是本仓库版本，packages下的包的版本等于或者小于本仓库的版本\n有两种情况：\n- 如果某个包的版本更新了，原版本是1.0.2，本仓库版本是1.0.9，则这个包的更新后的版本是1.0.10，而不是1.0.3\n- 如果有个包引入了重大改动（BREAKING CHANGE）, 则所有的包的major version都会改变\n其中commit message的编写遵循[Conventional Commits ](https://conventionalcommits.org/)，主要包括fix/feat/BREAKING CHANGE三种类型，以及对文档的修改`docs:`，或者其他`style:, refactor:, perf:, test:, chore:`。\n\n### 组件开发\n#### 定义组件配置项和方法\n组件对外暴露的类是PrizeWheel，该class的构造函数支持传入`rotateSelector`(将要旋转的元素对应的选择器)和`config`(转盘相关配置)两个参数，config中支持对奖项、旋转元素类型、转速等的配置。此外，该class提供了旋转到指定位置和终止旋转两个方法。\n初始化时，_countPrizeAngleMap方法会计算出每个奖项的目标角度。\n``` javascript\n_countPrizeAngleMap() {\n    const {prizeQueue, rotator, inSector} = this.config;\n    let len = prizeQueue.length;\n    prizeQueue.forEach( (level, index) => {\n        let diff = 0, targetAngle = 0;\n        if(inSector) {\n            diff = - 360/len/2;\n        }\n        if(rotator == 'pointer') { //指针旋转\n            targetAngle = 360/len * (index + 0.5) + diff;\n        }\n        else {  //转盘旋转\n            targetAngle = 360 - (360/len * (index + 0.5) + diff);\n        }\n        this.prizeAngleMap.set(level, targetAngle);\n    })\n}\n```\nprizeQueue是一个数组，对应转盘上的奖项队列，按照顺时针方向。rotator是旋转类型：'pointer'(Default) - 指针旋转、'wheel' - 转盘旋转。inSector代表初始位置是否在扇区内：false(Default)、true，false代表与扇区的边缘线重合，true代表在扇区的正中位置。旋转的情况有四种(N从0开始计数)：\n- 旋转的是指针，inSector为false：指针在边缘线，则第N个奖项的目标角度 = 每个扇区的角度 * (N + 0.5)；\n- 旋转的是指针，inSector为true：指针在扇区中央，旋转的角度相对上一种少了半个扇区，则第N个奖项的目标角度 = 每个扇区的角度 * (N + 0.5) - 每个扇区的角度 * 0.5；\n- 旋转的是扇区，inSector为false(或true)：目标角度都是 = 360 - (指针旋转情况下的角度)\n\n具体的转盘效果封装在了WheelEffect类中，该类的关键点是提供了一个缓动函数(参考的网上代码)：\n``` js\nfunction easing(t, b, c, d) { return -c * ((t=t/d-1)*t*t*t - 1) + b; }\n```\n其中参数含义：\n- t: 当前动画已经持续的时间\n- b: 开始的角度\n- c: 一共要旋转的角度和\n- d: 动画要持续的时间\n间隔特定的时间去旋转该方法返回的角度，实现动效。\n\n#### 组件发布\n期望通过`import PrizeWheel from 'nw-prize-wheel'`的方式引入组件，所以在prize-wheel.js中是这样export的：\n``` js\nexport default class PrizeWheel {\n}\n```\n但在打包成js文件时，通过script标签嵌入，发现直接`new PrizeWheel()`报错，提示undefined，在网上找了一圈，发现需要另外新建一个index.js，在index.js中:\n``` js\n    module.exports = require('./src/prize-wheel.js').default;\n```\nwebpack配置添加library和libraryTarget。\n``` js\n  output: {\n      path: __dirname + '/lib',\n      filename: '[name].js',\n      library: 'PrizeWheel',\n      libraryTarget: 'this'\n  }\n```\n期望webpack提供诸如`libraryTarget: 'default'`这样的配置来解决问题，但目前不支持，只能用上述方法来曲线救国。\n\n#### 组件API文档化\n``` bash\njsdoc2md --template readme.hbs --files src/prize-wheel.js > readme.md\n```\n结合了[jsdoc](http://usejsdoc.org/index.html)和jsdoc2md可以将自定义的模板和js注释生成一个API文档，具体的使用方式详见官网。\n\n最终实现的组件详情[nw-prize-wheel](https://www.npmjs.com/package/nw-prize-wheel)\n","slug":"npm转盘组件开发","published":1,"updated":"2019-03-18T02:27:14.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6q000sqmhfn18f9zzb","content":"<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>在开始开发之前，首先要准备好node环境和npm账户，nodeJS基本都有安装好，要做的就是注册npm：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm adduser</span><br><span class=\"line\">Username: your name</span><br><span class=\"line\">Password: your password</span><br><span class=\"line\">Email: (this IS public) your email</span><br></pre></td></tr></table></figure></p>\n<p>查询当前账号或者登陆别的用户：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm whoami</span><br><span class=\"line\">$ npm login</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"包管理工具lerna\"><a href=\"#包管理工具lerna\" class=\"headerlink\" title=\"包管理工具lerna\"></a>包管理工具lerna</h3><p>项目组采用了<a href=\"https://github.com/lerna/lerna\" target=\"_blank\" rel=\"noopener\">lerna</a>包管理工具，可以在一个仓库下管理多个npm包，基于monorepo理念。</p>\n<blockquote>\n<p>Monorepo is a unified source code repository used by an organisation to host as much of its code as possible.<br>Monorepo 它是一种管理 organisation 代码的方式，在这种方式下会摒弃原先一个 module 一个 repo 的方式，取而代之的是把所有的 modules 都放在一个 repo 内来管理。</p>\n</blockquote>\n<p>lerna安装和初始化<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install lerna -g</span><br><span class=\"line\">lerna init</span><br></pre></td></tr></table></figure></p>\n<p>初始化后，目录里面会自动生成/packages、lerna.json和package.json。<br>执行<code>lerna bootstrap</code>会自动为项目进行npm install和npm link操作，npm的作用是边开发边试用，具体使用参考<a href=\"http://javascript.ruanyifeng.com/nodejs/npm.html#toc18\" target=\"_blank\" rel=\"noopener\">npm link</a>。<br><a id=\"more\"></a><br>执行<code>lerna publish</code>可以发布版本。<br>lerna有两种模式的管理方式，项目仓库选用默认的Fixed/Locked模式，在lerna.json里的version字段是本仓库版本，packages下的包的版本等于或者小于本仓库的版本<br>有两种情况：</p>\n<ul>\n<li>如果某个包的版本更新了，原版本是1.0.2，本仓库版本是1.0.9，则这个包的更新后的版本是1.0.10，而不是1.0.3</li>\n<li>如果有个包引入了重大改动（BREAKING CHANGE）, 则所有的包的major version都会改变<br>其中commit message的编写遵循<a href=\"https://conventionalcommits.org/\" target=\"_blank\" rel=\"noopener\">Conventional Commits </a>，主要包括fix/feat/BREAKING CHANGE三种类型，以及对文档的修改<code>docs:</code>，或者其他<code>style:, refactor:, perf:, test:, chore:</code>。</li>\n</ul>\n<h3 id=\"组件开发\"><a href=\"#组件开发\" class=\"headerlink\" title=\"组件开发\"></a>组件开发</h3><h4 id=\"定义组件配置项和方法\"><a href=\"#定义组件配置项和方法\" class=\"headerlink\" title=\"定义组件配置项和方法\"></a>定义组件配置项和方法</h4><p>组件对外暴露的类是PrizeWheel，该class的构造函数支持传入<code>rotateSelector</code>(将要旋转的元素对应的选择器)和<code>config</code>(转盘相关配置)两个参数，config中支持对奖项、旋转元素类型、转速等的配置。此外，该class提供了旋转到指定位置和终止旋转两个方法。<br>初始化时，_countPrizeAngleMap方法会计算出每个奖项的目标角度。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_countPrizeAngleMap() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;prizeQueue, rotator, inSector&#125; = <span class=\"keyword\">this</span>.config;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = prizeQueue.length;</span><br><span class=\"line\">    prizeQueue.forEach( <span class=\"function\">(<span class=\"params\">level, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> diff = <span class=\"number\">0</span>, targetAngle = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(inSector) &#123;</span><br><span class=\"line\">            diff = - <span class=\"number\">360</span>/len/<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rotator == <span class=\"string\">'pointer'</span>) &#123; <span class=\"comment\">//指针旋转</span></span><br><span class=\"line\">            targetAngle = <span class=\"number\">360</span>/len * (index + <span class=\"number\">0.5</span>) + diff;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">//转盘旋转</span></span><br><span class=\"line\">            targetAngle = <span class=\"number\">360</span> - (<span class=\"number\">360</span>/len * (index + <span class=\"number\">0.5</span>) + diff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prizeAngleMap.set(level, targetAngle);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>prizeQueue是一个数组，对应转盘上的奖项队列，按照顺时针方向。rotator是旋转类型：’pointer’(Default) - 指针旋转、’wheel’ - 转盘旋转。inSector代表初始位置是否在扇区内：false(Default)、true，false代表与扇区的边缘线重合，true代表在扇区的正中位置。旋转的情况有四种(N从0开始计数)：</p>\n<ul>\n<li>旋转的是指针，inSector为false：指针在边缘线，则第N个奖项的目标角度 = 每个扇区的角度 * (N + 0.5)；</li>\n<li>旋转的是指针，inSector为true：指针在扇区中央，旋转的角度相对上一种少了半个扇区，则第N个奖项的目标角度 = 每个扇区的角度 <em> (N + 0.5) - 每个扇区的角度 </em> 0.5；</li>\n<li>旋转的是扇区，inSector为false(或true)：目标角度都是 = 360 - (指针旋转情况下的角度)</li>\n</ul>\n<p>具体的转盘效果封装在了WheelEffect类中，该类的关键点是提供了一个缓动函数(参考的网上代码)：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">easing</span>(<span class=\"params\">t, b, c, d</span>) </span>&#123; <span class=\"keyword\">return</span> -c * ((t=t/d<span class=\"number\">-1</span>)*t*t*t - <span class=\"number\">1</span>) + b; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中参数含义：</p>\n<ul>\n<li>t: 当前动画已经持续的时间</li>\n<li>b: 开始的角度</li>\n<li>c: 一共要旋转的角度和</li>\n<li>d: 动画要持续的时间<br>间隔特定的时间去旋转该方法返回的角度，实现动效。</li>\n</ul>\n<h4 id=\"组件发布\"><a href=\"#组件发布\" class=\"headerlink\" title=\"组件发布\"></a>组件发布</h4><p>期望通过<code>import PrizeWheel from &#39;nw-prize-wheel&#39;</code>的方式引入组件，所以在prize-wheel.js中是这样export的：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrizeWheel</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但在打包成js文件时，通过script标签嵌入，发现直接<code>new PrizeWheel()</code>报错，提示undefined，在网上找了一圈，发现需要另外新建一个index.js，在index.js中:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"built_in\">require</span>(<span class=\"string\">'./src/prize-wheel.js'</span>).default;</span><br></pre></td></tr></table></figure></p>\n<p>webpack配置添加library和libraryTarget。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">    path: __dirname + <span class=\"string\">'/lib'</span>,</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    library: <span class=\"string\">'PrizeWheel'</span>,</span><br><span class=\"line\">    libraryTarget: <span class=\"string\">'this'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>期望webpack提供诸如<code>libraryTarget: &#39;default&#39;</code>这样的配置来解决问题，但目前不支持，只能用上述方法来曲线救国。</p>\n<h4 id=\"组件API文档化\"><a href=\"#组件API文档化\" class=\"headerlink\" title=\"组件API文档化\"></a>组件API文档化</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsdoc2md --template readme.hbs --files src/prize-wheel.js &gt; readme.md</span><br></pre></td></tr></table></figure>\n<p>结合了<a href=\"http://usejsdoc.org/index.html\" target=\"_blank\" rel=\"noopener\">jsdoc</a>和jsdoc2md可以将自定义的模板和js注释生成一个API文档，具体的使用方式详见官网。</p>\n<p>最终实现的组件详情<a href=\"https://www.npmjs.com/package/nw-prize-wheel\" target=\"_blank\" rel=\"noopener\">nw-prize-wheel</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>在开始开发之前，首先要准备好node环境和npm账户，nodeJS基本都有安装好，要做的就是注册npm：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm adduser</span><br><span class=\"line\">Username: your name</span><br><span class=\"line\">Password: your password</span><br><span class=\"line\">Email: (this IS public) your email</span><br></pre></td></tr></table></figure></p>\n<p>查询当前账号或者登陆别的用户：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm whoami</span><br><span class=\"line\">$ npm login</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"包管理工具lerna\"><a href=\"#包管理工具lerna\" class=\"headerlink\" title=\"包管理工具lerna\"></a>包管理工具lerna</h3><p>项目组采用了<a href=\"https://github.com/lerna/lerna\" target=\"_blank\" rel=\"noopener\">lerna</a>包管理工具，可以在一个仓库下管理多个npm包，基于monorepo理念。</p>\n<blockquote>\n<p>Monorepo is a unified source code repository used by an organisation to host as much of its code as possible.<br>Monorepo 它是一种管理 organisation 代码的方式，在这种方式下会摒弃原先一个 module 一个 repo 的方式，取而代之的是把所有的 modules 都放在一个 repo 内来管理。</p>\n</blockquote>\n<p>lerna安装和初始化<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install lerna -g</span><br><span class=\"line\">lerna init</span><br></pre></td></tr></table></figure></p>\n<p>初始化后，目录里面会自动生成/packages、lerna.json和package.json。<br>执行<code>lerna bootstrap</code>会自动为项目进行npm install和npm link操作，npm的作用是边开发边试用，具体使用参考<a href=\"http://javascript.ruanyifeng.com/nodejs/npm.html#toc18\" target=\"_blank\" rel=\"noopener\">npm link</a>。<br>","more":"<br>执行<code>lerna publish</code>可以发布版本。<br>lerna有两种模式的管理方式，项目仓库选用默认的Fixed/Locked模式，在lerna.json里的version字段是本仓库版本，packages下的包的版本等于或者小于本仓库的版本<br>有两种情况：</p>\n<ul>\n<li>如果某个包的版本更新了，原版本是1.0.2，本仓库版本是1.0.9，则这个包的更新后的版本是1.0.10，而不是1.0.3</li>\n<li>如果有个包引入了重大改动（BREAKING CHANGE）, 则所有的包的major version都会改变<br>其中commit message的编写遵循<a href=\"https://conventionalcommits.org/\" target=\"_blank\" rel=\"noopener\">Conventional Commits </a>，主要包括fix/feat/BREAKING CHANGE三种类型，以及对文档的修改<code>docs:</code>，或者其他<code>style:, refactor:, perf:, test:, chore:</code>。</li>\n</ul>\n<h3 id=\"组件开发\"><a href=\"#组件开发\" class=\"headerlink\" title=\"组件开发\"></a>组件开发</h3><h4 id=\"定义组件配置项和方法\"><a href=\"#定义组件配置项和方法\" class=\"headerlink\" title=\"定义组件配置项和方法\"></a>定义组件配置项和方法</h4><p>组件对外暴露的类是PrizeWheel，该class的构造函数支持传入<code>rotateSelector</code>(将要旋转的元素对应的选择器)和<code>config</code>(转盘相关配置)两个参数，config中支持对奖项、旋转元素类型、转速等的配置。此外，该class提供了旋转到指定位置和终止旋转两个方法。<br>初始化时，_countPrizeAngleMap方法会计算出每个奖项的目标角度。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_countPrizeAngleMap() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;prizeQueue, rotator, inSector&#125; = <span class=\"keyword\">this</span>.config;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> len = prizeQueue.length;</span><br><span class=\"line\">    prizeQueue.forEach( <span class=\"function\">(<span class=\"params\">level, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> diff = <span class=\"number\">0</span>, targetAngle = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(inSector) &#123;</span><br><span class=\"line\">            diff = - <span class=\"number\">360</span>/len/<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rotator == <span class=\"string\">'pointer'</span>) &#123; <span class=\"comment\">//指针旋转</span></span><br><span class=\"line\">            targetAngle = <span class=\"number\">360</span>/len * (index + <span class=\"number\">0.5</span>) + diff;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;  <span class=\"comment\">//转盘旋转</span></span><br><span class=\"line\">            targetAngle = <span class=\"number\">360</span> - (<span class=\"number\">360</span>/len * (index + <span class=\"number\">0.5</span>) + diff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.prizeAngleMap.set(level, targetAngle);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>prizeQueue是一个数组，对应转盘上的奖项队列，按照顺时针方向。rotator是旋转类型：’pointer’(Default) - 指针旋转、’wheel’ - 转盘旋转。inSector代表初始位置是否在扇区内：false(Default)、true，false代表与扇区的边缘线重合，true代表在扇区的正中位置。旋转的情况有四种(N从0开始计数)：</p>\n<ul>\n<li>旋转的是指针，inSector为false：指针在边缘线，则第N个奖项的目标角度 = 每个扇区的角度 * (N + 0.5)；</li>\n<li>旋转的是指针，inSector为true：指针在扇区中央，旋转的角度相对上一种少了半个扇区，则第N个奖项的目标角度 = 每个扇区的角度 <em> (N + 0.5) - 每个扇区的角度 </em> 0.5；</li>\n<li>旋转的是扇区，inSector为false(或true)：目标角度都是 = 360 - (指针旋转情况下的角度)</li>\n</ul>\n<p>具体的转盘效果封装在了WheelEffect类中，该类的关键点是提供了一个缓动函数(参考的网上代码)：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">easing</span>(<span class=\"params\">t, b, c, d</span>) </span>&#123; <span class=\"keyword\">return</span> -c * ((t=t/d<span class=\"number\">-1</span>)*t*t*t - <span class=\"number\">1</span>) + b; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中参数含义：</p>\n<ul>\n<li>t: 当前动画已经持续的时间</li>\n<li>b: 开始的角度</li>\n<li>c: 一共要旋转的角度和</li>\n<li>d: 动画要持续的时间<br>间隔特定的时间去旋转该方法返回的角度，实现动效。</li>\n</ul>\n<h4 id=\"组件发布\"><a href=\"#组件发布\" class=\"headerlink\" title=\"组件发布\"></a>组件发布</h4><p>期望通过<code>import PrizeWheel from &#39;nw-prize-wheel&#39;</code>的方式引入组件，所以在prize-wheel.js中是这样export的：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PrizeWheel</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但在打包成js文件时，通过script标签嵌入，发现直接<code>new PrizeWheel()</code>报错，提示undefined，在网上找了一圈，发现需要另外新建一个index.js，在index.js中:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"built_in\">require</span>(<span class=\"string\">'./src/prize-wheel.js'</span>).default;</span><br></pre></td></tr></table></figure></p>\n<p>webpack配置添加library和libraryTarget。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">    path: __dirname + <span class=\"string\">'/lib'</span>,</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">    library: <span class=\"string\">'PrizeWheel'</span>,</span><br><span class=\"line\">    libraryTarget: <span class=\"string\">'this'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>期望webpack提供诸如<code>libraryTarget: &#39;default&#39;</code>这样的配置来解决问题，但目前不支持，只能用上述方法来曲线救国。</p>\n<h4 id=\"组件API文档化\"><a href=\"#组件API文档化\" class=\"headerlink\" title=\"组件API文档化\"></a>组件API文档化</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsdoc2md --template readme.hbs --files src/prize-wheel.js &gt; readme.md</span><br></pre></td></tr></table></figure>\n<p>结合了<a href=\"http://usejsdoc.org/index.html\" target=\"_blank\" rel=\"noopener\">jsdoc</a>和jsdoc2md可以将自定义的模板和js注释生成一个API文档，具体的使用方式详见官网。</p>\n<p>最终实现的组件详情<a href=\"https://www.npmjs.com/package/nw-prize-wheel\" target=\"_blank\" rel=\"noopener\">nw-prize-wheel</a></p>"},{"title":"react相关问题","date":"2019-01-29T07:38:28.000Z","_content":"\n### 什么是JSX?——浏览器是如何识别它的？\nJSX是facebook普及的一种标记语言，通过babel/TSC等工具会编译为`React.createElement`function。所以在React每个组件中，虽然没有显式用到React，但都需要`import React from 'react'`。\n\n#### JSX是如何区分React Component和HTML元素的？\n通过元素首字母的大小写，如果首字母大写，则认为是React组件，小写的话则会被认为是HTML元素。可以在[online Babel compiler](https://babeljs.io/repl/#?presets=react&code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA)中试一下。\n``` js\nfunction hello() {\n  return <div>Hello world!</div>;\n}\n\n// after babel compiler\nfunction hello() {\n  return React.createElement(\n    \"div\",\n    null,\n    \"Hello world!\"\n  );\n}\n```\n\n``` js\nfunction hello() {\n  return <div>Hello world!</div>;\n}\n\n// after babel compiler\nfunction hello() {\n  return React.createElement(\n    Div,\n    null,\n    \"Hello world!\"\n  );\n}\n```\n此外，把一个组件赋给`this.component`并且写`<this.component />`也会起作用。\n\n\n### react16生命周期\n#### Mounting\n- constructor()\n- static getDerivedStateFromProps()\n- render()\n- componentDidMount\n\n不建议使用`UNSAFE_componentWillMount()`\n\n#### Updating\n- static getDerivedStateFromProps()\n- shouldComponentUpdate()\n- render()\n- getSnapshotBeforeUpdate()\n- componentDidUpdate()\n\n不建议使用`UNSAFE_componentWillReceiveProps()`和`UNSAFE_componentWillUpdate()`\n`UNSAFE_componentWillReceiveProps()`经常会带来bug和不一致的问题。\n\n#### Unmounting\n- componentWillUnmount()\n\n`getDerivedStateFromProps(props, state)`每次render之前都会被触发，与`componentWillReceiveProps`只在父组件rerender时会触发不一样。此外，`getDerivedStateFromProps`方法不建议经常使用，使用前想一想是否有替代方案。\n\n\n### 加分题：数据获取为什么用 componentDidMount 而不是 constructor？\n你希望听到的两个原因会是：“在渲染发生之前数据不会存在” —— 虽然不是主要原因，但它向您显示该人员了解组件的处理方式; “在 React Fiber 中使用新的异步渲染……” —— 有人一直在努力学习。\n\n- r1: SSR模式下，componentWillMount在server端也是会被调用的，内容返回到client端后，componentWillMount会被第二次调用，如果在componentWillMount中处理数据获取则会被调用两次。\n- r2: 在componentWillMount中调用setState不会触发rerender，所以一般不会被用来获取数据。\n- r3: React16之后采用了Fiber架构，类似ComponentWillMount的生命周期钩子都有可能执行多次，所以不在这些生命周期中做有副作用的操作，比如请求数据。\n- r4: constructor用来初始化组件，作用应该保持纯粹，不应该引入数据获取这种有副作用的操作。\n\n#### react fiber纤程\nfiber是纤程颗粒化的概念，一个线程可以包含多个Fiber，主要是对react更新机制的优化。React16之前的版本，更新组件会一直占用主线程，如果组件树过大，则可能会导致浏览器失去响应。在React16中加入的fiber可以将同步任务拆解，每次执行完一小片后，都会把控制权交还给react负责任务调度的模块，如果有优先级更高的任务，就先执行高优先级的任务。\n##### 拆什么\n首先，看React的渲染，包括两个阶段：调度阶段(reconciliation)和渲染阶段(commit)。\n- 调度阶段react根据数据更新virtual DOM，再运用diff算法找到需要VDOM change。这一部分的工作是可以拆分的。\n- 渲染阶段根据计算出的所有diff去一次性更新真实的DOM。\n组件比较庞大时，diff运算会比较耗时，不可控，所以需要拆分的是调度阶段。\n\n##### 怎么拆\nfiber tree的部分结构如下所示，将简单的数结构，变成了基于单链表的树结构。\n``` json\n{\n    alternate: Fiber|null, //在fiber更新时克隆出的镜像fiber，对fiber的修改会标记在这个fiber上\n    nextEffect: Fiber | null, // 单链表结构，方便遍历 Fiber Tree 上有副作用的节点\n    pendingWorkPriority: PriorityLevel, // 标记子树上待更新任务的优先级\n\n    stateNode: any, // 管理 instance 自身的特性\n    return: Fiber|null, // 指向 Fiber Tree 中的父节点\n    child: Fiber|null, // 指向第一个子节点\n    sibling: Fiber|null, // 指向兄弟节点\n}\n```\n\n##### 执行顺序\n因为是单链表(A → B → C)的结构，所以在每次执行到某个节点(A → B)被中断后，下次可以从该节点(B → C)接着执行。\nrequestIdleCallback会让一个低优先级的任务在空闲期被调用，而requestAnimationFrame会让一个高优先级的任务在下一个栈帧被调用，从而保证了主线程按照优先级执行 fiber 单元。\n> 优先级顺序为：文本框输入 > 本次调度结束需完成的任务 > 动画过渡 > 交互反馈 > 数据更新 > 不会显示但以防将来会显示的任务。\n\n因为react fiber机制，一个任务很可能执行到一半就被其他优先级更高的任务所替代，或者因为时间原因而被终止。当再次执行这个任务时，是从头开始执行一遍，就会导致组件的某些 will 生命周期可能被多次调用而影响性能。\n\nREFs:\n- [[译]以面试官的角度来看React工作面试](https://juejin.im/post/5bca74cfe51d450e9163351b)\n- [浅析 React Fiber](https://juejin.im/post/5be969656fb9a049ad76931f)\n- [浅谈React 16中的Fiber机制](https://tech.youzan.com/react-fiber/)","source":"_posts/react相关问题.md","raw":"---\ntitle: react相关问题\ndate: 2019-01-29 15:38:28\ntags:\n---\n\n### 什么是JSX?——浏览器是如何识别它的？\nJSX是facebook普及的一种标记语言，通过babel/TSC等工具会编译为`React.createElement`function。所以在React每个组件中，虽然没有显式用到React，但都需要`import React from 'react'`。\n\n#### JSX是如何区分React Component和HTML元素的？\n通过元素首字母的大小写，如果首字母大写，则认为是React组件，小写的话则会被认为是HTML元素。可以在[online Babel compiler](https://babeljs.io/repl/#?presets=react&code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA)中试一下。\n``` js\nfunction hello() {\n  return <div>Hello world!</div>;\n}\n\n// after babel compiler\nfunction hello() {\n  return React.createElement(\n    \"div\",\n    null,\n    \"Hello world!\"\n  );\n}\n```\n\n``` js\nfunction hello() {\n  return <div>Hello world!</div>;\n}\n\n// after babel compiler\nfunction hello() {\n  return React.createElement(\n    Div,\n    null,\n    \"Hello world!\"\n  );\n}\n```\n此外，把一个组件赋给`this.component`并且写`<this.component />`也会起作用。\n\n\n### react16生命周期\n#### Mounting\n- constructor()\n- static getDerivedStateFromProps()\n- render()\n- componentDidMount\n\n不建议使用`UNSAFE_componentWillMount()`\n\n#### Updating\n- static getDerivedStateFromProps()\n- shouldComponentUpdate()\n- render()\n- getSnapshotBeforeUpdate()\n- componentDidUpdate()\n\n不建议使用`UNSAFE_componentWillReceiveProps()`和`UNSAFE_componentWillUpdate()`\n`UNSAFE_componentWillReceiveProps()`经常会带来bug和不一致的问题。\n\n#### Unmounting\n- componentWillUnmount()\n\n`getDerivedStateFromProps(props, state)`每次render之前都会被触发，与`componentWillReceiveProps`只在父组件rerender时会触发不一样。此外，`getDerivedStateFromProps`方法不建议经常使用，使用前想一想是否有替代方案。\n\n\n### 加分题：数据获取为什么用 componentDidMount 而不是 constructor？\n你希望听到的两个原因会是：“在渲染发生之前数据不会存在” —— 虽然不是主要原因，但它向您显示该人员了解组件的处理方式; “在 React Fiber 中使用新的异步渲染……” —— 有人一直在努力学习。\n\n- r1: SSR模式下，componentWillMount在server端也是会被调用的，内容返回到client端后，componentWillMount会被第二次调用，如果在componentWillMount中处理数据获取则会被调用两次。\n- r2: 在componentWillMount中调用setState不会触发rerender，所以一般不会被用来获取数据。\n- r3: React16之后采用了Fiber架构，类似ComponentWillMount的生命周期钩子都有可能执行多次，所以不在这些生命周期中做有副作用的操作，比如请求数据。\n- r4: constructor用来初始化组件，作用应该保持纯粹，不应该引入数据获取这种有副作用的操作。\n\n#### react fiber纤程\nfiber是纤程颗粒化的概念，一个线程可以包含多个Fiber，主要是对react更新机制的优化。React16之前的版本，更新组件会一直占用主线程，如果组件树过大，则可能会导致浏览器失去响应。在React16中加入的fiber可以将同步任务拆解，每次执行完一小片后，都会把控制权交还给react负责任务调度的模块，如果有优先级更高的任务，就先执行高优先级的任务。\n##### 拆什么\n首先，看React的渲染，包括两个阶段：调度阶段(reconciliation)和渲染阶段(commit)。\n- 调度阶段react根据数据更新virtual DOM，再运用diff算法找到需要VDOM change。这一部分的工作是可以拆分的。\n- 渲染阶段根据计算出的所有diff去一次性更新真实的DOM。\n组件比较庞大时，diff运算会比较耗时，不可控，所以需要拆分的是调度阶段。\n\n##### 怎么拆\nfiber tree的部分结构如下所示，将简单的数结构，变成了基于单链表的树结构。\n``` json\n{\n    alternate: Fiber|null, //在fiber更新时克隆出的镜像fiber，对fiber的修改会标记在这个fiber上\n    nextEffect: Fiber | null, // 单链表结构，方便遍历 Fiber Tree 上有副作用的节点\n    pendingWorkPriority: PriorityLevel, // 标记子树上待更新任务的优先级\n\n    stateNode: any, // 管理 instance 自身的特性\n    return: Fiber|null, // 指向 Fiber Tree 中的父节点\n    child: Fiber|null, // 指向第一个子节点\n    sibling: Fiber|null, // 指向兄弟节点\n}\n```\n\n##### 执行顺序\n因为是单链表(A → B → C)的结构，所以在每次执行到某个节点(A → B)被中断后，下次可以从该节点(B → C)接着执行。\nrequestIdleCallback会让一个低优先级的任务在空闲期被调用，而requestAnimationFrame会让一个高优先级的任务在下一个栈帧被调用，从而保证了主线程按照优先级执行 fiber 单元。\n> 优先级顺序为：文本框输入 > 本次调度结束需完成的任务 > 动画过渡 > 交互反馈 > 数据更新 > 不会显示但以防将来会显示的任务。\n\n因为react fiber机制，一个任务很可能执行到一半就被其他优先级更高的任务所替代，或者因为时间原因而被终止。当再次执行这个任务时，是从头开始执行一遍，就会导致组件的某些 will 生命周期可能被多次调用而影响性能。\n\nREFs:\n- [[译]以面试官的角度来看React工作面试](https://juejin.im/post/5bca74cfe51d450e9163351b)\n- [浅析 React Fiber](https://juejin.im/post/5be969656fb9a049ad76931f)\n- [浅谈React 16中的Fiber机制](https://tech.youzan.com/react-fiber/)","slug":"react相关问题","published":1,"updated":"2019-03-18T02:27:14.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6s000tqmhfdslgi1nz","content":"<h3 id=\"什么是JSX-——浏览器是如何识别它的？\"><a href=\"#什么是JSX-——浏览器是如何识别它的？\" class=\"headerlink\" title=\"什么是JSX?——浏览器是如何识别它的？\"></a>什么是JSX?——浏览器是如何识别它的？</h3><p>JSX是facebook普及的一种标记语言，通过babel/TSC等工具会编译为<code>React.createElement</code>function。所以在React每个组件中，虽然没有显式用到React，但都需要<code>import React from &#39;react&#39;</code>。</p>\n<h4 id=\"JSX是如何区分React-Component和HTML元素的？\"><a href=\"#JSX是如何区分React-Component和HTML元素的？\" class=\"headerlink\" title=\"JSX是如何区分React Component和HTML元素的？\"></a>JSX是如何区分React Component和HTML元素的？</h4><p>通过元素首字母的大小写，如果首字母大写，则认为是React组件，小写的话则会被认为是HTML元素。可以在<a href=\"https://babeljs.io/repl/#?presets=react&amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA\" target=\"_blank\" rel=\"noopener\">online Babel compiler</a>中试一下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after babel compiler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> React.createElement(</span><br><span class=\"line\">    <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Hello world!\"</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after babel compiler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> React.createElement(</span><br><span class=\"line\">    Div,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Hello world!\"</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，把一个组件赋给<code>this.component</code>并且写<code>&lt;this.component /&gt;</code>也会起作用。</p>\n<h3 id=\"react16生命周期\"><a href=\"#react16生命周期\" class=\"headerlink\" title=\"react16生命周期\"></a>react16生命周期</h3><h4 id=\"Mounting\"><a href=\"#Mounting\" class=\"headerlink\" title=\"Mounting\"></a>Mounting</h4><ul>\n<li>constructor()</li>\n<li>static getDerivedStateFromProps()</li>\n<li>render()</li>\n<li>componentDidMount</li>\n</ul>\n<p>不建议使用<code>UNSAFE_componentWillMount()</code></p>\n<h4 id=\"Updating\"><a href=\"#Updating\" class=\"headerlink\" title=\"Updating\"></a>Updating</h4><ul>\n<li>static getDerivedStateFromProps()</li>\n<li>shouldComponentUpdate()</li>\n<li>render()</li>\n<li>getSnapshotBeforeUpdate()</li>\n<li>componentDidUpdate()</li>\n</ul>\n<p>不建议使用<code>UNSAFE_componentWillReceiveProps()</code>和<code>UNSAFE_componentWillUpdate()</code><br><code>UNSAFE_componentWillReceiveProps()</code>经常会带来bug和不一致的问题。</p>\n<h4 id=\"Unmounting\"><a href=\"#Unmounting\" class=\"headerlink\" title=\"Unmounting\"></a>Unmounting</h4><ul>\n<li>componentWillUnmount()</li>\n</ul>\n<p><code>getDerivedStateFromProps(props, state)</code>每次render之前都会被触发，与<code>componentWillReceiveProps</code>只在父组件rerender时会触发不一样。此外，<code>getDerivedStateFromProps</code>方法不建议经常使用，使用前想一想是否有替代方案。</p>\n<h3 id=\"加分题：数据获取为什么用-componentDidMount-而不是-constructor？\"><a href=\"#加分题：数据获取为什么用-componentDidMount-而不是-constructor？\" class=\"headerlink\" title=\"加分题：数据获取为什么用 componentDidMount 而不是 constructor？\"></a>加分题：数据获取为什么用 componentDidMount 而不是 constructor？</h3><p>你希望听到的两个原因会是：“在渲染发生之前数据不会存在” —— 虽然不是主要原因，但它向您显示该人员了解组件的处理方式; “在 React Fiber 中使用新的异步渲染……” —— 有人一直在努力学习。</p>\n<ul>\n<li>r1: SSR模式下，componentWillMount在server端也是会被调用的，内容返回到client端后，componentWillMount会被第二次调用，如果在componentWillMount中处理数据获取则会被调用两次。</li>\n<li>r2: 在componentWillMount中调用setState不会触发rerender，所以一般不会被用来获取数据。</li>\n<li>r3: React16之后采用了Fiber架构，类似ComponentWillMount的生命周期钩子都有可能执行多次，所以不在这些生命周期中做有副作用的操作，比如请求数据。</li>\n<li>r4: constructor用来初始化组件，作用应该保持纯粹，不应该引入数据获取这种有副作用的操作。</li>\n</ul>\n<h4 id=\"react-fiber纤程\"><a href=\"#react-fiber纤程\" class=\"headerlink\" title=\"react fiber纤程\"></a>react fiber纤程</h4><p>fiber是纤程颗粒化的概念，一个线程可以包含多个Fiber，主要是对react更新机制的优化。React16之前的版本，更新组件会一直占用主线程，如果组件树过大，则可能会导致浏览器失去响应。在React16中加入的fiber可以将同步任务拆解，每次执行完一小片后，都会把控制权交还给react负责任务调度的模块，如果有优先级更高的任务，就先执行高优先级的任务。</p>\n<h5 id=\"拆什么\"><a href=\"#拆什么\" class=\"headerlink\" title=\"拆什么\"></a>拆什么</h5><p>首先，看React的渲染，包括两个阶段：调度阶段(reconciliation)和渲染阶段(commit)。</p>\n<ul>\n<li>调度阶段react根据数据更新virtual DOM，再运用diff算法找到需要VDOM change。这一部分的工作是可以拆分的。</li>\n<li>渲染阶段根据计算出的所有diff去一次性更新真实的DOM。<br>组件比较庞大时，diff运算会比较耗时，不可控，所以需要拆分的是调度阶段。</li>\n</ul>\n<h5 id=\"怎么拆\"><a href=\"#怎么拆\" class=\"headerlink\" title=\"怎么拆\"></a>怎么拆</h5><p>fiber tree的部分结构如下所示，将简单的数结构，变成了基于单链表的树结构。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    alternate: Fiber|null, //在fiber更新时克隆出的镜像fiber，对fiber的修改会标记在这个fiber上</span><br><span class=\"line\">    nextEffect: Fiber | null, // 单链表结构，方便遍历 Fiber Tree 上有副作用的节点</span><br><span class=\"line\">    pendingWorkPriority: PriorityLevel, // 标记子树上待更新任务的优先级</span><br><span class=\"line\"></span><br><span class=\"line\">    stateNode: any, // 管理 instance 自身的特性</span><br><span class=\"line\">    return: Fiber|null, // 指向 Fiber Tree 中的父节点</span><br><span class=\"line\">    child: Fiber|null, // 指向第一个子节点</span><br><span class=\"line\">    sibling: Fiber|null, // 指向兄弟节点</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h5><p>因为是单链表(A → B → C)的结构，所以在每次执行到某个节点(A → B)被中断后，下次可以从该节点(B → C)接着执行。<br>requestIdleCallback会让一个低优先级的任务在空闲期被调用，而requestAnimationFrame会让一个高优先级的任务在下一个栈帧被调用，从而保证了主线程按照优先级执行 fiber 单元。</p>\n<blockquote>\n<p>优先级顺序为：文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务。</p>\n</blockquote>\n<p>因为react fiber机制，一个任务很可能执行到一半就被其他优先级更高的任务所替代，或者因为时间原因而被终止。当再次执行这个任务时，是从头开始执行一遍，就会导致组件的某些 will 生命周期可能被多次调用而影响性能。</p>\n<p>REFs:</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5bca74cfe51d450e9163351b\" target=\"_blank\" rel=\"noopener\">[译]以面试官的角度来看React工作面试</a></li>\n<li><a href=\"https://juejin.im/post/5be969656fb9a049ad76931f\" target=\"_blank\" rel=\"noopener\">浅析 React Fiber</a></li>\n<li><a href=\"https://tech.youzan.com/react-fiber/\" target=\"_blank\" rel=\"noopener\">浅谈React 16中的Fiber机制</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是JSX-——浏览器是如何识别它的？\"><a href=\"#什么是JSX-——浏览器是如何识别它的？\" class=\"headerlink\" title=\"什么是JSX?——浏览器是如何识别它的？\"></a>什么是JSX?——浏览器是如何识别它的？</h3><p>JSX是facebook普及的一种标记语言，通过babel/TSC等工具会编译为<code>React.createElement</code>function。所以在React每个组件中，虽然没有显式用到React，但都需要<code>import React from &#39;react&#39;</code>。</p>\n<h4 id=\"JSX是如何区分React-Component和HTML元素的？\"><a href=\"#JSX是如何区分React-Component和HTML元素的？\" class=\"headerlink\" title=\"JSX是如何区分React Component和HTML元素的？\"></a>JSX是如何区分React Component和HTML元素的？</h4><p>通过元素首字母的大小写，如果首字母大写，则认为是React组件，小写的话则会被认为是HTML元素。可以在<a href=\"https://babeljs.io/repl/#?presets=react&amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA\" target=\"_blank\" rel=\"noopener\">online Babel compiler</a>中试一下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after babel compiler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> React.createElement(</span><br><span class=\"line\">    <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Hello world!\"</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// after babel compiler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> React.createElement(</span><br><span class=\"line\">    Div,</span><br><span class=\"line\">    <span class=\"literal\">null</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Hello world!\"</span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，把一个组件赋给<code>this.component</code>并且写<code>&lt;this.component /&gt;</code>也会起作用。</p>\n<h3 id=\"react16生命周期\"><a href=\"#react16生命周期\" class=\"headerlink\" title=\"react16生命周期\"></a>react16生命周期</h3><h4 id=\"Mounting\"><a href=\"#Mounting\" class=\"headerlink\" title=\"Mounting\"></a>Mounting</h4><ul>\n<li>constructor()</li>\n<li>static getDerivedStateFromProps()</li>\n<li>render()</li>\n<li>componentDidMount</li>\n</ul>\n<p>不建议使用<code>UNSAFE_componentWillMount()</code></p>\n<h4 id=\"Updating\"><a href=\"#Updating\" class=\"headerlink\" title=\"Updating\"></a>Updating</h4><ul>\n<li>static getDerivedStateFromProps()</li>\n<li>shouldComponentUpdate()</li>\n<li>render()</li>\n<li>getSnapshotBeforeUpdate()</li>\n<li>componentDidUpdate()</li>\n</ul>\n<p>不建议使用<code>UNSAFE_componentWillReceiveProps()</code>和<code>UNSAFE_componentWillUpdate()</code><br><code>UNSAFE_componentWillReceiveProps()</code>经常会带来bug和不一致的问题。</p>\n<h4 id=\"Unmounting\"><a href=\"#Unmounting\" class=\"headerlink\" title=\"Unmounting\"></a>Unmounting</h4><ul>\n<li>componentWillUnmount()</li>\n</ul>\n<p><code>getDerivedStateFromProps(props, state)</code>每次render之前都会被触发，与<code>componentWillReceiveProps</code>只在父组件rerender时会触发不一样。此外，<code>getDerivedStateFromProps</code>方法不建议经常使用，使用前想一想是否有替代方案。</p>\n<h3 id=\"加分题：数据获取为什么用-componentDidMount-而不是-constructor？\"><a href=\"#加分题：数据获取为什么用-componentDidMount-而不是-constructor？\" class=\"headerlink\" title=\"加分题：数据获取为什么用 componentDidMount 而不是 constructor？\"></a>加分题：数据获取为什么用 componentDidMount 而不是 constructor？</h3><p>你希望听到的两个原因会是：“在渲染发生之前数据不会存在” —— 虽然不是主要原因，但它向您显示该人员了解组件的处理方式; “在 React Fiber 中使用新的异步渲染……” —— 有人一直在努力学习。</p>\n<ul>\n<li>r1: SSR模式下，componentWillMount在server端也是会被调用的，内容返回到client端后，componentWillMount会被第二次调用，如果在componentWillMount中处理数据获取则会被调用两次。</li>\n<li>r2: 在componentWillMount中调用setState不会触发rerender，所以一般不会被用来获取数据。</li>\n<li>r3: React16之后采用了Fiber架构，类似ComponentWillMount的生命周期钩子都有可能执行多次，所以不在这些生命周期中做有副作用的操作，比如请求数据。</li>\n<li>r4: constructor用来初始化组件，作用应该保持纯粹，不应该引入数据获取这种有副作用的操作。</li>\n</ul>\n<h4 id=\"react-fiber纤程\"><a href=\"#react-fiber纤程\" class=\"headerlink\" title=\"react fiber纤程\"></a>react fiber纤程</h4><p>fiber是纤程颗粒化的概念，一个线程可以包含多个Fiber，主要是对react更新机制的优化。React16之前的版本，更新组件会一直占用主线程，如果组件树过大，则可能会导致浏览器失去响应。在React16中加入的fiber可以将同步任务拆解，每次执行完一小片后，都会把控制权交还给react负责任务调度的模块，如果有优先级更高的任务，就先执行高优先级的任务。</p>\n<h5 id=\"拆什么\"><a href=\"#拆什么\" class=\"headerlink\" title=\"拆什么\"></a>拆什么</h5><p>首先，看React的渲染，包括两个阶段：调度阶段(reconciliation)和渲染阶段(commit)。</p>\n<ul>\n<li>调度阶段react根据数据更新virtual DOM，再运用diff算法找到需要VDOM change。这一部分的工作是可以拆分的。</li>\n<li>渲染阶段根据计算出的所有diff去一次性更新真实的DOM。<br>组件比较庞大时，diff运算会比较耗时，不可控，所以需要拆分的是调度阶段。</li>\n</ul>\n<h5 id=\"怎么拆\"><a href=\"#怎么拆\" class=\"headerlink\" title=\"怎么拆\"></a>怎么拆</h5><p>fiber tree的部分结构如下所示，将简单的数结构，变成了基于单链表的树结构。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    alternate: Fiber|null, //在fiber更新时克隆出的镜像fiber，对fiber的修改会标记在这个fiber上</span><br><span class=\"line\">    nextEffect: Fiber | null, // 单链表结构，方便遍历 Fiber Tree 上有副作用的节点</span><br><span class=\"line\">    pendingWorkPriority: PriorityLevel, // 标记子树上待更新任务的优先级</span><br><span class=\"line\"></span><br><span class=\"line\">    stateNode: any, // 管理 instance 自身的特性</span><br><span class=\"line\">    return: Fiber|null, // 指向 Fiber Tree 中的父节点</span><br><span class=\"line\">    child: Fiber|null, // 指向第一个子节点</span><br><span class=\"line\">    sibling: Fiber|null, // 指向兄弟节点</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h5><p>因为是单链表(A → B → C)的结构，所以在每次执行到某个节点(A → B)被中断后，下次可以从该节点(B → C)接着执行。<br>requestIdleCallback会让一个低优先级的任务在空闲期被调用，而requestAnimationFrame会让一个高优先级的任务在下一个栈帧被调用，从而保证了主线程按照优先级执行 fiber 单元。</p>\n<blockquote>\n<p>优先级顺序为：文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务。</p>\n</blockquote>\n<p>因为react fiber机制，一个任务很可能执行到一半就被其他优先级更高的任务所替代，或者因为时间原因而被终止。当再次执行这个任务时，是从头开始执行一遍，就会导致组件的某些 will 生命周期可能被多次调用而影响性能。</p>\n<p>REFs:</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5bca74cfe51d450e9163351b\" target=\"_blank\" rel=\"noopener\">[译]以面试官的角度来看React工作面试</a></li>\n<li><a href=\"https://juejin.im/post/5be969656fb9a049ad76931f\" target=\"_blank\" rel=\"noopener\">浅析 React Fiber</a></li>\n<li><a href=\"https://tech.youzan.com/react-fiber/\" target=\"_blank\" rel=\"noopener\">浅谈React 16中的Fiber机制</a></li>\n</ul>\n"},{"title":"reading-record","date":"2019-03-18T02:49:49.000Z","_content":"\n## [你的Tree-Shaking并没什么卵用](https://juejin.im/post/5a5652d8f265da3e497ff3de#comment)\n> Tree-Shaking的原理\n> - ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。\n> - 分析程序流，判断哪些变量未被使用、引用，进而删除此代码\n\n但现实比较骨感，es6的代码经过babel和webpack编译打包后，产生的副作用(可能会改变外部变量)导致多余的代码并未被删掉。\nbabel6在编译的时候，会调用_createClass方法，使用Object.defineProperty去定义类里面的方法，原因是因为在es6的特性中，类里面声明的方法是不可枚举的。所以设置`{ \"loose\": false }`宽松模式，让babel编译的时候不必去严格遵循es6的特性。\n此外，UglifyJS不会进行程序流分析，所以在压缩的时候无法排除掉可能有副作用的代码，所以这部分代码还是会被打包进去。\n使用babel6/webpack打包可以考虑结合使用`BabelMinifyWebpackPlugin`，思路是先进行uglifyJS代码压缩，再去编译。\n> 评论中指出：关于Person和Apple阐述Babel副作用的例子在Babel升级到Babel7之后确实已经不存在了，使用Babel7的正式版和Webpack4亲测。\n\n## [http2.0 相比 1.0有哪些重大改进？](https://www.zhihu.com/question/34074946)\n1. 多路复用\n多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。\n在http1.0和1.1协议下，浏览器在同一时间针对同一域名下的请求有一定数量的限制。不同浏览器限制的数量不一样。\n\n2. 二进制分帧\nhttp2.0在应用层和传输层之间增加了一个二进制分帧层，在该层中，会将传输信息分割成更小的消息和帧。将http1.x的头部信息封装在到了HEADER frame，相应的Request Body封装到DATA frame中。\nhttp2.0让所有数据流共用一个连接，有效地使用TCP连接，减少服务端的链接压力，内存占用更少，实现高带宽。\n此外，减少了TCP慢启动的时间。\n\n3. 首部压缩\n支持首部压缩，使用了HPACK算法。\n\n4. 服务端推送\n服务器可以向客户端推送可能需要的资源，对\b一个请求发送多个响应。\n> 「如果客户端早已在缓存中有了一份 copy 怎么办？」\n> 一个推荐的解决方案是，客户端使用一个简洁的 Cache Digest 来告诉服务器，哪些已经在缓存中存在。\n\n5. 设置资源的优先级\n浏览器可以一次请求多个资源，指定一些优先级信息来帮助确定应该如何处理这些资源，然后等待服务器发回所有数据，而不是一次请求一个。如果浏览器和服务器都支持优先级，则应使用浏览器指定的规则并使用所有可用带宽来传递资源，而不会有资源之间的相互竞争。\n\n支持http2.0的前提是使用了SSL/TLS9(安全传输层协议)，如果网站没有使用SSL/TLS，接入http2.0协议带来的性能提升大致可以被TLS带来的性能损耗所抵消。\nhttps://www.mnot.net/talks/h2fe/\nhttps://www.w3ctech.com/topic/1563#tip7sharding\nhttps://juejin.im/post/5c1d9b8ae51d4559746922de\n\n## xss攻击\n例如：http://xxx/search?keyword=\"><script>alert('XSS');</script> \n``` html\n<input type=\"text\" value=\"<%= getParameter(\"keyword\") %>\">\n\n// 参数拼接后\n<input type=\"text\" value=\"\"><script>alert('XSS');</script>\">\n```\n跨站脚本攻击（Cross-site scripting），分为存储型(存储到数据库中)、反射型(网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器)和Dom型(前端浏览器拼接并执行)，需要前端处理的是Dom型。\n预防：\n- 合适的HTML转义，完善的转义库需要针对上下文制定多种规则，例如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等等\n- 利用模板引擎 开启模板引擎自带的 HTML 转义功能\n- 避免内联事件 尽量不要使用 onLoad=\"onload('{{data}}')\"\n- 避免拼接 HTML\n- 时刻保持警惕 在插入位置为 DOM 属性、链接等位置时\n- 增加攻击难度，降低攻击后果 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果\n- 主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞\n \n可以手动拼接字符串`jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>\\x3e`去检查\n\n## position:fixed\nposition:fixed 的元素将相对于屏幕视口（viewport）的位置来指定其位置。并且元素的位置在屏幕滚动时不会改变。\n**但是当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。**\n设置为position:fixed的元素，如果存在transform为非none的元素祖先时，会相对该元素去进行定位。因为transform设置为非none时，会创建一个堆叠上下文和包含块，会影响子元素的固定定位。\n不是所有的创建新的堆叠上下文都被影响fixed定位，在最新的Chrome浏览器下，只有下面3种还会影响：\n- 设置了 transform-style: preserve-3d 的元素\n- perspective 值不为 none 的元素\n- 在 will-change 中指定了任意 CSS 属性\n但不同浏览器表现不同，所以要具体问题具体分析。\n\n\n## vm wh\n显示器宽度: screen.width\n浏览器宽度: window.outerWidth\n网页宽度: window.innerWidth\n\nwm wh是相对与网页的宽高的，网页的宽为100vm，网页的高度为100vh","source":"_posts/reading-record.md","raw":"---\ntitle: reading-record\ndate: 2019-03-18 10:49:49\ntags:\n---\n\n## [你的Tree-Shaking并没什么卵用](https://juejin.im/post/5a5652d8f265da3e497ff3de#comment)\n> Tree-Shaking的原理\n> - ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。\n> - 分析程序流，判断哪些变量未被使用、引用，进而删除此代码\n\n但现实比较骨感，es6的代码经过babel和webpack编译打包后，产生的副作用(可能会改变外部变量)导致多余的代码并未被删掉。\nbabel6在编译的时候，会调用_createClass方法，使用Object.defineProperty去定义类里面的方法，原因是因为在es6的特性中，类里面声明的方法是不可枚举的。所以设置`{ \"loose\": false }`宽松模式，让babel编译的时候不必去严格遵循es6的特性。\n此外，UglifyJS不会进行程序流分析，所以在压缩的时候无法排除掉可能有副作用的代码，所以这部分代码还是会被打包进去。\n使用babel6/webpack打包可以考虑结合使用`BabelMinifyWebpackPlugin`，思路是先进行uglifyJS代码压缩，再去编译。\n> 评论中指出：关于Person和Apple阐述Babel副作用的例子在Babel升级到Babel7之后确实已经不存在了，使用Babel7的正式版和Webpack4亲测。\n\n## [http2.0 相比 1.0有哪些重大改进？](https://www.zhihu.com/question/34074946)\n1. 多路复用\n多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。\n在http1.0和1.1协议下，浏览器在同一时间针对同一域名下的请求有一定数量的限制。不同浏览器限制的数量不一样。\n\n2. 二进制分帧\nhttp2.0在应用层和传输层之间增加了一个二进制分帧层，在该层中，会将传输信息分割成更小的消息和帧。将http1.x的头部信息封装在到了HEADER frame，相应的Request Body封装到DATA frame中。\nhttp2.0让所有数据流共用一个连接，有效地使用TCP连接，减少服务端的链接压力，内存占用更少，实现高带宽。\n此外，减少了TCP慢启动的时间。\n\n3. 首部压缩\n支持首部压缩，使用了HPACK算法。\n\n4. 服务端推送\n服务器可以向客户端推送可能需要的资源，对\b一个请求发送多个响应。\n> 「如果客户端早已在缓存中有了一份 copy 怎么办？」\n> 一个推荐的解决方案是，客户端使用一个简洁的 Cache Digest 来告诉服务器，哪些已经在缓存中存在。\n\n5. 设置资源的优先级\n浏览器可以一次请求多个资源，指定一些优先级信息来帮助确定应该如何处理这些资源，然后等待服务器发回所有数据，而不是一次请求一个。如果浏览器和服务器都支持优先级，则应使用浏览器指定的规则并使用所有可用带宽来传递资源，而不会有资源之间的相互竞争。\n\n支持http2.0的前提是使用了SSL/TLS9(安全传输层协议)，如果网站没有使用SSL/TLS，接入http2.0协议带来的性能提升大致可以被TLS带来的性能损耗所抵消。\nhttps://www.mnot.net/talks/h2fe/\nhttps://www.w3ctech.com/topic/1563#tip7sharding\nhttps://juejin.im/post/5c1d9b8ae51d4559746922de\n\n## xss攻击\n例如：http://xxx/search?keyword=\"><script>alert('XSS');</script> \n``` html\n<input type=\"text\" value=\"<%= getParameter(\"keyword\") %>\">\n\n// 参数拼接后\n<input type=\"text\" value=\"\"><script>alert('XSS');</script>\">\n```\n跨站脚本攻击（Cross-site scripting），分为存储型(存储到数据库中)、反射型(网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器)和Dom型(前端浏览器拼接并执行)，需要前端处理的是Dom型。\n预防：\n- 合适的HTML转义，完善的转义库需要针对上下文制定多种规则，例如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等等\n- 利用模板引擎 开启模板引擎自带的 HTML 转义功能\n- 避免内联事件 尽量不要使用 onLoad=\"onload('{{data}}')\"\n- 避免拼接 HTML\n- 时刻保持警惕 在插入位置为 DOM 属性、链接等位置时\n- 增加攻击难度，降低攻击后果 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果\n- 主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞\n \n可以手动拼接字符串`jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>\\x3e`去检查\n\n## position:fixed\nposition:fixed 的元素将相对于屏幕视口（viewport）的位置来指定其位置。并且元素的位置在屏幕滚动时不会改变。\n**但是当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。**\n设置为position:fixed的元素，如果存在transform为非none的元素祖先时，会相对该元素去进行定位。因为transform设置为非none时，会创建一个堆叠上下文和包含块，会影响子元素的固定定位。\n不是所有的创建新的堆叠上下文都被影响fixed定位，在最新的Chrome浏览器下，只有下面3种还会影响：\n- 设置了 transform-style: preserve-3d 的元素\n- perspective 值不为 none 的元素\n- 在 will-change 中指定了任意 CSS 属性\n但不同浏览器表现不同，所以要具体问题具体分析。\n\n\n## vm wh\n显示器宽度: screen.width\n浏览器宽度: window.outerWidth\n网页宽度: window.innerWidth\n\nwm wh是相对与网页的宽高的，网页的宽为100vm，网页的高度为100vh","slug":"reading-record","published":1,"updated":"2019-03-22T08:57:56.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6u000vqmhfsxy9dre1","content":"<h2 id=\"你的Tree-Shaking并没什么卵用\"><a href=\"#你的Tree-Shaking并没什么卵用\" class=\"headerlink\" title=\"你的Tree-Shaking并没什么卵用\"></a><a href=\"https://juejin.im/post/5a5652d8f265da3e497ff3de#comment\" target=\"_blank\" rel=\"noopener\">你的Tree-Shaking并没什么卵用</a></h2><blockquote>\n<p>Tree-Shaking的原理</p>\n<ul>\n<li>ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。</li>\n<li>分析程序流，判断哪些变量未被使用、引用，进而删除此代码</li>\n</ul>\n</blockquote>\n<p>但现实比较骨感，es6的代码经过babel和webpack编译打包后，产生的副作用(可能会改变外部变量)导致多余的代码并未被删掉。<br>babel6在编译的时候，会调用_createClass方法，使用Object.defineProperty去定义类里面的方法，原因是因为在es6的特性中，类里面声明的方法是不可枚举的。所以设置<code>{ &quot;loose&quot;: false }</code>宽松模式，让babel编译的时候不必去严格遵循es6的特性。<br>此外，UglifyJS不会进行程序流分析，所以在压缩的时候无法排除掉可能有副作用的代码，所以这部分代码还是会被打包进去。<br>使用babel6/webpack打包可以考虑结合使用<code>BabelMinifyWebpackPlugin</code>，思路是先进行uglifyJS代码压缩，再去编译。</p>\n<blockquote>\n<p>评论中指出：关于Person和Apple阐述Babel副作用的例子在Babel升级到Babel7之后确实已经不存在了，使用Babel7的正式版和Webpack4亲测。</p>\n</blockquote>\n<h2 id=\"http2-0-相比-1-0有哪些重大改进？\"><a href=\"#http2-0-相比-1-0有哪些重大改进？\" class=\"headerlink\" title=\"http2.0 相比 1.0有哪些重大改进？\"></a><a href=\"https://www.zhihu.com/question/34074946\" target=\"_blank\" rel=\"noopener\">http2.0 相比 1.0有哪些重大改进？</a></h2><ol>\n<li><p>多路复用<br>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。<br>在http1.0和1.1协议下，浏览器在同一时间针对同一域名下的请求有一定数量的限制。不同浏览器限制的数量不一样。</p>\n</li>\n<li><p>二进制分帧<br>http2.0在应用层和传输层之间增加了一个二进制分帧层，在该层中，会将传输信息分割成更小的消息和帧。将http1.x的头部信息封装在到了HEADER frame，相应的Request Body封装到DATA frame中。<br>http2.0让所有数据流共用一个连接，有效地使用TCP连接，减少服务端的链接压力，内存占用更少，实现高带宽。<br>此外，减少了TCP慢启动的时间。</p>\n</li>\n<li><p>首部压缩<br>支持首部压缩，使用了HPACK算法。</p>\n</li>\n<li><p>服务端推送<br>服务器可以向客户端推送可能需要的资源，对\b一个请求发送多个响应。</p>\n<blockquote>\n<p>「如果客户端早已在缓存中有了一份 copy 怎么办？」<br>一个推荐的解决方案是，客户端使用一个简洁的 Cache Digest 来告诉服务器，哪些已经在缓存中存在。</p>\n</blockquote>\n</li>\n<li><p>设置资源的优先级<br>浏览器可以一次请求多个资源，指定一些优先级信息来帮助确定应该如何处理这些资源，然后等待服务器发回所有数据，而不是一次请求一个。如果浏览器和服务器都支持优先级，则应使用浏览器指定的规则并使用所有可用带宽来传递资源，而不会有资源之间的相互竞争。</p>\n</li>\n</ol>\n<p>支持http2.0的前提是使用了SSL/TLS9(安全传输层协议)，如果网站没有使用SSL/TLS，接入http2.0协议带来的性能提升大致可以被TLS带来的性能损耗所抵消。<br><a href=\"https://www.mnot.net/talks/h2fe/\" target=\"_blank\" rel=\"noopener\">https://www.mnot.net/talks/h2fe/</a><br><a href=\"https://www.w3ctech.com/topic/1563#tip7sharding\" target=\"_blank\" rel=\"noopener\">https://www.w3ctech.com/topic/1563#tip7sharding</a><br><a href=\"https://juejin.im/post/5c1d9b8ae51d4559746922de\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c1d9b8ae51d4559746922de</a></p>\n<h2 id=\"xss攻击\"><a href=\"#xss攻击\" class=\"headerlink\" title=\"xss攻击\"></a>xss攻击</h2><p>例如：<a href=\"http://xxx/search?keyword=&quot;&gt;\" target=\"_blank\" rel=\"noopener\">http://xxx/search?keyword=&quot;&gt;</a><script>alert(‘XSS’);</script><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"&lt;%= getParameter(\"</span><span class=\"attr\">keyword</span>\") %&gt;</span>\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 参数拼接后</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\">alert(<span class=\"string\">'XSS'</span>);</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\"&gt;</span><br></pre></td></tr></table></figure></p>\n<p>跨站脚本攻击（Cross-site scripting），分为存储型(存储到数据库中)、反射型(网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器)和Dom型(前端浏览器拼接并执行)，需要前端处理的是Dom型。<br>预防：</p>\n<ul>\n<li>合适的HTML转义，完善的转义库需要针对上下文制定多种规则，例如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等等</li>\n<li>利用模板引擎 开启模板引擎自带的 HTML 转义功能</li>\n<li>避免内联事件 尽量不要使用 onLoad=”onload(‘‘)”</li>\n<li>避免拼接 HTML</li>\n<li>时刻保持警惕 在插入位置为 DOM 属性、链接等位置时</li>\n<li>增加攻击难度，降低攻击后果 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果</li>\n<li>主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞</li>\n</ul>\n<p>可以手动拼接字符串<code>jaVasCript:/*-/*</code>/<em>`/</em>‘/<em>“/**/(/</em> */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/–!&gt;\\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\\x3e`去检查</p>\n<h2 id=\"position-fixed\"><a href=\"#position-fixed\" class=\"headerlink\" title=\"position:fixed\"></a>position:fixed</h2><p>position:fixed 的元素将相对于屏幕视口（viewport）的位置来指定其位置。并且元素的位置在屏幕滚动时不会改变。<br><strong>但是当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。</strong><br>设置为position:fixed的元素，如果存在transform为非none的元素祖先时，会相对该元素去进行定位。因为transform设置为非none时，会创建一个堆叠上下文和包含块，会影响子元素的固定定位。<br>不是所有的创建新的堆叠上下文都被影响fixed定位，在最新的Chrome浏览器下，只有下面3种还会影响：</p>\n<ul>\n<li>设置了 transform-style: preserve-3d 的元素</li>\n<li>perspective 值不为 none 的元素</li>\n<li>在 will-change 中指定了任意 CSS 属性<br>但不同浏览器表现不同，所以要具体问题具体分析。</li>\n</ul>\n<h2 id=\"vm-wh\"><a href=\"#vm-wh\" class=\"headerlink\" title=\"vm wh\"></a>vm wh</h2><p>显示器宽度: screen.width<br>浏览器宽度: window.outerWidth<br>网页宽度: window.innerWidth</p>\n<p>wm wh是相对与网页的宽高的，网页的宽为100vm，网页的高度为100vh</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"你的Tree-Shaking并没什么卵用\"><a href=\"#你的Tree-Shaking并没什么卵用\" class=\"headerlink\" title=\"你的Tree-Shaking并没什么卵用\"></a><a href=\"https://juejin.im/post/5a5652d8f265da3e497ff3de#comment\" target=\"_blank\" rel=\"noopener\">你的Tree-Shaking并没什么卵用</a></h2><blockquote>\n<p>Tree-Shaking的原理</p>\n<ul>\n<li>ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。</li>\n<li>分析程序流，判断哪些变量未被使用、引用，进而删除此代码</li>\n</ul>\n</blockquote>\n<p>但现实比较骨感，es6的代码经过babel和webpack编译打包后，产生的副作用(可能会改变外部变量)导致多余的代码并未被删掉。<br>babel6在编译的时候，会调用_createClass方法，使用Object.defineProperty去定义类里面的方法，原因是因为在es6的特性中，类里面声明的方法是不可枚举的。所以设置<code>{ &quot;loose&quot;: false }</code>宽松模式，让babel编译的时候不必去严格遵循es6的特性。<br>此外，UglifyJS不会进行程序流分析，所以在压缩的时候无法排除掉可能有副作用的代码，所以这部分代码还是会被打包进去。<br>使用babel6/webpack打包可以考虑结合使用<code>BabelMinifyWebpackPlugin</code>，思路是先进行uglifyJS代码压缩，再去编译。</p>\n<blockquote>\n<p>评论中指出：关于Person和Apple阐述Babel副作用的例子在Babel升级到Babel7之后确实已经不存在了，使用Babel7的正式版和Webpack4亲测。</p>\n</blockquote>\n<h2 id=\"http2-0-相比-1-0有哪些重大改进？\"><a href=\"#http2-0-相比-1-0有哪些重大改进？\" class=\"headerlink\" title=\"http2.0 相比 1.0有哪些重大改进？\"></a><a href=\"https://www.zhihu.com/question/34074946\" target=\"_blank\" rel=\"noopener\">http2.0 相比 1.0有哪些重大改进？</a></h2><ol>\n<li><p>多路复用<br>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。<br>在http1.0和1.1协议下，浏览器在同一时间针对同一域名下的请求有一定数量的限制。不同浏览器限制的数量不一样。</p>\n</li>\n<li><p>二进制分帧<br>http2.0在应用层和传输层之间增加了一个二进制分帧层，在该层中，会将传输信息分割成更小的消息和帧。将http1.x的头部信息封装在到了HEADER frame，相应的Request Body封装到DATA frame中。<br>http2.0让所有数据流共用一个连接，有效地使用TCP连接，减少服务端的链接压力，内存占用更少，实现高带宽。<br>此外，减少了TCP慢启动的时间。</p>\n</li>\n<li><p>首部压缩<br>支持首部压缩，使用了HPACK算法。</p>\n</li>\n<li><p>服务端推送<br>服务器可以向客户端推送可能需要的资源，对\b一个请求发送多个响应。</p>\n<blockquote>\n<p>「如果客户端早已在缓存中有了一份 copy 怎么办？」<br>一个推荐的解决方案是，客户端使用一个简洁的 Cache Digest 来告诉服务器，哪些已经在缓存中存在。</p>\n</blockquote>\n</li>\n<li><p>设置资源的优先级<br>浏览器可以一次请求多个资源，指定一些优先级信息来帮助确定应该如何处理这些资源，然后等待服务器发回所有数据，而不是一次请求一个。如果浏览器和服务器都支持优先级，则应使用浏览器指定的规则并使用所有可用带宽来传递资源，而不会有资源之间的相互竞争。</p>\n</li>\n</ol>\n<p>支持http2.0的前提是使用了SSL/TLS9(安全传输层协议)，如果网站没有使用SSL/TLS，接入http2.0协议带来的性能提升大致可以被TLS带来的性能损耗所抵消。<br><a href=\"https://www.mnot.net/talks/h2fe/\" target=\"_blank\" rel=\"noopener\">https://www.mnot.net/talks/h2fe/</a><br><a href=\"https://www.w3ctech.com/topic/1563#tip7sharding\" target=\"_blank\" rel=\"noopener\">https://www.w3ctech.com/topic/1563#tip7sharding</a><br><a href=\"https://juejin.im/post/5c1d9b8ae51d4559746922de\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5c1d9b8ae51d4559746922de</a></p>\n<h2 id=\"xss攻击\"><a href=\"#xss攻击\" class=\"headerlink\" title=\"xss攻击\"></a>xss攻击</h2><p>例如：<a href=\"http://xxx/search?keyword=&quot;&gt;\" target=\"_blank\" rel=\"noopener\">http://xxx/search?keyword=&quot;&gt;</a><script>alert(‘XSS’);</script><br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"&lt;%= getParameter(\"</span><span class=\"attr\">keyword</span>\") %&gt;</span>\"&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 参数拼接后</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\">alert(<span class=\"string\">'XSS'</span>);</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\"&gt;</span><br></pre></td></tr></table></figure></p>\n<p>跨站脚本攻击（Cross-site scripting），分为存储型(存储到数据库中)、反射型(网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器)和Dom型(前端浏览器拼接并执行)，需要前端处理的是Dom型。<br>预防：</p>\n<ul>\n<li>合适的HTML转义，完善的转义库需要针对上下文制定多种规则，例如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等等</li>\n<li>利用模板引擎 开启模板引擎自带的 HTML 转义功能</li>\n<li>避免内联事件 尽量不要使用 onLoad=”onload(‘‘)”</li>\n<li>避免拼接 HTML</li>\n<li>时刻保持警惕 在插入位置为 DOM 属性、链接等位置时</li>\n<li>增加攻击难度，降低攻击后果 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果</li>\n<li>主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞</li>\n</ul>\n<p>可以手动拼接字符串<code>jaVasCript:/*-/*</code>/<em>`/</em>‘/<em>“/**/(/</em> */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/–!&gt;\\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\\x3e`去检查</p>\n<h2 id=\"position-fixed\"><a href=\"#position-fixed\" class=\"headerlink\" title=\"position:fixed\"></a>position:fixed</h2><p>position:fixed 的元素将相对于屏幕视口（viewport）的位置来指定其位置。并且元素的位置在屏幕滚动时不会改变。<br><strong>但是当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。</strong><br>设置为position:fixed的元素，如果存在transform为非none的元素祖先时，会相对该元素去进行定位。因为transform设置为非none时，会创建一个堆叠上下文和包含块，会影响子元素的固定定位。<br>不是所有的创建新的堆叠上下文都被影响fixed定位，在最新的Chrome浏览器下，只有下面3种还会影响：</p>\n<ul>\n<li>设置了 transform-style: preserve-3d 的元素</li>\n<li>perspective 值不为 none 的元素</li>\n<li>在 will-change 中指定了任意 CSS 属性<br>但不同浏览器表现不同，所以要具体问题具体分析。</li>\n</ul>\n<h2 id=\"vm-wh\"><a href=\"#vm-wh\" class=\"headerlink\" title=\"vm wh\"></a>vm wh</h2><p>显示器宽度: screen.width<br>浏览器宽度: window.outerWidth<br>网页宽度: window.innerWidth</p>\n<p>wm wh是相对与网页的宽高的，网页的宽为100vm，网页的高度为100vh</p>\n"},{"title":"webpack配置","date":"2017-06-27T07:06:13.000Z","_content":"\n### dll动态链接库优化打包\n为dll单独配置一个webpack.dll.config.js文件，在entry中引入你要打包到vendor的模块，通常是一些通用的不涉及业务的库。\n``` javascript\nvar webpack = require('webpack');\n\nmodule.exports = {\n    entry: {vendor: ['react', 'react-dom']},\n    output: {\n        path: './dist',\n        filename: '[name].bundle.js',\n        library: '[name]'\n    },\n    plugins:[\n        new webpack.DllPlugin({\n            path: './dist/[name]-manifest.json',\n            name: '[name]',\n            context: __dirname,\n        })\n    ]\n}\n```\n**webpack.DllPlugin**的选项中，path是manifest文件的输出路径；name是dll暴露的对象名，要跟output.library保持一致。执行`webpack --config webpack.dll.config.js`后会在dist文件夹下面生成<font color=#F44336>vendor.manifest.json</font>和<font color=#F44336>vendor.bundle.js</font>。其中vendor.manifest.json长这样：\n\n``` javascript\n{\n  \"name\": \"vendor\",\n  \"content\": {\n    \"./node_modules/react/react.js\": 1,\n    \"./node_modules/react/lib/React.js\": 2,\n    \"./node_modules/process/browser.js\": 3,\n    \"./node_modules/object-assign/index.js\": 4,\n    \"./node_modules/react/lib/ReactBaseClasses.js\": 5,\n    \"./node_modules/react/lib/reactProdInvariant.js\": 6,\n    \"./node_modules/react/lib/ReactNoopUpdateQueue.js\": 7,\n    \"./node_modules/fbjs/lib/warning.js\": 8,\n    ......\n```\nwebpack将每个库进行了编号，之后dll user可以读取该文件，根据这个索引来引用。\n\n<!-- more -->\n\n之后，在webpack.config.js文件中添加DllReferencePlugin的插件配置。\n``` javascript\n    plugins:[\n        new webpack.DllReferencePlugin({\n            context: __dirname,//需要与webpack.dll.config.js中DllPlugin上下文一致\n            manifest: require('./dist/vendor-manifest.json')//DllPlugin输出的manifest.json文件\n        })\n    ]\n```\n配置完成后，每次业务逻辑的修改只需要执行`webpack --config webpack.config.js`，不需要重复对dll进行打包，可以节约打包时间。\n\n\n### 使用require.ensure分包\n``` javascript\n  require.ensure([/*预加载模块*/], function(require) {\n    const Promise = require('es6-promise').Promise;\n  }, 'promise');\n```\nwebpack会将es6-promise模块打包成promise.chunk.js(require.ensure的第三个参数和chunkFilename决定了打包后的文件名)。\n每个require.ensure会把前面数组里面的模块和内部require的模块都打包到一个文件内，异步加载。\n可以在ensure的[]数组中加入想要预加载的模块，也可以在function内部使用require.include对文件进行预加载。\n\n\n### webpack-dev-server热替换\n> webpack-dev-server 主要提供两个功能：\n- 为静态文件提供服务\n- 自动刷新和热替换(HMR)\n\nwebpack-dev-server提供了两种自动刷新模式：iframe和inline，默认模式是iframe。inline方式会将webpack-dev-server客户端加入到webpack入口文件的配置中，配置方式有CLI和NodeJs API两种。\n\n##### CLI方式\n```javascript\nwebpack-dev-server --env development --port=8081 --hot --inline\n```\n\n##### Node.js API方式\n手动将webpack-dev-server客户端配置到webpack打包的入口文件中\n修改文件webpack.config.dev.js，添加webpack/hot/dev-server，添加插件HotModuleReplacementPlugin：\n``` javascript\nvar webpack = require(\"webpack\");\nvar webpackBase = require(\"./webpack.config.base.js\");\n\n\nvar cfg = Object.assign(webpackBase, {\n    devtool: \"cheap-module-eval-source-map\"\n});\n\n//entry\nObject.getOwnPropertyNames((webpackBase.entry || {})).map(function (name) {\n    cfg.entry[name] = []\n        //添加HMR文件\n        .concat(\"webpack/hot/dev-server\")\n        .concat(\"webpack-dev-server/client?http://localhost:9390\")\n        .concat(webpackBase.entry[name])\n});\n\n//plugins\ncfg.plugins = (webpackBase.plugins || []).concat(\n    new webpack.optimize.OccurrenceOrderPlugin(),\n    //添加HMR插件\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin()\n)\n\nmodule.exports = cfg;\n```\n\n根目录添加文件devServer.js，用于创建服务器实例\n``` javascript\nvar path = require(\"path\");\nvar webpack = require(\"webpack\");\nvar webpackDevServer = require(\"webpack-dev-server\");\nvar webpackCfg = require(\"./webpack.config.dev.js\");\n\nvar compiler = webpack(webpackCfg);\n\n//init server\nvar app = new webpackDevServer(compiler, {\n    //注意此处publicPath必填\n    publicPath: webpackCfg.output.publicPath,\n    //HMR配置\n    hot:true\n});\n\napp.listen(9390, \"localhost\", function (err) {\n    if (err) {\n        console.log(err);\n    }\n});\n\nconsole.log(\"listen at http://localhost:9390\");\n```\n修改package.json中scripts配置，通过执行devServer.js文件启动服务器：\n``` javascript\n\"scripts\":{\n    \"start\":\"node devServer.js\"\n}\n```\n\n\n### 基础版webpack配置\n1. 开发环境下\n\n``` javascript\nvar webpack = require('webpack');\nvar path = require('path');\n\nmodule.exports = {\n    entry: {iread: \"./iread/src/index.js\",\n            icartoons: \"./icartoons/src/index.js\"},\n    output: {\n        path: \"./dist\", //资源文件引用的目录\n        publicPath: '../dist/',  //相对于html中,指定资源文件引用的目录\n        filename: \"[name].bundle.js\",\n        chunkFilename: '[name].chunk.js'\n    },\n    module: {\n        loaders: [\n            { test: path.resolve('./','lib/zepto.js'), loader: \"exports?window.$!script\" },\n            { test: /\\.css$/, loader: \"style-loader!css-loader\" },\n            { test: /\\.(png|jpg)$/, loader: \"url-loader\" },\n            { test: /.jsx?$/, loader: 'babel-loader',exclude: /node_modules/, query: { presets: ['es2015', 'react'] } }\n         ]\n    },\n    plugins:[\n        new webpack.ProvidePlugin({\n            $: path.resolve('./','lib/zepto.js')\n        }),\n        new webpack.DllReferencePlugin({\n            context: __dirname,//需要与webpack.dll.config.js中DllPlugin上下文一致\n            manifest: require('./dist/vendor-manifest.json')//DllPlugin输出的manifest.json文件\n        })\n    ]\n}\n```\n\n2. 生产环境下\n\n```javascript\nvar webpack = require('webpack');\nvar path = require('path');\n\nmodule.exports = {\n    entry: {iread: './iread/src/index.js',\n            icartoons: './icartoons/src/index.js'},\n    output: {\n        path: \"./dist\",\n        filename: \"[name].bundle.min.js\"\n    },\n    module: {\n        loaders: [\n            { test: path.resolve('./','lib/zepto.js'), loader: \"exports?window.$!script\" },\n            { test: /\\.css$/, loader: \"style-loader!css-loader\" },\n            { test: /\\.(png|jpg)$/, loader: \"url-loader\" },\n            { test: /.jsx?$/, loader: 'babel-loader',exclude: /node_modules/, query: { presets: ['es2015', 'react'] } }  \n         ]\n    },\n    plugins:[\n        new webpack.ProvidePlugin({\n            $: path.resolve('./','lib/zepto.js')\n        }),\n        new webpack.DefinePlugin({\n            'process.env': {\n              'NODE_ENV': JSON.stringify('production')\n            }\n        }),\n        new webpack.optimize.UglifyJsPlugin({\n          compress: {\n            warnings: false\n          }\n        })\n    ]\n}\n```\n","source":"_posts/webpack配置.md","raw":"---\ntitle: webpack配置\ndate: 2017-06-27 15:06:13\ntags: [webpack, 前端打包, require]\n---\n\n### dll动态链接库优化打包\n为dll单独配置一个webpack.dll.config.js文件，在entry中引入你要打包到vendor的模块，通常是一些通用的不涉及业务的库。\n``` javascript\nvar webpack = require('webpack');\n\nmodule.exports = {\n    entry: {vendor: ['react', 'react-dom']},\n    output: {\n        path: './dist',\n        filename: '[name].bundle.js',\n        library: '[name]'\n    },\n    plugins:[\n        new webpack.DllPlugin({\n            path: './dist/[name]-manifest.json',\n            name: '[name]',\n            context: __dirname,\n        })\n    ]\n}\n```\n**webpack.DllPlugin**的选项中，path是manifest文件的输出路径；name是dll暴露的对象名，要跟output.library保持一致。执行`webpack --config webpack.dll.config.js`后会在dist文件夹下面生成<font color=#F44336>vendor.manifest.json</font>和<font color=#F44336>vendor.bundle.js</font>。其中vendor.manifest.json长这样：\n\n``` javascript\n{\n  \"name\": \"vendor\",\n  \"content\": {\n    \"./node_modules/react/react.js\": 1,\n    \"./node_modules/react/lib/React.js\": 2,\n    \"./node_modules/process/browser.js\": 3,\n    \"./node_modules/object-assign/index.js\": 4,\n    \"./node_modules/react/lib/ReactBaseClasses.js\": 5,\n    \"./node_modules/react/lib/reactProdInvariant.js\": 6,\n    \"./node_modules/react/lib/ReactNoopUpdateQueue.js\": 7,\n    \"./node_modules/fbjs/lib/warning.js\": 8,\n    ......\n```\nwebpack将每个库进行了编号，之后dll user可以读取该文件，根据这个索引来引用。\n\n<!-- more -->\n\n之后，在webpack.config.js文件中添加DllReferencePlugin的插件配置。\n``` javascript\n    plugins:[\n        new webpack.DllReferencePlugin({\n            context: __dirname,//需要与webpack.dll.config.js中DllPlugin上下文一致\n            manifest: require('./dist/vendor-manifest.json')//DllPlugin输出的manifest.json文件\n        })\n    ]\n```\n配置完成后，每次业务逻辑的修改只需要执行`webpack --config webpack.config.js`，不需要重复对dll进行打包，可以节约打包时间。\n\n\n### 使用require.ensure分包\n``` javascript\n  require.ensure([/*预加载模块*/], function(require) {\n    const Promise = require('es6-promise').Promise;\n  }, 'promise');\n```\nwebpack会将es6-promise模块打包成promise.chunk.js(require.ensure的第三个参数和chunkFilename决定了打包后的文件名)。\n每个require.ensure会把前面数组里面的模块和内部require的模块都打包到一个文件内，异步加载。\n可以在ensure的[]数组中加入想要预加载的模块，也可以在function内部使用require.include对文件进行预加载。\n\n\n### webpack-dev-server热替换\n> webpack-dev-server 主要提供两个功能：\n- 为静态文件提供服务\n- 自动刷新和热替换(HMR)\n\nwebpack-dev-server提供了两种自动刷新模式：iframe和inline，默认模式是iframe。inline方式会将webpack-dev-server客户端加入到webpack入口文件的配置中，配置方式有CLI和NodeJs API两种。\n\n##### CLI方式\n```javascript\nwebpack-dev-server --env development --port=8081 --hot --inline\n```\n\n##### Node.js API方式\n手动将webpack-dev-server客户端配置到webpack打包的入口文件中\n修改文件webpack.config.dev.js，添加webpack/hot/dev-server，添加插件HotModuleReplacementPlugin：\n``` javascript\nvar webpack = require(\"webpack\");\nvar webpackBase = require(\"./webpack.config.base.js\");\n\n\nvar cfg = Object.assign(webpackBase, {\n    devtool: \"cheap-module-eval-source-map\"\n});\n\n//entry\nObject.getOwnPropertyNames((webpackBase.entry || {})).map(function (name) {\n    cfg.entry[name] = []\n        //添加HMR文件\n        .concat(\"webpack/hot/dev-server\")\n        .concat(\"webpack-dev-server/client?http://localhost:9390\")\n        .concat(webpackBase.entry[name])\n});\n\n//plugins\ncfg.plugins = (webpackBase.plugins || []).concat(\n    new webpack.optimize.OccurrenceOrderPlugin(),\n    //添加HMR插件\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NoErrorsPlugin()\n)\n\nmodule.exports = cfg;\n```\n\n根目录添加文件devServer.js，用于创建服务器实例\n``` javascript\nvar path = require(\"path\");\nvar webpack = require(\"webpack\");\nvar webpackDevServer = require(\"webpack-dev-server\");\nvar webpackCfg = require(\"./webpack.config.dev.js\");\n\nvar compiler = webpack(webpackCfg);\n\n//init server\nvar app = new webpackDevServer(compiler, {\n    //注意此处publicPath必填\n    publicPath: webpackCfg.output.publicPath,\n    //HMR配置\n    hot:true\n});\n\napp.listen(9390, \"localhost\", function (err) {\n    if (err) {\n        console.log(err);\n    }\n});\n\nconsole.log(\"listen at http://localhost:9390\");\n```\n修改package.json中scripts配置，通过执行devServer.js文件启动服务器：\n``` javascript\n\"scripts\":{\n    \"start\":\"node devServer.js\"\n}\n```\n\n\n### 基础版webpack配置\n1. 开发环境下\n\n``` javascript\nvar webpack = require('webpack');\nvar path = require('path');\n\nmodule.exports = {\n    entry: {iread: \"./iread/src/index.js\",\n            icartoons: \"./icartoons/src/index.js\"},\n    output: {\n        path: \"./dist\", //资源文件引用的目录\n        publicPath: '../dist/',  //相对于html中,指定资源文件引用的目录\n        filename: \"[name].bundle.js\",\n        chunkFilename: '[name].chunk.js'\n    },\n    module: {\n        loaders: [\n            { test: path.resolve('./','lib/zepto.js'), loader: \"exports?window.$!script\" },\n            { test: /\\.css$/, loader: \"style-loader!css-loader\" },\n            { test: /\\.(png|jpg)$/, loader: \"url-loader\" },\n            { test: /.jsx?$/, loader: 'babel-loader',exclude: /node_modules/, query: { presets: ['es2015', 'react'] } }\n         ]\n    },\n    plugins:[\n        new webpack.ProvidePlugin({\n            $: path.resolve('./','lib/zepto.js')\n        }),\n        new webpack.DllReferencePlugin({\n            context: __dirname,//需要与webpack.dll.config.js中DllPlugin上下文一致\n            manifest: require('./dist/vendor-manifest.json')//DllPlugin输出的manifest.json文件\n        })\n    ]\n}\n```\n\n2. 生产环境下\n\n```javascript\nvar webpack = require('webpack');\nvar path = require('path');\n\nmodule.exports = {\n    entry: {iread: './iread/src/index.js',\n            icartoons: './icartoons/src/index.js'},\n    output: {\n        path: \"./dist\",\n        filename: \"[name].bundle.min.js\"\n    },\n    module: {\n        loaders: [\n            { test: path.resolve('./','lib/zepto.js'), loader: \"exports?window.$!script\" },\n            { test: /\\.css$/, loader: \"style-loader!css-loader\" },\n            { test: /\\.(png|jpg)$/, loader: \"url-loader\" },\n            { test: /.jsx?$/, loader: 'babel-loader',exclude: /node_modules/, query: { presets: ['es2015', 'react'] } }  \n         ]\n    },\n    plugins:[\n        new webpack.ProvidePlugin({\n            $: path.resolve('./','lib/zepto.js')\n        }),\n        new webpack.DefinePlugin({\n            'process.env': {\n              'NODE_ENV': JSON.stringify('production')\n            }\n        }),\n        new webpack.optimize.UglifyJsPlugin({\n          compress: {\n            warnings: false\n          }\n        })\n    ]\n}\n```\n","slug":"webpack配置","published":1,"updated":"2019-03-18T02:27:14.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6v000wqmhfrtoxoftg","content":"<h3 id=\"dll动态链接库优化打包\"><a href=\"#dll动态链接库优化打包\" class=\"headerlink\" title=\"dll动态链接库优化打包\"></a>dll动态链接库优化打包</h3><p>为dll单独配置一个webpack.dll.config.js文件，在entry中引入你要打包到vendor的模块，通常是一些通用的不涉及业务的库。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;<span class=\"attr\">vendor</span>: [<span class=\"string\">'react'</span>, <span class=\"string\">'react-dom'</span>]&#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">'./dist'</span>,</span><br><span class=\"line\">        filename: <span class=\"string\">'[name].bundle.js'</span>,</span><br><span class=\"line\">        library: <span class=\"string\">'[name]'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins:[</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.DllPlugin(&#123;</span><br><span class=\"line\">            path: <span class=\"string\">'./dist/[name]-manifest.json'</span>,</span><br><span class=\"line\">            name: <span class=\"string\">'[name]'</span>,</span><br><span class=\"line\">            context: __dirname,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>webpack.DllPlugin</strong>的选项中，path是manifest文件的输出路径；name是dll暴露的对象名，要跟output.library保持一致。执行<code>webpack --config webpack.dll.config.js</code>后会在dist文件夹下面生成<font color=\"#F44336\">vendor.manifest.json</font>和<font color=\"#F44336\">vendor.bundle.js</font>。其中vendor.manifest.json长这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"vendor\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"content\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/react/react.js\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/react/lib/React.js\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/process/browser.js\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/object-assign/index.js\"</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/react/lib/ReactBaseClasses.js\"</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/react/lib/reactProdInvariant.js\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/react/lib/ReactNoopUpdateQueue.js\"</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/fbjs/lib/warning.js\"</span>: <span class=\"number\">8</span>,</span><br><span class=\"line\">    ......</span><br></pre></td></tr></table></figure>\n<p>webpack将每个库进行了编号，之后dll user可以读取该文件，根据这个索引来引用。</p>\n<a id=\"more\"></a>\n<p>之后，在webpack.config.js文件中添加DllReferencePlugin的插件配置。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">        context: __dirname,<span class=\"comment\">//需要与webpack.dll.config.js中DllPlugin上下文一致</span></span><br><span class=\"line\">        manifest: <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/vendor-manifest.json'</span>)<span class=\"comment\">//DllPlugin输出的manifest.json文件</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>配置完成后，每次业务逻辑的修改只需要执行<code>webpack --config webpack.config.js</code>，不需要重复对dll进行打包，可以节约打包时间。</p>\n<h3 id=\"使用require-ensure分包\"><a href=\"#使用require-ensure分包\" class=\"headerlink\" title=\"使用require.ensure分包\"></a>使用require.ensure分包</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.ensure([<span class=\"comment\">/*预加载模块*/</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">Promise</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'es6-promise'</span>).Promise;</span><br><span class=\"line\">&#125;, <span class=\"string\">'promise'</span>);</span><br></pre></td></tr></table></figure>\n<p>webpack会将es6-promise模块打包成promise.chunk.js(require.ensure的第三个参数和chunkFilename决定了打包后的文件名)。<br>每个require.ensure会把前面数组里面的模块和内部require的模块都打包到一个文件内，异步加载。<br>可以在ensure的[]数组中加入想要预加载的模块，也可以在function内部使用require.include对文件进行预加载。</p>\n<h3 id=\"webpack-dev-server热替换\"><a href=\"#webpack-dev-server热替换\" class=\"headerlink\" title=\"webpack-dev-server热替换\"></a>webpack-dev-server热替换</h3><blockquote>\n<p>webpack-dev-server 主要提供两个功能：</p>\n<ul>\n<li>为静态文件提供服务</li>\n<li>自动刷新和热替换(HMR)</li>\n</ul>\n</blockquote>\n<p>webpack-dev-server提供了两种自动刷新模式：iframe和inline，默认模式是iframe。inline方式会将webpack-dev-server客户端加入到webpack入口文件的配置中，配置方式有CLI和NodeJs API两种。</p>\n<h5 id=\"CLI方式\"><a href=\"#CLI方式\" class=\"headerlink\" title=\"CLI方式\"></a>CLI方式</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack-dev-server --env development --port=<span class=\"number\">8081</span> --hot --inline</span><br></pre></td></tr></table></figure>\n<h5 id=\"Node-js-API方式\"><a href=\"#Node-js-API方式\" class=\"headerlink\" title=\"Node.js API方式\"></a>Node.js API方式</h5><p>手动将webpack-dev-server客户端配置到webpack打包的入口文件中<br>修改文件webpack.config.dev.js，添加webpack/hot/dev-server，添加插件HotModuleReplacementPlugin：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackBase = <span class=\"built_in\">require</span>(<span class=\"string\">\"./webpack.config.base.js\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cfg = <span class=\"built_in\">Object</span>.assign(webpackBase, &#123;</span><br><span class=\"line\">    devtool: <span class=\"string\">\"cheap-module-eval-source-map\"</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//entry</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames((webpackBase.entry || &#123;&#125;)).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    cfg.entry[name] = []</span><br><span class=\"line\">        <span class=\"comment\">//添加HMR文件</span></span><br><span class=\"line\">        .concat(<span class=\"string\">\"webpack/hot/dev-server\"</span>)</span><br><span class=\"line\">        .concat(<span class=\"string\">\"webpack-dev-server/client?http://localhost:9390\"</span>)</span><br><span class=\"line\">        .concat(webpackBase.entry[name])</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//plugins</span></span><br><span class=\"line\">cfg.plugins = (webpackBase.plugins || []).concat(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class=\"line\">    <span class=\"comment\">//添加HMR插件</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NoErrorsPlugin()</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = cfg;</span><br></pre></td></tr></table></figure></p>\n<p>根目录添加文件devServer.js，用于创建服务器实例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">\"path\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackDevServer = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack-dev-server\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackCfg = <span class=\"built_in\">require</span>(<span class=\"string\">\"./webpack.config.dev.js\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(webpackCfg);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//init server</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> webpackDevServer(compiler, &#123;</span><br><span class=\"line\">    <span class=\"comment\">//注意此处publicPath必填</span></span><br><span class=\"line\">    publicPath: webpackCfg.output.publicPath,</span><br><span class=\"line\">    <span class=\"comment\">//HMR配置</span></span><br><span class=\"line\">    hot:<span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">9390</span>, <span class=\"string\">\"localhost\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"listen at http://localhost:9390\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>修改package.json中scripts配置，通过执行devServer.js文件启动服务器：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">\"start\"</span>:<span class=\"string\">\"node devServer.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"基础版webpack配置\"><a href=\"#基础版webpack配置\" class=\"headerlink\" title=\"基础版webpack配置\"></a>基础版webpack配置</h3><ol>\n<li>开发环境下</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;<span class=\"attr\">iread</span>: <span class=\"string\">\"./iread/src/index.js\"</span>,</span><br><span class=\"line\">            icartoons: <span class=\"string\">\"./icartoons/src/index.js\"</span>&#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">\"./dist\"</span>, <span class=\"comment\">//资源文件引用的目录</span></span><br><span class=\"line\">        publicPath: <span class=\"string\">'../dist/'</span>,  <span class=\"comment\">//相对于html中,指定资源文件引用的目录</span></span><br><span class=\"line\">        filename: <span class=\"string\">\"[name].bundle.js\"</span>,</span><br><span class=\"line\">        chunkFilename: <span class=\"string\">'[name].chunk.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: path.resolve(<span class=\"string\">'./'</span>,<span class=\"string\">'lib/zepto.js'</span>), <span class=\"attr\">loader</span>: <span class=\"string\">\"exports?window.$!script\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">\"style-loader!css-loader\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpg)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">\"url-loader\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/.jsx?$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'babel-loader'</span>,<span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>, <span class=\"attr\">query</span>: &#123; <span class=\"attr\">presets</span>: [<span class=\"string\">'es2015'</span>, <span class=\"string\">'react'</span>] &#125; &#125;</span><br><span class=\"line\">         ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins:[</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.ProvidePlugin(&#123;</span><br><span class=\"line\">            $: path.resolve(<span class=\"string\">'./'</span>,<span class=\"string\">'lib/zepto.js'</span>)</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">            context: __dirname,<span class=\"comment\">//需要与webpack.dll.config.js中DllPlugin上下文一致</span></span><br><span class=\"line\">            manifest: <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/vendor-manifest.json'</span>)<span class=\"comment\">//DllPlugin输出的manifest.json文件</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>生产环境下</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;<span class=\"attr\">iread</span>: <span class=\"string\">'./iread/src/index.js'</span>,</span><br><span class=\"line\">            icartoons: <span class=\"string\">'./icartoons/src/index.js'</span>&#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">\"./dist\"</span>,</span><br><span class=\"line\">        filename: <span class=\"string\">\"[name].bundle.min.js\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: path.resolve(<span class=\"string\">'./'</span>,<span class=\"string\">'lib/zepto.js'</span>), <span class=\"attr\">loader</span>: <span class=\"string\">\"exports?window.$!script\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">\"style-loader!css-loader\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpg)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">\"url-loader\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/.jsx?$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'babel-loader'</span>,<span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>, <span class=\"attr\">query</span>: &#123; <span class=\"attr\">presets</span>: [<span class=\"string\">'es2015'</span>, <span class=\"string\">'react'</span>] &#125; &#125;  </span><br><span class=\"line\">         ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins:[</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.ProvidePlugin(&#123;</span><br><span class=\"line\">            $: path.resolve(<span class=\"string\">'./'</span>,<span class=\"string\">'lib/zepto.js'</span>)</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">            <span class=\"string\">'process.env'</span>: &#123;</span><br><span class=\"line\">              <span class=\"string\">'NODE_ENV'</span>: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'production'</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class=\"line\">          compress: &#123;</span><br><span class=\"line\">            warnings: <span class=\"literal\">false</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"dll动态链接库优化打包\"><a href=\"#dll动态链接库优化打包\" class=\"headerlink\" title=\"dll动态链接库优化打包\"></a>dll动态链接库优化打包</h3><p>为dll单独配置一个webpack.dll.config.js文件，在entry中引入你要打包到vendor的模块，通常是一些通用的不涉及业务的库。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;<span class=\"attr\">vendor</span>: [<span class=\"string\">'react'</span>, <span class=\"string\">'react-dom'</span>]&#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">'./dist'</span>,</span><br><span class=\"line\">        filename: <span class=\"string\">'[name].bundle.js'</span>,</span><br><span class=\"line\">        library: <span class=\"string\">'[name]'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins:[</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.DllPlugin(&#123;</span><br><span class=\"line\">            path: <span class=\"string\">'./dist/[name]-manifest.json'</span>,</span><br><span class=\"line\">            name: <span class=\"string\">'[name]'</span>,</span><br><span class=\"line\">            context: __dirname,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>webpack.DllPlugin</strong>的选项中，path是manifest文件的输出路径；name是dll暴露的对象名，要跟output.library保持一致。执行<code>webpack --config webpack.dll.config.js</code>后会在dist文件夹下面生成<font color=\"#F44336\">vendor.manifest.json</font>和<font color=\"#F44336\">vendor.bundle.js</font>。其中vendor.manifest.json长这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"name\"</span>: <span class=\"string\">\"vendor\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"content\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/react/react.js\"</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/react/lib/React.js\"</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/process/browser.js\"</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/object-assign/index.js\"</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/react/lib/ReactBaseClasses.js\"</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/react/lib/reactProdInvariant.js\"</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/react/lib/ReactNoopUpdateQueue.js\"</span>: <span class=\"number\">7</span>,</span><br><span class=\"line\">    <span class=\"string\">\"./node_modules/fbjs/lib/warning.js\"</span>: <span class=\"number\">8</span>,</span><br><span class=\"line\">    ......</span><br></pre></td></tr></table></figure>\n<p>webpack将每个库进行了编号，之后dll user可以读取该文件，根据这个索引来引用。</p>","more":"<p>之后，在webpack.config.js文件中添加DllReferencePlugin的插件配置。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">plugins:[</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">        context: __dirname,<span class=\"comment\">//需要与webpack.dll.config.js中DllPlugin上下文一致</span></span><br><span class=\"line\">        manifest: <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/vendor-manifest.json'</span>)<span class=\"comment\">//DllPlugin输出的manifest.json文件</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>配置完成后，每次业务逻辑的修改只需要执行<code>webpack --config webpack.config.js</code>，不需要重复对dll进行打包，可以节约打包时间。</p>\n<h3 id=\"使用require-ensure分包\"><a href=\"#使用require-ensure分包\" class=\"headerlink\" title=\"使用require.ensure分包\"></a>使用require.ensure分包</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.ensure([<span class=\"comment\">/*预加载模块*/</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">Promise</span> = <span class=\"built_in\">require</span>(<span class=\"string\">'es6-promise'</span>).Promise;</span><br><span class=\"line\">&#125;, <span class=\"string\">'promise'</span>);</span><br></pre></td></tr></table></figure>\n<p>webpack会将es6-promise模块打包成promise.chunk.js(require.ensure的第三个参数和chunkFilename决定了打包后的文件名)。<br>每个require.ensure会把前面数组里面的模块和内部require的模块都打包到一个文件内，异步加载。<br>可以在ensure的[]数组中加入想要预加载的模块，也可以在function内部使用require.include对文件进行预加载。</p>\n<h3 id=\"webpack-dev-server热替换\"><a href=\"#webpack-dev-server热替换\" class=\"headerlink\" title=\"webpack-dev-server热替换\"></a>webpack-dev-server热替换</h3><blockquote>\n<p>webpack-dev-server 主要提供两个功能：</p>\n<ul>\n<li>为静态文件提供服务</li>\n<li>自动刷新和热替换(HMR)</li>\n</ul>\n</blockquote>\n<p>webpack-dev-server提供了两种自动刷新模式：iframe和inline，默认模式是iframe。inline方式会将webpack-dev-server客户端加入到webpack入口文件的配置中，配置方式有CLI和NodeJs API两种。</p>\n<h5 id=\"CLI方式\"><a href=\"#CLI方式\" class=\"headerlink\" title=\"CLI方式\"></a>CLI方式</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack-dev-server --env development --port=<span class=\"number\">8081</span> --hot --inline</span><br></pre></td></tr></table></figure>\n<h5 id=\"Node-js-API方式\"><a href=\"#Node-js-API方式\" class=\"headerlink\" title=\"Node.js API方式\"></a>Node.js API方式</h5><p>手动将webpack-dev-server客户端配置到webpack打包的入口文件中<br>修改文件webpack.config.dev.js，添加webpack/hot/dev-server，添加插件HotModuleReplacementPlugin：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackBase = <span class=\"built_in\">require</span>(<span class=\"string\">\"./webpack.config.base.js\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> cfg = <span class=\"built_in\">Object</span>.assign(webpackBase, &#123;</span><br><span class=\"line\">    devtool: <span class=\"string\">\"cheap-module-eval-source-map\"</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//entry</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getOwnPropertyNames((webpackBase.entry || &#123;&#125;)).map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    cfg.entry[name] = []</span><br><span class=\"line\">        <span class=\"comment\">//添加HMR文件</span></span><br><span class=\"line\">        .concat(<span class=\"string\">\"webpack/hot/dev-server\"</span>)</span><br><span class=\"line\">        .concat(<span class=\"string\">\"webpack-dev-server/client?http://localhost:9390\"</span>)</span><br><span class=\"line\">        .concat(webpackBase.entry[name])</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//plugins</span></span><br><span class=\"line\">cfg.plugins = (webpackBase.plugins || []).concat(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class=\"line\">    <span class=\"comment\">//添加HMR插件</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class=\"line\">    <span class=\"keyword\">new</span> webpack.NoErrorsPlugin()</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = cfg;</span><br></pre></td></tr></table></figure></p>\n<p>根目录添加文件devServer.js，用于创建服务器实例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">\"path\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackDevServer = <span class=\"built_in\">require</span>(<span class=\"string\">\"webpack-dev-server\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackCfg = <span class=\"built_in\">require</span>(<span class=\"string\">\"./webpack.config.dev.js\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(webpackCfg);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//init server</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> webpackDevServer(compiler, &#123;</span><br><span class=\"line\">    <span class=\"comment\">//注意此处publicPath必填</span></span><br><span class=\"line\">    publicPath: webpackCfg.output.publicPath,</span><br><span class=\"line\">    <span class=\"comment\">//HMR配置</span></span><br><span class=\"line\">    hot:<span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">9390</span>, <span class=\"string\">\"localhost\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"listen at http://localhost:9390\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>修改package.json中scripts配置，通过执行devServer.js文件启动服务器：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>:&#123;</span><br><span class=\"line\">    <span class=\"string\">\"start\"</span>:<span class=\"string\">\"node devServer.js\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"基础版webpack配置\"><a href=\"#基础版webpack配置\" class=\"headerlink\" title=\"基础版webpack配置\"></a>基础版webpack配置</h3><ol>\n<li>开发环境下</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;<span class=\"attr\">iread</span>: <span class=\"string\">\"./iread/src/index.js\"</span>,</span><br><span class=\"line\">            icartoons: <span class=\"string\">\"./icartoons/src/index.js\"</span>&#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">\"./dist\"</span>, <span class=\"comment\">//资源文件引用的目录</span></span><br><span class=\"line\">        publicPath: <span class=\"string\">'../dist/'</span>,  <span class=\"comment\">//相对于html中,指定资源文件引用的目录</span></span><br><span class=\"line\">        filename: <span class=\"string\">\"[name].bundle.js\"</span>,</span><br><span class=\"line\">        chunkFilename: <span class=\"string\">'[name].chunk.js'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: path.resolve(<span class=\"string\">'./'</span>,<span class=\"string\">'lib/zepto.js'</span>), <span class=\"attr\">loader</span>: <span class=\"string\">\"exports?window.$!script\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">\"style-loader!css-loader\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpg)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">\"url-loader\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/.jsx?$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'babel-loader'</span>,<span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>, <span class=\"attr\">query</span>: &#123; <span class=\"attr\">presets</span>: [<span class=\"string\">'es2015'</span>, <span class=\"string\">'react'</span>] &#125; &#125;</span><br><span class=\"line\">         ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins:[</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.ProvidePlugin(&#123;</span><br><span class=\"line\">            $: path.resolve(<span class=\"string\">'./'</span>,<span class=\"string\">'lib/zepto.js'</span>)</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class=\"line\">            context: __dirname,<span class=\"comment\">//需要与webpack.dll.config.js中DllPlugin上下文一致</span></span><br><span class=\"line\">            manifest: <span class=\"built_in\">require</span>(<span class=\"string\">'./dist/vendor-manifest.json'</span>)<span class=\"comment\">//DllPlugin输出的manifest.json文件</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>生产环境下</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: &#123;<span class=\"attr\">iread</span>: <span class=\"string\">'./iread/src/index.js'</span>,</span><br><span class=\"line\">            icartoons: <span class=\"string\">'./icartoons/src/index.js'</span>&#125;,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">\"./dist\"</span>,</span><br><span class=\"line\">        filename: <span class=\"string\">\"[name].bundle.min.js\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        loaders: [</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: path.resolve(<span class=\"string\">'./'</span>,<span class=\"string\">'lib/zepto.js'</span>), <span class=\"attr\">loader</span>: <span class=\"string\">\"exports?window.$!script\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">\"style-loader!css-loader\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpg)$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">\"url-loader\"</span> &#125;,</span><br><span class=\"line\">            &#123; <span class=\"attr\">test</span>: <span class=\"regexp\">/.jsx?$/</span>, <span class=\"attr\">loader</span>: <span class=\"string\">'babel-loader'</span>,<span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span>, <span class=\"attr\">query</span>: &#123; <span class=\"attr\">presets</span>: [<span class=\"string\">'es2015'</span>, <span class=\"string\">'react'</span>] &#125; &#125;  </span><br><span class=\"line\">         ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins:[</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.ProvidePlugin(&#123;</span><br><span class=\"line\">            $: path.resolve(<span class=\"string\">'./'</span>,<span class=\"string\">'lib/zepto.js'</span>)</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</span><br><span class=\"line\">            <span class=\"string\">'process.env'</span>: &#123;</span><br><span class=\"line\">              <span class=\"string\">'NODE_ENV'</span>: <span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">'production'</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class=\"line\">          compress: &#123;</span><br><span class=\"line\">            warnings: <span class=\"literal\">false</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"web浏览器兼容性问题","date":"2017-06-15T12:19:58.000Z","_content":"\n### IE的问题\n- IE中animate作用在body上会失效，使用$('html, body')\n```javascript\n    $('html, body').animate({\n        scrollTop: offsetTop - $('#J_nav').height()\n    }, 500)\n```\n- $('body').scrollTop()在IE中获得的值始终是0，使用$(document).scrollTop()可以获得正确的值\n- IE中通过offset获得的top值 = chrome浏览器offset的top值 + 该元素的paddingTop值。要获取元素offset值，需要兼容IE，如下：\n\n```javascript\n    \\\\大于等于Ver版本的IE浏览器\n    isGteIE(ver) {\n        let b = document.createElement('b');\n        b.innerHTML = '<!--[if lte IE ' + ver + ']><i></i><![endif]-->';\n        return b.getElementsByTagName('i').length === 1;\n    }\n    let offsetTop = $(target).offset().top;\n    //IE8及以上, 修正offset\n    if(self.isGteIE(8)) {\n        offsetTop -= parseInt($(target).css('paddingTop'));\n    }\n```\n\n### 浏览器内核\n浏览器 | 内核\n- | :-:\nIE | Trident\nSafari | webkit\nChrome | WebKit的分支—Chromium引擎\nChrome 28.0.1469.0版本之后 | 基于WebKit2—Blink引擎\nFirefox | Gecko内核\nOpera | Presto渲染引擎，2013年2月之后紧跟chrome引擎\n\n浏览器市场份额\nhttp://www.netmarketshare.com/\n\n### 兼容IE8\nIE8不支持本地视频播放，要使用在线的\n为了让IE8兼容video标签，使用html5media\n``` js\n <!–[if lt IE 9]>\n        <script src=\"http://api.html5media.info/1.1.8/html5media.min.js\"></script>\n<![endif]–>\n```\n\n兼容IE8的图表库：highcharts\nhttp://www.highcharts.com/demo\n需要使用1.x的jQuery版本\n","source":"_posts/web浏览器兼容性问题.md","raw":"---\ntitle: web浏览器兼容性问题\ndate: 2017-06-15 20:19:58\ntags: [兼容]\n---\n\n### IE的问题\n- IE中animate作用在body上会失效，使用$('html, body')\n```javascript\n    $('html, body').animate({\n        scrollTop: offsetTop - $('#J_nav').height()\n    }, 500)\n```\n- $('body').scrollTop()在IE中获得的值始终是0，使用$(document).scrollTop()可以获得正确的值\n- IE中通过offset获得的top值 = chrome浏览器offset的top值 + 该元素的paddingTop值。要获取元素offset值，需要兼容IE，如下：\n\n```javascript\n    \\\\大于等于Ver版本的IE浏览器\n    isGteIE(ver) {\n        let b = document.createElement('b');\n        b.innerHTML = '<!--[if lte IE ' + ver + ']><i></i><![endif]-->';\n        return b.getElementsByTagName('i').length === 1;\n    }\n    let offsetTop = $(target).offset().top;\n    //IE8及以上, 修正offset\n    if(self.isGteIE(8)) {\n        offsetTop -= parseInt($(target).css('paddingTop'));\n    }\n```\n\n### 浏览器内核\n浏览器 | 内核\n- | :-:\nIE | Trident\nSafari | webkit\nChrome | WebKit的分支—Chromium引擎\nChrome 28.0.1469.0版本之后 | 基于WebKit2—Blink引擎\nFirefox | Gecko内核\nOpera | Presto渲染引擎，2013年2月之后紧跟chrome引擎\n\n浏览器市场份额\nhttp://www.netmarketshare.com/\n\n### 兼容IE8\nIE8不支持本地视频播放，要使用在线的\n为了让IE8兼容video标签，使用html5media\n``` js\n <!–[if lt IE 9]>\n        <script src=\"http://api.html5media.info/1.1.8/html5media.min.js\"></script>\n<![endif]–>\n```\n\n兼容IE8的图表库：highcharts\nhttp://www.highcharts.com/demo\n需要使用1.x的jQuery版本\n","slug":"web浏览器兼容性问题","published":1,"updated":"2019-03-18T02:27:14.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6x000yqmhfths1s5m9","content":"<h3 id=\"IE的问题\"><a href=\"#IE的问题\" class=\"headerlink\" title=\"IE的问题\"></a>IE的问题</h3><ul>\n<li><p>IE中animate作用在body上会失效，使用$(‘html, body’)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'html, body'</span>).animate(&#123;</span><br><span class=\"line\">    scrollTop: offsetTop - $(<span class=\"string\">'#J_nav'</span>).height()</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>$(‘body’).scrollTop()在IE中获得的值始终是0，使用$(document).scrollTop()可以获得正确的值</p>\n</li>\n<li>IE中通过offset获得的top值 = chrome浏览器offset的top值 + 该元素的paddingTop值。要获取元素offset值，需要兼容IE，如下：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\\\大于等于Ver版本的IE浏览器</span><br><span class=\"line\">isGteIE(ver) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">    b.innerHTML = <span class=\"string\">'&lt;!--[if lte IE '</span> + ver + <span class=\"string\">']&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b.getElementsByTagName(<span class=\"string\">'i'</span>).length === <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> offsetTop = $(target).offset().top;</span><br><span class=\"line\"><span class=\"comment\">//IE8及以上, 修正offset</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(self.isGteIE(<span class=\"number\">8</span>)) &#123;</span><br><span class=\"line\">    offsetTop -= <span class=\"built_in\">parseInt</span>($(target).css(<span class=\"string\">'paddingTop'</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h3><table>\n<thead>\n<tr>\n<th>浏览器</th>\n<th style=\"text-align:center\">内核</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IE</td>\n<td style=\"text-align:center\">Trident</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td style=\"text-align:center\">webkit</td>\n</tr>\n<tr>\n<td>Chrome</td>\n<td style=\"text-align:center\">WebKit的分支—Chromium引擎</td>\n</tr>\n<tr>\n<td>Chrome 28.0.1469.0版本之后</td>\n<td style=\"text-align:center\">基于WebKit2—Blink引擎</td>\n</tr>\n<tr>\n<td>Firefox</td>\n<td style=\"text-align:center\">Gecko内核</td>\n</tr>\n<tr>\n<td>Opera</td>\n<td style=\"text-align:center\">Presto渲染引擎，2013年2月之后紧跟chrome引擎</td>\n</tr>\n</tbody>\n</table>\n<p>浏览器市场份额<br><a href=\"http://www.netmarketshare.com/\" target=\"_blank\" rel=\"noopener\">http://www.netmarketshare.com/</a></p>\n<h3 id=\"兼容IE8\"><a href=\"#兼容IE8\" class=\"headerlink\" title=\"兼容IE8\"></a>兼容IE8</h3><p>IE8不支持本地视频播放，要使用在线的<br>为了让IE8兼容video标签，使用html5media<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;!–[<span class=\"keyword\">if</span> lt IE <span class=\"number\">9</span>]&gt;</span><br><span class=\"line\">        &lt;script src=<span class=\"string\">\"http://api.html5media.info/1.1.8/html5media.min.js\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\">&lt;![endif]–&gt;</span><br></pre></td></tr></table></figure></p>\n<p>兼容IE8的图表库：highcharts<br><a href=\"http://www.highcharts.com/demo\" target=\"_blank\" rel=\"noopener\">http://www.highcharts.com/demo</a><br>需要使用1.x的jQuery版本</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"IE的问题\"><a href=\"#IE的问题\" class=\"headerlink\" title=\"IE的问题\"></a>IE的问题</h3><ul>\n<li><p>IE中animate作用在body上会失效，使用$(‘html, body’)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'html, body'</span>).animate(&#123;</span><br><span class=\"line\">    scrollTop: offsetTop - $(<span class=\"string\">'#J_nav'</span>).height()</span><br><span class=\"line\">&#125;, <span class=\"number\">500</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>$(‘body’).scrollTop()在IE中获得的值始终是0，使用$(document).scrollTop()可以获得正确的值</p>\n</li>\n<li>IE中通过offset获得的top值 = chrome浏览器offset的top值 + 该元素的paddingTop值。要获取元素offset值，需要兼容IE，如下：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\\\大于等于Ver版本的IE浏览器</span><br><span class=\"line\">isGteIE(ver) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">    b.innerHTML = <span class=\"string\">'&lt;!--[if lte IE '</span> + ver + <span class=\"string\">']&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b.getElementsByTagName(<span class=\"string\">'i'</span>).length === <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> offsetTop = $(target).offset().top;</span><br><span class=\"line\"><span class=\"comment\">//IE8及以上, 修正offset</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(self.isGteIE(<span class=\"number\">8</span>)) &#123;</span><br><span class=\"line\">    offsetTop -= <span class=\"built_in\">parseInt</span>($(target).css(<span class=\"string\">'paddingTop'</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"浏览器内核\"><a href=\"#浏览器内核\" class=\"headerlink\" title=\"浏览器内核\"></a>浏览器内核</h3><table>\n<thead>\n<tr>\n<th>浏览器</th>\n<th style=\"text-align:center\">内核</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IE</td>\n<td style=\"text-align:center\">Trident</td>\n</tr>\n<tr>\n<td>Safari</td>\n<td style=\"text-align:center\">webkit</td>\n</tr>\n<tr>\n<td>Chrome</td>\n<td style=\"text-align:center\">WebKit的分支—Chromium引擎</td>\n</tr>\n<tr>\n<td>Chrome 28.0.1469.0版本之后</td>\n<td style=\"text-align:center\">基于WebKit2—Blink引擎</td>\n</tr>\n<tr>\n<td>Firefox</td>\n<td style=\"text-align:center\">Gecko内核</td>\n</tr>\n<tr>\n<td>Opera</td>\n<td style=\"text-align:center\">Presto渲染引擎，2013年2月之后紧跟chrome引擎</td>\n</tr>\n</tbody>\n</table>\n<p>浏览器市场份额<br><a href=\"http://www.netmarketshare.com/\" target=\"_blank\" rel=\"noopener\">http://www.netmarketshare.com/</a></p>\n<h3 id=\"兼容IE8\"><a href=\"#兼容IE8\" class=\"headerlink\" title=\"兼容IE8\"></a>兼容IE8</h3><p>IE8不支持本地视频播放，要使用在线的<br>为了让IE8兼容video标签，使用html5media<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &lt;!–[<span class=\"keyword\">if</span> lt IE <span class=\"number\">9</span>]&gt;</span><br><span class=\"line\">        &lt;script src=<span class=\"string\">\"http://api.html5media.info/1.1.8/html5media.min.js\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\">&lt;![endif]–&gt;</span><br></pre></td></tr></table></figure></p>\n<p>兼容IE8的图表库：highcharts<br><a href=\"http://www.highcharts.com/demo\" target=\"_blank\" rel=\"noopener\">http://www.highcharts.com/demo</a><br>需要使用1.x的jQuery版本</p>\n"},{"title":"函数式编程的应用","date":"2018-08-24T01:38:54.000Z","_content":"\n### react的render方法\nrender()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法。保持render() 方法纯净使得组件更容易思考。\n\n","source":"_posts/函数式编程的应用.md","raw":"---\ntitle: 函数式编程的应用\ndate: 2018-08-24 09:38:54\ntags:\n---\n\n### react的render方法\nrender()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法。保持render() 方法纯净使得组件更容易思考。\n\n","slug":"函数式编程的应用","published":1,"updated":"2019-03-18T02:27:14.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx6z0010qmhfmtdexeol","content":"<h3 id=\"react的render方法\"><a href=\"#react的render方法\" class=\"headerlink\" title=\"react的render方法\"></a>react的render方法</h3><p>render()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法。保持render() 方法纯净使得组件更容易思考。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"react的render方法\"><a href=\"#react的render方法\" class=\"headerlink\" title=\"react的render方法\"></a>react的render方法</h3><p>render()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法。保持render() 方法纯净使得组件更容易思考。</p>\n"},{"title":"打点实践总结","date":"2019-03-07T03:02:29.000Z","_content":"beacon 请求方法均为POST，且不支持修改\n兼容性 https://caniuse.com/#search=beacon\n- polyfill https://github.com/kronicker/sendbeacon-polyfill/blob/master/sendbeacon.js\n- https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon\n- [如何在 Web 关闭页面时发送 Ajax 请求](https://juejin.im/post/5c7e541b6fb9a049e06415a5?utm_source=gold_browser_extension)\n- [[译] 使用 Web Beacon API 记录活动](https://juejin.im/post/5b694b5de51d4519700fa56a)\n\npost请求\ncontent-type:\n### application/json\n\nRequest Payload:\n{layouts: [\"1\", \"2\", \"5\"]}\n\n### application/x-www-form-urlencoded\n\nQuery String Parameters\nsourceUuid:np_c3sEKMgU3Xau_Tl0fmsqyReIdKH9OXQpby_FSNhz__ppcy0EKQ\narticleUuid:np_eXoyZJwfsX-q8j5OLm0pyEbYGK0\nforceFollow:0\nisContinue:0\nforceAutoPurchase:1\n\n### multipart/form-data\n使用表单上传文件时，必须让 form 的 enctype 等于这个值。\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryBJIFBCE2CA2Fwbyl\n\n\n","source":"_posts/打点实践总结.md","raw":"---\ntitle: 打点实践总结\ndate: 2019-03-07 11:02:29\ntags:\n---\nbeacon 请求方法均为POST，且不支持修改\n兼容性 https://caniuse.com/#search=beacon\n- polyfill https://github.com/kronicker/sendbeacon-polyfill/blob/master/sendbeacon.js\n- https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon\n- [如何在 Web 关闭页面时发送 Ajax 请求](https://juejin.im/post/5c7e541b6fb9a049e06415a5?utm_source=gold_browser_extension)\n- [[译] 使用 Web Beacon API 记录活动](https://juejin.im/post/5b694b5de51d4519700fa56a)\n\npost请求\ncontent-type:\n### application/json\n\nRequest Payload:\n{layouts: [\"1\", \"2\", \"5\"]}\n\n### application/x-www-form-urlencoded\n\nQuery String Parameters\nsourceUuid:np_c3sEKMgU3Xau_Tl0fmsqyReIdKH9OXQpby_FSNhz__ppcy0EKQ\narticleUuid:np_eXoyZJwfsX-q8j5OLm0pyEbYGK0\nforceFollow:0\nisContinue:0\nforceAutoPurchase:1\n\n### multipart/form-data\n使用表单上传文件时，必须让 form 的 enctype 等于这个值。\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryBJIFBCE2CA2Fwbyl\n\n\n","slug":"打点实践总结","published":1,"updated":"2019-03-18T12:59:45.640Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx720013qmhfd7mvfscx","content":"<p>beacon 请求方法均为POST，且不支持修改<br>兼容性 <a href=\"https://caniuse.com/#search=beacon\" target=\"_blank\" rel=\"noopener\">https://caniuse.com/#search=beacon</a></p>\n<ul>\n<li>polyfill <a href=\"https://github.com/kronicker/sendbeacon-polyfill/blob/master/sendbeacon.js\" target=\"_blank\" rel=\"noopener\">https://github.com/kronicker/sendbeacon-polyfill/blob/master/sendbeacon.js</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon</a></li>\n<li><a href=\"https://juejin.im/post/5c7e541b6fb9a049e06415a5?utm_source=gold_browser_extension\" target=\"_blank\" rel=\"noopener\">如何在 Web 关闭页面时发送 Ajax 请求</a></li>\n<li><a href=\"https://juejin.im/post/5b694b5de51d4519700fa56a\" target=\"_blank\" rel=\"noopener\">[译] 使用 Web Beacon API 记录活动</a></li>\n</ul>\n<p>post请求<br>content-type:</p>\n<h3 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h3><p>Request Payload:<br>{layouts: [“1”, “2”, “5”]}</p>\n<h3 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h3><p>Query String Parameters<br>sourceUuid:np_c3sEKMgU3Xau_Tl0fmsqyReIdKH9OXQpby_FSNhz__ppcy0EKQ<br>articleUuid:np_eXoyZJwfsX-q8j5OLm0pyEbYGK0<br>forceFollow:0<br>isContinue:0<br>forceAutoPurchase:1</p>\n<h3 id=\"multipart-form-data\"><a href=\"#multipart-form-data\" class=\"headerlink\" title=\"multipart/form-data\"></a>multipart/form-data</h3><p>使用表单上传文件时，必须让 form 的 enctype 等于这个值。<br>Content-Type: multipart/form-data; boundary=—-WebKitFormBoundaryBJIFBCE2CA2Fwbyl</p>\n","site":{"data":{}},"excerpt":"","more":"<p>beacon 请求方法均为POST，且不支持修改<br>兼容性 <a href=\"https://caniuse.com/#search=beacon\" target=\"_blank\" rel=\"noopener\">https://caniuse.com/#search=beacon</a></p>\n<ul>\n<li>polyfill <a href=\"https://github.com/kronicker/sendbeacon-polyfill/blob/master/sendbeacon.js\" target=\"_blank\" rel=\"noopener\">https://github.com/kronicker/sendbeacon-polyfill/blob/master/sendbeacon.js</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon</a></li>\n<li><a href=\"https://juejin.im/post/5c7e541b6fb9a049e06415a5?utm_source=gold_browser_extension\" target=\"_blank\" rel=\"noopener\">如何在 Web 关闭页面时发送 Ajax 请求</a></li>\n<li><a href=\"https://juejin.im/post/5b694b5de51d4519700fa56a\" target=\"_blank\" rel=\"noopener\">[译] 使用 Web Beacon API 记录活动</a></li>\n</ul>\n<p>post请求<br>content-type:</p>\n<h3 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h3><p>Request Payload:<br>{layouts: [“1”, “2”, “5”]}</p>\n<h3 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h3><p>Query String Parameters<br>sourceUuid:np_c3sEKMgU3Xau_Tl0fmsqyReIdKH9OXQpby_FSNhz__ppcy0EKQ<br>articleUuid:np_eXoyZJwfsX-q8j5OLm0pyEbYGK0<br>forceFollow:0<br>isContinue:0<br>forceAutoPurchase:1</p>\n<h3 id=\"multipart-form-data\"><a href=\"#multipart-form-data\" class=\"headerlink\" title=\"multipart/form-data\"></a>multipart/form-data</h3><p>使用表单上传文件时，必须让 form 的 enctype 等于这个值。<br>Content-Type: multipart/form-data; boundary=—-WebKitFormBoundaryBJIFBCE2CA2Fwbyl</p>\n"},{"title":"日常经验积累","date":"2017-10-19T03:28:58.000Z","_content":"\n### 禁用复制功能\n``` javascript\n    document.oncontextmenu = function() { return false; }  //禁用鼠标右键功能\n    document.body.oncopy = function() { return false; }    //禁用复制功能\n    document.onselectstart = function() { return false; }  //禁用选择功能\n```\n\n### UC浏览器问题\nUC浏览器会过滤掉top、test、ad、download等关键字\nuc浏览器判断到页面上文字居多时，会自动放大字体优化移动用户体验。\n添加以下头部可以禁用掉该优化\n<meta name=\"wap-font-scale\" content=\"no\">\n\n### Font Boosting问题\n问题：字体的显示大小，与在CSS中指定的大小不一致。\n通过设置max-height: 999999px;或max-height: 100%;可以解决\n\n### ios<10 js无法实现复制\n[copy-to-clipboard-using-javascript-in-ios](https://stackoverflow.com/questions/34045777/copy-to-clipboard-using-javascript-in-ios)\n\n### 移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行\n\n### ios微信缓存问题\n问题：ios9系统下微信内(非必现)，从充值页回到正文页，正文页获取的余额没有刷新，发现get请求没有发出，应该是微信AJAX缓存的问题。可通过给ajax请求加时间戳的方式解决。\n参考：[微信自带浏览器物理返回不刷新问题](https://www.jianshu.com/p/6baa49e26533)\n\n奇怪现象：其他的ios系统下，请求也没有发出去，但是数据是正确的，可能和缓存快照有关系，正常的可能保存了这个页面上次运行的整个数据栈。\n\n### 移动端滚动穿透问题完美解决方案\n``` css\nbody.modal-open {\n    position: fixed;\n    width: 100%;\n}\n```\n当打开modal的时候给body添加`modal-open`类，fixed让底部页面无法滚动，同时根据页面滚动位置设置top值。\n在关闭modal时，再让页面恢复之前的滚动状态。\n``` js\n/**\n  * ModalHelper helpers resolve the modal scrolling issue on mobile devices\n  * https://github.com/twbs/bootstrap/issues/15852\n  * requires document.scrollingElement polyfill https://github.com/yangg/scrolling-element\n  */\nvar ModalHelper = (function(bodyCls) {\n  var scrollTop;\n  return {\n    afterOpen: function() {\n      scrollTop = document.scrollingElement.scrollTop;\n      document.body.classList.add(bodyCls);\n      document.body.style.top = -scrollTop + 'px';\n    },\n    beforeClose: function() {\n      document.body.classList.remove(bodyCls);\n      // scrollTop lost after set position:fixed, restore it back.\n      document.scrollingElement.scrollTop = scrollTop;\n    }\n  };\n})('modal-open');\n```\n\n### 不简单的自适应高度输入框\n主要实现代码如下：\n``` css\ntextarea {\n    width: 100%;\n    height: 92px;\n    padding: 20px;\n    line-height: 50px;\n    resize: none;\n    outline: none;\n    border: 1px solid #ccc;\n    background: #eee;\n    font-size: 32px;\n    box-sizing: border-box;\n    overflow: hidden;  //去掉滚动条\n}\n```\n\n``` html\n<textarea id=\"textarea\"></textarea>\n```\n\n``` js\nvar $textarea = document.getElementById('textarea');\nvar lastLength = 0;\nvar lastHeight = 0;\n\n$textarea.addEventListener('input', function() {\n    var currentLength = $textarea.value.length;\n\n    // 判断字数如果比之前少了，说明内容正在减少，需要清除高度样式，重新获取\n    if (currentLength < lastLength) {\n        $textarea.style.height = '';\n    }\n\n    var currentHeight = $textarea.scrollHeight;\n\n    // 如果内容高度发生了变化，再去设置高度值\n    if (lastHeight !== currentHeight || !$textarea.style.height) {\n        $textarea.style.height = currentHeight + 2 + 'px';\n    }\n\n    lastLength = currentLength;\n    lastHeight = currentHeight;\n});\n```\n原理是检测textarea.scrollHeight属性变化，并随之设置textarea的高度。\n\n参考：https://juejin.im/post/5b7653bde51d454dba70c0b1?utm_source=gold_browser_extension\n\n### setTimeout(fun, 0)\n``` js\nsetTimeout(function () {\n    func1();\n}, 0)\nfunc2();\n```\nfunc1和func2谁会先执行？很明显func2先执行；\nsetTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f,0)，那么会立刻执行吗？\n答案是不会。因为setTimeout运行机制说过，**必须要等到当前脚本的同步任务和“任务队列”中已有的事件，全部处理完以后，才会执行setTimeout指定的任务**。也就是说，setTimeout的真正作用是，在“任务队列”的现有事件的后面再添加一个事件，规定在指定时间执行某段代码。setTimeout添加的事件，会在下一次Event Loop执行。\nsetTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务——**脚本的同步任务和“任务队列”中已有的事件**，一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。\n``` js\nsetTimeout(function() {\n  console.log(\"Timeout\");\n}, 0);\n\nfunction a(x) {\n  console.log(\"a() 开始运行\");\n  b(x);\n  console.log(\"a() 结束运行\");\n}\n\nfunction b(y) {\n  console.log(\"b() 开始运行\");\n  console.log(\"传入的值为\" + y);\n  console.log(\"b() 结束运行\");\n}\n\nconsole.log(\"当前任务开始\");\na(42);\nconsole.log(\"当前任务结束\");\n\n// 当前任务开始\n// a() 开始运行\n// b() 开始运行\n// 传入的值为42\n// b() 结束运行\n// a() 结束运行\n// 当前任务结束\n// Timeout\n```\n上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。\n0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，**最少是4毫秒**。如果小于这个值，会被自动增加到4。这是为了防止多个setTimeout(f,0)语句连续执行，造成性能问题。\n利用`setTimeout(func, 0)`可以帮助我们：\n- 调整函数运行顺序\n- 分割耗时任务\n\n### 0.5px边框\n``` css\n .scale-1px {\n    position: relative;\n    margin-bottom: 20px;\n    border:none;\n}\n.scale-1px:after {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    border: 1px solid #000;\n    box-sizing: border-box;\n    width: 200%;\n    height: 200%;\n    transform: scale(0.5);\n    transform-origin: left top;\n}\n```\n\n### ios系统上active不生效问题\n在iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。\n可以采用下面两种方式解决：\n``` js\n  document.addEventListener(\"touchstart\", function() {}, false);\n```\n\n``` html\n<body ontouchstart=\"\">\n</body>\n```\n\n### beforeunload事件\n兼容问题：为了优化用户体验，新式浏览器会要求有交互才会触发beforeunload事件，例如新版本的chrome浏览器。\nPS: 从Firefox 4、 Chrome 51、Opera 38 和Safari 9.1开始，通用确认信息代替事件返回的字符串，即无法通过下面的方式自定义文案。\n``` js\nwindow.onbeforeunload = function (e) {\n  e = e || window.event;\n\n  // 兼容IE8和Firefox 4之前的版本\n  if (e) {\n    e.returnValue = '关闭提示';\n  }\n\n  // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+\n  return '关闭提示';\n};\n```\nHTML5规范中指出，在该事件中调用window.alert(), window.confirm(), 和 window.prompt()，会被忽略。详细的可参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload)。\n","source":"_posts/日常经验积累.md","raw":"---\ntitle: 日常经验积累\ndate: 2017-10-19 11:28:58\ntags: [总结]\n---\n\n### 禁用复制功能\n``` javascript\n    document.oncontextmenu = function() { return false; }  //禁用鼠标右键功能\n    document.body.oncopy = function() { return false; }    //禁用复制功能\n    document.onselectstart = function() { return false; }  //禁用选择功能\n```\n\n### UC浏览器问题\nUC浏览器会过滤掉top、test、ad、download等关键字\nuc浏览器判断到页面上文字居多时，会自动放大字体优化移动用户体验。\n添加以下头部可以禁用掉该优化\n<meta name=\"wap-font-scale\" content=\"no\">\n\n### Font Boosting问题\n问题：字体的显示大小，与在CSS中指定的大小不一致。\n通过设置max-height: 999999px;或max-height: 100%;可以解决\n\n### ios<10 js无法实现复制\n[copy-to-clipboard-using-javascript-in-ios](https://stackoverflow.com/questions/34045777/copy-to-clipboard-using-javascript-in-ios)\n\n### 移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行\n\n### ios微信缓存问题\n问题：ios9系统下微信内(非必现)，从充值页回到正文页，正文页获取的余额没有刷新，发现get请求没有发出，应该是微信AJAX缓存的问题。可通过给ajax请求加时间戳的方式解决。\n参考：[微信自带浏览器物理返回不刷新问题](https://www.jianshu.com/p/6baa49e26533)\n\n奇怪现象：其他的ios系统下，请求也没有发出去，但是数据是正确的，可能和缓存快照有关系，正常的可能保存了这个页面上次运行的整个数据栈。\n\n### 移动端滚动穿透问题完美解决方案\n``` css\nbody.modal-open {\n    position: fixed;\n    width: 100%;\n}\n```\n当打开modal的时候给body添加`modal-open`类，fixed让底部页面无法滚动，同时根据页面滚动位置设置top值。\n在关闭modal时，再让页面恢复之前的滚动状态。\n``` js\n/**\n  * ModalHelper helpers resolve the modal scrolling issue on mobile devices\n  * https://github.com/twbs/bootstrap/issues/15852\n  * requires document.scrollingElement polyfill https://github.com/yangg/scrolling-element\n  */\nvar ModalHelper = (function(bodyCls) {\n  var scrollTop;\n  return {\n    afterOpen: function() {\n      scrollTop = document.scrollingElement.scrollTop;\n      document.body.classList.add(bodyCls);\n      document.body.style.top = -scrollTop + 'px';\n    },\n    beforeClose: function() {\n      document.body.classList.remove(bodyCls);\n      // scrollTop lost after set position:fixed, restore it back.\n      document.scrollingElement.scrollTop = scrollTop;\n    }\n  };\n})('modal-open');\n```\n\n### 不简单的自适应高度输入框\n主要实现代码如下：\n``` css\ntextarea {\n    width: 100%;\n    height: 92px;\n    padding: 20px;\n    line-height: 50px;\n    resize: none;\n    outline: none;\n    border: 1px solid #ccc;\n    background: #eee;\n    font-size: 32px;\n    box-sizing: border-box;\n    overflow: hidden;  //去掉滚动条\n}\n```\n\n``` html\n<textarea id=\"textarea\"></textarea>\n```\n\n``` js\nvar $textarea = document.getElementById('textarea');\nvar lastLength = 0;\nvar lastHeight = 0;\n\n$textarea.addEventListener('input', function() {\n    var currentLength = $textarea.value.length;\n\n    // 判断字数如果比之前少了，说明内容正在减少，需要清除高度样式，重新获取\n    if (currentLength < lastLength) {\n        $textarea.style.height = '';\n    }\n\n    var currentHeight = $textarea.scrollHeight;\n\n    // 如果内容高度发生了变化，再去设置高度值\n    if (lastHeight !== currentHeight || !$textarea.style.height) {\n        $textarea.style.height = currentHeight + 2 + 'px';\n    }\n\n    lastLength = currentLength;\n    lastHeight = currentHeight;\n});\n```\n原理是检测textarea.scrollHeight属性变化，并随之设置textarea的高度。\n\n参考：https://juejin.im/post/5b7653bde51d454dba70c0b1?utm_source=gold_browser_extension\n\n### setTimeout(fun, 0)\n``` js\nsetTimeout(function () {\n    func1();\n}, 0)\nfunc2();\n```\nfunc1和func2谁会先执行？很明显func2先执行；\nsetTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f,0)，那么会立刻执行吗？\n答案是不会。因为setTimeout运行机制说过，**必须要等到当前脚本的同步任务和“任务队列”中已有的事件，全部处理完以后，才会执行setTimeout指定的任务**。也就是说，setTimeout的真正作用是，在“任务队列”的现有事件的后面再添加一个事件，规定在指定时间执行某段代码。setTimeout添加的事件，会在下一次Event Loop执行。\nsetTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务——**脚本的同步任务和“任务队列”中已有的事件**，一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。\n``` js\nsetTimeout(function() {\n  console.log(\"Timeout\");\n}, 0);\n\nfunction a(x) {\n  console.log(\"a() 开始运行\");\n  b(x);\n  console.log(\"a() 结束运行\");\n}\n\nfunction b(y) {\n  console.log(\"b() 开始运行\");\n  console.log(\"传入的值为\" + y);\n  console.log(\"b() 结束运行\");\n}\n\nconsole.log(\"当前任务开始\");\na(42);\nconsole.log(\"当前任务结束\");\n\n// 当前任务开始\n// a() 开始运行\n// b() 开始运行\n// 传入的值为42\n// b() 结束运行\n// a() 结束运行\n// 当前任务结束\n// Timeout\n```\n上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。\n0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，**最少是4毫秒**。如果小于这个值，会被自动增加到4。这是为了防止多个setTimeout(f,0)语句连续执行，造成性能问题。\n利用`setTimeout(func, 0)`可以帮助我们：\n- 调整函数运行顺序\n- 分割耗时任务\n\n### 0.5px边框\n``` css\n .scale-1px {\n    position: relative;\n    margin-bottom: 20px;\n    border:none;\n}\n.scale-1px:after {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    border: 1px solid #000;\n    box-sizing: border-box;\n    width: 200%;\n    height: 200%;\n    transform: scale(0.5);\n    transform-origin: left top;\n}\n```\n\n### ios系统上active不生效问题\n在iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。\n可以采用下面两种方式解决：\n``` js\n  document.addEventListener(\"touchstart\", function() {}, false);\n```\n\n``` html\n<body ontouchstart=\"\">\n</body>\n```\n\n### beforeunload事件\n兼容问题：为了优化用户体验，新式浏览器会要求有交互才会触发beforeunload事件，例如新版本的chrome浏览器。\nPS: 从Firefox 4、 Chrome 51、Opera 38 和Safari 9.1开始，通用确认信息代替事件返回的字符串，即无法通过下面的方式自定义文案。\n``` js\nwindow.onbeforeunload = function (e) {\n  e = e || window.event;\n\n  // 兼容IE8和Firefox 4之前的版本\n  if (e) {\n    e.returnValue = '关闭提示';\n  }\n\n  // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+\n  return '关闭提示';\n};\n```\nHTML5规范中指出，在该事件中调用window.alert(), window.confirm(), 和 window.prompt()，会被忽略。详细的可参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload)。\n","slug":"日常经验积累","published":1,"updated":"2019-03-18T02:27:14.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx730015qmhfhliturow","content":"<h3 id=\"禁用复制功能\"><a href=\"#禁用复制功能\" class=\"headerlink\" title=\"禁用复制功能\"></a>禁用复制功能</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.oncontextmenu = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; &#125;  <span class=\"comment\">//禁用鼠标右键功能</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.oncopy = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; &#125;    <span class=\"comment\">//禁用复制功能</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.onselectstart = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; &#125;  <span class=\"comment\">//禁用选择功能</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"UC浏览器问题\"><a href=\"#UC浏览器问题\" class=\"headerlink\" title=\"UC浏览器问题\"></a>UC浏览器问题</h3><p>UC浏览器会过滤掉top、test、ad、download等关键字<br>uc浏览器判断到页面上文字居多时，会自动放大字体优化移动用户体验。<br>添加以下头部可以禁用掉该优化</p>\n<meta name=\"wap-font-scale\" content=\"no\">\n\n<h3 id=\"Font-Boosting问题\"><a href=\"#Font-Boosting问题\" class=\"headerlink\" title=\"Font Boosting问题\"></a>Font Boosting问题</h3><p>问题：字体的显示大小，与在CSS中指定的大小不一致。<br>通过设置max-height: 999999px;或max-height: 100%;可以解决</p>\n<h3 id=\"ios-lt-10-js无法实现复制\"><a href=\"#ios-lt-10-js无法实现复制\" class=\"headerlink\" title=\"ios&lt;10 js无法实现复制\"></a>ios&lt;10 js无法实现复制</h3><p><a href=\"https://stackoverflow.com/questions/34045777/copy-to-clipboard-using-javascript-in-ios\" target=\"_blank\" rel=\"noopener\">copy-to-clipboard-using-javascript-in-ios</a></p>\n<h3 id=\"移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行\"><a href=\"#移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行\" class=\"headerlink\" title=\"移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行\"></a>移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行</h3><h3 id=\"ios微信缓存问题\"><a href=\"#ios微信缓存问题\" class=\"headerlink\" title=\"ios微信缓存问题\"></a>ios微信缓存问题</h3><p>问题：ios9系统下微信内(非必现)，从充值页回到正文页，正文页获取的余额没有刷新，发现get请求没有发出，应该是微信AJAX缓存的问题。可通过给ajax请求加时间戳的方式解决。<br>参考：<a href=\"https://www.jianshu.com/p/6baa49e26533\" target=\"_blank\" rel=\"noopener\">微信自带浏览器物理返回不刷新问题</a></p>\n<p>奇怪现象：其他的ios系统下，请求也没有发出去，但是数据是正确的，可能和缓存快照有关系，正常的可能保存了这个页面上次运行的整个数据栈。</p>\n<h3 id=\"移动端滚动穿透问题完美解决方案\"><a href=\"#移动端滚动穿透问题完美解决方案\" class=\"headerlink\" title=\"移动端滚动穿透问题完美解决方案\"></a>移动端滚动穿透问题完美解决方案</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.modal-open</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当打开modal的时候给body添加<code>modal-open</code>类，fixed让底部页面无法滚动，同时根据页面滚动位置设置top值。<br>在关闭modal时，再让页面恢复之前的滚动状态。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * ModalHelper helpers resolve the modal scrolling issue on mobile devices</span></span><br><span class=\"line\"><span class=\"comment\">  * https://github.com/twbs/bootstrap/issues/15852</span></span><br><span class=\"line\"><span class=\"comment\">  * requires document.scrollingElement polyfill https://github.com/yangg/scrolling-element</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ModalHelper = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bodyCls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scrollTop;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    afterOpen: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      scrollTop = <span class=\"built_in\">document</span>.scrollingElement.scrollTop;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.classList.add(bodyCls);</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.style.top = -scrollTop + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    beforeClose: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.classList.remove(bodyCls);</span><br><span class=\"line\">      <span class=\"comment\">// scrollTop lost after set position:fixed, restore it back.</span></span><br><span class=\"line\">      <span class=\"built_in\">document</span>.scrollingElement.scrollTop = scrollTop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)(<span class=\"string\">'modal-open'</span>);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不简单的自适应高度输入框\"><a href=\"#不简单的自适应高度输入框\" class=\"headerlink\" title=\"不简单的自适应高度输入框\"></a>不简单的自适应高度输入框</h3><p>主要实现代码如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">textarea</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">92px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">resize</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">outline</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">32px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">    overflow: hidden;  //去掉滚动条</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">id</span>=<span class=\"string\">\"textarea\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> $textarea = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'textarea'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> lastLength = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> lastHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$textarea.addEventListener(<span class=\"string\">'input'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentLength = $textarea.value.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断字数如果比之前少了，说明内容正在减少，需要清除高度样式，重新获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentLength &lt; lastLength) &#123;</span><br><span class=\"line\">        $textarea.style.height = <span class=\"string\">''</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentHeight = $textarea.scrollHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果内容高度发生了变化，再去设置高度值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastHeight !== currentHeight || !$textarea.style.height) &#123;</span><br><span class=\"line\">        $textarea.style.height = currentHeight + <span class=\"number\">2</span> + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastLength = currentLength;</span><br><span class=\"line\">    lastHeight = currentHeight;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>原理是检测textarea.scrollHeight属性变化，并随之设置textarea的高度。</p>\n<p>参考：<a href=\"https://juejin.im/post/5b7653bde51d454dba70c0b1?utm_source=gold_browser_extension\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5b7653bde51d454dba70c0b1?utm_source=gold_browser_extension</a></p>\n<h3 id=\"setTimeout-fun-0\"><a href=\"#setTimeout-fun-0\" class=\"headerlink\" title=\"setTimeout(fun, 0)\"></a>setTimeout(fun, 0)</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    func1();</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">func2();</span><br></pre></td></tr></table></figure>\n<p>func1和func2谁会先执行？很明显func2先执行；<br>setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f,0)，那么会立刻执行吗？<br>答案是不会。因为setTimeout运行机制说过，<strong>必须要等到当前脚本的同步任务和“任务队列”中已有的事件，全部处理完以后，才会执行setTimeout指定的任务</strong>。也就是说，setTimeout的真正作用是，在“任务队列”的现有事件的后面再添加一个事件，规定在指定时间执行某段代码。setTimeout添加的事件，会在下一次Event Loop执行。<br>setTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务——<strong>脚本的同步任务和“任务队列”中已有的事件</strong>，一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Timeout\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a() 开始运行\"</span>);</span><br><span class=\"line\">  b(x);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a() 结束运行\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"b() 开始运行\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"传入的值为\"</span> + y);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"b() 结束运行\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"当前任务开始\"</span>);</span><br><span class=\"line\">a(<span class=\"number\">42</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"当前任务结束\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当前任务开始</span></span><br><span class=\"line\"><span class=\"comment\">// a() 开始运行</span></span><br><span class=\"line\"><span class=\"comment\">// b() 开始运行</span></span><br><span class=\"line\"><span class=\"comment\">// 传入的值为42</span></span><br><span class=\"line\"><span class=\"comment\">// b() 结束运行</span></span><br><span class=\"line\"><span class=\"comment\">// a() 结束运行</span></span><br><span class=\"line\"><span class=\"comment\">// 当前任务结束</span></span><br><span class=\"line\"><span class=\"comment\">// Timeout</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。<br>0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，<strong>最少是4毫秒</strong>。如果小于这个值，会被自动增加到4。这是为了防止多个setTimeout(f,0)语句连续执行，造成性能问题。<br>利用<code>setTimeout(func, 0)</code>可以帮助我们：</p>\n<ul>\n<li>调整函数运行顺序</li>\n<li>分割耗时任务</li>\n</ul>\n<h3 id=\"0-5px边框\"><a href=\"#0-5px边框\" class=\"headerlink\" title=\"0.5px边框\"></a>0.5px边框</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"selector-class\">.scale-1px</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>:none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.scale-1px</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0.5);</span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: left top;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ios系统上active不生效问题\"><a href=\"#ios系统上active不生效问题\" class=\"headerlink\" title=\"ios系统上active不生效问题\"></a>ios系统上active不生效问题</h3><p>在iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。<br>可以采用下面两种方式解决：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">\"touchstart\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ontouchstart</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"beforeunload事件\"><a href=\"#beforeunload事件\" class=\"headerlink\" title=\"beforeunload事件\"></a>beforeunload事件</h3><p>兼容问题：为了优化用户体验，新式浏览器会要求有交互才会触发beforeunload事件，例如新版本的chrome浏览器。<br>PS: 从Firefox 4、 Chrome 51、Opera 38 和Safari 9.1开始，通用确认信息代替事件返回的字符串，即无法通过下面的方式自定义文案。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onbeforeunload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  e = e || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 兼容IE8和Firefox 4之前的版本</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e) &#123;</span><br><span class=\"line\">    e.returnValue = <span class=\"string\">'关闭提示'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'关闭提示'</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>HTML5规范中指出，在该事件中调用window.alert(), window.confirm(), 和 window.prompt()，会被忽略。详细的可参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload\" target=\"_blank\" rel=\"noopener\">MDN</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"禁用复制功能\"><a href=\"#禁用复制功能\" class=\"headerlink\" title=\"禁用复制功能\"></a>禁用复制功能</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.oncontextmenu = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; &#125;  <span class=\"comment\">//禁用鼠标右键功能</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.oncopy = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; &#125;    <span class=\"comment\">//禁用复制功能</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.onselectstart = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; &#125;  <span class=\"comment\">//禁用选择功能</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"UC浏览器问题\"><a href=\"#UC浏览器问题\" class=\"headerlink\" title=\"UC浏览器问题\"></a>UC浏览器问题</h3><p>UC浏览器会过滤掉top、test、ad、download等关键字<br>uc浏览器判断到页面上文字居多时，会自动放大字体优化移动用户体验。<br>添加以下头部可以禁用掉该优化</p>\n<meta name=\"wap-font-scale\" content=\"no\">\n\n<h3 id=\"Font-Boosting问题\"><a href=\"#Font-Boosting问题\" class=\"headerlink\" title=\"Font Boosting问题\"></a>Font Boosting问题</h3><p>问题：字体的显示大小，与在CSS中指定的大小不一致。<br>通过设置max-height: 999999px;或max-height: 100%;可以解决</p>\n<h3 id=\"ios-lt-10-js无法实现复制\"><a href=\"#ios-lt-10-js无法实现复制\" class=\"headerlink\" title=\"ios&lt;10 js无法实现复制\"></a>ios&lt;10 js无法实现复制</h3><p><a href=\"https://stackoverflow.com/questions/34045777/copy-to-clipboard-using-javascript-in-ios\" target=\"_blank\" rel=\"noopener\">copy-to-clipboard-using-javascript-in-ios</a></p>\n<h3 id=\"移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行\"><a href=\"#移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行\" class=\"headerlink\" title=\"移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行\"></a>移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行</h3><h3 id=\"ios微信缓存问题\"><a href=\"#ios微信缓存问题\" class=\"headerlink\" title=\"ios微信缓存问题\"></a>ios微信缓存问题</h3><p>问题：ios9系统下微信内(非必现)，从充值页回到正文页，正文页获取的余额没有刷新，发现get请求没有发出，应该是微信AJAX缓存的问题。可通过给ajax请求加时间戳的方式解决。<br>参考：<a href=\"https://www.jianshu.com/p/6baa49e26533\" target=\"_blank\" rel=\"noopener\">微信自带浏览器物理返回不刷新问题</a></p>\n<p>奇怪现象：其他的ios系统下，请求也没有发出去，但是数据是正确的，可能和缓存快照有关系，正常的可能保存了这个页面上次运行的整个数据栈。</p>\n<h3 id=\"移动端滚动穿透问题完美解决方案\"><a href=\"#移动端滚动穿透问题完美解决方案\" class=\"headerlink\" title=\"移动端滚动穿透问题完美解决方案\"></a>移动端滚动穿透问题完美解决方案</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span><span class=\"selector-class\">.modal-open</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当打开modal的时候给body添加<code>modal-open</code>类，fixed让底部页面无法滚动，同时根据页面滚动位置设置top值。<br>在关闭modal时，再让页面恢复之前的滚动状态。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * ModalHelper helpers resolve the modal scrolling issue on mobile devices</span></span><br><span class=\"line\"><span class=\"comment\">  * https://github.com/twbs/bootstrap/issues/15852</span></span><br><span class=\"line\"><span class=\"comment\">  * requires document.scrollingElement polyfill https://github.com/yangg/scrolling-element</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ModalHelper = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">bodyCls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> scrollTop;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    afterOpen: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      scrollTop = <span class=\"built_in\">document</span>.scrollingElement.scrollTop;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.classList.add(bodyCls);</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.style.top = -scrollTop + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    beforeClose: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.classList.remove(bodyCls);</span><br><span class=\"line\">      <span class=\"comment\">// scrollTop lost after set position:fixed, restore it back.</span></span><br><span class=\"line\">      <span class=\"built_in\">document</span>.scrollingElement.scrollTop = scrollTop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;)(<span class=\"string\">'modal-open'</span>);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不简单的自适应高度输入框\"><a href=\"#不简单的自适应高度输入框\" class=\"headerlink\" title=\"不简单的自适应高度输入框\"></a>不简单的自适应高度输入框</h3><p>主要实现代码如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">textarea</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">92px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">line-height</span>: <span class=\"number\">50px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">resize</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">outline</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">    <span class=\"attribute\">font-size</span>: <span class=\"number\">32px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">    overflow: hidden;  //去掉滚动条</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">id</span>=<span class=\"string\">\"textarea\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> $textarea = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'textarea'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> lastLength = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> lastHeight = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$textarea.addEventListener(<span class=\"string\">'input'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentLength = $textarea.value.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断字数如果比之前少了，说明内容正在减少，需要清除高度样式，重新获取</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentLength &lt; lastLength) &#123;</span><br><span class=\"line\">        $textarea.style.height = <span class=\"string\">''</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentHeight = $textarea.scrollHeight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果内容高度发生了变化，再去设置高度值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lastHeight !== currentHeight || !$textarea.style.height) &#123;</span><br><span class=\"line\">        $textarea.style.height = currentHeight + <span class=\"number\">2</span> + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    lastLength = currentLength;</span><br><span class=\"line\">    lastHeight = currentHeight;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>原理是检测textarea.scrollHeight属性变化，并随之设置textarea的高度。</p>\n<p>参考：<a href=\"https://juejin.im/post/5b7653bde51d454dba70c0b1?utm_source=gold_browser_extension\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5b7653bde51d454dba70c0b1?utm_source=gold_browser_extension</a></p>\n<h3 id=\"setTimeout-fun-0\"><a href=\"#setTimeout-fun-0\" class=\"headerlink\" title=\"setTimeout(fun, 0)\"></a>setTimeout(fun, 0)</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    func1();</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">func2();</span><br></pre></td></tr></table></figure>\n<p>func1和func2谁会先执行？很明显func2先执行；<br>setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f,0)，那么会立刻执行吗？<br>答案是不会。因为setTimeout运行机制说过，<strong>必须要等到当前脚本的同步任务和“任务队列”中已有的事件，全部处理完以后，才会执行setTimeout指定的任务</strong>。也就是说，setTimeout的真正作用是，在“任务队列”的现有事件的后面再添加一个事件，规定在指定时间执行某段代码。setTimeout添加的事件，会在下一次Event Loop执行。<br>setTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务——<strong>脚本的同步任务和“任务队列”中已有的事件</strong>，一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Timeout\"</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a() 开始运行\"</span>);</span><br><span class=\"line\">  b(x);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"a() 结束运行\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"b() 开始运行\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"传入的值为\"</span> + y);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"b() 结束运行\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"当前任务开始\"</span>);</span><br><span class=\"line\">a(<span class=\"number\">42</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"当前任务结束\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当前任务开始</span></span><br><span class=\"line\"><span class=\"comment\">// a() 开始运行</span></span><br><span class=\"line\"><span class=\"comment\">// b() 开始运行</span></span><br><span class=\"line\"><span class=\"comment\">// 传入的值为42</span></span><br><span class=\"line\"><span class=\"comment\">// b() 结束运行</span></span><br><span class=\"line\"><span class=\"comment\">// a() 结束运行</span></span><br><span class=\"line\"><span class=\"comment\">// 当前任务结束</span></span><br><span class=\"line\"><span class=\"comment\">// Timeout</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。<br>0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，<strong>最少是4毫秒</strong>。如果小于这个值，会被自动增加到4。这是为了防止多个setTimeout(f,0)语句连续执行，造成性能问题。<br>利用<code>setTimeout(func, 0)</code>可以帮助我们：</p>\n<ul>\n<li>调整函数运行顺序</li>\n<li>分割耗时任务</li>\n</ul>\n<h3 id=\"0-5px边框\"><a href=\"#0-5px边框\" class=\"headerlink\" title=\"0.5px边框\"></a>0.5px边框</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"selector-class\">.scale-1px</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">margin-bottom</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>:none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.scale-1px</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0.5);</span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: left top;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ios系统上active不生效问题\"><a href=\"#ios系统上active不生效问题\" class=\"headerlink\" title=\"ios系统上active不生效问题\"></a>ios系统上active不生效问题</h3><p>在iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。<br>可以采用下面两种方式解决：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">\"touchstart\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ontouchstart</span>=<span class=\"string\">\"\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"beforeunload事件\"><a href=\"#beforeunload事件\" class=\"headerlink\" title=\"beforeunload事件\"></a>beforeunload事件</h3><p>兼容问题：为了优化用户体验，新式浏览器会要求有交互才会触发beforeunload事件，例如新版本的chrome浏览器。<br>PS: 从Firefox 4、 Chrome 51、Opera 38 和Safari 9.1开始，通用确认信息代替事件返回的字符串，即无法通过下面的方式自定义文案。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onbeforeunload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  e = e || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 兼容IE8和Firefox 4之前的版本</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e) &#123;</span><br><span class=\"line\">    e.returnValue = <span class=\"string\">'关闭提示'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'关闭提示'</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>HTML5规范中指出，在该事件中调用window.alert(), window.confirm(), 和 window.prompt()，会被忽略。详细的可参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload\" target=\"_blank\" rel=\"noopener\">MDN</a>。</p>\n"},{"title":"继承&原型链","date":"2018-04-10T09:14:43.000Z","_content":"# 基于__proto__和prototype的原型链\n关于`__proto__`属性，MDN上的解释如下：\n> The __proto__ property of Object.prototype is an accessor property (a getter function and a setter function) that exposes the internal [[Prototype]] (either an object or null) of the object through which it is accessed.\n\n即是说，`__proto__` 属性指向了实例对象的原型Constructor.prototype。\n\n首先用一张图来总结`__proto__`和`prototype`的关系：\n<img src=\"/image/jsobj_full.jpg\" width=\"600px\">\n\n<!-- more -->\n\n## 实例的`__proto__`\n``` js\nfunction Foo() {}\nvar f1 = new Foo();\nf1.__proto__ == Foo.prototype; //true\n```\n通过new方法创建函数Foo的实例f1，`f1.__proto__`会指向`Foo.prototype`，进而继承Foo函数原型上的所有属性和方法。\n在JS中，只有函数有`prototype`属性，基于`prototype`可以去模拟实现类和继承。\n\n### 函数原型和构造器\n``` js\nf1.constructor === Foo.prototype.constructor; //true\nFoo.prototype.constructor === Foo; //true\nf1.constructor === Foo; //true\n```\nf1是Foo的示例，它的`constructor`就是Foo函数原型对象中的`constructor`，而Foo函数原型上的`constructor`就指向函数本身。\n\n\n## 对象的`__proto__`\n``` js\nvar one = {x: 1};\nvar two = new Object();\none.__proto__ === Object.prototype // true\ntwo.__proto__ === Object.prototype // true\none.toString === one.__proto__.toString // true\n```\n不管是隐式还是显式创建的对象，对象的`__proto__`都是`Object.prototype`，Object实际上是一个js函数`function Object(){}`，所以拥有`prototype`属性。`two = new Object()`中Object是构造函数，所以`two.__proto__`就是`Object.prototype`。至于one，ES规范定义对象字面量的原型就是`Object.prototype`。\n``` js\none.constructor === Object.prototype.constructor;\nObject.prototype.constructor === Object;\none.constructor === Object;\n```\n\n## 函数的`__proto__`\n``` js\nFoo.constructor === Function; //true\nFoo.__proto__ === Function.prototype; // true\n```\n函数Foo的构造函数是`function Function(){}`，所以函数Foo的`__proto__`都指向`Function.prototype`。\n``` js\nFunction.__proto__ === Function.prototype; // true\nArray.__proto__ === Function.prototype; // true\nObject.__proto__ === Function.prototype; // true\nString.__proto__ === Function.prototype; // true\n```\n而**Function本身就是函数，所以`Function.__proto__`就是`Function.prototype`，二者为同一对象**。同理，`Object/Array/String`等等构造函数本质上和Function一样，均继承于`Function.prototype`。\n\n## Function.prototype的`__proto__`\n`Function.prototype`直接继承自`Object.prototype`，`Function.prototype.__proto__`就是`Object.prototype`，二者为同一对象。\n``` js\n    Function.prototype.__proto__ === Object.prototype; //true\n    Function.prototype instanceof Object; //true\n    Function.prototype instanceof Function; //false\n```\n通过这点我们可以弄清**继承的原型链：Object.prototype--->Function.prototype--->Function|Object|Array...。**。\n综上所述可以得出：\n``` js\n    Function.__proto__.__proto__ === Object.prototype;\n```\n所以Function是Object的实例\n``` js\n    Function instanceof Object; //true\n```\n此外Object作为函数，继承了`Function.prototype`的方法，所以Object又是Function的实例。\n``` js\n    Object.__proto__ === Function.prototype;\n    Object instanceof Function; //true\n```\n哈哈，二者互为实例，这就是有名的**鸡生蛋和蛋生鸡**的关系。\n\n\n## Object.prototype的`__proto__`\n原型链的尽头（root）是Object.prototype。所有对象均从Object.prototype继承属性。\n``` js\nObject.prototype.__proto__ === null; //true\n```\n\nREFS:\n> [从`__proto__`和prototype来深入理解JS对象和原型链](https://github.com/creeperyang/blog/issues/9)\n> [Javascript Object Layout](http://www.mollypages.org/tutorials/js.mp)\n\n# es6继承\nclass通过extends实现继承，比起es5基于原型链、借用构造函数实现继承方便很多。\n``` js\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n```\n上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。\n这是由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。\n- set的时候，super为this子类实例\n- get的时候，super获取的是A.prototype\n\n大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。\n``` js\nfunction test(){}\ntest.__proto__ = test.constructor.prototype\n```\n\nes6中extends实现的继承，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n``` js\nB.__proto__ === A\nB.prototype.__proto__ === A.prototype\n//对应es5实现\nB.prototype = new A()\n```\n实现继承的关键：\n- 子类B.prototype的`__proto__`属性指向A.prototype，即`B.prototype.__proto__ = A.prototype`，表示将继承父类原型上的属性和方法;\n- 子类B的`__proto__`属性总是指向父类A，即`B.__proto__ = A`，表示将继承父类的静态属性和方法。\n\n这样的结果是因为，类的继承是按照下面的模式实现的。\n``` js\nclass A {}\n\nclass B {}\n\n// B 的实例继承 A 的实例\nObject.setPrototypeOf(B.prototype, A.prototype);\n\n// B 继承 A 的静态属性\nObject.setPrototypeOf(B, A);\n\nconst b = new B();\n```\n\nObject.setPrototypeOf方法的实现，会将proto对象作为obj的原型。\n``` js\nObject.setPrototypeOf = function (obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n```\n本质上，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。\n","source":"_posts/继承-原型链.md","raw":"---\ntitle: 继承&原型链\ndate: 2018-04-10 17:14:43\ntags: [继承, 原型链]\n---\n# 基于__proto__和prototype的原型链\n关于`__proto__`属性，MDN上的解释如下：\n> The __proto__ property of Object.prototype is an accessor property (a getter function and a setter function) that exposes the internal [[Prototype]] (either an object or null) of the object through which it is accessed.\n\n即是说，`__proto__` 属性指向了实例对象的原型Constructor.prototype。\n\n首先用一张图来总结`__proto__`和`prototype`的关系：\n<img src=\"/image/jsobj_full.jpg\" width=\"600px\">\n\n<!-- more -->\n\n## 实例的`__proto__`\n``` js\nfunction Foo() {}\nvar f1 = new Foo();\nf1.__proto__ == Foo.prototype; //true\n```\n通过new方法创建函数Foo的实例f1，`f1.__proto__`会指向`Foo.prototype`，进而继承Foo函数原型上的所有属性和方法。\n在JS中，只有函数有`prototype`属性，基于`prototype`可以去模拟实现类和继承。\n\n### 函数原型和构造器\n``` js\nf1.constructor === Foo.prototype.constructor; //true\nFoo.prototype.constructor === Foo; //true\nf1.constructor === Foo; //true\n```\nf1是Foo的示例，它的`constructor`就是Foo函数原型对象中的`constructor`，而Foo函数原型上的`constructor`就指向函数本身。\n\n\n## 对象的`__proto__`\n``` js\nvar one = {x: 1};\nvar two = new Object();\none.__proto__ === Object.prototype // true\ntwo.__proto__ === Object.prototype // true\none.toString === one.__proto__.toString // true\n```\n不管是隐式还是显式创建的对象，对象的`__proto__`都是`Object.prototype`，Object实际上是一个js函数`function Object(){}`，所以拥有`prototype`属性。`two = new Object()`中Object是构造函数，所以`two.__proto__`就是`Object.prototype`。至于one，ES规范定义对象字面量的原型就是`Object.prototype`。\n``` js\none.constructor === Object.prototype.constructor;\nObject.prototype.constructor === Object;\none.constructor === Object;\n```\n\n## 函数的`__proto__`\n``` js\nFoo.constructor === Function; //true\nFoo.__proto__ === Function.prototype; // true\n```\n函数Foo的构造函数是`function Function(){}`，所以函数Foo的`__proto__`都指向`Function.prototype`。\n``` js\nFunction.__proto__ === Function.prototype; // true\nArray.__proto__ === Function.prototype; // true\nObject.__proto__ === Function.prototype; // true\nString.__proto__ === Function.prototype; // true\n```\n而**Function本身就是函数，所以`Function.__proto__`就是`Function.prototype`，二者为同一对象**。同理，`Object/Array/String`等等构造函数本质上和Function一样，均继承于`Function.prototype`。\n\n## Function.prototype的`__proto__`\n`Function.prototype`直接继承自`Object.prototype`，`Function.prototype.__proto__`就是`Object.prototype`，二者为同一对象。\n``` js\n    Function.prototype.__proto__ === Object.prototype; //true\n    Function.prototype instanceof Object; //true\n    Function.prototype instanceof Function; //false\n```\n通过这点我们可以弄清**继承的原型链：Object.prototype--->Function.prototype--->Function|Object|Array...。**。\n综上所述可以得出：\n``` js\n    Function.__proto__.__proto__ === Object.prototype;\n```\n所以Function是Object的实例\n``` js\n    Function instanceof Object; //true\n```\n此外Object作为函数，继承了`Function.prototype`的方法，所以Object又是Function的实例。\n``` js\n    Object.__proto__ === Function.prototype;\n    Object instanceof Function; //true\n```\n哈哈，二者互为实例，这就是有名的**鸡生蛋和蛋生鸡**的关系。\n\n\n## Object.prototype的`__proto__`\n原型链的尽头（root）是Object.prototype。所有对象均从Object.prototype继承属性。\n``` js\nObject.prototype.__proto__ === null; //true\n```\n\nREFS:\n> [从`__proto__`和prototype来深入理解JS对象和原型链](https://github.com/creeperyang/blog/issues/9)\n> [Javascript Object Layout](http://www.mollypages.org/tutorials/js.mp)\n\n# es6继承\nclass通过extends实现继承，比起es5基于原型链、借用构造函数实现继承方便很多。\n``` js\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n```\n上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。\n这是由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。\n- set的时候，super为this子类实例\n- get的时候，super获取的是A.prototype\n\n大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。\n``` js\nfunction test(){}\ntest.__proto__ = test.constructor.prototype\n```\n\nes6中extends实现的继承，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n``` js\nB.__proto__ === A\nB.prototype.__proto__ === A.prototype\n//对应es5实现\nB.prototype = new A()\n```\n实现继承的关键：\n- 子类B.prototype的`__proto__`属性指向A.prototype，即`B.prototype.__proto__ = A.prototype`，表示将继承父类原型上的属性和方法;\n- 子类B的`__proto__`属性总是指向父类A，即`B.__proto__ = A`，表示将继承父类的静态属性和方法。\n\n这样的结果是因为，类的继承是按照下面的模式实现的。\n``` js\nclass A {}\n\nclass B {}\n\n// B 的实例继承 A 的实例\nObject.setPrototypeOf(B.prototype, A.prototype);\n\n// B 继承 A 的静态属性\nObject.setPrototypeOf(B, A);\n\nconst b = new B();\n```\n\nObject.setPrototypeOf方法的实现，会将proto对象作为obj的原型。\n``` js\nObject.setPrototypeOf = function (obj, proto) {\n  obj.__proto__ = proto;\n  return obj;\n}\n```\n本质上，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。\n","slug":"继承-原型链","published":1,"updated":"2019-03-18T02:27:14.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx750018qmhf57tqrzeq","content":"<h1 id=\"基于proto和prototype的原型链\"><a href=\"#基于proto和prototype的原型链\" class=\"headerlink\" title=\"基于proto和prototype的原型链\"></a>基于<strong>proto</strong>和prototype的原型链</h1><p>关于<code>__proto__</code>属性，MDN上的解释如下：</p>\n<blockquote>\n<p>The <strong>proto</strong> property of Object.prototype is an accessor property (a getter function and a setter function) that exposes the internal [[Prototype]] (either an object or null) of the object through which it is accessed.</p>\n</blockquote>\n<p>即是说，<code>__proto__</code> 属性指向了实例对象的原型Constructor.prototype。</p>\n<p>首先用一张图来总结<code>__proto__</code>和<code>prototype</code>的关系：<br><img src=\"/image/jsobj_full.jpg\" width=\"600px\"></p>\n<a id=\"more\"></a>\n<h2 id=\"实例的-proto\"><a href=\"#实例的-proto\" class=\"headerlink\" title=\"实例的__proto__\"></a>实例的<code>__proto__</code></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">f1.__proto__ == Foo.prototype; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>通过new方法创建函数Foo的实例f1，<code>f1.__proto__</code>会指向<code>Foo.prototype</code>，进而继承Foo函数原型上的所有属性和方法。<br>在JS中，只有函数有<code>prototype</code>属性，基于<code>prototype</code>可以去模拟实现类和继承。</p>\n<h3 id=\"函数原型和构造器\"><a href=\"#函数原型和构造器\" class=\"headerlink\" title=\"函数原型和构造器\"></a>函数原型和构造器</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.constructor === Foo.prototype.constructor; <span class=\"comment\">//true</span></span><br><span class=\"line\">Foo.prototype.constructor === Foo; <span class=\"comment\">//true</span></span><br><span class=\"line\">f1.constructor === Foo; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>f1是Foo的示例，它的<code>constructor</code>就是Foo函数原型对象中的<code>constructor</code>，而Foo函数原型上的<code>constructor</code>就指向函数本身。</p>\n<h2 id=\"对象的-proto\"><a href=\"#对象的-proto\" class=\"headerlink\" title=\"对象的__proto__\"></a>对象的<code>__proto__</code></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> one = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> two = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">one.__proto__ === <span class=\"built_in\">Object</span>.prototype <span class=\"comment\">// true</span></span><br><span class=\"line\">two.__proto__ === <span class=\"built_in\">Object</span>.prototype <span class=\"comment\">// true</span></span><br><span class=\"line\">one.toString === one.__proto__.toString <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>不管是隐式还是显式创建的对象，对象的<code>__proto__</code>都是<code>Object.prototype</code>，Object实际上是一个js函数<code>function Object(){}</code>，所以拥有<code>prototype</code>属性。<code>two = new Object()</code>中Object是构造函数，所以<code>two.__proto__</code>就是<code>Object.prototype</code>。至于one，ES规范定义对象字面量的原型就是<code>Object.prototype</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one.constructor === <span class=\"built_in\">Object</span>.prototype.constructor;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.constructor === <span class=\"built_in\">Object</span>;</span><br><span class=\"line\">one.constructor === <span class=\"built_in\">Object</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数的-proto\"><a href=\"#函数的-proto\" class=\"headerlink\" title=\"函数的__proto__\"></a>函数的<code>__proto__</code></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.constructor === <span class=\"built_in\">Function</span>; <span class=\"comment\">//true</span></span><br><span class=\"line\">Foo.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>函数Foo的构造函数是<code>function Function(){}</code>，所以函数Foo的<code>__proto__</code>都指向<code>Function.prototype</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>而<strong>Function本身就是函数，所以<code>Function.__proto__</code>就是<code>Function.prototype</code>，二者为同一对象</strong>。同理，<code>Object/Array/String</code>等等构造函数本质上和Function一样，均继承于<code>Function.prototype</code>。</p>\n<h2 id=\"Function-prototype的-proto\"><a href=\"#Function-prototype的-proto\" class=\"headerlink\" title=\"Function.prototype的__proto__\"></a>Function.prototype的<code>__proto__</code></h2><p><code>Function.prototype</code>直接继承自<code>Object.prototype</code>，<code>Function.prototype.__proto__</code>就是<code>Object.prototype</code>，二者为同一对象。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>; <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>; <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>通过这点我们可以弄清<strong>继承的原型链：Object.prototype—&gt;Function.prototype—&gt;Function|Object|Array…。</strong>。<br>综上所述可以得出：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.__proto__.__proto__ === <span class=\"built_in\">Object</span>.prototype;</span><br></pre></td></tr></table></figure></p>\n<p>所以Function是Object的实例<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>此外Object作为函数，继承了<code>Function.prototype</code>的方法，所以Object又是Function的实例。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype;</span><br><span class=\"line\"><span class=\"built_in\">Object</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>哈哈，二者互为实例，这就是有名的<strong>鸡生蛋和蛋生鸡</strong>的关系。</p>\n<h2 id=\"Object-prototype的-proto\"><a href=\"#Object-prototype的-proto\" class=\"headerlink\" title=\"Object.prototype的__proto__\"></a>Object.prototype的<code>__proto__</code></h2><p>原型链的尽头（root）是Object.prototype。所有对象均从Object.prototype继承属性。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__ === <span class=\"literal\">null</span>; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>REFS:</p>\n<blockquote>\n<p><a href=\"https://github.com/creeperyang/blog/issues/9\" target=\"_blank\" rel=\"noopener\">从<code>__proto__</code>和prototype来深入理解JS对象和原型链</a><br><a href=\"http://www.mollypages.org/tutorials/js.mp\" target=\"_blank\" rel=\"noopener\">Javascript Object Layout</a></p>\n</blockquote>\n<h1 id=\"es6继承\"><a href=\"#es6继承\" class=\"headerlink\" title=\"es6继承\"></a>es6继承</h1><p>class通过extends实现继承，比起es5基于原型链、借用构造函数实现继承方便很多。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.x = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">super</span>.x); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。<br>这是由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。</p>\n<ul>\n<li>set的时候，super为this子类实例</li>\n<li>get的时候，super获取的是A.prototype</li>\n</ul>\n<p>大多数浏览器的 ES5 实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">test.__proto__ = test.constructor.prototype</span><br></pre></td></tr></table></figure></p>\n<p>es6中extends实现的继承，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">B.__proto__ === A</span><br><span class=\"line\">B.prototype.__proto__ === A.prototype</span><br><span class=\"line\"><span class=\"comment\">//对应es5实现</span></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A()</span><br></pre></td></tr></table></figure></p>\n<p>实现继承的关键：</p>\n<ul>\n<li>子类B.prototype的<code>__proto__</code>属性指向A.prototype，即<code>B.prototype.__proto__ = A.prototype</code>，表示将继承父类原型上的属性和方法;</li>\n<li>子类B的<code>__proto__</code>属性总是指向父类A，即<code>B.__proto__ = A</code>，表示将继承父类的静态属性和方法。</li>\n</ul>\n<p>这样的结果是因为，类的继承是按照下面的模式实现的。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B 的实例继承 A 的实例</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B 继承 A 的静态属性</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(B, A);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> B();</span><br></pre></td></tr></table></figure></p>\n<p>Object.setPrototypeOf方法的实现，会将proto对象作为obj的原型。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj, proto</span>) </span>&#123;</span><br><span class=\"line\">  obj.__proto__ = proto;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>本质上，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"基于proto和prototype的原型链\"><a href=\"#基于proto和prototype的原型链\" class=\"headerlink\" title=\"基于proto和prototype的原型链\"></a>基于<strong>proto</strong>和prototype的原型链</h1><p>关于<code>__proto__</code>属性，MDN上的解释如下：</p>\n<blockquote>\n<p>The <strong>proto</strong> property of Object.prototype is an accessor property (a getter function and a setter function) that exposes the internal [[Prototype]] (either an object or null) of the object through which it is accessed.</p>\n</blockquote>\n<p>即是说，<code>__proto__</code> 属性指向了实例对象的原型Constructor.prototype。</p>\n<p>首先用一张图来总结<code>__proto__</code>和<code>prototype</code>的关系：<br><img src=\"/image/jsobj_full.jpg\" width=\"600px\"></p>","more":"<h2 id=\"实例的-proto\"><a href=\"#实例的-proto\" class=\"headerlink\" title=\"实例的__proto__\"></a>实例的<code>__proto__</code></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f1 = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">f1.__proto__ == Foo.prototype; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>通过new方法创建函数Foo的实例f1，<code>f1.__proto__</code>会指向<code>Foo.prototype</code>，进而继承Foo函数原型上的所有属性和方法。<br>在JS中，只有函数有<code>prototype</code>属性，基于<code>prototype</code>可以去模拟实现类和继承。</p>\n<h3 id=\"函数原型和构造器\"><a href=\"#函数原型和构造器\" class=\"headerlink\" title=\"函数原型和构造器\"></a>函数原型和构造器</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1.constructor === Foo.prototype.constructor; <span class=\"comment\">//true</span></span><br><span class=\"line\">Foo.prototype.constructor === Foo; <span class=\"comment\">//true</span></span><br><span class=\"line\">f1.constructor === Foo; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>f1是Foo的示例，它的<code>constructor</code>就是Foo函数原型对象中的<code>constructor</code>，而Foo函数原型上的<code>constructor</code>就指向函数本身。</p>\n<h2 id=\"对象的-proto\"><a href=\"#对象的-proto\" class=\"headerlink\" title=\"对象的__proto__\"></a>对象的<code>__proto__</code></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> one = &#123;<span class=\"attr\">x</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> two = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">one.__proto__ === <span class=\"built_in\">Object</span>.prototype <span class=\"comment\">// true</span></span><br><span class=\"line\">two.__proto__ === <span class=\"built_in\">Object</span>.prototype <span class=\"comment\">// true</span></span><br><span class=\"line\">one.toString === one.__proto__.toString <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>不管是隐式还是显式创建的对象，对象的<code>__proto__</code>都是<code>Object.prototype</code>，Object实际上是一个js函数<code>function Object(){}</code>，所以拥有<code>prototype</code>属性。<code>two = new Object()</code>中Object是构造函数，所以<code>two.__proto__</code>就是<code>Object.prototype</code>。至于one，ES规范定义对象字面量的原型就是<code>Object.prototype</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one.constructor === <span class=\"built_in\">Object</span>.prototype.constructor;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.constructor === <span class=\"built_in\">Object</span>;</span><br><span class=\"line\">one.constructor === <span class=\"built_in\">Object</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数的-proto\"><a href=\"#函数的-proto\" class=\"headerlink\" title=\"函数的__proto__\"></a>函数的<code>__proto__</code></h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.constructor === <span class=\"built_in\">Function</span>; <span class=\"comment\">//true</span></span><br><span class=\"line\">Foo.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<p>函数Foo的构造函数是<code>function Function(){}</code>，所以函数Foo的<code>__proto__</code>都指向<code>Function.prototype</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">String</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>而<strong>Function本身就是函数，所以<code>Function.__proto__</code>就是<code>Function.prototype</code>，二者为同一对象</strong>。同理，<code>Object/Array/String</code>等等构造函数本质上和Function一样，均继承于<code>Function.prototype</code>。</p>\n<h2 id=\"Function-prototype的-proto\"><a href=\"#Function-prototype的-proto\" class=\"headerlink\" title=\"Function.prototype的__proto__\"></a>Function.prototype的<code>__proto__</code></h2><p><code>Function.prototype</code>直接继承自<code>Object.prototype</code>，<code>Function.prototype.__proto__</code>就是<code>Object.prototype</code>，二者为同一对象。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.__proto__ === <span class=\"built_in\">Object</span>.prototype; <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>; <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>; <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>通过这点我们可以弄清<strong>继承的原型链：Object.prototype—&gt;Function.prototype—&gt;Function|Object|Array…。</strong>。<br>综上所述可以得出：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.__proto__.__proto__ === <span class=\"built_in\">Object</span>.prototype;</span><br></pre></td></tr></table></figure></p>\n<p>所以Function是Object的实例<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>此外Object作为函数，继承了<code>Function.prototype</code>的方法，所以Object又是Function的实例。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.__proto__ === <span class=\"built_in\">Function</span>.prototype;</span><br><span class=\"line\"><span class=\"built_in\">Object</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>哈哈，二者互为实例，这就是有名的<strong>鸡生蛋和蛋生鸡</strong>的关系。</p>\n<h2 id=\"Object-prototype的-proto\"><a href=\"#Object-prototype的-proto\" class=\"headerlink\" title=\"Object.prototype的__proto__\"></a>Object.prototype的<code>__proto__</code></h2><p>原型链的尽头（root）是Object.prototype。所有对象均从Object.prototype继承属性。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__ === <span class=\"literal\">null</span>; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>REFS:</p>\n<blockquote>\n<p><a href=\"https://github.com/creeperyang/blog/issues/9\" target=\"_blank\" rel=\"noopener\">从<code>__proto__</code>和prototype来深入理解JS对象和原型链</a><br><a href=\"http://www.mollypages.org/tutorials/js.mp\" target=\"_blank\" rel=\"noopener\">Javascript Object Layout</a></p>\n</blockquote>\n<h1 id=\"es6继承\"><a href=\"#es6继承\" class=\"headerlink\" title=\"es6继承\"></a>es6继承</h1><p>class通过extends实现继承，比起es5基于原型链、借用构造函数实现继承方便很多。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.x = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">super</span>.x); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x); <span class=\"comment\">// 3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"keyword\">new</span> B();</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。<br>这是由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。</p>\n<ul>\n<li>set的时候，super为this子类实例</li>\n<li>get的时候，super获取的是A.prototype</li>\n</ul>\n<p>大多数浏览器的 ES5 实现之中，每一个对象都有<strong>proto</strong>属性，指向对应的构造函数的prototype属性。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">test.__proto__ = test.constructor.prototype</span><br></pre></td></tr></table></figure></p>\n<p>es6中extends实现的继承，同时有prototype属性和<strong>proto</strong>属性，因此同时存在两条继承链。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">B.__proto__ === A</span><br><span class=\"line\">B.prototype.__proto__ === A.prototype</span><br><span class=\"line\"><span class=\"comment\">//对应es5实现</span></span><br><span class=\"line\">B.prototype = <span class=\"keyword\">new</span> A()</span><br></pre></td></tr></table></figure></p>\n<p>实现继承的关键：</p>\n<ul>\n<li>子类B.prototype的<code>__proto__</code>属性指向A.prototype，即<code>B.prototype.__proto__ = A.prototype</code>，表示将继承父类原型上的属性和方法;</li>\n<li>子类B的<code>__proto__</code>属性总是指向父类A，即<code>B.__proto__ = A</code>，表示将继承父类的静态属性和方法。</li>\n</ul>\n<p>这样的结果是因为，类的继承是按照下面的模式实现的。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B 的实例继承 A 的实例</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// B 继承 A 的静态属性</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf(B, A);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> B();</span><br></pre></td></tr></table></figure></p>\n<p>Object.setPrototypeOf方法的实现，会将proto对象作为obj的原型。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.setPrototypeOf = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj, proto</span>) </span>&#123;</span><br><span class=\"line\">  obj.__proto__ = proto;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>本质上，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。</p>"},{"title":"JS函数式编程笔记(下)","date":"2018-07-13T03:20:08.000Z","_content":"# 示例应用\n### 声明式编程\n- 命令式编程（imperative）：喜欢大量使用可变对象和指令，我们总是习惯于创建对象或者变量，并且修改它们的状态或者值，或者喜欢提供一系列指令，要求程序执行。\n- 声明式编程（Declarative）：对于声明式的编程范式，你不在需要提供明确的指令操作，所有的细节指令将会更好的被程序库所封装，你要做的只是提出你要的要求，声明你的用意即可。\n与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。`SQL`是典型的声明式编程，明确指出想要什么(what)，而不是如何实现(how)。\n``` js\n// 命令式\nvar makes = [];\nfor (i = 0; i < cars.length; i++) {\n  makes.push(cars[i].make);\n}\n\n\n// 声明式\nvar makes = cars.map(function(car){ return car.make; });\n```\n上述命令式编程要求先声明一个数组，再去遍历，然后执行循环中具体的方法。\n使用`map`的版本是一个表达式，它对执行顺序没有要求,它指明的是做什么，不是怎么做。\n\n\n\nREFS:\n[声明式编程和命令式编程的比较](http://www.aqee.net/post/imperative-vs-declarative.html)\n\n# Hindley-Milner 类型签名\n> 类型签名在写纯函数时所起的作用非常大，短短一行，就能暴露函数的行为和目的。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。\nJavaScript 也有一些类型检查工具，比如 [Flow](http://flowtype.org/)，或者它的静态类型方言 [TypeScript](http://www.typescriptlang.org/) 。\n\n### 举个栗子\n``` js\n//  capitalize :: String -> String\nvar capitalize = function(s){\n  return toUpperCase(head(s)) + toLowerCase(tail(s));\n}\ncapitalize(\"smurf\");\n//=> \"Smurf\"\n```\n从类型签名来看，`capitalize`方法接收了一个`String`，最终也返回了一个`String`。\n\n对于柯里化后的函数，对类型的签名可以有不同的理解：\n``` js\n//  match :: Regex -> String -> [String]\nvar match = curry(function(reg, s){\n  return s.match(reg);\n});\n```\n- 一种思路是接收`Regex`和`String`两种类型参数，返回一个`[String]`\n- 另一种思路是`match :: Regex -> (String -> [String])`，先接收了一个`Regex`参数，返回一个新的函数，该函数接收`String`并返回一个`[String]`。\n\n### 再举个栗子\n``` js\n//  reduce :: (b -> a -> b) -> b -> [a] -> b\nvar reduce = curry(function(f, x, xs){\n  return xs.reduce(f, x);\n});\n```\n约定俗成，a、b可以是任一种类型，但相同的字母`a`代表同一类型。其中`(b -> a -> b)`约定了函数的类型签名：\n- `b`是传入f的累加器（初始值是括号后面的`-> b`）;\n- `a`是遍历`[a]`得到的`currentValue`;\n- `f`返回的类型是`b`，最终`reduce`方法返回的类型也就是`f`的返回。\n**类型签名的美妙之处在于明确告诉我们函数做了什么**\n\n### 缩小可能性范围\n大多数语言都有范型(也成为参数多态性)，其中函数是通过一个或多个抽象类型定义的。\n``` js\n// head :: [a] -> a\n```\n引入了类型签名后，可以缩小`head`函数的可能范围，a可以是任意类型的参数，即多态性(polymorphism)，对于任意类型的参数都要支持`[a] -> a`的映射，可以帮助我们缩小函数可能性的范围。\n我们甚至可以用`[a] -> a`去到类型签名搜索引擎里面搜索我们需要的函数，详细移步到[Hoogle](https://www.haskell.org/hoogle/)去尝试，很有意思。\n\n### 自由定理\n```js\n// head :: [a] -> a\ncompose(f, head) == compose(head, map(f));\n```\n等式左边说的是，先获取数组的头部，然后对它调用函数 f；等式右边说的是，先对数组中的每一个元素调用 f，然后再取其返回结果的头部。这两个表达式的作用是相等的，但是前者要快得多。\n可以得到一个普适的道理：如果你映射某个函数到列表上，然后对其应用 `f`，其等同于对映射应用 `f`。\n数学提供的这种形式化方法，可以帮助计算机去进行类似的代码优化。\n\n### 类型约束\n``` js\n// sort :: Ord a => [a] -> [a]\n```\n签名也可以把类型约束为一个特定的接口（interface），a必须是`Ord`对象，在强类型语言中，可以是一个自定义的接口。\n\n# 特百惠\n### 容器\n为什么叫特百惠呢？因为特百惠是一个家居品品牌，代表产品是容器。\n``` js\nvar Container = function(x) {\n  this.__value = x;\n}\n\nContainer.of = function(x) { return new Container(x); };\n```\n使用`Container.of`作为构造器，暂且认为它是把值放到容器里的一种方式。\n\n### 第一个 functor\n容器中有了值之后，我们需要一种方式来操作容器中的值：\n``` js\n// (a -> b) -> Container a -> Container b\nContainer.prototype.map = function(f){\n  return Container.of(f(this.__value))\n}\n```\n这个`map`跟数组那个著名的`map`一样，除了前者的参数是`Container a`而后者是`[a]`。它们的使用方式也几乎一致：\n``` js\nContainer.of(2).map(function(two){ return two + 2 })\n//=> Container(4)\n\n\nContainer.of(\"flamethrowers\").map(function(s){ return s.toUpperCase() })\n//=> Container(\"FLAMETHROWERS\")\n\n\nContainer.of(\"bombs\").map(concat(' away')).map(_.prop('length'))\n//=> Container(10)\n```\nContainer将值传给map后，通过`f`方法，我们可以对值进行任意操作，操作结束后再放入`Container`中并返回，这样就可以连续对容器中的值进行操作。这样一直调用`map`的形式，不就是前面提到的组合么。\n这里面起作用的**数学魔法**就是`functor`(函子):\n> functor 是实现了`map`函数并遵守一些特定规则的容器类型。\n\n为什么要使用`functor`这种方式来处理呢？\n> 即让容器自己去运用函数能给我们带来什么好处？书中给出的答案是抽象——对于函数运用的抽象。\n\n### 薛定谔的 Maybe\n定义另外一个`functor`，同样实现了`map`函数的、类似容器的数据类型`Maybe'。\n``` js\nvar Maybe = function(x) {\n  this.__value = x;\n}\n\nMaybe.of = function(x) {\n  return new Maybe(x);\n}\n\nMaybe.prototype.isNothing = function() {\n  return (this.__value === null || this.__value === undefined);\n}\n\nMaybe.prototype.map = function(f) {\n  return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));\n}\n```\n`Maybe`和`Container`的不同点就是它新增了一个`isNothing`，在每次调用函数前，先检查它自己的值是否为空。\n\n``` js\nMaybe.of(\"Malkovich Malkovich\").map(match(/a/ig));\n//=> this._value = match(/a/ig)(\"\"Malkovich Malkovich\"\")\n//=> Maybe(['a', 'a'])\n\nMaybe.of(null).map(match(/a/ig));\n//=> Maybe(null)\n```\n点记法（dot notation syntax）已经足够函数式了，但我们更想保持一种 pointfree 的风格。碰巧的是，`map`完全有能力以`curry`函数的方式来“代理”任何 functor，柯里化后就可以方便地使用`compose`了：\n``` js\n//  map :: Functor f => (a -> b) -> f a -> f b\nvar map = curry(function(f, any_functor_at_all) {\n  return any_functor_at_all.map(f);\n});\n```\n结合前面提到的类型签名，首先约束了f是Functor类型，去掉类型约束后签名是`(a -> b) -> f a -> f b`，可以看出传入的参数是一个函数`f`: (a -> b)，一个`functor`: f a，最后返回一个`functor`: f b。\n这个方法可以帮助我们取出容器中的值，可以参考下面的例子：\n``` js\n//  safeHead :: [a] -> Maybe(a)\nvar safeHead = function(xs) {\n  return Maybe.of(xs[0]); // this.__value = xs[0]\n};\n\nvar streetName = compose(map(_.prop('street')), safeHead, _.prop('addresses'));\n\nstreetName({addresses: []});\n// Maybe(null)\n\nstreetName({addresses: [{street: \"Shady Ln.\", number: 4201}]});\n// Maybe(\"Shady Ln.\")\n```\nsafeHead返回了一个Maybe对象（eg2：Maybe({street: \"Shady Ln.\", number: 4201})），要想对隐藏在Maybe容器中的值进行操作，需要借助`map`函数来操作，通过调用该对象的map函数，传入`_.prop('street')`函数，对`this.__value`进行操作，返回一个新的Maybe对象（eg2: Maybe(\"Shady Ln.\")）。\n\n### “纯”错误处理\n`Maybe`实现了空和非空两种类型的分开处理，利用这种思想，我们可以对错误进行更友好、健壮地处理。\n用一个简单的例子示意一下：\n``` js\nvar Left = function(x) {\n  this.__value = x;\n}\n\nLeft.of = function(x) {\n  return new Left(x);\n}\n\nLeft.prototype.map = function(f) {\n  return this;\n}\n\nvar Right = function(x) {\n  this.__value = x;\n}\n\nRight.of = function(x) {\n  return new Right(x);\n}\n\nRight.prototype.map = function(f) {\n  return Right.of(f(this.__value));\n}\n```\n\n``` js\nvar moment = require('moment');\n\n//  getAge :: Date -> User -> Either(String, Number)\nvar getAge = curry(function(now, user) {\n  var birthdate = moment(user.birthdate, 'YYYY-MM-DD');\n  if(!birthdate.isValid()) return Left.of(\"Birth date could not be parsed\");\n  return Right.of(now.diff(birthdate, 'years'));\n});\n\ngetAge(moment(), {birthdate: '2005-12-12'});\n// Right(9)\n\ngetAge(moment(), {birthdate: '20010704'});\n// Left(\"Birth date could not be parsed\")\n```\n其中Left用来处理错误状态，Right用来处理正常情况。\n\n### Old McDonald had Effects...\n在纯函数那一章，通过将不纯的函数包裹在另一个函数中，使得它看起来像个纯函数。类似的例子：\n``` js\n//  getFromStorage :: String -> (_ -> String)\nvar getFromStorage = function(key) {\n  return function() {\n    return localStorage[key];\n  }\n}\n```\n这儿将`getFromStorage`改造成，相同的输入key总会对应相同的输出：一个从`localStorage`里取出某个特定元素的函数。（然而，感觉并没什么用啊= =）\n\n``` js\nvar IO = function(f) {\n  this.__value = f; //f总是一个函数\n}\n\nIO.of = function(x) {\n  return new IO(function() {\n    return x;\n  });\n}\n\nIO.prototype.map = function(f) {\n  //这儿和Maybe.of(f(this.__value))实现效果一致\n  return new IO(_.compose(f, this.__value));\n}\n```\n`IO(function(){ return x })`仅仅是为了延迟执行，其实我们得到的是 IO(x)。\n\n实际使用的时候：\n``` js\n////// 纯代码库: lib/params.js ///////\n\n//  url :: IO String\nvar url = new IO(function() { return window.location.href; });\n\n//  toPairs =  String -> [[String]]\nvar toPairs = compose(map(split('=')), split('&'));\n\n//  params :: String -> [[String]]\nvar params = compose(toPairs, last, split('?'));\n\n//  findParam :: String -> IO Maybe [String]\nvar findParam = function(key) {\n  return map(compose(Maybe.of, filter(compose(eq(key), head)), params), url);\n};\n\n////// 非纯调用代码: main.js ///////\n\n// 调用 __value() 来运行它！\nfindParam(\"searchTerm\").__value();\n// Maybe(['searchTerm', 'wafflehouse'])\n```\n本质上是将逻辑分成了**纯代码库**和**非纯调用代码**两部分，纯代码库最后生成的函数是唯一的，最后的风险都放在了调用者身上。\n`__value`的命名并不合理，`__value`的调用会触发前面已压栈的所有操作，替换为`unsafePerformIO`更能提醒用户它的变化无常。\n\nfunctor 的概念来自于范畴学，并满足一些定律。\n``` js\n// identity\nmap(id) === id;\n\n// composition\ncompose(map(f), map(g)) === map(compose(f, g));\n```\n\n# Monad\n### pointed functor\n`of`方法并不是用来避免使用`new`关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。`pointed functor`就是实现了`of`方法的Functor。\n**默认最小化上下文是什么？**\n> TODO\n> \n### 混合比喻\n``` js\n// Support\n// ===========================\nvar fs = require('fs');\n\n//  readFile :: String -> IO String\nvar readFile = function(filename) {\n  return new IO(function() {\n    return fs.readFileSync(filename, 'utf-8');\n  });\n};\n\n//  print :: String -> IO String\nvar print = function(x) {\n  return new IO(function() {\n    console.log(x);\n    return x;\n  });\n}\n\n// Example\n// ===========================\n//  cat :: IO (IO String)\nvar cat = compose(map(print), readFile);\n\ncat(\".git/config\")\n// IO(IO(\"[core]\\nrepositoryformatversion = 0\\n\"))\n```\n最后返回了一个嵌套两层的`IO`对象，如果想要再次调用，对其中的值进行处理，则需要`map(map(f))`；像是穿着两套防护服在工作，很奇怪。\n``` js\nMaybe.prototype.join = function() {\n  return this.isNothing() ? Maybe.of(null) : this.__value;\n}\n\nvar mmo = Maybe.of(Maybe.of(\"nunchucks\"));\n// Maybe(Maybe(\"nunchucks\"))\n\nmmo.join();\n// Maybe(\"nunchucks\")\n\n```\n定义一个`join`方法，可以帮助我们简单地移除一层嵌套，在使用的时候，我们可以在每个map后面，都调用一次join方法，但是我们期望的不止如此。\n```js\n//  join :: Monad m => m (m a) -> m a\nvar join = function(mma){ return mma.join(); }\n\n//  firstAddressStreet :: User -> Maybe Street\nvar firstAddressStreet = compose(\n  join, map(safeProp('street')), join, map(safeHead), safeProp('addresses')\n);\n```\n\n### chain函数\n把`map`和`join`封装成chain函数，则`firstAddressStreet`方法可以改写成：\n``` js\n//  chain :: Monad m => (a -> m b) -> m a -> m b\nvar chain = curry(function(f, m){\n  return m.map(f).join(); // 或者 compose(join, map(f))(m)\n});\n\n//  firstAddressStreet :: User -> Maybe Street\nvar firstAddressStreet = compose(\n  chain(safeProp('street')), chain(safeHead), safeProp('addresses')\n);\n```\n> 简单说，Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。\n\nREFS:\n[图解 Monad](http://www.ruanyifeng.com/blog/2015/07/monad.html)\n\n","source":"_posts/JS函数式编程笔记(下).md","raw":"---\ntitle: JS函数式编程笔记(下)\ndate: 2018-07-13 11:20:08\ntags:\n---\n# 示例应用\n### 声明式编程\n- 命令式编程（imperative）：喜欢大量使用可变对象和指令，我们总是习惯于创建对象或者变量，并且修改它们的状态或者值，或者喜欢提供一系列指令，要求程序执行。\n- 声明式编程（Declarative）：对于声明式的编程范式，你不在需要提供明确的指令操作，所有的细节指令将会更好的被程序库所封装，你要做的只是提出你要的要求，声明你的用意即可。\n与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。`SQL`是典型的声明式编程，明确指出想要什么(what)，而不是如何实现(how)。\n``` js\n// 命令式\nvar makes = [];\nfor (i = 0; i < cars.length; i++) {\n  makes.push(cars[i].make);\n}\n\n\n// 声明式\nvar makes = cars.map(function(car){ return car.make; });\n```\n上述命令式编程要求先声明一个数组，再去遍历，然后执行循环中具体的方法。\n使用`map`的版本是一个表达式，它对执行顺序没有要求,它指明的是做什么，不是怎么做。\n\n\n\nREFS:\n[声明式编程和命令式编程的比较](http://www.aqee.net/post/imperative-vs-declarative.html)\n\n# Hindley-Milner 类型签名\n> 类型签名在写纯函数时所起的作用非常大，短短一行，就能暴露函数的行为和目的。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。\nJavaScript 也有一些类型检查工具，比如 [Flow](http://flowtype.org/)，或者它的静态类型方言 [TypeScript](http://www.typescriptlang.org/) 。\n\n### 举个栗子\n``` js\n//  capitalize :: String -> String\nvar capitalize = function(s){\n  return toUpperCase(head(s)) + toLowerCase(tail(s));\n}\ncapitalize(\"smurf\");\n//=> \"Smurf\"\n```\n从类型签名来看，`capitalize`方法接收了一个`String`，最终也返回了一个`String`。\n\n对于柯里化后的函数，对类型的签名可以有不同的理解：\n``` js\n//  match :: Regex -> String -> [String]\nvar match = curry(function(reg, s){\n  return s.match(reg);\n});\n```\n- 一种思路是接收`Regex`和`String`两种类型参数，返回一个`[String]`\n- 另一种思路是`match :: Regex -> (String -> [String])`，先接收了一个`Regex`参数，返回一个新的函数，该函数接收`String`并返回一个`[String]`。\n\n### 再举个栗子\n``` js\n//  reduce :: (b -> a -> b) -> b -> [a] -> b\nvar reduce = curry(function(f, x, xs){\n  return xs.reduce(f, x);\n});\n```\n约定俗成，a、b可以是任一种类型，但相同的字母`a`代表同一类型。其中`(b -> a -> b)`约定了函数的类型签名：\n- `b`是传入f的累加器（初始值是括号后面的`-> b`）;\n- `a`是遍历`[a]`得到的`currentValue`;\n- `f`返回的类型是`b`，最终`reduce`方法返回的类型也就是`f`的返回。\n**类型签名的美妙之处在于明确告诉我们函数做了什么**\n\n### 缩小可能性范围\n大多数语言都有范型(也成为参数多态性)，其中函数是通过一个或多个抽象类型定义的。\n``` js\n// head :: [a] -> a\n```\n引入了类型签名后，可以缩小`head`函数的可能范围，a可以是任意类型的参数，即多态性(polymorphism)，对于任意类型的参数都要支持`[a] -> a`的映射，可以帮助我们缩小函数可能性的范围。\n我们甚至可以用`[a] -> a`去到类型签名搜索引擎里面搜索我们需要的函数，详细移步到[Hoogle](https://www.haskell.org/hoogle/)去尝试，很有意思。\n\n### 自由定理\n```js\n// head :: [a] -> a\ncompose(f, head) == compose(head, map(f));\n```\n等式左边说的是，先获取数组的头部，然后对它调用函数 f；等式右边说的是，先对数组中的每一个元素调用 f，然后再取其返回结果的头部。这两个表达式的作用是相等的，但是前者要快得多。\n可以得到一个普适的道理：如果你映射某个函数到列表上，然后对其应用 `f`，其等同于对映射应用 `f`。\n数学提供的这种形式化方法，可以帮助计算机去进行类似的代码优化。\n\n### 类型约束\n``` js\n// sort :: Ord a => [a] -> [a]\n```\n签名也可以把类型约束为一个特定的接口（interface），a必须是`Ord`对象，在强类型语言中，可以是一个自定义的接口。\n\n# 特百惠\n### 容器\n为什么叫特百惠呢？因为特百惠是一个家居品品牌，代表产品是容器。\n``` js\nvar Container = function(x) {\n  this.__value = x;\n}\n\nContainer.of = function(x) { return new Container(x); };\n```\n使用`Container.of`作为构造器，暂且认为它是把值放到容器里的一种方式。\n\n### 第一个 functor\n容器中有了值之后，我们需要一种方式来操作容器中的值：\n``` js\n// (a -> b) -> Container a -> Container b\nContainer.prototype.map = function(f){\n  return Container.of(f(this.__value))\n}\n```\n这个`map`跟数组那个著名的`map`一样，除了前者的参数是`Container a`而后者是`[a]`。它们的使用方式也几乎一致：\n``` js\nContainer.of(2).map(function(two){ return two + 2 })\n//=> Container(4)\n\n\nContainer.of(\"flamethrowers\").map(function(s){ return s.toUpperCase() })\n//=> Container(\"FLAMETHROWERS\")\n\n\nContainer.of(\"bombs\").map(concat(' away')).map(_.prop('length'))\n//=> Container(10)\n```\nContainer将值传给map后，通过`f`方法，我们可以对值进行任意操作，操作结束后再放入`Container`中并返回，这样就可以连续对容器中的值进行操作。这样一直调用`map`的形式，不就是前面提到的组合么。\n这里面起作用的**数学魔法**就是`functor`(函子):\n> functor 是实现了`map`函数并遵守一些特定规则的容器类型。\n\n为什么要使用`functor`这种方式来处理呢？\n> 即让容器自己去运用函数能给我们带来什么好处？书中给出的答案是抽象——对于函数运用的抽象。\n\n### 薛定谔的 Maybe\n定义另外一个`functor`，同样实现了`map`函数的、类似容器的数据类型`Maybe'。\n``` js\nvar Maybe = function(x) {\n  this.__value = x;\n}\n\nMaybe.of = function(x) {\n  return new Maybe(x);\n}\n\nMaybe.prototype.isNothing = function() {\n  return (this.__value === null || this.__value === undefined);\n}\n\nMaybe.prototype.map = function(f) {\n  return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));\n}\n```\n`Maybe`和`Container`的不同点就是它新增了一个`isNothing`，在每次调用函数前，先检查它自己的值是否为空。\n\n``` js\nMaybe.of(\"Malkovich Malkovich\").map(match(/a/ig));\n//=> this._value = match(/a/ig)(\"\"Malkovich Malkovich\"\")\n//=> Maybe(['a', 'a'])\n\nMaybe.of(null).map(match(/a/ig));\n//=> Maybe(null)\n```\n点记法（dot notation syntax）已经足够函数式了，但我们更想保持一种 pointfree 的风格。碰巧的是，`map`完全有能力以`curry`函数的方式来“代理”任何 functor，柯里化后就可以方便地使用`compose`了：\n``` js\n//  map :: Functor f => (a -> b) -> f a -> f b\nvar map = curry(function(f, any_functor_at_all) {\n  return any_functor_at_all.map(f);\n});\n```\n结合前面提到的类型签名，首先约束了f是Functor类型，去掉类型约束后签名是`(a -> b) -> f a -> f b`，可以看出传入的参数是一个函数`f`: (a -> b)，一个`functor`: f a，最后返回一个`functor`: f b。\n这个方法可以帮助我们取出容器中的值，可以参考下面的例子：\n``` js\n//  safeHead :: [a] -> Maybe(a)\nvar safeHead = function(xs) {\n  return Maybe.of(xs[0]); // this.__value = xs[0]\n};\n\nvar streetName = compose(map(_.prop('street')), safeHead, _.prop('addresses'));\n\nstreetName({addresses: []});\n// Maybe(null)\n\nstreetName({addresses: [{street: \"Shady Ln.\", number: 4201}]});\n// Maybe(\"Shady Ln.\")\n```\nsafeHead返回了一个Maybe对象（eg2：Maybe({street: \"Shady Ln.\", number: 4201})），要想对隐藏在Maybe容器中的值进行操作，需要借助`map`函数来操作，通过调用该对象的map函数，传入`_.prop('street')`函数，对`this.__value`进行操作，返回一个新的Maybe对象（eg2: Maybe(\"Shady Ln.\")）。\n\n### “纯”错误处理\n`Maybe`实现了空和非空两种类型的分开处理，利用这种思想，我们可以对错误进行更友好、健壮地处理。\n用一个简单的例子示意一下：\n``` js\nvar Left = function(x) {\n  this.__value = x;\n}\n\nLeft.of = function(x) {\n  return new Left(x);\n}\n\nLeft.prototype.map = function(f) {\n  return this;\n}\n\nvar Right = function(x) {\n  this.__value = x;\n}\n\nRight.of = function(x) {\n  return new Right(x);\n}\n\nRight.prototype.map = function(f) {\n  return Right.of(f(this.__value));\n}\n```\n\n``` js\nvar moment = require('moment');\n\n//  getAge :: Date -> User -> Either(String, Number)\nvar getAge = curry(function(now, user) {\n  var birthdate = moment(user.birthdate, 'YYYY-MM-DD');\n  if(!birthdate.isValid()) return Left.of(\"Birth date could not be parsed\");\n  return Right.of(now.diff(birthdate, 'years'));\n});\n\ngetAge(moment(), {birthdate: '2005-12-12'});\n// Right(9)\n\ngetAge(moment(), {birthdate: '20010704'});\n// Left(\"Birth date could not be parsed\")\n```\n其中Left用来处理错误状态，Right用来处理正常情况。\n\n### Old McDonald had Effects...\n在纯函数那一章，通过将不纯的函数包裹在另一个函数中，使得它看起来像个纯函数。类似的例子：\n``` js\n//  getFromStorage :: String -> (_ -> String)\nvar getFromStorage = function(key) {\n  return function() {\n    return localStorage[key];\n  }\n}\n```\n这儿将`getFromStorage`改造成，相同的输入key总会对应相同的输出：一个从`localStorage`里取出某个特定元素的函数。（然而，感觉并没什么用啊= =）\n\n``` js\nvar IO = function(f) {\n  this.__value = f; //f总是一个函数\n}\n\nIO.of = function(x) {\n  return new IO(function() {\n    return x;\n  });\n}\n\nIO.prototype.map = function(f) {\n  //这儿和Maybe.of(f(this.__value))实现效果一致\n  return new IO(_.compose(f, this.__value));\n}\n```\n`IO(function(){ return x })`仅仅是为了延迟执行，其实我们得到的是 IO(x)。\n\n实际使用的时候：\n``` js\n////// 纯代码库: lib/params.js ///////\n\n//  url :: IO String\nvar url = new IO(function() { return window.location.href; });\n\n//  toPairs =  String -> [[String]]\nvar toPairs = compose(map(split('=')), split('&'));\n\n//  params :: String -> [[String]]\nvar params = compose(toPairs, last, split('?'));\n\n//  findParam :: String -> IO Maybe [String]\nvar findParam = function(key) {\n  return map(compose(Maybe.of, filter(compose(eq(key), head)), params), url);\n};\n\n////// 非纯调用代码: main.js ///////\n\n// 调用 __value() 来运行它！\nfindParam(\"searchTerm\").__value();\n// Maybe(['searchTerm', 'wafflehouse'])\n```\n本质上是将逻辑分成了**纯代码库**和**非纯调用代码**两部分，纯代码库最后生成的函数是唯一的，最后的风险都放在了调用者身上。\n`__value`的命名并不合理，`__value`的调用会触发前面已压栈的所有操作，替换为`unsafePerformIO`更能提醒用户它的变化无常。\n\nfunctor 的概念来自于范畴学，并满足一些定律。\n``` js\n// identity\nmap(id) === id;\n\n// composition\ncompose(map(f), map(g)) === map(compose(f, g));\n```\n\n# Monad\n### pointed functor\n`of`方法并不是用来避免使用`new`关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。`pointed functor`就是实现了`of`方法的Functor。\n**默认最小化上下文是什么？**\n> TODO\n> \n### 混合比喻\n``` js\n// Support\n// ===========================\nvar fs = require('fs');\n\n//  readFile :: String -> IO String\nvar readFile = function(filename) {\n  return new IO(function() {\n    return fs.readFileSync(filename, 'utf-8');\n  });\n};\n\n//  print :: String -> IO String\nvar print = function(x) {\n  return new IO(function() {\n    console.log(x);\n    return x;\n  });\n}\n\n// Example\n// ===========================\n//  cat :: IO (IO String)\nvar cat = compose(map(print), readFile);\n\ncat(\".git/config\")\n// IO(IO(\"[core]\\nrepositoryformatversion = 0\\n\"))\n```\n最后返回了一个嵌套两层的`IO`对象，如果想要再次调用，对其中的值进行处理，则需要`map(map(f))`；像是穿着两套防护服在工作，很奇怪。\n``` js\nMaybe.prototype.join = function() {\n  return this.isNothing() ? Maybe.of(null) : this.__value;\n}\n\nvar mmo = Maybe.of(Maybe.of(\"nunchucks\"));\n// Maybe(Maybe(\"nunchucks\"))\n\nmmo.join();\n// Maybe(\"nunchucks\")\n\n```\n定义一个`join`方法，可以帮助我们简单地移除一层嵌套，在使用的时候，我们可以在每个map后面，都调用一次join方法，但是我们期望的不止如此。\n```js\n//  join :: Monad m => m (m a) -> m a\nvar join = function(mma){ return mma.join(); }\n\n//  firstAddressStreet :: User -> Maybe Street\nvar firstAddressStreet = compose(\n  join, map(safeProp('street')), join, map(safeHead), safeProp('addresses')\n);\n```\n\n### chain函数\n把`map`和`join`封装成chain函数，则`firstAddressStreet`方法可以改写成：\n``` js\n//  chain :: Monad m => (a -> m b) -> m a -> m b\nvar chain = curry(function(f, m){\n  return m.map(f).join(); // 或者 compose(join, map(f))(m)\n});\n\n//  firstAddressStreet :: User -> Maybe Street\nvar firstAddressStreet = compose(\n  chain(safeProp('street')), chain(safeHead), safeProp('addresses')\n);\n```\n> 简单说，Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。\n\nREFS:\n[图解 Monad](http://www.ruanyifeng.com/blog/2015/07/monad.html)\n\n","slug":"JS函数式编程笔记(下)","published":1,"updated":"2019-03-18T02:27:14.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx7y002pqmhffdgxd226","content":"<h1 id=\"示例应用\"><a href=\"#示例应用\" class=\"headerlink\" title=\"示例应用\"></a>示例应用</h1><h3 id=\"声明式编程\"><a href=\"#声明式编程\" class=\"headerlink\" title=\"声明式编程\"></a>声明式编程</h3><ul>\n<li>命令式编程（imperative）：喜欢大量使用可变对象和指令，我们总是习惯于创建对象或者变量，并且修改它们的状态或者值，或者喜欢提供一系列指令，要求程序执行。</li>\n<li>声明式编程（Declarative）：对于声明式的编程范式，你不在需要提供明确的指令操作，所有的细节指令将会更好的被程序库所封装，你要做的只是提出你要的要求，声明你的用意即可。<br>与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。<code>SQL</code>是典型的声明式编程，明确指出想要什么(what)，而不是如何实现(how)。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命令式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> makes = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; cars.length; i++) &#123;</span><br><span class=\"line\">  makes.push(cars[i].make);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> makes = cars.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">car</span>)</span>&#123; <span class=\"keyword\">return</span> car.make; &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上述命令式编程要求先声明一个数组，再去遍历，然后执行循环中具体的方法。<br>使用<code>map</code>的版本是一个表达式，它对执行顺序没有要求,它指明的是做什么，不是怎么做。</p>\n<p>REFS:<br><a href=\"http://www.aqee.net/post/imperative-vs-declarative.html\" target=\"_blank\" rel=\"noopener\">声明式编程和命令式编程的比较</a></p>\n<h1 id=\"Hindley-Milner-类型签名\"><a href=\"#Hindley-Milner-类型签名\" class=\"headerlink\" title=\"Hindley-Milner 类型签名\"></a>Hindley-Milner 类型签名</h1><blockquote>\n<p>类型签名在写纯函数时所起的作用非常大，短短一行，就能暴露函数的行为和目的。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。<br>JavaScript 也有一些类型检查工具，比如 <a href=\"http://flowtype.org/\" target=\"_blank\" rel=\"noopener\">Flow</a>，或者它的静态类型方言 <a href=\"http://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">TypeScript</a> 。</p>\n</blockquote>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  capitalize :: String -&gt; String</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> capitalize = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> toUpperCase(head(s)) + toLowerCase(tail(s));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">capitalize(<span class=\"string\">\"smurf\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; \"Smurf\"</span></span><br></pre></td></tr></table></figure>\n<p>从类型签名来看，<code>capitalize</code>方法接收了一个<code>String</code>，最终也返回了一个<code>String</code>。</p>\n<p>对于柯里化后的函数，对类型的签名可以有不同的理解：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  match :: Regex -&gt; String -&gt; [String]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> match = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reg, s</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.match(reg);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>一种思路是接收<code>Regex</code>和<code>String</code>两种类型参数，返回一个<code>[String]</code></li>\n<li>另一种思路是<code>match :: Regex -&gt; (String -&gt; [String])</code>，先接收了一个<code>Regex</code>参数，返回一个新的函数，该函数接收<code>String</code>并返回一个<code>[String]</code>。</li>\n</ul>\n<h3 id=\"再举个栗子\"><a href=\"#再举个栗子\" class=\"headerlink\" title=\"再举个栗子\"></a>再举个栗子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  reduce :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reduce = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, x, xs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xs.reduce(f, x);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>约定俗成，a、b可以是任一种类型，但相同的字母<code>a</code>代表同一类型。其中<code>(b -&gt; a -&gt; b)</code>约定了函数的类型签名：</p>\n<ul>\n<li><code>b</code>是传入f的累加器（初始值是括号后面的<code>-&gt; b</code>）;</li>\n<li><code>a</code>是遍历<code>[a]</code>得到的<code>currentValue</code>;</li>\n<li><code>f</code>返回的类型是<code>b</code>，最终<code>reduce</code>方法返回的类型也就是<code>f</code>的返回。<br><strong>类型签名的美妙之处在于明确告诉我们函数做了什么</strong></li>\n</ul>\n<h3 id=\"缩小可能性范围\"><a href=\"#缩小可能性范围\" class=\"headerlink\" title=\"缩小可能性范围\"></a>缩小可能性范围</h3><p>大多数语言都有范型(也成为参数多态性)，其中函数是通过一个或多个抽象类型定义的。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// head :: [a] -&gt; a</span></span><br></pre></td></tr></table></figure></p>\n<p>引入了类型签名后，可以缩小<code>head</code>函数的可能范围，a可以是任意类型的参数，即多态性(polymorphism)，对于任意类型的参数都要支持<code>[a] -&gt; a</code>的映射，可以帮助我们缩小函数可能性的范围。<br>我们甚至可以用<code>[a] -&gt; a</code>去到类型签名搜索引擎里面搜索我们需要的函数，详细移步到<a href=\"https://www.haskell.org/hoogle/\" target=\"_blank\" rel=\"noopener\">Hoogle</a>去尝试，很有意思。</p>\n<h3 id=\"自由定理\"><a href=\"#自由定理\" class=\"headerlink\" title=\"自由定理\"></a>自由定理</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// head :: [a] -&gt; a</span></span><br><span class=\"line\">compose(f, head) == compose(head, map(f));</span><br></pre></td></tr></table></figure>\n<p>等式左边说的是，先获取数组的头部，然后对它调用函数 f；等式右边说的是，先对数组中的每一个元素调用 f，然后再取其返回结果的头部。这两个表达式的作用是相等的，但是前者要快得多。<br>可以得到一个普适的道理：如果你映射某个函数到列表上，然后对其应用 <code>f</code>，其等同于对映射应用 <code>f</code>。<br>数学提供的这种形式化方法，可以帮助计算机去进行类似的代码优化。</p>\n<h3 id=\"类型约束\"><a href=\"#类型约束\" class=\"headerlink\" title=\"类型约束\"></a>类型约束</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sort :: Ord a =&gt; [a] -&gt; [a]</span></span><br></pre></td></tr></table></figure>\n<p>签名也可以把类型约束为一个特定的接口（interface），a必须是<code>Ord</code>对象，在强类型语言中，可以是一个自定义的接口。</p>\n<h1 id=\"特百惠\"><a href=\"#特百惠\" class=\"headerlink\" title=\"特百惠\"></a>特百惠</h1><h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><p>为什么叫特百惠呢？因为特百惠是一个家居品品牌，代表产品是容器。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Container = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.__value = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Container.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Container(x); &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>Container.of</code>作为构造器，暂且认为它是把值放到容器里的一种方式。</p>\n<h3 id=\"第一个-functor\"><a href=\"#第一个-functor\" class=\"headerlink\" title=\"第一个 functor\"></a>第一个 functor</h3><p>容器中有了值之后，我们需要一种方式来操作容器中的值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (a -&gt; b) -&gt; Container a -&gt; Container b</span></span><br><span class=\"line\">Container.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Container.of(f(<span class=\"keyword\">this</span>.__value))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个<code>map</code>跟数组那个著名的<code>map</code>一样，除了前者的参数是<code>Container a</code>而后者是<code>[a]</code>。它们的使用方式也几乎一致：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Container.of(<span class=\"number\">2</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">two</span>)</span>&#123; <span class=\"keyword\">return</span> two + <span class=\"number\">2</span> &#125;)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; Container(4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Container.of(<span class=\"string\">\"flamethrowers\"</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>)</span>&#123; <span class=\"keyword\">return</span> s.toUpperCase() &#125;)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; Container(\"FLAMETHROWERS\")</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Container.of(<span class=\"string\">\"bombs\"</span>).map(concat(<span class=\"string\">' away'</span>)).map(_.prop(<span class=\"string\">'length'</span>))</span><br><span class=\"line\"><span class=\"comment\">//=&gt; Container(10)</span></span><br></pre></td></tr></table></figure></p>\n<p>Container将值传给map后，通过<code>f</code>方法，我们可以对值进行任意操作，操作结束后再放入<code>Container</code>中并返回，这样就可以连续对容器中的值进行操作。这样一直调用<code>map</code>的形式，不就是前面提到的组合么。<br>这里面起作用的<strong>数学魔法</strong>就是<code>functor</code>(函子):</p>\n<blockquote>\n<p>functor 是实现了<code>map</code>函数并遵守一些特定规则的容器类型。</p>\n</blockquote>\n<p>为什么要使用<code>functor</code>这种方式来处理呢？</p>\n<blockquote>\n<p>即让容器自己去运用函数能给我们带来什么好处？书中给出的答案是抽象——对于函数运用的抽象。</p>\n</blockquote>\n<h3 id=\"薛定谔的-Maybe\"><a href=\"#薛定谔的-Maybe\" class=\"headerlink\" title=\"薛定谔的 Maybe\"></a>薛定谔的 Maybe</h3><p>定义另外一个<code>functor</code>，同样实现了<code>map</code>函数的、类似容器的数据类型`Maybe’。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Maybe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.__value = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Maybe.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Maybe(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Maybe.prototype.isNothing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.__value === <span class=\"literal\">null</span> || <span class=\"keyword\">this</span>.__value === <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Maybe.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.isNothing() ? Maybe.of(<span class=\"literal\">null</span>) : Maybe.of(f(<span class=\"keyword\">this</span>.__value));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>Maybe</code>和<code>Container</code>的不同点就是它新增了一个<code>isNothing</code>，在每次调用函数前，先检查它自己的值是否为空。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Maybe.of(<span class=\"string\">\"Malkovich Malkovich\"</span>).map(match(<span class=\"regexp\">/a/ig</span>));</span><br><span class=\"line\"><span class=\"comment\">//=&gt; this._value = match(/a/ig)(\"\"Malkovich Malkovich\"\")</span></span><br><span class=\"line\"><span class=\"comment\">//=&gt; Maybe(['a', 'a'])</span></span><br><span class=\"line\"></span><br><span class=\"line\">Maybe.of(<span class=\"literal\">null</span>).map(match(<span class=\"regexp\">/a/ig</span>));</span><br><span class=\"line\"><span class=\"comment\">//=&gt; Maybe(null)</span></span><br></pre></td></tr></table></figure>\n<p>点记法（dot notation syntax）已经足够函数式了，但我们更想保持一种 pointfree 的风格。碰巧的是，<code>map</code>完全有能力以<code>curry</code>函数的方式来“代理”任何 functor，柯里化后就可以方便地使用<code>compose</code>了：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, any_functor_at_all</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> any_functor_at_all.map(f);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>结合前面提到的类型签名，首先约束了f是Functor类型，去掉类型约束后签名是<code>(a -&gt; b) -&gt; f a -&gt; f b</code>，可以看出传入的参数是一个函数<code>f</code>: (a -&gt; b)，一个<code>functor</code>: f a，最后返回一个<code>functor</code>: f b。<br>这个方法可以帮助我们取出容器中的值，可以参考下面的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  safeHead :: [a] -&gt; Maybe(a)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> safeHead = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Maybe.of(xs[<span class=\"number\">0</span>]); <span class=\"comment\">// this.__value = xs[0]</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> streetName = compose(map(_.prop(<span class=\"string\">'street'</span>)), safeHead, _.prop(<span class=\"string\">'addresses'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">streetName(&#123;<span class=\"attr\">addresses</span>: []&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Maybe(null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">streetName(&#123;<span class=\"attr\">addresses</span>: [&#123;<span class=\"attr\">street</span>: <span class=\"string\">\"Shady Ln.\"</span>, <span class=\"attr\">number</span>: <span class=\"number\">4201</span>&#125;]&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Maybe(\"Shady Ln.\")</span></span><br></pre></td></tr></table></figure></p>\n<p>safeHead返回了一个Maybe对象（eg2：Maybe({street: “Shady Ln.”, number: 4201})），要想对隐藏在Maybe容器中的值进行操作，需要借助<code>map</code>函数来操作，通过调用该对象的map函数，传入<code>_.prop(&#39;street&#39;)</code>函数，对<code>this.__value</code>进行操作，返回一个新的Maybe对象（eg2: Maybe(“Shady Ln.”)）。</p>\n<h3 id=\"“纯”错误处理\"><a href=\"#“纯”错误处理\" class=\"headerlink\" title=\"“纯”错误处理\"></a>“纯”错误处理</h3><p><code>Maybe</code>实现了空和非空两种类型的分开处理，利用这种思想，我们可以对错误进行更友好、健壮地处理。<br>用一个简单的例子示意一下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Left = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.__value = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Left.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Left(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Left.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Right = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.__value = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Right.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Right(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Right.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Right.of(f(<span class=\"keyword\">this</span>.__value));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> moment = <span class=\"built_in\">require</span>(<span class=\"string\">'moment'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  getAge :: Date -&gt; User -&gt; Either(String, Number)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getAge = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">now, user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> birthdate = moment(user.birthdate, <span class=\"string\">'YYYY-MM-DD'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!birthdate.isValid()) <span class=\"keyword\">return</span> Left.of(<span class=\"string\">\"Birth date could not be parsed\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Right.of(now.diff(birthdate, <span class=\"string\">'years'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">getAge(moment(), &#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'2005-12-12'</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Right(9)</span></span><br><span class=\"line\"></span><br><span class=\"line\">getAge(moment(), &#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'20010704'</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Left(\"Birth date could not be parsed\")</span></span><br></pre></td></tr></table></figure>\n<p>其中Left用来处理错误状态，Right用来处理正常情况。</p>\n<h3 id=\"Old-McDonald-had-Effects…\"><a href=\"#Old-McDonald-had-Effects…\" class=\"headerlink\" title=\"Old McDonald had Effects…\"></a>Old McDonald had Effects…</h3><p>在纯函数那一章，通过将不纯的函数包裹在另一个函数中，使得它看起来像个纯函数。类似的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  getFromStorage :: String -&gt; (_ -&gt; String)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getFromStorage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> localStorage[key];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这儿将<code>getFromStorage</code>改造成，相同的输入key总会对应相同的输出：一个从<code>localStorage</code>里取出某个特定元素的函数。（然而，感觉并没什么用啊= =）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> IO = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.__value = f; <span class=\"comment\">//f总是一个函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">IO.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">IO.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这儿和Maybe.of(f(this.__value))实现效果一致</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(_.compose(f, <span class=\"keyword\">this</span>.__value));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>IO(function(){ return x })</code>仅仅是为了延迟执行，其实我们得到的是 IO(x)。</p>\n<p>实际使用的时候：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">////// 纯代码库: lib/params.js ///////</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  url :: IO String</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  toPairs =  String -&gt; [[String]]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> toPairs = compose(map(split(<span class=\"string\">'='</span>)), split(<span class=\"string\">'&amp;'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  params :: String -&gt; [[String]]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> params = compose(toPairs, last, split(<span class=\"string\">'?'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  findParam :: String -&gt; IO Maybe [String]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findParam = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(compose(Maybe.of, filter(compose(eq(key), head)), params), url);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">////// 非纯调用代码: main.js ///////</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 __value() 来运行它！</span></span><br><span class=\"line\">findParam(<span class=\"string\">\"searchTerm\"</span>).__value();</span><br><span class=\"line\"><span class=\"comment\">// Maybe(['searchTerm', 'wafflehouse'])</span></span><br></pre></td></tr></table></figure></p>\n<p>本质上是将逻辑分成了<strong>纯代码库</strong>和<strong>非纯调用代码</strong>两部分，纯代码库最后生成的函数是唯一的，最后的风险都放在了调用者身上。<br><code>__value</code>的命名并不合理，<code>__value</code>的调用会触发前面已压栈的所有操作，替换为<code>unsafePerformIO</code>更能提醒用户它的变化无常。</p>\n<p>functor 的概念来自于范畴学，并满足一些定律。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// identity</span></span><br><span class=\"line\">map(id) === id;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// composition</span></span><br><span class=\"line\">compose(map(f), map(g)) === map(compose(f, g));</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Monad\"><a href=\"#Monad\" class=\"headerlink\" title=\"Monad\"></a>Monad</h1><h3 id=\"pointed-functor\"><a href=\"#pointed-functor\" class=\"headerlink\" title=\"pointed functor\"></a>pointed functor</h3><p><code>of</code>方法并不是用来避免使用<code>new</code>关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。<code>pointed functor</code>就是实现了<code>of</code>方法的Functor。<br><strong>默认最小化上下文是什么？</strong></p>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<h3 id=\"混合比喻\"><a href=\"#混合比喻\" class=\"headerlink\" title=\"混合比喻\"></a>混合比喻</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Support</span></span><br><span class=\"line\"><span class=\"comment\">// ===========================</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  readFile :: String -&gt; IO String</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filename</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs.readFileSync(filename, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  print :: String -&gt; IO String</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> print = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Example</span></span><br><span class=\"line\"><span class=\"comment\">// ===========================</span></span><br><span class=\"line\"><span class=\"comment\">//  cat :: IO (IO String)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = compose(map(print), readFile);</span><br><span class=\"line\"></span><br><span class=\"line\">cat(<span class=\"string\">\".git/config\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// IO(IO(\"[core]\\nrepositoryformatversion = 0\\n\"))</span></span><br></pre></td></tr></table></figure>\n<p>最后返回了一个嵌套两层的<code>IO</code>对象，如果想要再次调用，对其中的值进行处理，则需要<code>map(map(f))</code>；像是穿着两套防护服在工作，很奇怪。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Maybe.prototype.join = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.isNothing() ? Maybe.of(<span class=\"literal\">null</span>) : <span class=\"keyword\">this</span>.__value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mmo = Maybe.of(Maybe.of(<span class=\"string\">\"nunchucks\"</span>));</span><br><span class=\"line\"><span class=\"comment\">// Maybe(Maybe(\"nunchucks\"))</span></span><br><span class=\"line\"></span><br><span class=\"line\">mmo.join();</span><br><span class=\"line\"><span class=\"comment\">// Maybe(\"nunchucks\")</span></span><br></pre></td></tr></table></figure></p>\n<p>定义一个<code>join</code>方法，可以帮助我们简单地移除一层嵌套，在使用的时候，我们可以在每个map后面，都调用一次join方法，但是我们期望的不止如此。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  join :: Monad m =&gt; m (m a) -&gt; m a</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> join = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mma</span>)</span>&#123; <span class=\"keyword\">return</span> mma.join(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  firstAddressStreet :: User -&gt; Maybe Street</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstAddressStreet = compose(</span><br><span class=\"line\">  join, map(safeProp(<span class=\"string\">'street'</span>)), join, map(safeHead), safeProp(<span class=\"string\">'addresses'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"chain函数\"><a href=\"#chain函数\" class=\"headerlink\" title=\"chain函数\"></a>chain函数</h3><p>把<code>map</code>和<code>join</code>封装成chain函数，则<code>firstAddressStreet</code>方法可以改写成：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  chain :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> chain = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, m</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> m.map(f).join(); <span class=\"comment\">// 或者 compose(join, map(f))(m)</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  firstAddressStreet :: User -&gt; Maybe Street</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstAddressStreet = compose(</span><br><span class=\"line\">  chain(safeProp(<span class=\"string\">'street'</span>)), chain(safeHead), safeProp(<span class=\"string\">'addresses'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>简单说，Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。</p>\n</blockquote>\n<p>REFS:<br><a href=\"http://www.ruanyifeng.com/blog/2015/07/monad.html\" target=\"_blank\" rel=\"noopener\">图解 Monad</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"示例应用\"><a href=\"#示例应用\" class=\"headerlink\" title=\"示例应用\"></a>示例应用</h1><h3 id=\"声明式编程\"><a href=\"#声明式编程\" class=\"headerlink\" title=\"声明式编程\"></a>声明式编程</h3><ul>\n<li>命令式编程（imperative）：喜欢大量使用可变对象和指令，我们总是习惯于创建对象或者变量，并且修改它们的状态或者值，或者喜欢提供一系列指令，要求程序执行。</li>\n<li>声明式编程（Declarative）：对于声明式的编程范式，你不在需要提供明确的指令操作，所有的细节指令将会更好的被程序库所封装，你要做的只是提出你要的要求，声明你的用意即可。<br>与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。<code>SQL</code>是典型的声明式编程，明确指出想要什么(what)，而不是如何实现(how)。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命令式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> makes = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; cars.length; i++) &#123;</span><br><span class=\"line\">  makes.push(cars[i].make);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> makes = cars.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">car</span>)</span>&#123; <span class=\"keyword\">return</span> car.make; &#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上述命令式编程要求先声明一个数组，再去遍历，然后执行循环中具体的方法。<br>使用<code>map</code>的版本是一个表达式，它对执行顺序没有要求,它指明的是做什么，不是怎么做。</p>\n<p>REFS:<br><a href=\"http://www.aqee.net/post/imperative-vs-declarative.html\" target=\"_blank\" rel=\"noopener\">声明式编程和命令式编程的比较</a></p>\n<h1 id=\"Hindley-Milner-类型签名\"><a href=\"#Hindley-Milner-类型签名\" class=\"headerlink\" title=\"Hindley-Milner 类型签名\"></a>Hindley-Milner 类型签名</h1><blockquote>\n<p>类型签名在写纯函数时所起的作用非常大，短短一行，就能暴露函数的行为和目的。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。<br>JavaScript 也有一些类型检查工具，比如 <a href=\"http://flowtype.org/\" target=\"_blank\" rel=\"noopener\">Flow</a>，或者它的静态类型方言 <a href=\"http://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">TypeScript</a> 。</p>\n</blockquote>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  capitalize :: String -&gt; String</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> capitalize = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> toUpperCase(head(s)) + toLowerCase(tail(s));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">capitalize(<span class=\"string\">\"smurf\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; \"Smurf\"</span></span><br></pre></td></tr></table></figure>\n<p>从类型签名来看，<code>capitalize</code>方法接收了一个<code>String</code>，最终也返回了一个<code>String</code>。</p>\n<p>对于柯里化后的函数，对类型的签名可以有不同的理解：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  match :: Regex -&gt; String -&gt; [String]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> match = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reg, s</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.match(reg);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>一种思路是接收<code>Regex</code>和<code>String</code>两种类型参数，返回一个<code>[String]</code></li>\n<li>另一种思路是<code>match :: Regex -&gt; (String -&gt; [String])</code>，先接收了一个<code>Regex</code>参数，返回一个新的函数，该函数接收<code>String</code>并返回一个<code>[String]</code>。</li>\n</ul>\n<h3 id=\"再举个栗子\"><a href=\"#再举个栗子\" class=\"headerlink\" title=\"再举个栗子\"></a>再举个栗子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  reduce :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reduce = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, x, xs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xs.reduce(f, x);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>约定俗成，a、b可以是任一种类型，但相同的字母<code>a</code>代表同一类型。其中<code>(b -&gt; a -&gt; b)</code>约定了函数的类型签名：</p>\n<ul>\n<li><code>b</code>是传入f的累加器（初始值是括号后面的<code>-&gt; b</code>）;</li>\n<li><code>a</code>是遍历<code>[a]</code>得到的<code>currentValue</code>;</li>\n<li><code>f</code>返回的类型是<code>b</code>，最终<code>reduce</code>方法返回的类型也就是<code>f</code>的返回。<br><strong>类型签名的美妙之处在于明确告诉我们函数做了什么</strong></li>\n</ul>\n<h3 id=\"缩小可能性范围\"><a href=\"#缩小可能性范围\" class=\"headerlink\" title=\"缩小可能性范围\"></a>缩小可能性范围</h3><p>大多数语言都有范型(也成为参数多态性)，其中函数是通过一个或多个抽象类型定义的。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// head :: [a] -&gt; a</span></span><br></pre></td></tr></table></figure></p>\n<p>引入了类型签名后，可以缩小<code>head</code>函数的可能范围，a可以是任意类型的参数，即多态性(polymorphism)，对于任意类型的参数都要支持<code>[a] -&gt; a</code>的映射，可以帮助我们缩小函数可能性的范围。<br>我们甚至可以用<code>[a] -&gt; a</code>去到类型签名搜索引擎里面搜索我们需要的函数，详细移步到<a href=\"https://www.haskell.org/hoogle/\" target=\"_blank\" rel=\"noopener\">Hoogle</a>去尝试，很有意思。</p>\n<h3 id=\"自由定理\"><a href=\"#自由定理\" class=\"headerlink\" title=\"自由定理\"></a>自由定理</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// head :: [a] -&gt; a</span></span><br><span class=\"line\">compose(f, head) == compose(head, map(f));</span><br></pre></td></tr></table></figure>\n<p>等式左边说的是，先获取数组的头部，然后对它调用函数 f；等式右边说的是，先对数组中的每一个元素调用 f，然后再取其返回结果的头部。这两个表达式的作用是相等的，但是前者要快得多。<br>可以得到一个普适的道理：如果你映射某个函数到列表上，然后对其应用 <code>f</code>，其等同于对映射应用 <code>f</code>。<br>数学提供的这种形式化方法，可以帮助计算机去进行类似的代码优化。</p>\n<h3 id=\"类型约束\"><a href=\"#类型约束\" class=\"headerlink\" title=\"类型约束\"></a>类型约束</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sort :: Ord a =&gt; [a] -&gt; [a]</span></span><br></pre></td></tr></table></figure>\n<p>签名也可以把类型约束为一个特定的接口（interface），a必须是<code>Ord</code>对象，在强类型语言中，可以是一个自定义的接口。</p>\n<h1 id=\"特百惠\"><a href=\"#特百惠\" class=\"headerlink\" title=\"特百惠\"></a>特百惠</h1><h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><p>为什么叫特百惠呢？因为特百惠是一个家居品品牌，代表产品是容器。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Container = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.__value = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Container.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Container(x); &#125;;</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>Container.of</code>作为构造器，暂且认为它是把值放到容器里的一种方式。</p>\n<h3 id=\"第一个-functor\"><a href=\"#第一个-functor\" class=\"headerlink\" title=\"第一个 functor\"></a>第一个 functor</h3><p>容器中有了值之后，我们需要一种方式来操作容器中的值：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (a -&gt; b) -&gt; Container a -&gt; Container b</span></span><br><span class=\"line\">Container.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Container.of(f(<span class=\"keyword\">this</span>.__value))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个<code>map</code>跟数组那个著名的<code>map</code>一样，除了前者的参数是<code>Container a</code>而后者是<code>[a]</code>。它们的使用方式也几乎一致：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Container.of(<span class=\"number\">2</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">two</span>)</span>&#123; <span class=\"keyword\">return</span> two + <span class=\"number\">2</span> &#125;)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; Container(4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Container.of(<span class=\"string\">\"flamethrowers\"</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>)</span>&#123; <span class=\"keyword\">return</span> s.toUpperCase() &#125;)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; Container(\"FLAMETHROWERS\")</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Container.of(<span class=\"string\">\"bombs\"</span>).map(concat(<span class=\"string\">' away'</span>)).map(_.prop(<span class=\"string\">'length'</span>))</span><br><span class=\"line\"><span class=\"comment\">//=&gt; Container(10)</span></span><br></pre></td></tr></table></figure></p>\n<p>Container将值传给map后，通过<code>f</code>方法，我们可以对值进行任意操作，操作结束后再放入<code>Container</code>中并返回，这样就可以连续对容器中的值进行操作。这样一直调用<code>map</code>的形式，不就是前面提到的组合么。<br>这里面起作用的<strong>数学魔法</strong>就是<code>functor</code>(函子):</p>\n<blockquote>\n<p>functor 是实现了<code>map</code>函数并遵守一些特定规则的容器类型。</p>\n</blockquote>\n<p>为什么要使用<code>functor</code>这种方式来处理呢？</p>\n<blockquote>\n<p>即让容器自己去运用函数能给我们带来什么好处？书中给出的答案是抽象——对于函数运用的抽象。</p>\n</blockquote>\n<h3 id=\"薛定谔的-Maybe\"><a href=\"#薛定谔的-Maybe\" class=\"headerlink\" title=\"薛定谔的 Maybe\"></a>薛定谔的 Maybe</h3><p>定义另外一个<code>functor</code>，同样实现了<code>map</code>函数的、类似容器的数据类型`Maybe’。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Maybe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.__value = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Maybe.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Maybe(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Maybe.prototype.isNothing = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span>.__value === <span class=\"literal\">null</span> || <span class=\"keyword\">this</span>.__value === <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Maybe.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.isNothing() ? Maybe.of(<span class=\"literal\">null</span>) : Maybe.of(f(<span class=\"keyword\">this</span>.__value));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>Maybe</code>和<code>Container</code>的不同点就是它新增了一个<code>isNothing</code>，在每次调用函数前，先检查它自己的值是否为空。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Maybe.of(<span class=\"string\">\"Malkovich Malkovich\"</span>).map(match(<span class=\"regexp\">/a/ig</span>));</span><br><span class=\"line\"><span class=\"comment\">//=&gt; this._value = match(/a/ig)(\"\"Malkovich Malkovich\"\")</span></span><br><span class=\"line\"><span class=\"comment\">//=&gt; Maybe(['a', 'a'])</span></span><br><span class=\"line\"></span><br><span class=\"line\">Maybe.of(<span class=\"literal\">null</span>).map(match(<span class=\"regexp\">/a/ig</span>));</span><br><span class=\"line\"><span class=\"comment\">//=&gt; Maybe(null)</span></span><br></pre></td></tr></table></figure>\n<p>点记法（dot notation syntax）已经足够函数式了，但我们更想保持一种 pointfree 的风格。碰巧的是，<code>map</code>完全有能力以<code>curry</code>函数的方式来“代理”任何 functor，柯里化后就可以方便地使用<code>compose</code>了：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, any_functor_at_all</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> any_functor_at_all.map(f);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>结合前面提到的类型签名，首先约束了f是Functor类型，去掉类型约束后签名是<code>(a -&gt; b) -&gt; f a -&gt; f b</code>，可以看出传入的参数是一个函数<code>f</code>: (a -&gt; b)，一个<code>functor</code>: f a，最后返回一个<code>functor</code>: f b。<br>这个方法可以帮助我们取出容器中的值，可以参考下面的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  safeHead :: [a] -&gt; Maybe(a)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> safeHead = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Maybe.of(xs[<span class=\"number\">0</span>]); <span class=\"comment\">// this.__value = xs[0]</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> streetName = compose(map(_.prop(<span class=\"string\">'street'</span>)), safeHead, _.prop(<span class=\"string\">'addresses'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">streetName(&#123;<span class=\"attr\">addresses</span>: []&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Maybe(null)</span></span><br><span class=\"line\"></span><br><span class=\"line\">streetName(&#123;<span class=\"attr\">addresses</span>: [&#123;<span class=\"attr\">street</span>: <span class=\"string\">\"Shady Ln.\"</span>, <span class=\"attr\">number</span>: <span class=\"number\">4201</span>&#125;]&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Maybe(\"Shady Ln.\")</span></span><br></pre></td></tr></table></figure></p>\n<p>safeHead返回了一个Maybe对象（eg2：Maybe({street: “Shady Ln.”, number: 4201})），要想对隐藏在Maybe容器中的值进行操作，需要借助<code>map</code>函数来操作，通过调用该对象的map函数，传入<code>_.prop(&#39;street&#39;)</code>函数，对<code>this.__value</code>进行操作，返回一个新的Maybe对象（eg2: Maybe(“Shady Ln.”)）。</p>\n<h3 id=\"“纯”错误处理\"><a href=\"#“纯”错误处理\" class=\"headerlink\" title=\"“纯”错误处理\"></a>“纯”错误处理</h3><p><code>Maybe</code>实现了空和非空两种类型的分开处理，利用这种思想，我们可以对错误进行更友好、健壮地处理。<br>用一个简单的例子示意一下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Left = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.__value = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Left.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Left(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Left.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Right = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.__value = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Right.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Right(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Right.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Right.of(f(<span class=\"keyword\">this</span>.__value));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> moment = <span class=\"built_in\">require</span>(<span class=\"string\">'moment'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  getAge :: Date -&gt; User -&gt; Either(String, Number)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getAge = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">now, user</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> birthdate = moment(user.birthdate, <span class=\"string\">'YYYY-MM-DD'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!birthdate.isValid()) <span class=\"keyword\">return</span> Left.of(<span class=\"string\">\"Birth date could not be parsed\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Right.of(now.diff(birthdate, <span class=\"string\">'years'</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">getAge(moment(), &#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'2005-12-12'</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Right(9)</span></span><br><span class=\"line\"></span><br><span class=\"line\">getAge(moment(), &#123;<span class=\"attr\">birthdate</span>: <span class=\"string\">'20010704'</span>&#125;);</span><br><span class=\"line\"><span class=\"comment\">// Left(\"Birth date could not be parsed\")</span></span><br></pre></td></tr></table></figure>\n<p>其中Left用来处理错误状态，Right用来处理正常情况。</p>\n<h3 id=\"Old-McDonald-had-Effects…\"><a href=\"#Old-McDonald-had-Effects…\" class=\"headerlink\" title=\"Old McDonald had Effects…\"></a>Old McDonald had Effects…</h3><p>在纯函数那一章，通过将不纯的函数包裹在另一个函数中，使得它看起来像个纯函数。类似的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  getFromStorage :: String -&gt; (_ -&gt; String)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getFromStorage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> localStorage[key];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这儿将<code>getFromStorage</code>改造成，相同的输入key总会对应相同的输出：一个从<code>localStorage</code>里取出某个特定元素的函数。（然而，感觉并没什么用啊= =）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> IO = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.__value = f; <span class=\"comment\">//f总是一个函数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">IO.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">IO.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这儿和Maybe.of(f(this.__value))实现效果一致</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(_.compose(f, <span class=\"keyword\">this</span>.__value));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>IO(function(){ return x })</code>仅仅是为了延迟执行，其实我们得到的是 IO(x)。</p>\n<p>实际使用的时候：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">////// 纯代码库: lib/params.js ///////</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  url :: IO String</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">window</span>.location.href; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  toPairs =  String -&gt; [[String]]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> toPairs = compose(map(split(<span class=\"string\">'='</span>)), split(<span class=\"string\">'&amp;'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  params :: String -&gt; [[String]]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> params = compose(toPairs, last, split(<span class=\"string\">'?'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  findParam :: String -&gt; IO Maybe [String]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> findParam = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(compose(Maybe.of, filter(compose(eq(key), head)), params), url);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">////// 非纯调用代码: main.js ///////</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用 __value() 来运行它！</span></span><br><span class=\"line\">findParam(<span class=\"string\">\"searchTerm\"</span>).__value();</span><br><span class=\"line\"><span class=\"comment\">// Maybe(['searchTerm', 'wafflehouse'])</span></span><br></pre></td></tr></table></figure></p>\n<p>本质上是将逻辑分成了<strong>纯代码库</strong>和<strong>非纯调用代码</strong>两部分，纯代码库最后生成的函数是唯一的，最后的风险都放在了调用者身上。<br><code>__value</code>的命名并不合理，<code>__value</code>的调用会触发前面已压栈的所有操作，替换为<code>unsafePerformIO</code>更能提醒用户它的变化无常。</p>\n<p>functor 的概念来自于范畴学，并满足一些定律。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// identity</span></span><br><span class=\"line\">map(id) === id;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// composition</span></span><br><span class=\"line\">compose(map(f), map(g)) === map(compose(f, g));</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Monad\"><a href=\"#Monad\" class=\"headerlink\" title=\"Monad\"></a>Monad</h1><h3 id=\"pointed-functor\"><a href=\"#pointed-functor\" class=\"headerlink\" title=\"pointed functor\"></a>pointed functor</h3><p><code>of</code>方法并不是用来避免使用<code>new</code>关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。<code>pointed functor</code>就是实现了<code>of</code>方法的Functor。<br><strong>默认最小化上下文是什么？</strong></p>\n<blockquote>\n<p>TODO</p>\n</blockquote>\n<h3 id=\"混合比喻\"><a href=\"#混合比喻\" class=\"headerlink\" title=\"混合比喻\"></a>混合比喻</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Support</span></span><br><span class=\"line\"><span class=\"comment\">// ===========================</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  readFile :: String -&gt; IO String</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">filename</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs.readFileSync(filename, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  print :: String -&gt; IO String</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> print = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> IO(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Example</span></span><br><span class=\"line\"><span class=\"comment\">// ===========================</span></span><br><span class=\"line\"><span class=\"comment\">//  cat :: IO (IO String)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cat = compose(map(print), readFile);</span><br><span class=\"line\"></span><br><span class=\"line\">cat(<span class=\"string\">\".git/config\"</span>)</span><br><span class=\"line\"><span class=\"comment\">// IO(IO(\"[core]\\nrepositoryformatversion = 0\\n\"))</span></span><br></pre></td></tr></table></figure>\n<p>最后返回了一个嵌套两层的<code>IO</code>对象，如果想要再次调用，对其中的值进行处理，则需要<code>map(map(f))</code>；像是穿着两套防护服在工作，很奇怪。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Maybe.prototype.join = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.isNothing() ? Maybe.of(<span class=\"literal\">null</span>) : <span class=\"keyword\">this</span>.__value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mmo = Maybe.of(Maybe.of(<span class=\"string\">\"nunchucks\"</span>));</span><br><span class=\"line\"><span class=\"comment\">// Maybe(Maybe(\"nunchucks\"))</span></span><br><span class=\"line\"></span><br><span class=\"line\">mmo.join();</span><br><span class=\"line\"><span class=\"comment\">// Maybe(\"nunchucks\")</span></span><br></pre></td></tr></table></figure></p>\n<p>定义一个<code>join</code>方法，可以帮助我们简单地移除一层嵌套，在使用的时候，我们可以在每个map后面，都调用一次join方法，但是我们期望的不止如此。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  join :: Monad m =&gt; m (m a) -&gt; m a</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> join = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mma</span>)</span>&#123; <span class=\"keyword\">return</span> mma.join(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  firstAddressStreet :: User -&gt; Maybe Street</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstAddressStreet = compose(</span><br><span class=\"line\">  join, map(safeProp(<span class=\"string\">'street'</span>)), join, map(safeHead), safeProp(<span class=\"string\">'addresses'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"chain函数\"><a href=\"#chain函数\" class=\"headerlink\" title=\"chain函数\"></a>chain函数</h3><p>把<code>map</code>和<code>join</code>封装成chain函数，则<code>firstAddressStreet</code>方法可以改写成：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  chain :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> chain = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, m</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> m.map(f).join(); <span class=\"comment\">// 或者 compose(join, map(f))(m)</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  firstAddressStreet :: User -&gt; Maybe Street</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> firstAddressStreet = compose(</span><br><span class=\"line\">  chain(safeProp(<span class=\"string\">'street'</span>)), chain(safeHead), safeProp(<span class=\"string\">'addresses'</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>简单说，Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。</p>\n</blockquote>\n<p>REFS:<br><a href=\"http://www.ruanyifeng.com/blog/2015/07/monad.html\" target=\"_blank\" rel=\"noopener\">图解 Monad</a></p>\n"},{"title":"core-decorators源码简析——autobind","date":"2018-04-12T12:22:06.000Z","_content":"## 入口函数\n先看入口函数，通过`export default`暴露的autobind函数，通过`...args`形式的rest参数获取函数的多余参数，这儿是所有参数。通过decorator形式有两种调用方式：\n- @autobind()，会返回一个匿名函数`function (...argsClass) {return handle(argsClass);}`，argsClass为最终decorator传入的参数，函数内部返回了handle函数；在修饰器外面再封装一层函数的方式，可以用于接收额外的参数；\n- @autobind，args即为decorator传入的参数，直接调用handle函数\n\n``` js\n/**\n * 两种调用方式\n *\n * 2. @autobind\n * @param  {...[type]} args [description]\n * @return {[type]}         [description]\n */\nexport default function autobind(...args) {\n  if (args.length === 0) {\n    return function (...argsClass) {\n      return handle(argsClass);\n    };\n  } else {\n    return handle(args);\n  }\n}\n```\n## handle函数\nhandle函数根据参数的长度去判断修饰类型，当args参数长度为1时，是对类的修饰，该参数即所要修饰的目标类；当长度为3时，是对方法的修饰，参数和Object.defineProperty的参数相对应`target, name, descriptor:{value, configurable, enumerable, writable}`。\n``` js\nfunction handle(args) {\n  if (args.length === 1) {\n    return autobindClass(...args);\n  } else {\n    return autobindMethod(...args);\n  }\n}\n```\n## 对类的修饰\n- `Object.getOwnPropertyDescriptors`会以键值对的形式返回某对象属性的描述对象descriptor；\n- `getOwnKeys`方法会返回一个数组，包含目标类原型对象上所有的属性的键名，包括不可枚举属性以及Symbol属性\n`autobindClass`遍历目标类原型上的所有方法，若某个属性对应的value类型是`function`并且属性不是`constructor`，则用`Object.defineProperty`对该属性进行重新赋值，调用`autobindMethod`实现对该方法的autobind；\n<!-- more -->\n``` js\nfunction autobindClass(klass) {\n  const descs = getOwnPropertyDescriptors(klass.prototype);\n  const keys = getOwnKeys(descs);\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const desc = descs[key];\n\n    if (typeof desc.value !== 'function' || key === 'constructor') {\n      continue;\n    }\n    defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc));\n  }\n}\n```\n`getOwnKeys`方法的实现如下所示：\n``` js\nexport const getOwnKeys = getOwnPropertySymbols\n    ? function (object) {\n        return getOwnPropertyNames(object)\n          .concat(getOwnPropertySymbols(object));\n      }\n    : getOwnPropertyNames;\n```\n其中`getOwnPropertySymbols`会返回包含对象所有Symbol属性的数组，`getOwnPropertyNames`会返回包含自身所有属性（不包括Symbol属性，但包括不可枚举属性）的数组。\n此外，`Object.assign`拷贝只会拷贝属性的值，并不会拷贝它的赋值方法set和取值方法get，结合`Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))`可以实现对象属性取值、赋值方法的拷贝。\n\n## 对方法的修饰\n`autobindMethod`第一个参数是类的原型对象，第二个参数是要修饰的属性名，第三个参数是该属性的描述对象，它通过修改描述对象的get赋值方法，实现了对方法的自动绑定，返回修改后的descriptor。赋值方法内不同条件分别对应的调用场景为：\n1. `this === target`: 调用方式`let method = Child.prototype.childMethod`，this就是`Child.prototype`，不绑定直接return。\n2. `this.constructor !== constructor && getPrototypeOf(this).constructor === constructor`:  调用方式`let method = Child.prototype.parentMethod`，子类没有该方法，`this.constructor`是`Child.prototype.constructor`，`constructor`是`Parent.prototype.constructor`，二者不等，但是`this.__proto__.constructor`和`Parent.prototype.constructor`是相同的(在es6的继承中`Child.prototype.__proto__` === `Parent.prototype`)，不绑定直接return。\n3. `this.constructor !== constructor && key in this.constructor.prototype`: 子类调用父类的方法，仍然绑定为子类的this；如果不做该判断，直接到下一步bind(fn, this);则父类的方法会覆盖子类，下次调用就只执行父类中的方法了。\n4. 其他：调用`bind(fn, this)`绑定上下文。\n``` js\nfunction autobindMethod(target, key, { value: fn, configurable, enumerable }) {\n  if (typeof fn !== 'function') {\n    throw new SyntaxError(`@autobind can only be used on functions, not: ${fn}`);\n  }\n\n  const { constructor } = target;\n\n  return {\n    configurable,\n    enumerable,\n\n    get() {\n      // Class.prototype.key lookup\n      // Someone accesses the property directly on the prototype on which it is\n      // actually defined on, i.e. Class.prototype.hasOwnProperty(key)\n      if (this === target) {\n        return fn;\n      }\n\n      console.log(target, key)\n      // Class.prototype.key lookup\n      // Someone accesses the property directly on a prototype but it was found\n      // up the chain, not defined directly on it\n      // i.e. Class.prototype.hasOwnProperty(key) == false && key in Class.prototype\n      // Object.getPrototypeOf作用：\n      // 1. 用于获取一个实例对象的原型对象\n      // 2. Object.getPrototypeOf(ColorPoint) === Point 用来判断一个类是否继承了另一个类\n      if (this.constructor !== constructor && getPrototypeOf(this).constructor === constructor) {\n        return fn;\n      }\n\n      // Autobound method calling super.sameMethod() which is also autobound and so on.\n      // this.constructor: Child constructor: Parent\n      if (this.constructor !== constructor && key in this.constructor.prototype) {\n        return getBoundSuper(this, fn);\n      }\n\n      const boundFn = bind(fn, this);\n\n      defineProperty(this, key, {\n        configurable: true,\n        writable: true,\n        // NOT enumerable when it's a bound method\n        enumerable: false,\n        value: boundFn\n      });\n\n      return boundFn;\n    },\n    set: createDefaultSetter(key)\n  };\n}\n```\n实际调用时的例子：\n``` js\n@autobind\nclass Person {\n  constructor() {\n  }\n\n  getPerson() {\n    console.log('parent called, AWESOME METHOD');\n    return this;\n  }\n}\n\n@autobind\nclass Man extends Person {\n  constructor() {\n    super();\n  }\n\n  getMan() {\n    return this;\n  }\n}\n\n//四种方法分别对应上面列出的四种场景\nconsole.log('---Man.prototype.getMan---');\nlet getProtoMan = Man.prototype.getMan;\nconsole.log(getProtoMan());\n\nconsole.log('---Man.prototype.getPerson---');\nlet getProtoPerson = Man.prototype.getPerson;\nconsole.log(getProtoPerson());\n\nconsole.log('---man.getPerson---');\nlet man = new Man();\nlet getPerson = man.getPerson;\nconsole.log(getPerson() === man);\n\nconsole.log('---man.getMan---');\nlet man2 = new Man();\nlet getMan = man2.getMan;\nconsole.log(getMan() === man2);\n```\n输出结果如下图所示：\n<img src=\"/image/autobind_console.png\" width=\"800px\">\n## getBoundSuper函数\n### 作用\n给子类Man添加一个方法`getPerson`，方法内通过super调用父类的getPerson方法，`super.getPerson`对应上述场景3；如果不调用getBoundSuper函数，子类的getPerson方法在执行`super.getPerson`时会被父类覆盖，会导致下面方法只有第一次会输出'parent called, AWESOME METHOD'和'child called, AWESOME CHILD METHOD'，其他四次则只输出'parent called, AWESOME METHOD'。\n``` js\n@autobind\nclass Man extends Person {\n  constructor() {\n    super();\n  }\n\n  getPerson() {\n    console.log('child called, AWESOME CHILD METHOD');\n    super.getPerson();\n    return this;\n  }\n\n  getMan() {\n    return this;\n  }\n}\n\nfor (var i = 0; i < 5; ++i) {\n  console.log('invoking');\n  man.getPerson();\n  console.log('---');\n}\n```\n\n### WeakMap的特性：\n> 1. 只能用对象obj作为key值\n> 2. WeakMap的键名对应的对象不计入垃圾回收机制，如果对应的对象被清除，垃圾回收机制就会释放该对象所占用的内存，即WeakMap中的对应的键名对象和键值也会自动消失，不用手动删除\n适用场景：WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。\n\n通过getBoundSuper可以将父类方法绑定到子类this上，并且使用WeakMap存储已经绑定的方法，在mapStore中key值对应子类实例，不同的子类实例对应不同的WeakMap，若该子类被删除，对应的WeakMap对象也会被清除。\n``` js\nlet mapStore;\nfunction getBoundSuper(obj, fn) {\n  if (!mapStore) {\n     mapStore = new WeakMap();\n  }\n\n  if (mapStore.has(obj) === false) {\n    mapStore.set(obj, new WeakMap());\n  }\n\n  const superStore = mapStore.get(obj);\n\n  if (superStore.has(fn) === false) {\n    superStore.set(fn, bind(fn, obj));\n  }\n\n  return superStore.get(fn);\n}\n```\n","source":"_posts/core-decorators源码简析——autobind.md","raw":"---\ntitle: core-decorators源码简析——autobind\ndate: 2018-04-12 20:22:06\ntags: [core-decorators, decorator, autobind, js]\n---\n## 入口函数\n先看入口函数，通过`export default`暴露的autobind函数，通过`...args`形式的rest参数获取函数的多余参数，这儿是所有参数。通过decorator形式有两种调用方式：\n- @autobind()，会返回一个匿名函数`function (...argsClass) {return handle(argsClass);}`，argsClass为最终decorator传入的参数，函数内部返回了handle函数；在修饰器外面再封装一层函数的方式，可以用于接收额外的参数；\n- @autobind，args即为decorator传入的参数，直接调用handle函数\n\n``` js\n/**\n * 两种调用方式\n *\n * 2. @autobind\n * @param  {...[type]} args [description]\n * @return {[type]}         [description]\n */\nexport default function autobind(...args) {\n  if (args.length === 0) {\n    return function (...argsClass) {\n      return handle(argsClass);\n    };\n  } else {\n    return handle(args);\n  }\n}\n```\n## handle函数\nhandle函数根据参数的长度去判断修饰类型，当args参数长度为1时，是对类的修饰，该参数即所要修饰的目标类；当长度为3时，是对方法的修饰，参数和Object.defineProperty的参数相对应`target, name, descriptor:{value, configurable, enumerable, writable}`。\n``` js\nfunction handle(args) {\n  if (args.length === 1) {\n    return autobindClass(...args);\n  } else {\n    return autobindMethod(...args);\n  }\n}\n```\n## 对类的修饰\n- `Object.getOwnPropertyDescriptors`会以键值对的形式返回某对象属性的描述对象descriptor；\n- `getOwnKeys`方法会返回一个数组，包含目标类原型对象上所有的属性的键名，包括不可枚举属性以及Symbol属性\n`autobindClass`遍历目标类原型上的所有方法，若某个属性对应的value类型是`function`并且属性不是`constructor`，则用`Object.defineProperty`对该属性进行重新赋值，调用`autobindMethod`实现对该方法的autobind；\n<!-- more -->\n``` js\nfunction autobindClass(klass) {\n  const descs = getOwnPropertyDescriptors(klass.prototype);\n  const keys = getOwnKeys(descs);\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const desc = descs[key];\n\n    if (typeof desc.value !== 'function' || key === 'constructor') {\n      continue;\n    }\n    defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc));\n  }\n}\n```\n`getOwnKeys`方法的实现如下所示：\n``` js\nexport const getOwnKeys = getOwnPropertySymbols\n    ? function (object) {\n        return getOwnPropertyNames(object)\n          .concat(getOwnPropertySymbols(object));\n      }\n    : getOwnPropertyNames;\n```\n其中`getOwnPropertySymbols`会返回包含对象所有Symbol属性的数组，`getOwnPropertyNames`会返回包含自身所有属性（不包括Symbol属性，但包括不可枚举属性）的数组。\n此外，`Object.assign`拷贝只会拷贝属性的值，并不会拷贝它的赋值方法set和取值方法get，结合`Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))`可以实现对象属性取值、赋值方法的拷贝。\n\n## 对方法的修饰\n`autobindMethod`第一个参数是类的原型对象，第二个参数是要修饰的属性名，第三个参数是该属性的描述对象，它通过修改描述对象的get赋值方法，实现了对方法的自动绑定，返回修改后的descriptor。赋值方法内不同条件分别对应的调用场景为：\n1. `this === target`: 调用方式`let method = Child.prototype.childMethod`，this就是`Child.prototype`，不绑定直接return。\n2. `this.constructor !== constructor && getPrototypeOf(this).constructor === constructor`:  调用方式`let method = Child.prototype.parentMethod`，子类没有该方法，`this.constructor`是`Child.prototype.constructor`，`constructor`是`Parent.prototype.constructor`，二者不等，但是`this.__proto__.constructor`和`Parent.prototype.constructor`是相同的(在es6的继承中`Child.prototype.__proto__` === `Parent.prototype`)，不绑定直接return。\n3. `this.constructor !== constructor && key in this.constructor.prototype`: 子类调用父类的方法，仍然绑定为子类的this；如果不做该判断，直接到下一步bind(fn, this);则父类的方法会覆盖子类，下次调用就只执行父类中的方法了。\n4. 其他：调用`bind(fn, this)`绑定上下文。\n``` js\nfunction autobindMethod(target, key, { value: fn, configurable, enumerable }) {\n  if (typeof fn !== 'function') {\n    throw new SyntaxError(`@autobind can only be used on functions, not: ${fn}`);\n  }\n\n  const { constructor } = target;\n\n  return {\n    configurable,\n    enumerable,\n\n    get() {\n      // Class.prototype.key lookup\n      // Someone accesses the property directly on the prototype on which it is\n      // actually defined on, i.e. Class.prototype.hasOwnProperty(key)\n      if (this === target) {\n        return fn;\n      }\n\n      console.log(target, key)\n      // Class.prototype.key lookup\n      // Someone accesses the property directly on a prototype but it was found\n      // up the chain, not defined directly on it\n      // i.e. Class.prototype.hasOwnProperty(key) == false && key in Class.prototype\n      // Object.getPrototypeOf作用：\n      // 1. 用于获取一个实例对象的原型对象\n      // 2. Object.getPrototypeOf(ColorPoint) === Point 用来判断一个类是否继承了另一个类\n      if (this.constructor !== constructor && getPrototypeOf(this).constructor === constructor) {\n        return fn;\n      }\n\n      // Autobound method calling super.sameMethod() which is also autobound and so on.\n      // this.constructor: Child constructor: Parent\n      if (this.constructor !== constructor && key in this.constructor.prototype) {\n        return getBoundSuper(this, fn);\n      }\n\n      const boundFn = bind(fn, this);\n\n      defineProperty(this, key, {\n        configurable: true,\n        writable: true,\n        // NOT enumerable when it's a bound method\n        enumerable: false,\n        value: boundFn\n      });\n\n      return boundFn;\n    },\n    set: createDefaultSetter(key)\n  };\n}\n```\n实际调用时的例子：\n``` js\n@autobind\nclass Person {\n  constructor() {\n  }\n\n  getPerson() {\n    console.log('parent called, AWESOME METHOD');\n    return this;\n  }\n}\n\n@autobind\nclass Man extends Person {\n  constructor() {\n    super();\n  }\n\n  getMan() {\n    return this;\n  }\n}\n\n//四种方法分别对应上面列出的四种场景\nconsole.log('---Man.prototype.getMan---');\nlet getProtoMan = Man.prototype.getMan;\nconsole.log(getProtoMan());\n\nconsole.log('---Man.prototype.getPerson---');\nlet getProtoPerson = Man.prototype.getPerson;\nconsole.log(getProtoPerson());\n\nconsole.log('---man.getPerson---');\nlet man = new Man();\nlet getPerson = man.getPerson;\nconsole.log(getPerson() === man);\n\nconsole.log('---man.getMan---');\nlet man2 = new Man();\nlet getMan = man2.getMan;\nconsole.log(getMan() === man2);\n```\n输出结果如下图所示：\n<img src=\"/image/autobind_console.png\" width=\"800px\">\n## getBoundSuper函数\n### 作用\n给子类Man添加一个方法`getPerson`，方法内通过super调用父类的getPerson方法，`super.getPerson`对应上述场景3；如果不调用getBoundSuper函数，子类的getPerson方法在执行`super.getPerson`时会被父类覆盖，会导致下面方法只有第一次会输出'parent called, AWESOME METHOD'和'child called, AWESOME CHILD METHOD'，其他四次则只输出'parent called, AWESOME METHOD'。\n``` js\n@autobind\nclass Man extends Person {\n  constructor() {\n    super();\n  }\n\n  getPerson() {\n    console.log('child called, AWESOME CHILD METHOD');\n    super.getPerson();\n    return this;\n  }\n\n  getMan() {\n    return this;\n  }\n}\n\nfor (var i = 0; i < 5; ++i) {\n  console.log('invoking');\n  man.getPerson();\n  console.log('---');\n}\n```\n\n### WeakMap的特性：\n> 1. 只能用对象obj作为key值\n> 2. WeakMap的键名对应的对象不计入垃圾回收机制，如果对应的对象被清除，垃圾回收机制就会释放该对象所占用的内存，即WeakMap中的对应的键名对象和键值也会自动消失，不用手动删除\n适用场景：WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。\n\n通过getBoundSuper可以将父类方法绑定到子类this上，并且使用WeakMap存储已经绑定的方法，在mapStore中key值对应子类实例，不同的子类实例对应不同的WeakMap，若该子类被删除，对应的WeakMap对象也会被清除。\n``` js\nlet mapStore;\nfunction getBoundSuper(obj, fn) {\n  if (!mapStore) {\n     mapStore = new WeakMap();\n  }\n\n  if (mapStore.has(obj) === false) {\n    mapStore.set(obj, new WeakMap());\n  }\n\n  const superStore = mapStore.get(obj);\n\n  if (superStore.has(fn) === false) {\n    superStore.set(fn, bind(fn, obj));\n  }\n\n  return superStore.get(fn);\n}\n```\n","slug":"core-decorators源码简析——autobind","published":1,"updated":"2019-03-18T02:27:14.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx80002qqmhfg2gakr0e","content":"<h2 id=\"入口函数\"><a href=\"#入口函数\" class=\"headerlink\" title=\"入口函数\"></a>入口函数</h2><p>先看入口函数，通过<code>export default</code>暴露的autobind函数，通过<code>...args</code>形式的rest参数获取函数的多余参数，这儿是所有参数。通过decorator形式有两种调用方式：</p>\n<ul>\n<li>@autobind()，会返回一个匿名函数<code>function (...argsClass) {return handle(argsClass);}</code>，argsClass为最终decorator传入的参数，函数内部返回了handle函数；在修饰器外面再封装一层函数的方式，可以用于接收额外的参数；</li>\n<li>@autobind，args即为decorator传入的参数，直接调用handle函数</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 两种调用方式</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. @autobind</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;...[type]&#125; args [description]</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;[type]&#125;         [description]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autobind</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (args.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...argsClass</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> handle(argsClass);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handle(args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"handle函数\"><a href=\"#handle函数\" class=\"headerlink\" title=\"handle函数\"></a>handle函数</h2><p>handle函数根据参数的长度去判断修饰类型，当args参数长度为1时，是对类的修饰，该参数即所要修饰的目标类；当长度为3时，是对方法的修饰，参数和Object.defineProperty的参数相对应<code>target, name, descriptor:{value, configurable, enumerable, writable}</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (args.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> autobindClass(...args);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> autobindMethod(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"对类的修饰\"><a href=\"#对类的修饰\" class=\"headerlink\" title=\"对类的修饰\"></a>对类的修饰</h2><ul>\n<li><code>Object.getOwnPropertyDescriptors</code>会以键值对的形式返回某对象属性的描述对象descriptor；</li>\n<li><code>getOwnKeys</code>方法会返回一个数组，包含目标类原型对象上所有的属性的键名，包括不可枚举属性以及Symbol属性<br><code>autobindClass</code>遍历目标类原型上的所有方法，若某个属性对应的value类型是<code>function</code>并且属性不是<code>constructor</code>，则用<code>Object.defineProperty</code>对该属性进行重新赋值，调用<code>autobindMethod</code>实现对该方法的autobind；<a id=\"more\"></a>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autobindClass</span>(<span class=\"params\">klass</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> descs = getOwnPropertyDescriptors(klass.prototype);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> keys = getOwnKeys(descs);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = keys[i];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> desc = descs[key];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> desc.value !== <span class=\"string\">'function'</span> || key === <span class=\"string\">'constructor'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>getOwnKeys</code>方法的实现如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getOwnKeys = getOwnPropertySymbols</span><br><span class=\"line\">    ? <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">object</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getOwnPropertyNames(object)</span><br><span class=\"line\">          .concat(getOwnPropertySymbols(object));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    : getOwnPropertyNames;</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>getOwnPropertySymbols</code>会返回包含对象所有Symbol属性的数组，<code>getOwnPropertyNames</code>会返回包含自身所有属性（不包括Symbol属性，但包括不可枚举属性）的数组。<br>此外，<code>Object.assign</code>拷贝只会拷贝属性的值，并不会拷贝它的赋值方法set和取值方法get，结合<code>Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))</code>可以实现对象属性取值、赋值方法的拷贝。</p>\n<h2 id=\"对方法的修饰\"><a href=\"#对方法的修饰\" class=\"headerlink\" title=\"对方法的修饰\"></a>对方法的修饰</h2><p><code>autobindMethod</code>第一个参数是类的原型对象，第二个参数是要修饰的属性名，第三个参数是该属性的描述对象，它通过修改描述对象的get赋值方法，实现了对方法的自动绑定，返回修改后的descriptor。赋值方法内不同条件分别对应的调用场景为：</p>\n<ol>\n<li><code>this === target</code>: 调用方式<code>let method = Child.prototype.childMethod</code>，this就是<code>Child.prototype</code>，不绑定直接return。</li>\n<li><code>this.constructor !== constructor &amp;&amp; getPrototypeOf(this).constructor === constructor</code>:  调用方式<code>let method = Child.prototype.parentMethod</code>，子类没有该方法，<code>this.constructor</code>是<code>Child.prototype.constructor</code>，<code>constructor</code>是<code>Parent.prototype.constructor</code>，二者不等，但是<code>this.__proto__.constructor</code>和<code>Parent.prototype.constructor</code>是相同的(在es6的继承中<code>Child.prototype.__proto__</code> === <code>Parent.prototype</code>)，不绑定直接return。</li>\n<li><code>this.constructor !== constructor &amp;&amp; key in this.constructor.prototype</code>: 子类调用父类的方法，仍然绑定为子类的this；如果不做该判断，直接到下一步bind(fn, this);则父类的方法会覆盖子类，下次调用就只执行父类中的方法了。</li>\n<li>其他：调用<code>bind(fn, this)</code>绑定上下文。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autobindMethod</span>(<span class=\"params\">target, key, &#123; value: fn, configurable, enumerable &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">SyntaxError</span>(<span class=\"string\">`@autobind can only be used on functions, not: <span class=\"subst\">$&#123;fn&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">constructor</span> &#125; = target;</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    configurable,</span><br><span class=\"line\">    enumerable,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Class.prototype.key lookup</span></span><br><span class=\"line\">      <span class=\"comment\">// Someone accesses the property directly on the prototype on which it is</span></span><br><span class=\"line\">      <span class=\"comment\">// actually defined on, i.e. Class.prototype.hasOwnProperty(key)</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> === target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(target, key)</span><br><span class=\"line\">      <span class=\"comment\">// Class.prototype.key lookup</span></span><br><span class=\"line\">      <span class=\"comment\">// Someone accesses the property directly on a prototype but it was found</span></span><br><span class=\"line\">      <span class=\"comment\">// up the chain, not defined directly on it</span></span><br><span class=\"line\">      <span class=\"comment\">// i.e. Class.prototype.hasOwnProperty(key) == false &amp;&amp; key in Class.prototype</span></span><br><span class=\"line\">      <span class=\"comment\">// Object.getPrototypeOf作用：</span></span><br><span class=\"line\">      <span class=\"comment\">// 1. 用于获取一个实例对象的原型对象</span></span><br><span class=\"line\">      <span class=\"comment\">// 2. Object.getPrototypeOf(ColorPoint) === Point 用来判断一个类是否继承了另一个类</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.constructor !== <span class=\"keyword\">constructor</span> &amp;&amp; getPrototypeOf(this).<span class=\"keyword\">constructor</span> === <span class=\"keyword\">constructor</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Autobound method calling super.sameMethod() which is also autobound and so on.</span></span><br><span class=\"line\">      <span class=\"comment\">// this.constructor: Child constructor: Parent</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.constructor !== <span class=\"keyword\">constructor</span> &amp;&amp; key in this.<span class=\"keyword\">constructor</span>.prototype) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getBoundSuper(<span class=\"keyword\">this</span>, fn);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> boundFn = bind(fn, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      defineProperty(<span class=\"keyword\">this</span>, key, &#123;</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"comment\">// NOT enumerable when it's a bound method</span></span><br><span class=\"line\">        enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        value: boundFn</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> boundFn;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>: createDefaultSetter(key)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>实际调用时的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autobind</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPerson() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'parent called, AWESOME METHOD'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@autobind</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getMan() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//四种方法分别对应上面列出的四种场景</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'---Man.prototype.getMan---'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> getProtoMan = Man.prototype.getMan;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getProtoMan());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'---Man.prototype.getPerson---'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> getProtoPerson = Man.prototype.getPerson;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getProtoPerson());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'---man.getPerson---'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> man = <span class=\"keyword\">new</span> Man();</span><br><span class=\"line\"><span class=\"keyword\">let</span> getPerson = man.getPerson;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPerson() === man);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'---man.getMan---'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> man2 = <span class=\"keyword\">new</span> Man();</span><br><span class=\"line\"><span class=\"keyword\">let</span> getMan = man2.getMan;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getMan() === man2);</span><br></pre></td></tr></table></figure></p>\n<p>输出结果如下图所示：<br><img src=\"/image/autobind_console.png\" width=\"800px\"></p>\n<h2 id=\"getBoundSuper函数\"><a href=\"#getBoundSuper函数\" class=\"headerlink\" title=\"getBoundSuper函数\"></a>getBoundSuper函数</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>给子类Man添加一个方法<code>getPerson</code>，方法内通过super调用父类的getPerson方法，<code>super.getPerson</code>对应上述场景3；如果不调用getBoundSuper函数，子类的getPerson方法在执行<code>super.getPerson</code>时会被父类覆盖，会导致下面方法只有第一次会输出’parent called, AWESOME METHOD’和’child called, AWESOME CHILD METHOD’，其他四次则只输出’parent called, AWESOME METHOD’。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autobind</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPerson() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'child called, AWESOME CHILD METHOD'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.getPerson();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getMan() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'invoking'</span>);</span><br><span class=\"line\">  man.getPerson();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'---'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"WeakMap的特性：\"><a href=\"#WeakMap的特性：\" class=\"headerlink\" title=\"WeakMap的特性：\"></a>WeakMap的特性：</h3><blockquote>\n<ol>\n<li>只能用对象obj作为key值</li>\n<li>WeakMap的键名对应的对象不计入垃圾回收机制，如果对应的对象被清除，垃圾回收机制就会释放该对象所占用的内存，即WeakMap中的对应的键名对象和键值也会自动消失，不用手动删除<br>适用场景：WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</li>\n</ol>\n</blockquote>\n<p>通过getBoundSuper可以将父类方法绑定到子类this上，并且使用WeakMap存储已经绑定的方法，在mapStore中key值对应子类实例，不同的子类实例对应不同的WeakMap，若该子类被删除，对应的WeakMap对象也会被清除。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mapStore;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoundSuper</span>(<span class=\"params\">obj, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!mapStore) &#123;</span><br><span class=\"line\">     mapStore = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mapStore.has(obj) === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    mapStore.set(obj, <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> superStore = mapStore.get(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (superStore.has(fn) === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    superStore.set(fn, bind(fn, obj));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> superStore.get(fn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"入口函数\"><a href=\"#入口函数\" class=\"headerlink\" title=\"入口函数\"></a>入口函数</h2><p>先看入口函数，通过<code>export default</code>暴露的autobind函数，通过<code>...args</code>形式的rest参数获取函数的多余参数，这儿是所有参数。通过decorator形式有两种调用方式：</p>\n<ul>\n<li>@autobind()，会返回一个匿名函数<code>function (...argsClass) {return handle(argsClass);}</code>，argsClass为最终decorator传入的参数，函数内部返回了handle函数；在修饰器外面再封装一层函数的方式，可以用于接收额外的参数；</li>\n<li>@autobind，args即为decorator传入的参数，直接调用handle函数</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 两种调用方式</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * 2. @autobind</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;...[type]&#125; args [description]</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;[type]&#125;         [description]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autobind</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (args.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">...argsClass</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> handle(argsClass);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handle(args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"handle函数\"><a href=\"#handle函数\" class=\"headerlink\" title=\"handle函数\"></a>handle函数</h2><p>handle函数根据参数的长度去判断修饰类型，当args参数长度为1时，是对类的修饰，该参数即所要修饰的目标类；当长度为3时，是对方法的修饰，参数和Object.defineProperty的参数相对应<code>target, name, descriptor:{value, configurable, enumerable, writable}</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (args.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> autobindClass(...args);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> autobindMethod(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"对类的修饰\"><a href=\"#对类的修饰\" class=\"headerlink\" title=\"对类的修饰\"></a>对类的修饰</h2><ul>\n<li><code>Object.getOwnPropertyDescriptors</code>会以键值对的形式返回某对象属性的描述对象descriptor；</li>\n<li><code>getOwnKeys</code>方法会返回一个数组，包含目标类原型对象上所有的属性的键名，包括不可枚举属性以及Symbol属性<br><code>autobindClass</code>遍历目标类原型上的所有方法，若某个属性对应的value类型是<code>function</code>并且属性不是<code>constructor</code>，则用<code>Object.defineProperty</code>对该属性进行重新赋值，调用<code>autobindMethod</code>实现对该方法的autobind；","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autobindClass</span>(<span class=\"params\">klass</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> descs = getOwnPropertyDescriptors(klass.prototype);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> keys = getOwnKeys(descs);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = keys[i];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> desc = descs[key];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> desc.value !== <span class=\"string\">'function'</span> || key === <span class=\"string\">'constructor'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>getOwnKeys</code>方法的实现如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getOwnKeys = getOwnPropertySymbols</span><br><span class=\"line\">    ? <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">object</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getOwnPropertyNames(object)</span><br><span class=\"line\">          .concat(getOwnPropertySymbols(object));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    : getOwnPropertyNames;</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>getOwnPropertySymbols</code>会返回包含对象所有Symbol属性的数组，<code>getOwnPropertyNames</code>会返回包含自身所有属性（不包括Symbol属性，但包括不可枚举属性）的数组。<br>此外，<code>Object.assign</code>拷贝只会拷贝属性的值，并不会拷贝它的赋值方法set和取值方法get，结合<code>Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))</code>可以实现对象属性取值、赋值方法的拷贝。</p>\n<h2 id=\"对方法的修饰\"><a href=\"#对方法的修饰\" class=\"headerlink\" title=\"对方法的修饰\"></a>对方法的修饰</h2><p><code>autobindMethod</code>第一个参数是类的原型对象，第二个参数是要修饰的属性名，第三个参数是该属性的描述对象，它通过修改描述对象的get赋值方法，实现了对方法的自动绑定，返回修改后的descriptor。赋值方法内不同条件分别对应的调用场景为：</p>\n<ol>\n<li><code>this === target</code>: 调用方式<code>let method = Child.prototype.childMethod</code>，this就是<code>Child.prototype</code>，不绑定直接return。</li>\n<li><code>this.constructor !== constructor &amp;&amp; getPrototypeOf(this).constructor === constructor</code>:  调用方式<code>let method = Child.prototype.parentMethod</code>，子类没有该方法，<code>this.constructor</code>是<code>Child.prototype.constructor</code>，<code>constructor</code>是<code>Parent.prototype.constructor</code>，二者不等，但是<code>this.__proto__.constructor</code>和<code>Parent.prototype.constructor</code>是相同的(在es6的继承中<code>Child.prototype.__proto__</code> === <code>Parent.prototype</code>)，不绑定直接return。</li>\n<li><code>this.constructor !== constructor &amp;&amp; key in this.constructor.prototype</code>: 子类调用父类的方法，仍然绑定为子类的this；如果不做该判断，直接到下一步bind(fn, this);则父类的方法会覆盖子类，下次调用就只执行父类中的方法了。</li>\n<li>其他：调用<code>bind(fn, this)</code>绑定上下文。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autobindMethod</span>(<span class=\"params\">target, key, &#123; value: fn, configurable, enumerable &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fn !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">SyntaxError</span>(<span class=\"string\">`@autobind can only be used on functions, not: <span class=\"subst\">$&#123;fn&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; <span class=\"keyword\">constructor</span> &#125; = target;</span><br><span class=\"line\"></span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    configurable,</span><br><span class=\"line\">    enumerable,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">get</span>() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Class.prototype.key lookup</span></span><br><span class=\"line\">      <span class=\"comment\">// Someone accesses the property directly on the prototype on which it is</span></span><br><span class=\"line\">      <span class=\"comment\">// actually defined on, i.e. Class.prototype.hasOwnProperty(key)</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> === target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(target, key)</span><br><span class=\"line\">      <span class=\"comment\">// Class.prototype.key lookup</span></span><br><span class=\"line\">      <span class=\"comment\">// Someone accesses the property directly on a prototype but it was found</span></span><br><span class=\"line\">      <span class=\"comment\">// up the chain, not defined directly on it</span></span><br><span class=\"line\">      <span class=\"comment\">// i.e. Class.prototype.hasOwnProperty(key) == false &amp;&amp; key in Class.prototype</span></span><br><span class=\"line\">      <span class=\"comment\">// Object.getPrototypeOf作用：</span></span><br><span class=\"line\">      <span class=\"comment\">// 1. 用于获取一个实例对象的原型对象</span></span><br><span class=\"line\">      <span class=\"comment\">// 2. Object.getPrototypeOf(ColorPoint) === Point 用来判断一个类是否继承了另一个类</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.constructor !== <span class=\"keyword\">constructor</span> &amp;&amp; getPrototypeOf(this).<span class=\"keyword\">constructor</span> === <span class=\"keyword\">constructor</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// Autobound method calling super.sameMethod() which is also autobound and so on.</span></span><br><span class=\"line\">      <span class=\"comment\">// this.constructor: Child constructor: Parent</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.constructor !== <span class=\"keyword\">constructor</span> &amp;&amp; key in this.<span class=\"keyword\">constructor</span>.prototype) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getBoundSuper(<span class=\"keyword\">this</span>, fn);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> boundFn = bind(fn, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      defineProperty(<span class=\"keyword\">this</span>, key, &#123;</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        writable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"comment\">// NOT enumerable when it's a bound method</span></span><br><span class=\"line\">        enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        value: boundFn</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> boundFn;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>: createDefaultSetter(key)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>实际调用时的例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autobind</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPerson() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'parent called, AWESOME METHOD'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@autobind</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getMan() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//四种方法分别对应上面列出的四种场景</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'---Man.prototype.getMan---'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> getProtoMan = Man.prototype.getMan;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getProtoMan());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'---Man.prototype.getPerson---'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> getProtoPerson = Man.prototype.getPerson;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getProtoPerson());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'---man.getPerson---'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> man = <span class=\"keyword\">new</span> Man();</span><br><span class=\"line\"><span class=\"keyword\">let</span> getPerson = man.getPerson;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getPerson() === man);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'---man.getMan---'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> man2 = <span class=\"keyword\">new</span> Man();</span><br><span class=\"line\"><span class=\"keyword\">let</span> getMan = man2.getMan;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getMan() === man2);</span><br></pre></td></tr></table></figure></p>\n<p>输出结果如下图所示：<br><img src=\"/image/autobind_console.png\" width=\"800px\"></p>\n<h2 id=\"getBoundSuper函数\"><a href=\"#getBoundSuper函数\" class=\"headerlink\" title=\"getBoundSuper函数\"></a>getBoundSuper函数</h2><h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>给子类Man添加一个方法<code>getPerson</code>，方法内通过super调用父类的getPerson方法，<code>super.getPerson</code>对应上述场景3；如果不调用getBoundSuper函数，子类的getPerson方法在执行<code>super.getPerson</code>时会被父类覆盖，会导致下面方法只有第一次会输出’parent called, AWESOME METHOD’和’child called, AWESOME CHILD METHOD’，其他四次则只输出’parent called, AWESOME METHOD’。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autobind</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getPerson() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'child called, AWESOME CHILD METHOD'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.getPerson();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getMan() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; ++i) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'invoking'</span>);</span><br><span class=\"line\">  man.getPerson();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'---'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"WeakMap的特性：\"><a href=\"#WeakMap的特性：\" class=\"headerlink\" title=\"WeakMap的特性：\"></a>WeakMap的特性：</h3><blockquote>\n<ol>\n<li>只能用对象obj作为key值</li>\n<li>WeakMap的键名对应的对象不计入垃圾回收机制，如果对应的对象被清除，垃圾回收机制就会释放该对象所占用的内存，即WeakMap中的对应的键名对象和键值也会自动消失，不用手动删除<br>适用场景：WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</li>\n</ol>\n</blockquote>\n<p>通过getBoundSuper可以将父类方法绑定到子类this上，并且使用WeakMap存储已经绑定的方法，在mapStore中key值对应子类实例，不同的子类实例对应不同的WeakMap，若该子类被删除，对应的WeakMap对象也会被清除。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mapStore;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getBoundSuper</span>(<span class=\"params\">obj, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!mapStore) &#123;</span><br><span class=\"line\">     mapStore = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mapStore.has(obj) === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    mapStore.set(obj, <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> superStore = mapStore.get(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (superStore.has(fn) === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    superStore.set(fn, bind(fn, obj));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> superStore.get(fn);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"react高阶组件","date":"2017-10-30T09:39:56.000Z","_content":"### 什么是高阶组件？\n官方文档指出，高阶组件（Higher-Order Components，简称HOC）是react中对组件逻辑进行重用的高级技术。但高阶组件本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。\n具体而言，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。\n先看一个典型的高阶组件：\n``` js\n// It's a function...\nfunction myHOC() {\n  // Which returns a function that takes a component...\n  return function(WrappedComponent) {\n    // It creates a new wrapper component...\n    class TheHOC extends React.Component {\n      render() {\n        // And it renders the component it was given\n        return <WrappedComponent {...this.props} />;\n      }\n    }\n\n    // Remember: it takes a component and returns a new component\n    // Gotta return it here.\n    return TheHOC;\n  }\n}\n```\n### 使用高阶组件优化代码\n需求是要在网站的每个页面要添加签到请求和签到成功弹窗，显然，一般人都不会想着要在每个页面写一遍。首先，我想到的是引入一个React组件，但是要在每个页面的render方法里面添加该组件，需要改动所有页面对应组件的render方法，感觉比较繁琐且易出错。也可以通过js方法去动态创建签到成功弹窗，然后在每个页面里面引入该方法，不过同样需要改变组件内部方法，且不符合React项目风格。\n最后，发现高阶组件可以满足我的需求，既实现了功能又不污染原有组件。下面是简化版的签到高阶组件：\n<!-- more -->\n``` js\nexport const signHoc = ComposedComponent => class extends Component {\n    constructor(props) {\n        super(props)\n        this.state = {show: false, config: {}}\n    }\n\n    componentDidMount() {\n        if(!this.props.showSign) return;\n        this.setState({\n            show: true,\n            config: {\n                title: '今日首次登录',\n                content: `获赠<em>50</em>阅点红包`\n            }\n        })\n    }\n\n    render() {\n        const {show, config} = this.state;\n        const {showSign, ...passThroughProps} = this.props;\n        return (<div>\n            <ComposedComponent {...passThroughProps} />\n            {show && (<MessageModal config={config}/>)}\n        </div>);\n    }\n};\n```\n可以通过this.props获得传给WrappedComponent的props，在操作props的时候要确保不会破坏要传给WrappedComponent的props。在componentDidMount可以发起签到请求，此外可以根据props.showSign和签到结果决定是否显示签到组件等。当页面有其他弹窗的优先级大于签到弹窗时，props.showSign设为false，就可以控制签到弹窗是否显示。\n```\nexport default class WrappedComponent extends Component {\n    render() {\n        return false\n    }\n}\nsignHoc(WrappedComponent)\n```\n调用signHoc函数获得组合后的组件，也可以结合@decorator简化调用。\n```\n@signHoc\nexport default class WrappedComponent extends Component {\n    render() {\n        return false\n    }\n}\n```\n\n### 结合Context API使用\n`React 16.3`引入了全新的`Context API`，主要提供的API有：`React.createContext`, `Provider`和`Consumer`，详见[context](https://reactjs.org/docs/context.html)。\n这儿记录下如何结合高阶组件和Context API去实现全局变量的设置，如主题theme。\nstep1: 定义高阶组件，通过`ThemeContext.Consumer`获取变量并且传递给组件ComposedComponent。\n``` js\nexport const ThemeContext = React.createContext({\n    theme: localStorage.getItem('N_reader_theme') || 'light',\n    changeTheme: () => {}});\n\nexport const themeHoc = ComposedComponent => {\n    props => {\n        <ThemeContext.Consumer>\n            {({theme, changeTheme}) => <ComposedComponent {...props} theme={theme} changeTheme={changeTheme}/>}\n        </ThemeContext.Consumer>\n    }\n}\n```\n\nstep2: 使用`ThemeContext.Provider`传递当前theme、changeTheme给整个子树，任何子组件都可以读到这些变量的值，不需要显式的通过props传递。\n``` js\nimport {ThemeContext} from 'themeHoc.js'\n\nexport default class App extends Component {\n    changeTheme(theme) {\n        localStorage.setItem('N_reader_theme', theme);\n        document.querySelector('body').className = document.querySelector('body').className.replace(/theme--\\w*/, 'theme--' + theme);\n        this.setState({\n            theme: theme\n        })\n    }\n\n    render() {\n        return (\n            <ThemeContext.provider value={{theme: this.state.theme, changeTheme: this.changeTheme}}>\n                <Content />\n            </ThemeContext.provider>\n        )\n    }\n}\n```\n\nstep3: 通过decorator的方式添加`@themeHoc`标记，Content组件可以直接从props中读取theme和changeTheme函数。\n``` js\nimport {themeHoc} from 'themeHoc.js'\n\n@themeHoc\nexport default class Content extends Component {\n    render() {\n        return (\n            <div theme={props.theme}>\n                <a href=\"javascript:;\" className={props.theme} onClick={props.changeTheme.bind(this, 'blue')}>blue</a>\n                <a href=\"javascript:;\" className={props.theme} onClick={props.changeTheme.bind(this, 'yellow')}>yellow</a>\n            </div>\n        )\n    }\n}\n```\n\n### 公约\n\n#### 最大化使用组合\n高阶组件可以接受一个或多个参数：\n```\n//仅接收包裹组件一个参数\nconst NavbarWithRouter = withRouter(Navbar);\n//接收包裹组件和额外的参数\nconst CommentWithRelay = Relay.createContainer(Comment, config);\n//connect(commentListSelector, commentListActions)返回了一个高阶组件，最后作用于Comment组件\nconst ConnectedComment = connect(commentSelector, commentActions)(Comment);\n```\n#### 包装显示名字以便于调试\n高价组件创建的容器组件在React Developer Tools中的表现和其它的普通组件是一样的。为了便于调试，可以选择一个好的名字，确保能够识别出它是由高阶组件创建的新组件还是普通的组件。\n最常用的技术就是将包裹组件的名字包装在显示名字中。所以，如果你的高阶组件名字是 withSubscription，且包裹组件的显示名字是 CommentList，那么就是用 withSubscription(CommentList)这样的显示名字：\n``` js\nfunction withSubscription(WrappedComponent) {\n  class WithSubscription extends React.Component {/* ... */}\n  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n  return WithSubscription;\n}\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n```\n### 注意事项\n#### 静态方法需要被复制\n当你通过 HOC 创建组件的时候，原有组件被容器组件包裹。这意味着容器组件不含有原有组件的静态方法。\n``` js\n// 创建静态方法\nWrappedComponent.staticMethod = function() {/*...*/}\n// Now apply an HOC\nconst EnhancedComponent = enhance(WrappedComponent);\n\n// 新组件没有静态方法\ntypeof EnhancedComponent.staticMethod === 'undefined' // true\n```\n为了解决这个问题，你需要在包裹之前把静态方法拷贝给容器组件：\n``` js\nfunction enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  // Must know exactly which method(s) to copy :(\n  Enhance.staticMethod = WrappedComponent.staticMethod;\n  return Enhance;\n}\n```\n也可以使用 hoist-non-react-statics 来自动拷贝非原生 React 方法的静态方法。\n\n#### ref不会被传递\n尽管高阶组件的约定是把所有的 props 传递给被包裹的组件，但它并不能传递 ref。那是因为 ref 实际上并不是 prop —— 就像 key 一样，它们会被 React 特殊对待。如果你给 HOC 传递了 ref，它将指向容器组件而不是被包裹的组件。\n如果一定要用到ref，可以将ref当做普通的props传递给组件：\n``` js\nfunction Field({ inputRef, ...rest }) {\n  return <input ref={inputRef} {...rest} />;\n}\n\n// 将 Field 在高阶组件里包裹起来\nconst EnhancedField = enhance(Field);\n\n// 在组件的 render 方法内..\n<EnhancedField\n  inputRef={(inputEl) => {\n    // This callback gets passed through as a regular prop\n    this.inputEl = inputEl\n  }}\n/>\n\n// 在高阶组件中就可以访问组件实例和dom节点了...\nthis.inputEl.focus();\n```","source":"_posts/react高阶组件.md","raw":"---\ntitle: react高阶组件\ndate: 2017-10-30 17:39:56\ntags: [react, 高阶组件]\n---\n### 什么是高阶组件？\n官方文档指出，高阶组件（Higher-Order Components，简称HOC）是react中对组件逻辑进行重用的高级技术。但高阶组件本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。\n具体而言，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。\n先看一个典型的高阶组件：\n``` js\n// It's a function...\nfunction myHOC() {\n  // Which returns a function that takes a component...\n  return function(WrappedComponent) {\n    // It creates a new wrapper component...\n    class TheHOC extends React.Component {\n      render() {\n        // And it renders the component it was given\n        return <WrappedComponent {...this.props} />;\n      }\n    }\n\n    // Remember: it takes a component and returns a new component\n    // Gotta return it here.\n    return TheHOC;\n  }\n}\n```\n### 使用高阶组件优化代码\n需求是要在网站的每个页面要添加签到请求和签到成功弹窗，显然，一般人都不会想着要在每个页面写一遍。首先，我想到的是引入一个React组件，但是要在每个页面的render方法里面添加该组件，需要改动所有页面对应组件的render方法，感觉比较繁琐且易出错。也可以通过js方法去动态创建签到成功弹窗，然后在每个页面里面引入该方法，不过同样需要改变组件内部方法，且不符合React项目风格。\n最后，发现高阶组件可以满足我的需求，既实现了功能又不污染原有组件。下面是简化版的签到高阶组件：\n<!-- more -->\n``` js\nexport const signHoc = ComposedComponent => class extends Component {\n    constructor(props) {\n        super(props)\n        this.state = {show: false, config: {}}\n    }\n\n    componentDidMount() {\n        if(!this.props.showSign) return;\n        this.setState({\n            show: true,\n            config: {\n                title: '今日首次登录',\n                content: `获赠<em>50</em>阅点红包`\n            }\n        })\n    }\n\n    render() {\n        const {show, config} = this.state;\n        const {showSign, ...passThroughProps} = this.props;\n        return (<div>\n            <ComposedComponent {...passThroughProps} />\n            {show && (<MessageModal config={config}/>)}\n        </div>);\n    }\n};\n```\n可以通过this.props获得传给WrappedComponent的props，在操作props的时候要确保不会破坏要传给WrappedComponent的props。在componentDidMount可以发起签到请求，此外可以根据props.showSign和签到结果决定是否显示签到组件等。当页面有其他弹窗的优先级大于签到弹窗时，props.showSign设为false，就可以控制签到弹窗是否显示。\n```\nexport default class WrappedComponent extends Component {\n    render() {\n        return false\n    }\n}\nsignHoc(WrappedComponent)\n```\n调用signHoc函数获得组合后的组件，也可以结合@decorator简化调用。\n```\n@signHoc\nexport default class WrappedComponent extends Component {\n    render() {\n        return false\n    }\n}\n```\n\n### 结合Context API使用\n`React 16.3`引入了全新的`Context API`，主要提供的API有：`React.createContext`, `Provider`和`Consumer`，详见[context](https://reactjs.org/docs/context.html)。\n这儿记录下如何结合高阶组件和Context API去实现全局变量的设置，如主题theme。\nstep1: 定义高阶组件，通过`ThemeContext.Consumer`获取变量并且传递给组件ComposedComponent。\n``` js\nexport const ThemeContext = React.createContext({\n    theme: localStorage.getItem('N_reader_theme') || 'light',\n    changeTheme: () => {}});\n\nexport const themeHoc = ComposedComponent => {\n    props => {\n        <ThemeContext.Consumer>\n            {({theme, changeTheme}) => <ComposedComponent {...props} theme={theme} changeTheme={changeTheme}/>}\n        </ThemeContext.Consumer>\n    }\n}\n```\n\nstep2: 使用`ThemeContext.Provider`传递当前theme、changeTheme给整个子树，任何子组件都可以读到这些变量的值，不需要显式的通过props传递。\n``` js\nimport {ThemeContext} from 'themeHoc.js'\n\nexport default class App extends Component {\n    changeTheme(theme) {\n        localStorage.setItem('N_reader_theme', theme);\n        document.querySelector('body').className = document.querySelector('body').className.replace(/theme--\\w*/, 'theme--' + theme);\n        this.setState({\n            theme: theme\n        })\n    }\n\n    render() {\n        return (\n            <ThemeContext.provider value={{theme: this.state.theme, changeTheme: this.changeTheme}}>\n                <Content />\n            </ThemeContext.provider>\n        )\n    }\n}\n```\n\nstep3: 通过decorator的方式添加`@themeHoc`标记，Content组件可以直接从props中读取theme和changeTheme函数。\n``` js\nimport {themeHoc} from 'themeHoc.js'\n\n@themeHoc\nexport default class Content extends Component {\n    render() {\n        return (\n            <div theme={props.theme}>\n                <a href=\"javascript:;\" className={props.theme} onClick={props.changeTheme.bind(this, 'blue')}>blue</a>\n                <a href=\"javascript:;\" className={props.theme} onClick={props.changeTheme.bind(this, 'yellow')}>yellow</a>\n            </div>\n        )\n    }\n}\n```\n\n### 公约\n\n#### 最大化使用组合\n高阶组件可以接受一个或多个参数：\n```\n//仅接收包裹组件一个参数\nconst NavbarWithRouter = withRouter(Navbar);\n//接收包裹组件和额外的参数\nconst CommentWithRelay = Relay.createContainer(Comment, config);\n//connect(commentListSelector, commentListActions)返回了一个高阶组件，最后作用于Comment组件\nconst ConnectedComment = connect(commentSelector, commentActions)(Comment);\n```\n#### 包装显示名字以便于调试\n高价组件创建的容器组件在React Developer Tools中的表现和其它的普通组件是一样的。为了便于调试，可以选择一个好的名字，确保能够识别出它是由高阶组件创建的新组件还是普通的组件。\n最常用的技术就是将包裹组件的名字包装在显示名字中。所以，如果你的高阶组件名字是 withSubscription，且包裹组件的显示名字是 CommentList，那么就是用 withSubscription(CommentList)这样的显示名字：\n``` js\nfunction withSubscription(WrappedComponent) {\n  class WithSubscription extends React.Component {/* ... */}\n  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;\n  return WithSubscription;\n}\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n```\n### 注意事项\n#### 静态方法需要被复制\n当你通过 HOC 创建组件的时候，原有组件被容器组件包裹。这意味着容器组件不含有原有组件的静态方法。\n``` js\n// 创建静态方法\nWrappedComponent.staticMethod = function() {/*...*/}\n// Now apply an HOC\nconst EnhancedComponent = enhance(WrappedComponent);\n\n// 新组件没有静态方法\ntypeof EnhancedComponent.staticMethod === 'undefined' // true\n```\n为了解决这个问题，你需要在包裹之前把静态方法拷贝给容器组件：\n``` js\nfunction enhance(WrappedComponent) {\n  class Enhance extends React.Component {/*...*/}\n  // Must know exactly which method(s) to copy :(\n  Enhance.staticMethod = WrappedComponent.staticMethod;\n  return Enhance;\n}\n```\n也可以使用 hoist-non-react-statics 来自动拷贝非原生 React 方法的静态方法。\n\n#### ref不会被传递\n尽管高阶组件的约定是把所有的 props 传递给被包裹的组件，但它并不能传递 ref。那是因为 ref 实际上并不是 prop —— 就像 key 一样，它们会被 React 特殊对待。如果你给 HOC 传递了 ref，它将指向容器组件而不是被包裹的组件。\n如果一定要用到ref，可以将ref当做普通的props传递给组件：\n``` js\nfunction Field({ inputRef, ...rest }) {\n  return <input ref={inputRef} {...rest} />;\n}\n\n// 将 Field 在高阶组件里包裹起来\nconst EnhancedField = enhance(Field);\n\n// 在组件的 render 方法内..\n<EnhancedField\n  inputRef={(inputEl) => {\n    // This callback gets passed through as a regular prop\n    this.inputEl = inputEl\n  }}\n/>\n\n// 在高阶组件中就可以访问组件实例和dom节点了...\nthis.inputEl.focus();\n```","slug":"react高阶组件","published":1,"updated":"2019-03-18T02:27:14.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx81002rqmhfftqu3iyw","content":"<h3 id=\"什么是高阶组件？\"><a href=\"#什么是高阶组件？\" class=\"headerlink\" title=\"什么是高阶组件？\"></a>什么是高阶组件？</h3><p>官方文档指出，高阶组件（Higher-Order Components，简称HOC）是react中对组件逻辑进行重用的高级技术。但高阶组件本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。<br>具体而言，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。<br>先看一个典型的高阶组件：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// It's a function...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myHOC</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Which returns a function that takes a component...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// It creates a new wrapper component...</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TheHOC</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">      render() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// And it renders the component it was given</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">      &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    // Remember: it takes a component and returns a new component</span></span><br><span class=\"line\"><span class=\"xml\">    // Gotta return it here.</span></span><br><span class=\"line\"><span class=\"xml\">    return TheHOC;</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用高阶组件优化代码\"><a href=\"#使用高阶组件优化代码\" class=\"headerlink\" title=\"使用高阶组件优化代码\"></a>使用高阶组件优化代码</h3><p>需求是要在网站的每个页面要添加签到请求和签到成功弹窗，显然，一般人都不会想着要在每个页面写一遍。首先，我想到的是引入一个React组件，但是要在每个页面的render方法里面添加该组件，需要改动所有页面对应组件的render方法，感觉比较繁琐且易出错。也可以通过js方法去动态创建签到成功弹窗，然后在每个页面里面引入该方法，不过同样需要改变组件内部方法，且不符合React项目风格。<br>最后，发现高阶组件可以满足我的需求，既实现了功能又不污染原有组件。下面是简化版的签到高阶组件：<br><a id=\"more\"></a><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> signHoc = <span class=\"function\"><span class=\"params\">ComposedComponent</span> =&gt;</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">show</span>: <span class=\"literal\">false</span>, <span class=\"attr\">config</span>: &#123;&#125;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.props.showSign) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            show: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            config: &#123;</span><br><span class=\"line\">                title: <span class=\"string\">'今日首次登录'</span>,</span><br><span class=\"line\">                content: <span class=\"string\">`获赠&lt;em&gt;50&lt;/em&gt;阅点红包`</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123;show, config&#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123;showSign, ...passThroughProps&#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">            &lt;ComposedComponent &#123;...passThroughProps&#125; /&gt;</span><br><span class=\"line\">            &#123;show &amp;&amp; (&lt;MessageModal config=&#123;config&#125;/&gt;)&#125;</span><br><span class=\"line\">        &lt;/div&gt;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>可以通过this.props获得传给WrappedComponent的props，在操作props的时候要确保不会破坏要传给WrappedComponent的props。在componentDidMount可以发起签到请求，此外可以根据props.showSign和签到结果决定是否显示签到组件等。当页面有其他弹窗的优先级大于签到弹窗时，props.showSign设为false，就可以控制签到弹窗是否显示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default class WrappedComponent extends Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">signHoc(WrappedComponent)</span><br></pre></td></tr></table></figure></p>\n<p>调用signHoc函数获得组合后的组件，也可以结合@decorator简化调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@signHoc</span><br><span class=\"line\">export default class WrappedComponent extends Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"结合Context-API使用\"><a href=\"#结合Context-API使用\" class=\"headerlink\" title=\"结合Context API使用\"></a>结合Context API使用</h3><p><code>React 16.3</code>引入了全新的<code>Context API</code>，主要提供的API有：<code>React.createContext</code>, <code>Provider</code>和<code>Consumer</code>，详见<a href=\"https://reactjs.org/docs/context.html\" target=\"_blank\" rel=\"noopener\">context</a>。<br>这儿记录下如何结合高阶组件和Context API去实现全局变量的设置，如主题theme。<br>step1: 定义高阶组件，通过<code>ThemeContext.Consumer</code>获取变量并且传递给组件ComposedComponent。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ThemeContext = React.createContext(&#123;</span><br><span class=\"line\">    theme: localStorage.getItem(<span class=\"string\">'N_reader_theme'</span>) || <span class=\"string\">'light'</span>,</span><br><span class=\"line\">    changeTheme: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> themeHoc = <span class=\"function\"><span class=\"params\">ComposedComponent</span> =&gt;</span> &#123;</span><br><span class=\"line\">    props =&gt; &#123;</span><br><span class=\"line\">        &lt;ThemeContext.Consumer&gt;</span><br><span class=\"line\">            &#123;(&#123;theme, changeTheme&#125;) =&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ComposedComponent</span> &#123;<span class=\"attr\">...props</span>&#125; <span class=\"attr\">theme</span>=<span class=\"string\">&#123;theme&#125;</span> <span class=\"attr\">changeTheme</span>=<span class=\"string\">&#123;changeTheme&#125;/</span>&gt;</span>&#125;</span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>step2: 使用<code>ThemeContext.Provider</code>传递当前theme、changeTheme给整个子树，任何子组件都可以读到这些变量的值，不需要显式的通过props传递。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;ThemeContext&#125; <span class=\"keyword\">from</span> <span class=\"string\">'themeHoc.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    changeTheme(theme) &#123;</span><br><span class=\"line\">        localStorage.setItem(<span class=\"string\">'N_reader_theme'</span>, theme);</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'body'</span>).className = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'body'</span>).className.replace(<span class=\"regexp\">/theme--\\w*/</span>, <span class=\"string\">'theme--'</span> + theme);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            theme: theme</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;ThemeContext.provider value=&#123;&#123;<span class=\"attr\">theme</span>: <span class=\"keyword\">this</span>.state.theme, <span class=\"attr\">changeTheme</span>: <span class=\"keyword\">this</span>.changeTheme&#125;&#125;&gt;</span><br><span class=\"line\">                &lt;Content /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/ThemeContext.provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>step3: 通过decorator的方式添加<code>@themeHoc</code>标记，Content组件可以直接从props中读取theme和changeTheme函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;themeHoc&#125; <span class=\"keyword\">from</span> <span class=\"string\">'themeHoc.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">@themeHoc</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Content</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div theme=&#123;props.theme&#125;&gt;</span><br><span class=\"line\">                &lt;a href=<span class=\"string\">\"javascript:;\"</span> className=&#123;props.theme&#125; onClick=&#123;props.changeTheme.bind(<span class=\"keyword\">this</span>, <span class=\"string\">'blue'</span>)&#125;&gt;blue&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;a href=\"javascript:;\" className=&#123;props.theme&#125; onClick=&#123;props.changeTheme.bind(this, 'yellow')&#125;&gt;yellow&lt;/</span>a&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"公约\"><a href=\"#公约\" class=\"headerlink\" title=\"公约\"></a>公约</h3><h4 id=\"最大化使用组合\"><a href=\"#最大化使用组合\" class=\"headerlink\" title=\"最大化使用组合\"></a>最大化使用组合</h4><p>高阶组件可以接受一个或多个参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//仅接收包裹组件一个参数</span><br><span class=\"line\">const NavbarWithRouter = withRouter(Navbar);</span><br><span class=\"line\">//接收包裹组件和额外的参数</span><br><span class=\"line\">const CommentWithRelay = Relay.createContainer(Comment, config);</span><br><span class=\"line\">//connect(commentListSelector, commentListActions)返回了一个高阶组件，最后作用于Comment组件</span><br><span class=\"line\">const ConnectedComment = connect(commentSelector, commentActions)(Comment);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"包装显示名字以便于调试\"><a href=\"#包装显示名字以便于调试\" class=\"headerlink\" title=\"包装显示名字以便于调试\"></a>包装显示名字以便于调试</h4><p>高价组件创建的容器组件在React Developer Tools中的表现和其它的普通组件是一样的。为了便于调试，可以选择一个好的名字，确保能够识别出它是由高阶组件创建的新组件还是普通的组件。<br>最常用的技术就是将包裹组件的名字包装在显示名字中。所以，如果你的高阶组件名字是 withSubscription，且包裹组件的显示名字是 CommentList，那么就是用 withSubscription(CommentList)这样的显示名字：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withSubscription</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WithSubscription</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\">  WithSubscription.displayName = <span class=\"string\">`WithSubscription(<span class=\"subst\">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> WithSubscription;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDisplayName</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class=\"string\">'Component'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><h4 id=\"静态方法需要被复制\"><a href=\"#静态方法需要被复制\" class=\"headerlink\" title=\"静态方法需要被复制\"></a>静态方法需要被复制</h4><p>当你通过 HOC 创建组件的时候，原有组件被容器组件包裹。这意味着容器组件不含有原有组件的静态方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建静态方法</span></span><br><span class=\"line\">WrappedComponent.staticMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// Now apply an HOC</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = enhance(WrappedComponent);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新组件没有静态方法</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> EnhancedComponent.staticMethod === <span class=\"string\">'undefined'</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>为了解决这个问题，你需要在包裹之前把静态方法拷贝给容器组件：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhance</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\">// Must know exactly which method(s) to copy :(</span></span><br><span class=\"line\">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用 hoist-non-react-statics 来自动拷贝非原生 React 方法的静态方法。</p>\n<h4 id=\"ref不会被传递\"><a href=\"#ref不会被传递\" class=\"headerlink\" title=\"ref不会被传递\"></a>ref不会被传递</h4><p>尽管高阶组件的约定是把所有的 props 传递给被包裹的组件，但它并不能传递 ref。那是因为 ref 实际上并不是 prop —— 就像 key 一样，它们会被 React 特殊对待。如果你给 HOC 传递了 ref，它将指向容器组件而不是被包裹的组件。<br>如果一定要用到ref，可以将ref当做普通的props传递给组件：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Field</span>(<span class=\"params\">&#123; inputRef, ...rest &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;inputRef&#125;</span> &#123;<span class=\"attr\">...rest</span>&#125; /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">// 将 Field 在高阶组件里包裹起来</span></span><br><span class=\"line\"><span class=\"xml\">const EnhancedField = enhance(Field);</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">// 在组件的 render 方法内..</span></span><br><span class=\"line\">&lt;EnhancedField</span><br><span class=\"line\">  inputRef=&#123;(inputEl) =&gt; &#123;</span><br><span class=\"line\">    // This callback gets passed through as a regular prop</span><br><span class=\"line\">    this.inputEl = inputEl</span><br><span class=\"line\">  &#125;&#125;</span><br><span class=\"line\">/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 在高阶组件中就可以访问组件实例和dom节点了...</span><br><span class=\"line\">this.inputEl.focus();</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是高阶组件？\"><a href=\"#什么是高阶组件？\" class=\"headerlink\" title=\"什么是高阶组件？\"></a>什么是高阶组件？</h3><p>官方文档指出，高阶组件（Higher-Order Components，简称HOC）是react中对组件逻辑进行重用的高级技术。但高阶组件本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。<br>具体而言，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。<br>先看一个典型的高阶组件：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// It's a function...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myHOC</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Which returns a function that takes a component...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// It creates a new wrapper component...</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TheHOC</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">      render() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// And it renders the component it was given</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">      &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    // Remember: it takes a component and returns a new component</span></span><br><span class=\"line\"><span class=\"xml\">    // Gotta return it here.</span></span><br><span class=\"line\"><span class=\"xml\">    return TheHOC;</span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用高阶组件优化代码\"><a href=\"#使用高阶组件优化代码\" class=\"headerlink\" title=\"使用高阶组件优化代码\"></a>使用高阶组件优化代码</h3><p>需求是要在网站的每个页面要添加签到请求和签到成功弹窗，显然，一般人都不会想着要在每个页面写一遍。首先，我想到的是引入一个React组件，但是要在每个页面的render方法里面添加该组件，需要改动所有页面对应组件的render方法，感觉比较繁琐且易出错。也可以通过js方法去动态创建签到成功弹窗，然后在每个页面里面引入该方法，不过同样需要改变组件内部方法，且不符合React项目风格。<br>最后，发现高阶组件可以满足我的需求，既实现了功能又不污染原有组件。下面是简化版的签到高阶组件：<br>","more":"<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> signHoc = <span class=\"function\"><span class=\"params\">ComposedComponent</span> =&gt;</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123;<span class=\"attr\">show</span>: <span class=\"literal\">false</span>, <span class=\"attr\">config</span>: &#123;&#125;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.props.showSign) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            show: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            config: &#123;</span><br><span class=\"line\">                title: <span class=\"string\">'今日首次登录'</span>,</span><br><span class=\"line\">                content: <span class=\"string\">`获赠&lt;em&gt;50&lt;/em&gt;阅点红包`</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123;show, config&#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> &#123;showSign, ...passThroughProps&#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">            &lt;ComposedComponent &#123;...passThroughProps&#125; /&gt;</span><br><span class=\"line\">            &#123;show &amp;&amp; (&lt;MessageModal config=&#123;config&#125;/&gt;)&#125;</span><br><span class=\"line\">        &lt;/div&gt;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>可以通过this.props获得传给WrappedComponent的props，在操作props的时候要确保不会破坏要传给WrappedComponent的props。在componentDidMount可以发起签到请求，此外可以根据props.showSign和签到结果决定是否显示签到组件等。当页面有其他弹窗的优先级大于签到弹窗时，props.showSign设为false，就可以控制签到弹窗是否显示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default class WrappedComponent extends Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">signHoc(WrappedComponent)</span><br></pre></td></tr></table></figure></p>\n<p>调用signHoc函数获得组合后的组件，也可以结合@decorator简化调用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@signHoc</span><br><span class=\"line\">export default class WrappedComponent extends Component &#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        return false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"结合Context-API使用\"><a href=\"#结合Context-API使用\" class=\"headerlink\" title=\"结合Context API使用\"></a>结合Context API使用</h3><p><code>React 16.3</code>引入了全新的<code>Context API</code>，主要提供的API有：<code>React.createContext</code>, <code>Provider</code>和<code>Consumer</code>，详见<a href=\"https://reactjs.org/docs/context.html\" target=\"_blank\" rel=\"noopener\">context</a>。<br>这儿记录下如何结合高阶组件和Context API去实现全局变量的设置，如主题theme。<br>step1: 定义高阶组件，通过<code>ThemeContext.Consumer</code>获取变量并且传递给组件ComposedComponent。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ThemeContext = React.createContext(&#123;</span><br><span class=\"line\">    theme: localStorage.getItem(<span class=\"string\">'N_reader_theme'</span>) || <span class=\"string\">'light'</span>,</span><br><span class=\"line\">    changeTheme: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;&#125;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> themeHoc = <span class=\"function\"><span class=\"params\">ComposedComponent</span> =&gt;</span> &#123;</span><br><span class=\"line\">    props =&gt; &#123;</span><br><span class=\"line\">        &lt;ThemeContext.Consumer&gt;</span><br><span class=\"line\">            &#123;(&#123;theme, changeTheme&#125;) =&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ComposedComponent</span> &#123;<span class=\"attr\">...props</span>&#125; <span class=\"attr\">theme</span>=<span class=\"string\">&#123;theme&#125;</span> <span class=\"attr\">changeTheme</span>=<span class=\"string\">&#123;changeTheme&#125;/</span>&gt;</span>&#125;</span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>step2: 使用<code>ThemeContext.Provider</code>传递当前theme、changeTheme给整个子树，任何子组件都可以读到这些变量的值，不需要显式的通过props传递。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;ThemeContext&#125; <span class=\"keyword\">from</span> <span class=\"string\">'themeHoc.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    changeTheme(theme) &#123;</span><br><span class=\"line\">        localStorage.setItem(<span class=\"string\">'N_reader_theme'</span>, theme);</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'body'</span>).className = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'body'</span>).className.replace(<span class=\"regexp\">/theme--\\w*/</span>, <span class=\"string\">'theme--'</span> + theme);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            theme: theme</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;ThemeContext.provider value=&#123;&#123;<span class=\"attr\">theme</span>: <span class=\"keyword\">this</span>.state.theme, <span class=\"attr\">changeTheme</span>: <span class=\"keyword\">this</span>.changeTheme&#125;&#125;&gt;</span><br><span class=\"line\">                &lt;Content /&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/ThemeContext.provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>step3: 通过decorator的方式添加<code>@themeHoc</code>标记，Content组件可以直接从props中读取theme和changeTheme函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;themeHoc&#125; <span class=\"keyword\">from</span> <span class=\"string\">'themeHoc.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">@themeHoc</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Content</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            &lt;div theme=&#123;props.theme&#125;&gt;</span><br><span class=\"line\">                &lt;a href=<span class=\"string\">\"javascript:;\"</span> className=&#123;props.theme&#125; onClick=&#123;props.changeTheme.bind(<span class=\"keyword\">this</span>, <span class=\"string\">'blue'</span>)&#125;&gt;blue&lt;<span class=\"regexp\">/a&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">                &lt;a href=\"javascript:;\" className=&#123;props.theme&#125; onClick=&#123;props.changeTheme.bind(this, 'yellow')&#125;&gt;yellow&lt;/</span>a&gt;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"公约\"><a href=\"#公约\" class=\"headerlink\" title=\"公约\"></a>公约</h3><h4 id=\"最大化使用组合\"><a href=\"#最大化使用组合\" class=\"headerlink\" title=\"最大化使用组合\"></a>最大化使用组合</h4><p>高阶组件可以接受一个或多个参数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//仅接收包裹组件一个参数</span><br><span class=\"line\">const NavbarWithRouter = withRouter(Navbar);</span><br><span class=\"line\">//接收包裹组件和额外的参数</span><br><span class=\"line\">const CommentWithRelay = Relay.createContainer(Comment, config);</span><br><span class=\"line\">//connect(commentListSelector, commentListActions)返回了一个高阶组件，最后作用于Comment组件</span><br><span class=\"line\">const ConnectedComment = connect(commentSelector, commentActions)(Comment);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"包装显示名字以便于调试\"><a href=\"#包装显示名字以便于调试\" class=\"headerlink\" title=\"包装显示名字以便于调试\"></a>包装显示名字以便于调试</h4><p>高价组件创建的容器组件在React Developer Tools中的表现和其它的普通组件是一样的。为了便于调试，可以选择一个好的名字，确保能够识别出它是由高阶组件创建的新组件还是普通的组件。<br>最常用的技术就是将包裹组件的名字包装在显示名字中。所以，如果你的高阶组件名字是 withSubscription，且包裹组件的显示名字是 CommentList，那么就是用 withSubscription(CommentList)这样的显示名字：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withSubscription</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WithSubscription</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/* ... */</span>&#125;</span><br><span class=\"line\">  WithSubscription.displayName = <span class=\"string\">`WithSubscription(<span class=\"subst\">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> WithSubscription;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDisplayName</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> WrappedComponent.displayName || WrappedComponent.name || <span class=\"string\">'Component'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><h4 id=\"静态方法需要被复制\"><a href=\"#静态方法需要被复制\" class=\"headerlink\" title=\"静态方法需要被复制\"></a>静态方法需要被复制</h4><p>当你通过 HOC 创建组件的时候，原有组件被容器组件包裹。这意味着容器组件不含有原有组件的静态方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建静态方法</span></span><br><span class=\"line\">WrappedComponent.staticMethod = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">// Now apply an HOC</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> EnhancedComponent = enhance(WrappedComponent);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新组件没有静态方法</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> EnhancedComponent.staticMethod === <span class=\"string\">'undefined'</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<p>为了解决这个问题，你需要在包裹之前把静态方法拷贝给容器组件：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enhance</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Enhance</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/*...*/</span>&#125;</span><br><span class=\"line\">  <span class=\"comment\">// Must know exactly which method(s) to copy :(</span></span><br><span class=\"line\">  Enhance.staticMethod = WrappedComponent.staticMethod;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Enhance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用 hoist-non-react-statics 来自动拷贝非原生 React 方法的静态方法。</p>\n<h4 id=\"ref不会被传递\"><a href=\"#ref不会被传递\" class=\"headerlink\" title=\"ref不会被传递\"></a>ref不会被传递</h4><p>尽管高阶组件的约定是把所有的 props 传递给被包裹的组件，但它并不能传递 ref。那是因为 ref 实际上并不是 prop —— 就像 key 一样，它们会被 React 特殊对待。如果你给 HOC 传递了 ref，它将指向容器组件而不是被包裹的组件。<br>如果一定要用到ref，可以将ref当做普通的props传递给组件：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Field</span>(<span class=\"params\">&#123; inputRef, ...rest &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;inputRef&#125;</span> &#123;<span class=\"attr\">...rest</span>&#125; /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">// 将 Field 在高阶组件里包裹起来</span></span><br><span class=\"line\"><span class=\"xml\">const EnhancedField = enhance(Field);</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">// 在组件的 render 方法内..</span></span><br><span class=\"line\">&lt;EnhancedField</span><br><span class=\"line\">  inputRef=&#123;(inputEl) =&gt; &#123;</span><br><span class=\"line\">    // This callback gets passed through as a regular prop</span><br><span class=\"line\">    this.inputEl = inputEl</span><br><span class=\"line\">  &#125;&#125;</span><br><span class=\"line\">/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 在高阶组件中就可以访问组件实例和dom节点了...</span><br><span class=\"line\">this.inputEl.focus();</span><br></pre></td></tr></table></figure></p>"},{"title":"SASS使用二三事","date":"2017-08-28T10:15:21.000Z","_content":"\n### sass管理z-index\n\nz-index的值和上下文有关系，在复杂布局中要跟踪z-index比较困难，z-index的取值范围很广，很容易出错，所以可以使用sass预处理器去统一管理。\n\n#### 定义浮层\n首先，我们可以借助sass 3.3引入的Map定义一个数据结构，key代表了不同浮层类型，value即对应的z-index值：\n``` scss\n    $z-layers: (\n        'toast':          4000,\n        'modal':          3000,\n        'dropdown':       2000,\n        'mask':           1000,\n        'default':         1,\n        'below':          -1,\n        'bottomless-pit': -10000\n    );\n```\n#### 定义函数\n``` scss\n@function z($layer) {\n    @return map-get($z-layers, $layer);\n}\n```\n使用了sass的map-get方法，如果$layer参数存在于$z-layers中，会返回对应的value值，如z('toast')，返回对应的值为4000；若不存在于$z-layers中，则返回null。属性为null时，sass的编译不会输出。\n也可以借助map-has-key方法检查元素是否存在，对于不存在的元素使用@warn指令输出警告信息，方便我们在开发的时候发现问题。\n``` scss\n@function z($layer) {\n    @if not map-has-key($z-layers, $layer) {\n        @warn \"No z-index found in $z-layers map for `#{$layer}`. Property omitted.\";\n    }\n\n    @return map-get($z-layers, $layer);\n}\n```\n\n#### 使用方法\n``` scss\n//function方式\n.m-mask {\n    z-index: z('mask');\n}\n\n//mixin方式\n.m-mask {\n    @include z('mask');\n}\n```\n对于单个属性来说，建议采用function的定义方式，比起mixin方式，使用起来更加清晰、简单。\n<!-- more -->\n\n#### 嵌套层级\n在层级关系比较多的情况下，单一层级可能无法满足我们的需求，如弹窗里面还有很多的层级关系时，这个时候，我们可以使用嵌套的层级定义方式，针对modal进行再扩展，对modal里面的元素进一步定义层级数值。\n``` scss\n    $z-layers: (\n        'toast':          4000,\n        'modal':          (\n            \"base\": 3200,\n            \"close\": 3100,\n            \"header\": 3050,\n            \"footer\": 3000\n        ),\n        'dropdown':       2000,\n        'mask':           1000,\n        'default':         1,\n        'below':          -1,\n        'bottomless-pit': -10000\n    );\n```\n想要定义$z-layers中modal内部的层级关系，可以用嵌套的Map去设置，如上所示。要处理嵌套的层级关系，对应的z函数可以是：\n``` scss\n@function map-has-nested-keys($map, $keys...) {\n  @each $key in $keys {\n    @if not map-has-key($map, $key) {\n      @return false;\n    }\n    $map: map-get($map, $key);\n  }\n  @return true;\n}\n@function map-deep-get($map, $keys...) {\n  @each $key in $keys {\n    $map: map-get($map, $key);\n  }\n  @return $map;\n}\n@function z($layers...) {\n  @if not map-has-nested-keys($z-layers, $layers...) {\n    @warn \"No layer found for `#{inspect($layers...)}` in $z-layers map. Property omitted.\";\n  }\n  @return map-deep-get($z-layers, $layers...);\n}\n```\n其中map-has-nested-keys方法可以检查元素是否存在于已经定义的$z-layers中：\n1. 若$keys只有一个值'toast'，@each只需要循环一次，在循环内，$map被赋值为'toast'对应的z-index值，最后返回true值；\n2. 若$keys有两个值'modal'和'base'，@each循环两次，第一次循环，先检查'modal'是否存在于$z-layers中，再将$map赋值为map-get($z-layers, 'modal')，即内部嵌套的modal的map，第二次循环先判断'base'是否存在于$map中，若不存在直接返回false，若存在$map被赋值为'base'对应的z-index值，最后返回true值；\nmap-deep-get方法用于获得对应的z-index值，思路和map-has-nested-keys方法一致，只是前者返回true/false，后者返回$map值。\n具体的调用方式如下所示：\n``` scss\n.modal {\n  position: absolute;\n  z-index: z(\"modal\", \"base\");\n\n  .close-button {\n    z-index: z(\"modal\", \"close\");\n  }\n\n  header {\n    z-index: z(\"modal\", \"header\");\n  }\n\n  footer {\n    z-index: z(\"modal\", \"footer\");\n  }\n}\n.toast {\n  z-index: z(\"toast\");\n}\n```\n#### 另一种z-index管理思路\n首先创建一个层级列表，在这个列表中，元素的出现顺序是从低到高，使用sass提供的index方法获取元素在$elements中的顺序，即为该元素的z-index值。\n``` scss\n$elements: project-covers, sorting-bar, modals, navigation;\n\n.project-cover {\n  z-index: index($elements, project-covers);\n}\n```\n输出的z-index为1，与javascript不同，sass的索引值从1开始，就像css一样，css的:nth-child(n)中的n也是从1开始。\n``` scss\n.project-cover {\n  z-index: 1;\n}\n```\n个人觉得，这个方法更简单，适合于轻量级的项目，但灵活性不够好，取值范围受限于index值，对于嵌套的层级关系不友好，扩展性不好，对于较复杂项目更建议用前一种Map的形式来管理。\n\n### sass主题管理\n在项目开发中，涉及到不同主题的切换，例如在正文阅读时，有白天、黑夜、蓝色、黄色四种主题，不同主题配色不同，如果直接用css，结构复杂并且很难维护。利用scss提供的变量定义和方法，可以降低开发和维护成本。\n\n#### sass管理颜色\n首先，sass可以对整个项目常用的一些颜色进行定义，例如本次项目通用的红色值为#ED6460，则可以在单独的文件_color.scss中定义该色值，其他scss文件通过@import引用。\n``` scss\n$black: #24211F;\n$red: #ED6460;\n$blue: #60aaed;\n\n$border-gray: #ededed;\n$bg-gray: #f5f5f5;\n$btn-gray: #807A73;\n```\n#### 主题定义\n首先，定义一个Map，记录不同的主题和与之关联的颜色，每个主题下细分了不同用途的色值。\n``` scss\n@import './color.scss';\n\n//主题base设置\n$theme: (\n    light: (\n        bg: #fff,              //背景色\n        color: $black,         //正文颜色\n        title: #A83A45,        //章节标题颜色\n        link: #60AAED,         //底部链接颜色\n        border: #ededed,       //正文底部border颜色\n        themeBorder: #d8d8d8   //主题切换btn选中状态的border颜色\n    ),\n    dark: ( …… ),\n    blue: ( …… ),\n    yellow: ( …… )\n);\n\n@each $name, $theme in $theme {\n    .theme--#{$name} {\n        color: map-get($theme, color);\n        background-color: map-get($theme, bg);\n\n        .m-main .content {\n            h1, h2 {\n                color: map-get($theme, title);\n            }\n        }\n\n        .link {\n            color: map-get($theme, link);\n        }\n        // ... 其他涉及主题配色的选择器\n    }\n}\n```\n通过@each去遍历Map，.theme--#{$name}编译后会生成.theme-light, .theme-dark等，在.theme--#{$name} 选择器内部，可以定义该主题下不同元素的样式，具体颜色可以通过map-get方法获得。\n对于button这种，在不同主题下颜色、边框、背景、active状态等都需要改变，可以单独定义。\n``` scss\n$btn: (\n    light: (\n        color: $gray1, border: $gray0, bg: transparent,\n        color-active: #fff, border-active: $red, bg-active: $red\n    ),\n    dark: ( …… ),\n    blue: ( …… ),\n    yellow: ( …… ),\n);\n\n@each $name, $theme in $btn {\n    .btn--#{$name} {\n        color: map-get($theme, color);\n        border-color: map-get($theme, border);\n        background-color: map-get($theme, bg);\n    }\n\n    .btn--#{$name}:active, .btn--#{$name}-active {\n        color: map-get($theme, color-active);\n        border-color: map-get($theme, border-active);\n        background-color: map-get($theme, bg-active);\n    }\n}\n```\n将主题颜色与其他不变的样式分离出来进行管理，所有的主题颜色维护在_theme.scss中，从而极大地提高了代码的可维护性。在切换主题的时候，只需要更换相应的类名，尤其在结合react开发时，theme变化时只需要重新setState一下就会重新渲染页面，十分方便。\n\n### 定义通用样式\n可以通过sass提供的@mixin, @function等方式定义通用样式，如可以将实现单行\\多行文字截断效果的一组样式封装，用@mixin定义line-ellipsis方法，参数为行数和行高。传入行高是为了兼容不支持多行截断的浏览器，计算得出最大高度，防止样式错乱。其中行数的默认值为1，行高的默认值为1.5，可以使用@if,@else去判断行数，根据$num值去返回样式。\n``` scss\n@mixin line-ellipsis($num: 1, $lineH: 1.5){\n     @if $num > 1 {\n        display: -webkit-box;\n        -webkit-box-orient: vertical;\n        -webkit-line-clamp: $num;\n        text-overflow: ellipsis;\n        line-height: $lineH;\n        max-height: $lineH * $num;\n        overflow: hidden;\n     } @else {\n        white-space: nowrap;\n        text-overflow: ellipsis;\n        line-height: $lineH;\n        overflow: hidden;\n     }\n}\n```\n在使用的时候，通过@include方法引用，如下所示：\n``` scss\n    h3 {\n        @include line-ellipsis();  //默认单行截断\n    }\n\n    .desc {\n        @include line-ellipsis(3, rem(38));  //3行截断\n    }\n```\ndesc这个类是多行截断，其中行高是rem(38)，调用了sass定义的px转rem的函数，是将38像素转为rem值。借助sass，可以方便地定义将像素转为rem。\n``` scss\n@function rem($px, $base-font-size: 75px) {\n  @if (unitless($px)) {     //unitless(75) => true; unitless(75px) => false\n    @return rem($px + 0px);\n  } @else if (unit($px) == rem) {  //unit(75px) => px; unitless(1rem) => rem\n    @return $px;\n  }\n  @return ($px / $base-font-size) * 1rem;\n}\n```\n在rem()函数中设置了两个参数$px和$base-font-size，并且给$base-font-size设置了默认值75px。rem布局使用了淘宝的lib.flexible方案，所以默认值为75px。而且在rem()函数中使用了unitless去判断$px是否携带单位，若没带为true，否则为false。若$px没带单位，则通过+0px的方式带上px单位。若$px带单位，用unit获取$px带的单位，若是rem，则直接返回，其他的，与$base-font-size相除得到rem值。\n除此之外，可以结合项目需求定义更多的方法，如通用的button样式、适配浏览器分辨率、兼容性等等。\n\n\n参考链接：\n[Module: Sass::Script::Functions](http://sass-lang.com/documentation/Sass/Script/Functions.html)\n[A Better Solution for Managing z-index with Sass](http://www.smashingmagazine.com/2014/06/12/sassy-z-index-management-for-complex-layouts/)\n[Friendlier colour names with Sass maps](http://erskinedesign.com/blog/friendlier-colour-names-sass-maps/#solving-issue-1-the-naming-of-things)\n","source":"_posts/sass应用.md","raw":"---\ntitle: SASS使用二三事\ndate: 2017-08-28 18:15:21\ntags: [sass, css]\n---\n\n### sass管理z-index\n\nz-index的值和上下文有关系，在复杂布局中要跟踪z-index比较困难，z-index的取值范围很广，很容易出错，所以可以使用sass预处理器去统一管理。\n\n#### 定义浮层\n首先，我们可以借助sass 3.3引入的Map定义一个数据结构，key代表了不同浮层类型，value即对应的z-index值：\n``` scss\n    $z-layers: (\n        'toast':          4000,\n        'modal':          3000,\n        'dropdown':       2000,\n        'mask':           1000,\n        'default':         1,\n        'below':          -1,\n        'bottomless-pit': -10000\n    );\n```\n#### 定义函数\n``` scss\n@function z($layer) {\n    @return map-get($z-layers, $layer);\n}\n```\n使用了sass的map-get方法，如果$layer参数存在于$z-layers中，会返回对应的value值，如z('toast')，返回对应的值为4000；若不存在于$z-layers中，则返回null。属性为null时，sass的编译不会输出。\n也可以借助map-has-key方法检查元素是否存在，对于不存在的元素使用@warn指令输出警告信息，方便我们在开发的时候发现问题。\n``` scss\n@function z($layer) {\n    @if not map-has-key($z-layers, $layer) {\n        @warn \"No z-index found in $z-layers map for `#{$layer}`. Property omitted.\";\n    }\n\n    @return map-get($z-layers, $layer);\n}\n```\n\n#### 使用方法\n``` scss\n//function方式\n.m-mask {\n    z-index: z('mask');\n}\n\n//mixin方式\n.m-mask {\n    @include z('mask');\n}\n```\n对于单个属性来说，建议采用function的定义方式，比起mixin方式，使用起来更加清晰、简单。\n<!-- more -->\n\n#### 嵌套层级\n在层级关系比较多的情况下，单一层级可能无法满足我们的需求，如弹窗里面还有很多的层级关系时，这个时候，我们可以使用嵌套的层级定义方式，针对modal进行再扩展，对modal里面的元素进一步定义层级数值。\n``` scss\n    $z-layers: (\n        'toast':          4000,\n        'modal':          (\n            \"base\": 3200,\n            \"close\": 3100,\n            \"header\": 3050,\n            \"footer\": 3000\n        ),\n        'dropdown':       2000,\n        'mask':           1000,\n        'default':         1,\n        'below':          -1,\n        'bottomless-pit': -10000\n    );\n```\n想要定义$z-layers中modal内部的层级关系，可以用嵌套的Map去设置，如上所示。要处理嵌套的层级关系，对应的z函数可以是：\n``` scss\n@function map-has-nested-keys($map, $keys...) {\n  @each $key in $keys {\n    @if not map-has-key($map, $key) {\n      @return false;\n    }\n    $map: map-get($map, $key);\n  }\n  @return true;\n}\n@function map-deep-get($map, $keys...) {\n  @each $key in $keys {\n    $map: map-get($map, $key);\n  }\n  @return $map;\n}\n@function z($layers...) {\n  @if not map-has-nested-keys($z-layers, $layers...) {\n    @warn \"No layer found for `#{inspect($layers...)}` in $z-layers map. Property omitted.\";\n  }\n  @return map-deep-get($z-layers, $layers...);\n}\n```\n其中map-has-nested-keys方法可以检查元素是否存在于已经定义的$z-layers中：\n1. 若$keys只有一个值'toast'，@each只需要循环一次，在循环内，$map被赋值为'toast'对应的z-index值，最后返回true值；\n2. 若$keys有两个值'modal'和'base'，@each循环两次，第一次循环，先检查'modal'是否存在于$z-layers中，再将$map赋值为map-get($z-layers, 'modal')，即内部嵌套的modal的map，第二次循环先判断'base'是否存在于$map中，若不存在直接返回false，若存在$map被赋值为'base'对应的z-index值，最后返回true值；\nmap-deep-get方法用于获得对应的z-index值，思路和map-has-nested-keys方法一致，只是前者返回true/false，后者返回$map值。\n具体的调用方式如下所示：\n``` scss\n.modal {\n  position: absolute;\n  z-index: z(\"modal\", \"base\");\n\n  .close-button {\n    z-index: z(\"modal\", \"close\");\n  }\n\n  header {\n    z-index: z(\"modal\", \"header\");\n  }\n\n  footer {\n    z-index: z(\"modal\", \"footer\");\n  }\n}\n.toast {\n  z-index: z(\"toast\");\n}\n```\n#### 另一种z-index管理思路\n首先创建一个层级列表，在这个列表中，元素的出现顺序是从低到高，使用sass提供的index方法获取元素在$elements中的顺序，即为该元素的z-index值。\n``` scss\n$elements: project-covers, sorting-bar, modals, navigation;\n\n.project-cover {\n  z-index: index($elements, project-covers);\n}\n```\n输出的z-index为1，与javascript不同，sass的索引值从1开始，就像css一样，css的:nth-child(n)中的n也是从1开始。\n``` scss\n.project-cover {\n  z-index: 1;\n}\n```\n个人觉得，这个方法更简单，适合于轻量级的项目，但灵活性不够好，取值范围受限于index值，对于嵌套的层级关系不友好，扩展性不好，对于较复杂项目更建议用前一种Map的形式来管理。\n\n### sass主题管理\n在项目开发中，涉及到不同主题的切换，例如在正文阅读时，有白天、黑夜、蓝色、黄色四种主题，不同主题配色不同，如果直接用css，结构复杂并且很难维护。利用scss提供的变量定义和方法，可以降低开发和维护成本。\n\n#### sass管理颜色\n首先，sass可以对整个项目常用的一些颜色进行定义，例如本次项目通用的红色值为#ED6460，则可以在单独的文件_color.scss中定义该色值，其他scss文件通过@import引用。\n``` scss\n$black: #24211F;\n$red: #ED6460;\n$blue: #60aaed;\n\n$border-gray: #ededed;\n$bg-gray: #f5f5f5;\n$btn-gray: #807A73;\n```\n#### 主题定义\n首先，定义一个Map，记录不同的主题和与之关联的颜色，每个主题下细分了不同用途的色值。\n``` scss\n@import './color.scss';\n\n//主题base设置\n$theme: (\n    light: (\n        bg: #fff,              //背景色\n        color: $black,         //正文颜色\n        title: #A83A45,        //章节标题颜色\n        link: #60AAED,         //底部链接颜色\n        border: #ededed,       //正文底部border颜色\n        themeBorder: #d8d8d8   //主题切换btn选中状态的border颜色\n    ),\n    dark: ( …… ),\n    blue: ( …… ),\n    yellow: ( …… )\n);\n\n@each $name, $theme in $theme {\n    .theme--#{$name} {\n        color: map-get($theme, color);\n        background-color: map-get($theme, bg);\n\n        .m-main .content {\n            h1, h2 {\n                color: map-get($theme, title);\n            }\n        }\n\n        .link {\n            color: map-get($theme, link);\n        }\n        // ... 其他涉及主题配色的选择器\n    }\n}\n```\n通过@each去遍历Map，.theme--#{$name}编译后会生成.theme-light, .theme-dark等，在.theme--#{$name} 选择器内部，可以定义该主题下不同元素的样式，具体颜色可以通过map-get方法获得。\n对于button这种，在不同主题下颜色、边框、背景、active状态等都需要改变，可以单独定义。\n``` scss\n$btn: (\n    light: (\n        color: $gray1, border: $gray0, bg: transparent,\n        color-active: #fff, border-active: $red, bg-active: $red\n    ),\n    dark: ( …… ),\n    blue: ( …… ),\n    yellow: ( …… ),\n);\n\n@each $name, $theme in $btn {\n    .btn--#{$name} {\n        color: map-get($theme, color);\n        border-color: map-get($theme, border);\n        background-color: map-get($theme, bg);\n    }\n\n    .btn--#{$name}:active, .btn--#{$name}-active {\n        color: map-get($theme, color-active);\n        border-color: map-get($theme, border-active);\n        background-color: map-get($theme, bg-active);\n    }\n}\n```\n将主题颜色与其他不变的样式分离出来进行管理，所有的主题颜色维护在_theme.scss中，从而极大地提高了代码的可维护性。在切换主题的时候，只需要更换相应的类名，尤其在结合react开发时，theme变化时只需要重新setState一下就会重新渲染页面，十分方便。\n\n### 定义通用样式\n可以通过sass提供的@mixin, @function等方式定义通用样式，如可以将实现单行\\多行文字截断效果的一组样式封装，用@mixin定义line-ellipsis方法，参数为行数和行高。传入行高是为了兼容不支持多行截断的浏览器，计算得出最大高度，防止样式错乱。其中行数的默认值为1，行高的默认值为1.5，可以使用@if,@else去判断行数，根据$num值去返回样式。\n``` scss\n@mixin line-ellipsis($num: 1, $lineH: 1.5){\n     @if $num > 1 {\n        display: -webkit-box;\n        -webkit-box-orient: vertical;\n        -webkit-line-clamp: $num;\n        text-overflow: ellipsis;\n        line-height: $lineH;\n        max-height: $lineH * $num;\n        overflow: hidden;\n     } @else {\n        white-space: nowrap;\n        text-overflow: ellipsis;\n        line-height: $lineH;\n        overflow: hidden;\n     }\n}\n```\n在使用的时候，通过@include方法引用，如下所示：\n``` scss\n    h3 {\n        @include line-ellipsis();  //默认单行截断\n    }\n\n    .desc {\n        @include line-ellipsis(3, rem(38));  //3行截断\n    }\n```\ndesc这个类是多行截断，其中行高是rem(38)，调用了sass定义的px转rem的函数，是将38像素转为rem值。借助sass，可以方便地定义将像素转为rem。\n``` scss\n@function rem($px, $base-font-size: 75px) {\n  @if (unitless($px)) {     //unitless(75) => true; unitless(75px) => false\n    @return rem($px + 0px);\n  } @else if (unit($px) == rem) {  //unit(75px) => px; unitless(1rem) => rem\n    @return $px;\n  }\n  @return ($px / $base-font-size) * 1rem;\n}\n```\n在rem()函数中设置了两个参数$px和$base-font-size，并且给$base-font-size设置了默认值75px。rem布局使用了淘宝的lib.flexible方案，所以默认值为75px。而且在rem()函数中使用了unitless去判断$px是否携带单位，若没带为true，否则为false。若$px没带单位，则通过+0px的方式带上px单位。若$px带单位，用unit获取$px带的单位，若是rem，则直接返回，其他的，与$base-font-size相除得到rem值。\n除此之外，可以结合项目需求定义更多的方法，如通用的button样式、适配浏览器分辨率、兼容性等等。\n\n\n参考链接：\n[Module: Sass::Script::Functions](http://sass-lang.com/documentation/Sass/Script/Functions.html)\n[A Better Solution for Managing z-index with Sass](http://www.smashingmagazine.com/2014/06/12/sassy-z-index-management-for-complex-layouts/)\n[Friendlier colour names with Sass maps](http://erskinedesign.com/blog/friendlier-colour-names-sass-maps/#solving-issue-1-the-naming-of-things)\n","slug":"sass应用","published":1,"updated":"2019-03-18T02:27:14.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx82002tqmhf0np683pw","content":"<h3 id=\"sass管理z-index\"><a href=\"#sass管理z-index\" class=\"headerlink\" title=\"sass管理z-index\"></a>sass管理z-index</h3><p>z-index的值和上下文有关系，在复杂布局中要跟踪z-index比较困难，z-index的取值范围很广，很容易出错，所以可以使用sass预处理器去统一管理。</p>\n<h4 id=\"定义浮层\"><a href=\"#定义浮层\" class=\"headerlink\" title=\"定义浮层\"></a>定义浮层</h4><p>首先，我们可以借助sass 3.3引入的Map定义一个数据结构，key代表了不同浮层类型，value即对应的z-index值：<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$z-layers</span>: (</span><br><span class=\"line\">    <span class=\"string\">'toast'</span>:          <span class=\"number\">4000</span>,</span><br><span class=\"line\">    <span class=\"string\">'modal'</span>:          <span class=\"number\">3000</span>,</span><br><span class=\"line\">    <span class=\"string\">'dropdown'</span>:       <span class=\"number\">2000</span>,</span><br><span class=\"line\">    <span class=\"string\">'mask'</span>:           <span class=\"number\">1000</span>,</span><br><span class=\"line\">    <span class=\"string\">'default'</span>:         <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'below'</span>:          -<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'bottomless-pit'</span>: -<span class=\"number\">10000</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function z(<span class=\"variable\">$layer</span>) &#123;</span><br><span class=\"line\">    @return map-get(<span class=\"variable\">$z-layers</span>, <span class=\"variable\">$layer</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用了sass的map-get方法，如果$layer参数存在于$z-layers中，会返回对应的value值，如z(‘toast’)，返回对应的值为4000；若不存在于$z-layers中，则返回null。属性为null时，sass的编译不会输出。<br>也可以借助map-has-key方法检查元素是否存在，对于不存在的元素使用@warn指令输出警告信息，方便我们在开发的时候发现问题。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function z(<span class=\"variable\">$layer</span>) &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">if</span> not map-has-key(<span class=\"variable\">$z-layers</span>, <span class=\"variable\">$layer</span>) &#123;</span><br><span class=\"line\">        @<span class=\"keyword\">warn</span> <span class=\"string\">\"No z-index found in $z-layers map for `#&#123;$layer&#125;`. Property omitted.\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @return map-get(<span class=\"variable\">$z-layers</span>, <span class=\"variable\">$layer</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//function方式</span></span><br><span class=\"line\"><span class=\"selector-class\">.m-mask</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: z(<span class=\"string\">'mask'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//mixin方式</span></span><br><span class=\"line\"><span class=\"selector-class\">.m-mask</span> &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">include</span> z(<span class=\"string\">'mask'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于单个属性来说，建议采用function的定义方式，比起mixin方式，使用起来更加清晰、简单。<br><a id=\"more\"></a></p>\n<h4 id=\"嵌套层级\"><a href=\"#嵌套层级\" class=\"headerlink\" title=\"嵌套层级\"></a>嵌套层级</h4><p>在层级关系比较多的情况下，单一层级可能无法满足我们的需求，如弹窗里面还有很多的层级关系时，这个时候，我们可以使用嵌套的层级定义方式，针对modal进行再扩展，对modal里面的元素进一步定义层级数值。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$z-layers</span>: (</span><br><span class=\"line\">    <span class=\"string\">'toast'</span>:          <span class=\"number\">4000</span>,</span><br><span class=\"line\">    <span class=\"string\">'modal'</span>:          (</span><br><span class=\"line\">        <span class=\"string\">\"base\"</span>: <span class=\"number\">3200</span>,</span><br><span class=\"line\">        <span class=\"string\">\"close\"</span>: <span class=\"number\">3100</span>,</span><br><span class=\"line\">        <span class=\"string\">\"header\"</span>: <span class=\"number\">3050</span>,</span><br><span class=\"line\">        <span class=\"string\">\"footer\"</span>: <span class=\"number\">3000</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"string\">'dropdown'</span>:       <span class=\"number\">2000</span>,</span><br><span class=\"line\">    <span class=\"string\">'mask'</span>:           <span class=\"number\">1000</span>,</span><br><span class=\"line\">    <span class=\"string\">'default'</span>:         <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'below'</span>:          -<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'bottomless-pit'</span>: -<span class=\"number\">10000</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>想要定义$z-layers中modal内部的层级关系，可以用嵌套的Map去设置，如上所示。要处理嵌套的层级关系，对应的z函数可以是：<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function map-has-nested-keys(<span class=\"variable\">$map</span>, <span class=\"variable\">$keys</span>...) &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">each</span> <span class=\"variable\">$key</span> in <span class=\"variable\">$keys</span> &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">if</span> not map-has-key(<span class=\"variable\">$map</span>, <span class=\"variable\">$key</span>) &#123;</span><br><span class=\"line\">      @return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable\">$map</span>: map-get(<span class=\"variable\">$map</span>, <span class=\"variable\">$key</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@function map-deep-get(<span class=\"variable\">$map</span>, <span class=\"variable\">$keys</span>...) &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">each</span> <span class=\"variable\">$key</span> in <span class=\"variable\">$keys</span> &#123;</span><br><span class=\"line\">    <span class=\"variable\">$map</span>: map-get(<span class=\"variable\">$map</span>, <span class=\"variable\">$key</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @return <span class=\"variable\">$map</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@function z(<span class=\"variable\">$layers</span>...) &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">if</span> not map-has-nested-keys(<span class=\"variable\">$z-layers</span>, <span class=\"variable\">$layers</span>...) &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">warn</span> <span class=\"string\">\"No layer found for `#&#123;inspect($layers...)&#125;` in $z-layers map. Property omitted.\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @return map-deep-get(<span class=\"variable\">$z-layers</span>, <span class=\"variable\">$layers</span>...);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中map-has-nested-keys方法可以检查元素是否存在于已经定义的$z-layers中：</p>\n<ol>\n<li>若$keys只有一个值’toast’，@each只需要循环一次，在循环内，$map被赋值为’toast’对应的z-index值，最后返回true值；</li>\n<li>若$keys有两个值’modal’和’base’，@each循环两次，第一次循环，先检查’modal’是否存在于$z-layers中，再将$map赋值为map-get($z-layers, ‘modal’)，即内部嵌套的modal的map，第二次循环先判断’base’是否存在于$map中，若不存在直接返回false，若存在$map被赋值为’base’对应的z-index值，最后返回true值；<br>map-deep-get方法用于获得对应的z-index值，思路和map-has-nested-keys方法一致，只是前者返回true/false，后者返回$map值。<br>具体的调用方式如下所示：<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.modal</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: z(<span class=\"string\">\"modal\"</span>, <span class=\"string\">\"base\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-class\">.close-button</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: z(<span class=\"string\">\"modal\"</span>, <span class=\"string\">\"close\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-tag\">header</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: z(<span class=\"string\">\"modal\"</span>, <span class=\"string\">\"header\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: z(<span class=\"string\">\"modal\"</span>, <span class=\"string\">\"footer\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.toast</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: z(<span class=\"string\">\"toast\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"另一种z-index管理思路\"><a href=\"#另一种z-index管理思路\" class=\"headerlink\" title=\"另一种z-index管理思路\"></a>另一种z-index管理思路</h4><p>首先创建一个层级列表，在这个列表中，元素的出现顺序是从低到高，使用sass提供的index方法获取元素在$elements中的顺序，即为该元素的z-index值。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$elements</span>: project-covers, sorting-bar, modals, navigation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.project-cover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: index(<span class=\"variable\">$elements</span>, project-covers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出的z-index为1，与javascript不同，sass的索引值从1开始，就像css一样，css的:nth-child(n)中的n也是从1开始。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.project-cover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>个人觉得，这个方法更简单，适合于轻量级的项目，但灵活性不够好，取值范围受限于index值，对于嵌套的层级关系不友好，扩展性不好，对于较复杂项目更建议用前一种Map的形式来管理。</p>\n<h3 id=\"sass主题管理\"><a href=\"#sass主题管理\" class=\"headerlink\" title=\"sass主题管理\"></a>sass主题管理</h3><p>在项目开发中，涉及到不同主题的切换，例如在正文阅读时，有白天、黑夜、蓝色、黄色四种主题，不同主题配色不同，如果直接用css，结构复杂并且很难维护。利用scss提供的变量定义和方法，可以降低开发和维护成本。</p>\n<h4 id=\"sass管理颜色\"><a href=\"#sass管理颜色\" class=\"headerlink\" title=\"sass管理颜色\"></a>sass管理颜色</h4><p>首先，sass可以对整个项目常用的一些颜色进行定义，例如本次项目通用的红色值为#ED6460，则可以在单独的文件_color.scss中定义该色值，其他scss文件通过@import引用。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$black</span>: <span class=\"number\">#24211F</span>;</span><br><span class=\"line\"><span class=\"variable\">$red</span>: <span class=\"number\">#ED6460</span>;</span><br><span class=\"line\"><span class=\"variable\">$blue</span>: <span class=\"number\">#60aaed</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$border-gray</span>: <span class=\"number\">#ededed</span>;</span><br><span class=\"line\"><span class=\"variable\">$bg-gray</span>: <span class=\"number\">#f5f5f5</span>;</span><br><span class=\"line\"><span class=\"variable\">$btn-gray</span>: <span class=\"number\">#807A73</span>;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"主题定义\"><a href=\"#主题定义\" class=\"headerlink\" title=\"主题定义\"></a>主题定义</h4><p>首先，定义一个Map，记录不同的主题和与之关联的颜色，每个主题下细分了不同用途的色值。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">'./color.scss'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//主题base设置</span></span><br><span class=\"line\"><span class=\"variable\">$theme</span>: (</span><br><span class=\"line\">    light: (</span><br><span class=\"line\">        bg: <span class=\"number\">#fff</span>,              //背景色</span><br><span class=\"line\">        color: <span class=\"variable\">$black</span>,         //正文颜色</span><br><span class=\"line\">        title: <span class=\"number\">#A83A45</span>,        //章节标题颜色</span><br><span class=\"line\">        link: <span class=\"number\">#60AAED</span>,         //底部链接颜色</span><br><span class=\"line\">        border: <span class=\"number\">#ededed</span>,       //正文底部border颜色</span><br><span class=\"line\">        themeBorder: <span class=\"number\">#d8d8d8</span>   //主题切换btn选中状态的border颜色</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    dark: ( …… ),</span><br><span class=\"line\">    blue: ( …… ),</span><br><span class=\"line\">    yellow: ( …… )</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">each</span> <span class=\"variable\">$name</span>, <span class=\"variable\">$theme</span> in <span class=\"variable\">$theme</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-class\">.theme--</span>#&#123;<span class=\"variable\">$name</span>&#125; &#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$theme</span>, color);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: map-get(<span class=\"variable\">$theme</span>, bg);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-class\">.m-main</span> <span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">            <span class=\"selector-tag\">h1</span>, <span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">                <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$theme</span>, title);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-class\">.link</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$theme</span>, link);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// ... 其他涉及主题配色的选择器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过@each去遍历Map，.theme–#{$name}编译后会生成.theme-light, .theme-dark等，在.theme–#{$name} 选择器内部，可以定义该主题下不同元素的样式，具体颜色可以通过map-get方法获得。<br>对于button这种，在不同主题下颜色、边框、背景、active状态等都需要改变，可以单独定义。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$btn</span>: (</span><br><span class=\"line\">    light: (</span><br><span class=\"line\">        color: <span class=\"variable\">$gray1</span>, border: <span class=\"variable\">$gray0</span>, bg: transparent,</span><br><span class=\"line\">        color-active: <span class=\"number\">#fff</span>, border-active: <span class=\"variable\">$red</span>, bg-active: <span class=\"variable\">$red</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    dark: ( …… ),</span><br><span class=\"line\">    blue: ( …… ),</span><br><span class=\"line\">    yellow: ( …… ),</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">each</span> <span class=\"variable\">$name</span>, <span class=\"variable\">$theme</span> in <span class=\"variable\">$btn</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-class\">.btn--</span>#&#123;<span class=\"variable\">$name</span>&#125; &#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$theme</span>, color);</span><br><span class=\"line\">        <span class=\"attribute\">border-color</span>: map-get(<span class=\"variable\">$theme</span>, border);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: map-get(<span class=\"variable\">$theme</span>, bg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-class\">.btn--</span>#&#123;<span class=\"variable\">$name</span>&#125;:active, <span class=\"selector-class\">.btn--</span>#&#123;<span class=\"variable\">$name</span>&#125;-active &#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$theme</span>, color-active);</span><br><span class=\"line\">        <span class=\"attribute\">border-color</span>: map-get(<span class=\"variable\">$theme</span>, border-active);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: map-get(<span class=\"variable\">$theme</span>, bg-active);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将主题颜色与其他不变的样式分离出来进行管理，所有的主题颜色维护在_theme.scss中，从而极大地提高了代码的可维护性。在切换主题的时候，只需要更换相应的类名，尤其在结合react开发时，theme变化时只需要重新setState一下就会重新渲染页面，十分方便。</p>\n<h3 id=\"定义通用样式\"><a href=\"#定义通用样式\" class=\"headerlink\" title=\"定义通用样式\"></a>定义通用样式</h3><p>可以通过sass提供的@mixin, @function等方式定义通用样式，如可以将实现单行\\多行文字截断效果的一组样式封装，用@mixin定义line-ellipsis方法，参数为行数和行高。传入行高是为了兼容不支持多行截断的浏览器，计算得出最大高度，防止样式错乱。其中行数的默认值为1，行高的默认值为1.5，可以使用@if,@else去判断行数，根据$num值去返回样式。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> line-ellipsis(<span class=\"variable\">$num</span>: 1, <span class=\"variable\">$lineH</span>: 1.5)&#123;</span><br><span class=\"line\">     @<span class=\"keyword\">if</span> <span class=\"variable\">$num</span> &gt; 1 &#123;</span><br><span class=\"line\">        <span class=\"attribute\">display</span>: -webkit-box;</span><br><span class=\"line\">        -webkit-box-orient: vertical;</span><br><span class=\"line\">        -webkit-line-clamp: <span class=\"variable\">$num</span>;</span><br><span class=\"line\">        <span class=\"attribute\">text-overflow</span>: ellipsis;</span><br><span class=\"line\">        <span class=\"attribute\">line-height</span>: <span class=\"variable\">$lineH</span>;</span><br><span class=\"line\">        <span class=\"attribute\">max-height</span>: <span class=\"variable\">$lineH</span> * <span class=\"variable\">$num</span>;</span><br><span class=\"line\">        <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">     &#125; @<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">white-space</span>: nowrap;</span><br><span class=\"line\">        <span class=\"attribute\">text-overflow</span>: ellipsis;</span><br><span class=\"line\">        <span class=\"attribute\">line-height</span>: <span class=\"variable\">$lineH</span>;</span><br><span class=\"line\">        <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在使用的时候，通过@include方法引用，如下所示：<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">include</span> line-ellipsis();  <span class=\"comment\">//默认单行截断</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.desc</span> &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">include</span> line-ellipsis(<span class=\"number\">3</span>, rem(<span class=\"number\">38</span>));  <span class=\"comment\">//3行截断</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>desc这个类是多行截断，其中行高是rem(38)，调用了sass定义的px转rem的函数，是将38像素转为rem值。借助sass，可以方便地定义将像素转为rem。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function rem(<span class=\"variable\">$px</span>, <span class=\"variable\">$base-font-size</span>: 75px) &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">if</span> (unitless(<span class=\"variable\">$px</span>)) &#123;     <span class=\"comment\">//unitless(75) =&gt; true; unitless(75px) =&gt; false</span></span><br><span class=\"line\">    @return rem(<span class=\"variable\">$px</span> + 0px);</span><br><span class=\"line\">  &#125; @<span class=\"keyword\">else</span> if (unit(<span class=\"variable\">$px</span>) == rem) &#123;  <span class=\"comment\">//unit(75px) =&gt; px; unitless(1rem) =&gt; rem</span></span><br><span class=\"line\">    @return <span class=\"variable\">$px</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @return (<span class=\"variable\">$px</span> / <span class=\"variable\">$base-font-size</span>) * 1rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在rem()函数中设置了两个参数$px和$base-font-size，并且给$base-font-size设置了默认值75px。rem布局使用了淘宝的lib.flexible方案，所以默认值为75px。而且在rem()函数中使用了unitless去判断$px是否携带单位，若没带为true，否则为false。若$px没带单位，则通过+0px的方式带上px单位。若$px带单位，用unit获取$px带的单位，若是rem，则直接返回，其他的，与$base-font-size相除得到rem值。<br>除此之外，可以结合项目需求定义更多的方法，如通用的button样式、适配浏览器分辨率、兼容性等等。</p>\n<p>参考链接：<br><a href=\"http://sass-lang.com/documentation/Sass/Script/Functions.html\" target=\"_blank\" rel=\"noopener\">Module: Sass::Script::Functions</a><br><a href=\"http://www.smashingmagazine.com/2014/06/12/sassy-z-index-management-for-complex-layouts/\" target=\"_blank\" rel=\"noopener\">A Better Solution for Managing z-index with Sass</a><br><a href=\"http://erskinedesign.com/blog/friendlier-colour-names-sass-maps/#solving-issue-1-the-naming-of-things\" target=\"_blank\" rel=\"noopener\">Friendlier colour names with Sass maps</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"sass管理z-index\"><a href=\"#sass管理z-index\" class=\"headerlink\" title=\"sass管理z-index\"></a>sass管理z-index</h3><p>z-index的值和上下文有关系，在复杂布局中要跟踪z-index比较困难，z-index的取值范围很广，很容易出错，所以可以使用sass预处理器去统一管理。</p>\n<h4 id=\"定义浮层\"><a href=\"#定义浮层\" class=\"headerlink\" title=\"定义浮层\"></a>定义浮层</h4><p>首先，我们可以借助sass 3.3引入的Map定义一个数据结构，key代表了不同浮层类型，value即对应的z-index值：<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$z-layers</span>: (</span><br><span class=\"line\">    <span class=\"string\">'toast'</span>:          <span class=\"number\">4000</span>,</span><br><span class=\"line\">    <span class=\"string\">'modal'</span>:          <span class=\"number\">3000</span>,</span><br><span class=\"line\">    <span class=\"string\">'dropdown'</span>:       <span class=\"number\">2000</span>,</span><br><span class=\"line\">    <span class=\"string\">'mask'</span>:           <span class=\"number\">1000</span>,</span><br><span class=\"line\">    <span class=\"string\">'default'</span>:         <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'below'</span>:          -<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'bottomless-pit'</span>: -<span class=\"number\">10000</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"定义函数\"><a href=\"#定义函数\" class=\"headerlink\" title=\"定义函数\"></a>定义函数</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function z(<span class=\"variable\">$layer</span>) &#123;</span><br><span class=\"line\">    @return map-get(<span class=\"variable\">$z-layers</span>, <span class=\"variable\">$layer</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用了sass的map-get方法，如果$layer参数存在于$z-layers中，会返回对应的value值，如z(‘toast’)，返回对应的值为4000；若不存在于$z-layers中，则返回null。属性为null时，sass的编译不会输出。<br>也可以借助map-has-key方法检查元素是否存在，对于不存在的元素使用@warn指令输出警告信息，方便我们在开发的时候发现问题。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function z(<span class=\"variable\">$layer</span>) &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">if</span> not map-has-key(<span class=\"variable\">$z-layers</span>, <span class=\"variable\">$layer</span>) &#123;</span><br><span class=\"line\">        @<span class=\"keyword\">warn</span> <span class=\"string\">\"No z-index found in $z-layers map for `#&#123;$layer&#125;`. Property omitted.\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @return map-get(<span class=\"variable\">$z-layers</span>, <span class=\"variable\">$layer</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h4><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//function方式</span></span><br><span class=\"line\"><span class=\"selector-class\">.m-mask</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: z(<span class=\"string\">'mask'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//mixin方式</span></span><br><span class=\"line\"><span class=\"selector-class\">.m-mask</span> &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">include</span> z(<span class=\"string\">'mask'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于单个属性来说，建议采用function的定义方式，比起mixin方式，使用起来更加清晰、简单。<br>","more":"</p>\n<h4 id=\"嵌套层级\"><a href=\"#嵌套层级\" class=\"headerlink\" title=\"嵌套层级\"></a>嵌套层级</h4><p>在层级关系比较多的情况下，单一层级可能无法满足我们的需求，如弹窗里面还有很多的层级关系时，这个时候，我们可以使用嵌套的层级定义方式，针对modal进行再扩展，对modal里面的元素进一步定义层级数值。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$z-layers</span>: (</span><br><span class=\"line\">    <span class=\"string\">'toast'</span>:          <span class=\"number\">4000</span>,</span><br><span class=\"line\">    <span class=\"string\">'modal'</span>:          (</span><br><span class=\"line\">        <span class=\"string\">\"base\"</span>: <span class=\"number\">3200</span>,</span><br><span class=\"line\">        <span class=\"string\">\"close\"</span>: <span class=\"number\">3100</span>,</span><br><span class=\"line\">        <span class=\"string\">\"header\"</span>: <span class=\"number\">3050</span>,</span><br><span class=\"line\">        <span class=\"string\">\"footer\"</span>: <span class=\"number\">3000</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    <span class=\"string\">'dropdown'</span>:       <span class=\"number\">2000</span>,</span><br><span class=\"line\">    <span class=\"string\">'mask'</span>:           <span class=\"number\">1000</span>,</span><br><span class=\"line\">    <span class=\"string\">'default'</span>:         <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'below'</span>:          -<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'bottomless-pit'</span>: -<span class=\"number\">10000</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>想要定义$z-layers中modal内部的层级关系，可以用嵌套的Map去设置，如上所示。要处理嵌套的层级关系，对应的z函数可以是：<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function map-has-nested-keys(<span class=\"variable\">$map</span>, <span class=\"variable\">$keys</span>...) &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">each</span> <span class=\"variable\">$key</span> in <span class=\"variable\">$keys</span> &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">if</span> not map-has-key(<span class=\"variable\">$map</span>, <span class=\"variable\">$key</span>) &#123;</span><br><span class=\"line\">      @return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable\">$map</span>: map-get(<span class=\"variable\">$map</span>, <span class=\"variable\">$key</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@function map-deep-get(<span class=\"variable\">$map</span>, <span class=\"variable\">$keys</span>...) &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">each</span> <span class=\"variable\">$key</span> in <span class=\"variable\">$keys</span> &#123;</span><br><span class=\"line\">    <span class=\"variable\">$map</span>: map-get(<span class=\"variable\">$map</span>, <span class=\"variable\">$key</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @return <span class=\"variable\">$map</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@function z(<span class=\"variable\">$layers</span>...) &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">if</span> not map-has-nested-keys(<span class=\"variable\">$z-layers</span>, <span class=\"variable\">$layers</span>...) &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">warn</span> <span class=\"string\">\"No layer found for `#&#123;inspect($layers...)&#125;` in $z-layers map. Property omitted.\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @return map-deep-get(<span class=\"variable\">$z-layers</span>, <span class=\"variable\">$layers</span>...);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中map-has-nested-keys方法可以检查元素是否存在于已经定义的$z-layers中：</p>\n<ol>\n<li>若$keys只有一个值’toast’，@each只需要循环一次，在循环内，$map被赋值为’toast’对应的z-index值，最后返回true值；</li>\n<li>若$keys有两个值’modal’和’base’，@each循环两次，第一次循环，先检查’modal’是否存在于$z-layers中，再将$map赋值为map-get($z-layers, ‘modal’)，即内部嵌套的modal的map，第二次循环先判断’base’是否存在于$map中，若不存在直接返回false，若存在$map被赋值为’base’对应的z-index值，最后返回true值；<br>map-deep-get方法用于获得对应的z-index值，思路和map-has-nested-keys方法一致，只是前者返回true/false，后者返回$map值。<br>具体的调用方式如下所示：<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.modal</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: z(<span class=\"string\">\"modal\"</span>, <span class=\"string\">\"base\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-class\">.close-button</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: z(<span class=\"string\">\"modal\"</span>, <span class=\"string\">\"close\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-tag\">header</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: z(<span class=\"string\">\"modal\"</span>, <span class=\"string\">\"header\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">z-index</span>: z(<span class=\"string\">\"modal\"</span>, <span class=\"string\">\"footer\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.toast</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: z(<span class=\"string\">\"toast\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"另一种z-index管理思路\"><a href=\"#另一种z-index管理思路\" class=\"headerlink\" title=\"另一种z-index管理思路\"></a>另一种z-index管理思路</h4><p>首先创建一个层级列表，在这个列表中，元素的出现顺序是从低到高，使用sass提供的index方法获取元素在$elements中的顺序，即为该元素的z-index值。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$elements</span>: project-covers, sorting-bar, modals, navigation;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.project-cover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: index(<span class=\"variable\">$elements</span>, project-covers);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>输出的z-index为1，与javascript不同，sass的索引值从1开始，就像css一样，css的:nth-child(n)中的n也是从1开始。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.project-cover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>个人觉得，这个方法更简单，适合于轻量级的项目，但灵活性不够好，取值范围受限于index值，对于嵌套的层级关系不友好，扩展性不好，对于较复杂项目更建议用前一种Map的形式来管理。</p>\n<h3 id=\"sass主题管理\"><a href=\"#sass主题管理\" class=\"headerlink\" title=\"sass主题管理\"></a>sass主题管理</h3><p>在项目开发中，涉及到不同主题的切换，例如在正文阅读时，有白天、黑夜、蓝色、黄色四种主题，不同主题配色不同，如果直接用css，结构复杂并且很难维护。利用scss提供的变量定义和方法，可以降低开发和维护成本。</p>\n<h4 id=\"sass管理颜色\"><a href=\"#sass管理颜色\" class=\"headerlink\" title=\"sass管理颜色\"></a>sass管理颜色</h4><p>首先，sass可以对整个项目常用的一些颜色进行定义，例如本次项目通用的红色值为#ED6460，则可以在单独的文件_color.scss中定义该色值，其他scss文件通过@import引用。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$black</span>: <span class=\"number\">#24211F</span>;</span><br><span class=\"line\"><span class=\"variable\">$red</span>: <span class=\"number\">#ED6460</span>;</span><br><span class=\"line\"><span class=\"variable\">$blue</span>: <span class=\"number\">#60aaed</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$border-gray</span>: <span class=\"number\">#ededed</span>;</span><br><span class=\"line\"><span class=\"variable\">$bg-gray</span>: <span class=\"number\">#f5f5f5</span>;</span><br><span class=\"line\"><span class=\"variable\">$btn-gray</span>: <span class=\"number\">#807A73</span>;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"主题定义\"><a href=\"#主题定义\" class=\"headerlink\" title=\"主题定义\"></a>主题定义</h4><p>首先，定义一个Map，记录不同的主题和与之关联的颜色，每个主题下细分了不同用途的色值。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">import</span> <span class=\"string\">'./color.scss'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//主题base设置</span></span><br><span class=\"line\"><span class=\"variable\">$theme</span>: (</span><br><span class=\"line\">    light: (</span><br><span class=\"line\">        bg: <span class=\"number\">#fff</span>,              //背景色</span><br><span class=\"line\">        color: <span class=\"variable\">$black</span>,         //正文颜色</span><br><span class=\"line\">        title: <span class=\"number\">#A83A45</span>,        //章节标题颜色</span><br><span class=\"line\">        link: <span class=\"number\">#60AAED</span>,         //底部链接颜色</span><br><span class=\"line\">        border: <span class=\"number\">#ededed</span>,       //正文底部border颜色</span><br><span class=\"line\">        themeBorder: <span class=\"number\">#d8d8d8</span>   //主题切换btn选中状态的border颜色</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    dark: ( …… ),</span><br><span class=\"line\">    blue: ( …… ),</span><br><span class=\"line\">    yellow: ( …… )</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">each</span> <span class=\"variable\">$name</span>, <span class=\"variable\">$theme</span> in <span class=\"variable\">$theme</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-class\">.theme--</span>#&#123;<span class=\"variable\">$name</span>&#125; &#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$theme</span>, color);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: map-get(<span class=\"variable\">$theme</span>, bg);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-class\">.m-main</span> <span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">            <span class=\"selector-tag\">h1</span>, <span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">                <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$theme</span>, title);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"selector-class\">.link</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$theme</span>, link);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// ... 其他涉及主题配色的选择器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过@each去遍历Map，.theme–#{$name}编译后会生成.theme-light, .theme-dark等，在.theme–#{$name} 选择器内部，可以定义该主题下不同元素的样式，具体颜色可以通过map-get方法获得。<br>对于button这种，在不同主题下颜色、边框、背景、active状态等都需要改变，可以单独定义。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$btn</span>: (</span><br><span class=\"line\">    light: (</span><br><span class=\"line\">        color: <span class=\"variable\">$gray1</span>, border: <span class=\"variable\">$gray0</span>, bg: transparent,</span><br><span class=\"line\">        color-active: <span class=\"number\">#fff</span>, border-active: <span class=\"variable\">$red</span>, bg-active: <span class=\"variable\">$red</span></span><br><span class=\"line\">    ),</span><br><span class=\"line\">    dark: ( …… ),</span><br><span class=\"line\">    blue: ( …… ),</span><br><span class=\"line\">    yellow: ( …… ),</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">each</span> <span class=\"variable\">$name</span>, <span class=\"variable\">$theme</span> in <span class=\"variable\">$btn</span> &#123;</span><br><span class=\"line\">    <span class=\"selector-class\">.btn--</span>#&#123;<span class=\"variable\">$name</span>&#125; &#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$theme</span>, color);</span><br><span class=\"line\">        <span class=\"attribute\">border-color</span>: map-get(<span class=\"variable\">$theme</span>, border);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: map-get(<span class=\"variable\">$theme</span>, bg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-class\">.btn--</span>#&#123;<span class=\"variable\">$name</span>&#125;:active, <span class=\"selector-class\">.btn--</span>#&#123;<span class=\"variable\">$name</span>&#125;-active &#123;</span><br><span class=\"line\">        <span class=\"attribute\">color</span>: map-get(<span class=\"variable\">$theme</span>, color-active);</span><br><span class=\"line\">        <span class=\"attribute\">border-color</span>: map-get(<span class=\"variable\">$theme</span>, border-active);</span><br><span class=\"line\">        <span class=\"attribute\">background-color</span>: map-get(<span class=\"variable\">$theme</span>, bg-active);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将主题颜色与其他不变的样式分离出来进行管理，所有的主题颜色维护在_theme.scss中，从而极大地提高了代码的可维护性。在切换主题的时候，只需要更换相应的类名，尤其在结合react开发时，theme变化时只需要重新setState一下就会重新渲染页面，十分方便。</p>\n<h3 id=\"定义通用样式\"><a href=\"#定义通用样式\" class=\"headerlink\" title=\"定义通用样式\"></a>定义通用样式</h3><p>可以通过sass提供的@mixin, @function等方式定义通用样式，如可以将实现单行\\多行文字截断效果的一组样式封装，用@mixin定义line-ellipsis方法，参数为行数和行高。传入行高是为了兼容不支持多行截断的浏览器，计算得出最大高度，防止样式错乱。其中行数的默认值为1，行高的默认值为1.5，可以使用@if,@else去判断行数，根据$num值去返回样式。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">mixin</span> line-ellipsis(<span class=\"variable\">$num</span>: 1, <span class=\"variable\">$lineH</span>: 1.5)&#123;</span><br><span class=\"line\">     @<span class=\"keyword\">if</span> <span class=\"variable\">$num</span> &gt; 1 &#123;</span><br><span class=\"line\">        <span class=\"attribute\">display</span>: -webkit-box;</span><br><span class=\"line\">        -webkit-box-orient: vertical;</span><br><span class=\"line\">        -webkit-line-clamp: <span class=\"variable\">$num</span>;</span><br><span class=\"line\">        <span class=\"attribute\">text-overflow</span>: ellipsis;</span><br><span class=\"line\">        <span class=\"attribute\">line-height</span>: <span class=\"variable\">$lineH</span>;</span><br><span class=\"line\">        <span class=\"attribute\">max-height</span>: <span class=\"variable\">$lineH</span> * <span class=\"variable\">$num</span>;</span><br><span class=\"line\">        <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">     &#125; @<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">white-space</span>: nowrap;</span><br><span class=\"line\">        <span class=\"attribute\">text-overflow</span>: ellipsis;</span><br><span class=\"line\">        <span class=\"attribute\">line-height</span>: <span class=\"variable\">$lineH</span>;</span><br><span class=\"line\">        <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在使用的时候，通过@include方法引用，如下所示：<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">h3</span> &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">include</span> line-ellipsis();  <span class=\"comment\">//默认单行截断</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.desc</span> &#123;</span><br><span class=\"line\">    @<span class=\"keyword\">include</span> line-ellipsis(<span class=\"number\">3</span>, rem(<span class=\"number\">38</span>));  <span class=\"comment\">//3行截断</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>desc这个类是多行截断，其中行高是rem(38)，调用了sass定义的px转rem的函数，是将38像素转为rem值。借助sass，可以方便地定义将像素转为rem。<br><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function rem(<span class=\"variable\">$px</span>, <span class=\"variable\">$base-font-size</span>: 75px) &#123;</span><br><span class=\"line\">  @<span class=\"keyword\">if</span> (unitless(<span class=\"variable\">$px</span>)) &#123;     <span class=\"comment\">//unitless(75) =&gt; true; unitless(75px) =&gt; false</span></span><br><span class=\"line\">    @return rem(<span class=\"variable\">$px</span> + 0px);</span><br><span class=\"line\">  &#125; @<span class=\"keyword\">else</span> if (unit(<span class=\"variable\">$px</span>) == rem) &#123;  <span class=\"comment\">//unit(75px) =&gt; px; unitless(1rem) =&gt; rem</span></span><br><span class=\"line\">    @return <span class=\"variable\">$px</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  @return (<span class=\"variable\">$px</span> / <span class=\"variable\">$base-font-size</span>) * 1rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在rem()函数中设置了两个参数$px和$base-font-size，并且给$base-font-size设置了默认值75px。rem布局使用了淘宝的lib.flexible方案，所以默认值为75px。而且在rem()函数中使用了unitless去判断$px是否携带单位，若没带为true，否则为false。若$px没带单位，则通过+0px的方式带上px单位。若$px带单位，用unit获取$px带的单位，若是rem，则直接返回，其他的，与$base-font-size相除得到rem值。<br>除此之外，可以结合项目需求定义更多的方法，如通用的button样式、适配浏览器分辨率、兼容性等等。</p>\n<p>参考链接：<br><a href=\"http://sass-lang.com/documentation/Sass/Script/Functions.html\" target=\"_blank\" rel=\"noopener\">Module: Sass::Script::Functions</a><br><a href=\"http://www.smashingmagazine.com/2014/06/12/sassy-z-index-management-for-complex-layouts/\" target=\"_blank\" rel=\"noopener\">A Better Solution for Managing z-index with Sass</a><br><a href=\"http://erskinedesign.com/blog/friendlier-colour-names-sass-maps/#solving-issue-1-the-naming-of-things\" target=\"_blank\" rel=\"noopener\">Friendlier colour names with Sass maps</a></p>"},{"title":"菜鸟优化之路-图片webp&lazyload","date":"2018-09-27T12:17:29.000Z","_content":"## webp图片优化\nWebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。\n[webp兼容性](https://caniuse.com/#search=webp)见下图\n<img src=\"/image/webp_caniuse.png\" width=\"800px\">\n其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。\n\n## 检测浏览器是否支持webp格式\n### 方法1: canvas的toDataURL\n```js\nfunction checkWebp() {\n    try{\n        return (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0);\n    }catch(err) {\n        return  false;\n    }\n    //or\n    !![].map && document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;\n}\n```\n对比一下chrome和ie下`document.createElement('canvas').toDataURL('image/webp')`下的输出：\n```js\n//ie\n\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"\n//chrome\n\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\"\n```\n<!-- more -->\n基于`toDataURL`的特性，如果请求的类型不被支持，默认返回`data:image/png`。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则`toDataURL`会返回`\"data:,\"`。)\n所以，只有支持webp格式的浏览器调用`toDataURL('image/webp')`后返回的字符串中才包含`'data:image/webp'`。上面提供了两种写法，其中`!![].map`主要是判断是否是IE9+，以免toDataURL方法会报错。\n\n### 方法2: 图片onload\ngoogle官网提供的，通过加载小的webp图片来判断是否支持该格式：\n```js\n// check_webp_feature:\n//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.\n//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)\nfunction check_webp_feature(feature, callback) {\n    var kTestImages = {\n        lossy: \"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\",\n        lossless: \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\",\n        alpha: \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\",\n        animation: \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"\n    };\n    var img = new Image();\n    img.onload = function () {\n        var result = (img.width > 0) && (img.height > 0);\n        callback(feature, result);\n    };\n    img.onerror = function () {\n        callback(feature, false);\n    };\n    img.src = \"data:image/webp;base64,\" + kTestImages[feature];\n}\n```\n上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。\n调用方法如下，可以在`callback`方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加`webp`相关的class都可以。\n```js\ncheck_webp_feature('lossless',function(feature,result){\n    alert(result); //true or false\n});\n\n```\n\n## 使用webp\n### 处理webp通常有两种方式\n- 服务端处理，支持webp图片的浏览器会在请求头Accept中加上`image/webp`，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了；\n- 前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型\n我们产品使用的是网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考https://www.163yun.com/help/documents/114078550521466880。\n其中，通过在url后拼接`?imageView&type=webp`就可以获得对应的webp图片。\n\n### 在线生成\n- 智图 [zhitu.isux.us](https://zhitu.isux.us/)\n- 又拍云 [www.upyun.com/webp](https://www.upyun.com/webp)\n- CloudConvert [cloudconvert.com/anything-to-webp](https://cloudconvert.com/anything-to-webp)\n- iSparta [isparta.github.io/index.html](https://isparta.github.io/index.html)\n\n## 图片lazyload\n图片lazyload是常见的性能优化的一种方式。如果页面图片数量较多，一次性加载比较耗时，还会导致页面卡顿，所以，建议根据需要去加载部门图片，待页面滚动时再加载下面的图片。\n可以使用一个轻量级的[lazyload库](https://github.com/verlok/lazyload)，具体使用可以参考GitHub。\n通过`npm`安装`vanilla-lazyload`包，推荐的版本有：\n```\nnpm install vanilla-lazyload@8.17.0\nnpm install vanilla-lazyload@10.19.0\n```\n注意：10.x版本使用了`IntersectionObserver API`，IE和safari不支持，所有图片会一次性加载。\n简单粘贴一个示例：\n``` html\n<img class=\"lazy\" alt=\"...\" \n     data-src=\"../img/44721746JJ_15_a.jpg\"\n     width=\"220\" height=\"280\">\n```\n``` js\nimport LazyLoad from \"vanilla-lazyload\";\nvar myLazyLoad = new LazyLoad({\n    elements_selector: \".lazy\"\n});\n```\n在线demo可以访问：https://www.andreaverlicchi.eu/lazyload/demos/container_single.html\nREFS:\nhttps://github.com/verlok/lazyload\nhttps://www.haorooms.com/post/webp_bigpipe\nhttps://www.zhangxinxu.com/php/microCodeDetail?id=3","source":"_posts/菜鸟优化之路-图片webp-lazyload.md","raw":"---\ntitle: 菜鸟优化之路-图片webp&lazyload\ndate: 2018-09-27 20:17:29\ntags: [前端性能优化, webp]\n---\n## webp图片优化\nWebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。\n[webp兼容性](https://caniuse.com/#search=webp)见下图\n<img src=\"/image/webp_caniuse.png\" width=\"800px\">\n其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。\n\n## 检测浏览器是否支持webp格式\n### 方法1: canvas的toDataURL\n```js\nfunction checkWebp() {\n    try{\n        return (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0);\n    }catch(err) {\n        return  false;\n    }\n    //or\n    !![].map && document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;\n}\n```\n对比一下chrome和ie下`document.createElement('canvas').toDataURL('image/webp')`下的输出：\n```js\n//ie\n\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"\n//chrome\n\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\"\n```\n<!-- more -->\n基于`toDataURL`的特性，如果请求的类型不被支持，默认返回`data:image/png`。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则`toDataURL`会返回`\"data:,\"`。)\n所以，只有支持webp格式的浏览器调用`toDataURL('image/webp')`后返回的字符串中才包含`'data:image/webp'`。上面提供了两种写法，其中`!![].map`主要是判断是否是IE9+，以免toDataURL方法会报错。\n\n### 方法2: 图片onload\ngoogle官网提供的，通过加载小的webp图片来判断是否支持该格式：\n```js\n// check_webp_feature:\n//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.\n//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)\nfunction check_webp_feature(feature, callback) {\n    var kTestImages = {\n        lossy: \"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\",\n        lossless: \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\",\n        alpha: \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\",\n        animation: \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"\n    };\n    var img = new Image();\n    img.onload = function () {\n        var result = (img.width > 0) && (img.height > 0);\n        callback(feature, result);\n    };\n    img.onerror = function () {\n        callback(feature, false);\n    };\n    img.src = \"data:image/webp;base64,\" + kTestImages[feature];\n}\n```\n上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。\n调用方法如下，可以在`callback`方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加`webp`相关的class都可以。\n```js\ncheck_webp_feature('lossless',function(feature,result){\n    alert(result); //true or false\n});\n\n```\n\n## 使用webp\n### 处理webp通常有两种方式\n- 服务端处理，支持webp图片的浏览器会在请求头Accept中加上`image/webp`，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了；\n- 前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型\n我们产品使用的是网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考https://www.163yun.com/help/documents/114078550521466880。\n其中，通过在url后拼接`?imageView&type=webp`就可以获得对应的webp图片。\n\n### 在线生成\n- 智图 [zhitu.isux.us](https://zhitu.isux.us/)\n- 又拍云 [www.upyun.com/webp](https://www.upyun.com/webp)\n- CloudConvert [cloudconvert.com/anything-to-webp](https://cloudconvert.com/anything-to-webp)\n- iSparta [isparta.github.io/index.html](https://isparta.github.io/index.html)\n\n## 图片lazyload\n图片lazyload是常见的性能优化的一种方式。如果页面图片数量较多，一次性加载比较耗时，还会导致页面卡顿，所以，建议根据需要去加载部门图片，待页面滚动时再加载下面的图片。\n可以使用一个轻量级的[lazyload库](https://github.com/verlok/lazyload)，具体使用可以参考GitHub。\n通过`npm`安装`vanilla-lazyload`包，推荐的版本有：\n```\nnpm install vanilla-lazyload@8.17.0\nnpm install vanilla-lazyload@10.19.0\n```\n注意：10.x版本使用了`IntersectionObserver API`，IE和safari不支持，所有图片会一次性加载。\n简单粘贴一个示例：\n``` html\n<img class=\"lazy\" alt=\"...\" \n     data-src=\"../img/44721746JJ_15_a.jpg\"\n     width=\"220\" height=\"280\">\n```\n``` js\nimport LazyLoad from \"vanilla-lazyload\";\nvar myLazyLoad = new LazyLoad({\n    elements_selector: \".lazy\"\n});\n```\n在线demo可以访问：https://www.andreaverlicchi.eu/lazyload/demos/container_single.html\nREFS:\nhttps://github.com/verlok/lazyload\nhttps://www.haorooms.com/post/webp_bigpipe\nhttps://www.zhangxinxu.com/php/microCodeDetail?id=3","slug":"菜鸟优化之路-图片webp-lazyload","published":1,"updated":"2019-03-18T02:27:14.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx84002uqmhf0wnxf8zw","content":"<h2 id=\"webp图片优化\"><a href=\"#webp图片优化\" class=\"headerlink\" title=\"webp图片优化\"></a>webp图片优化</h2><p>WebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。<br><a href=\"https://caniuse.com/#search=webp\" target=\"_blank\" rel=\"noopener\">webp兼容性</a>见下图<br><img src=\"/image/webp_caniuse.png\" width=\"800px\"><br>其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。</p>\n<h2 id=\"检测浏览器是否支持webp格式\"><a href=\"#检测浏览器是否支持webp格式\" class=\"headerlink\" title=\"检测浏览器是否支持webp格式\"></a>检测浏览器是否支持webp格式</h2><h3 id=\"方法1-canvas的toDataURL\"><a href=\"#方法1-canvas的toDataURL\" class=\"headerlink\" title=\"方法1: canvas的toDataURL\"></a>方法1: canvas的toDataURL</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkWebp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>).toDataURL(<span class=\"string\">'image/webp'</span>).indexOf(<span class=\"string\">'data:image/webp'</span>) == <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//or</span></span><br><span class=\"line\">    !![].map &amp;&amp; <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>).toDataURL(<span class=\"string\">'image/webp'</span>).indexOf(<span class=\"string\">'data:image/webp'</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比一下chrome和ie下<code>document.createElement(&#39;canvas&#39;).toDataURL(&#39;image/webp&#39;)</code>下的输出：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ie</span></span><br><span class=\"line\"><span class=\"string\">\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"</span></span><br><span class=\"line\"><span class=\"comment\">//chrome</span></span><br><span class=\"line\"><span class=\"string\">\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\"</span></span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>基于<code>toDataURL</code>的特性，如果请求的类型不被支持，默认返回<code>data:image/png</code>。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则<code>toDataURL</code>会返回<code>&quot;data:,&quot;</code>。)<br>所以，只有支持webp格式的浏览器调用<code>toDataURL(&#39;image/webp&#39;)</code>后返回的字符串中才包含<code>&#39;data:image/webp&#39;</code>。上面提供了两种写法，其中<code>!![].map</code>主要是判断是否是IE9+，以免toDataURL方法会报错。</p>\n<h3 id=\"方法2-图片onload\"><a href=\"#方法2-图片onload\" class=\"headerlink\" title=\"方法2: 图片onload\"></a>方法2: 图片onload</h3><p>google官网提供的，通过加载小的webp图片来判断是否支持该格式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// check_webp_feature:</span></span><br><span class=\"line\"><span class=\"comment\">//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.</span></span><br><span class=\"line\"><span class=\"comment\">//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check_webp_feature</span>(<span class=\"params\">feature, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> kTestImages = &#123;</span><br><span class=\"line\">        lossy: <span class=\"string\">\"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\"</span>,</span><br><span class=\"line\">        lossless: <span class=\"string\">\"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\"</span>,</span><br><span class=\"line\">        alpha: <span class=\"string\">\"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\"</span>,</span><br><span class=\"line\">        animation: <span class=\"string\">\"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">    img.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = (img.width &gt; <span class=\"number\">0</span>) &amp;&amp; (img.height &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        callback(feature, result);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.onerror = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback(feature, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.src = <span class=\"string\">\"data:image/webp;base64,\"</span> + kTestImages[feature];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。<br>调用方法如下，可以在<code>callback</code>方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加<code>webp</code>相关的class都可以。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">check_webp_feature(<span class=\"string\">'lossless'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">feature,result</span>)</span>&#123;</span><br><span class=\"line\">    alert(result); <span class=\"comment\">//true or false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用webp\"><a href=\"#使用webp\" class=\"headerlink\" title=\"使用webp\"></a>使用webp</h2><h3 id=\"处理webp通常有两种方式\"><a href=\"#处理webp通常有两种方式\" class=\"headerlink\" title=\"处理webp通常有两种方式\"></a>处理webp通常有两种方式</h3><ul>\n<li>服务端处理，支持webp图片的浏览器会在请求头Accept中加上<code>image/webp</code>，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了；</li>\n<li>前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型<br>我们产品使用的是网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考<a href=\"https://www.163yun.com/help/documents/114078550521466880。\" target=\"_blank\" rel=\"noopener\">https://www.163yun.com/help/documents/114078550521466880。</a><br>其中，通过在url后拼接<code>?imageView&amp;type=webp</code>就可以获得对应的webp图片。</li>\n</ul>\n<h3 id=\"在线生成\"><a href=\"#在线生成\" class=\"headerlink\" title=\"在线生成\"></a>在线生成</h3><ul>\n<li>智图 <a href=\"https://zhitu.isux.us/\" target=\"_blank\" rel=\"noopener\">zhitu.isux.us</a></li>\n<li>又拍云 <a href=\"https://www.upyun.com/webp\" target=\"_blank\" rel=\"noopener\">www.upyun.com/webp</a></li>\n<li>CloudConvert <a href=\"https://cloudconvert.com/anything-to-webp\" target=\"_blank\" rel=\"noopener\">cloudconvert.com/anything-to-webp</a></li>\n<li>iSparta <a href=\"https://isparta.github.io/index.html\" target=\"_blank\" rel=\"noopener\">isparta.github.io/index.html</a></li>\n</ul>\n<h2 id=\"图片lazyload\"><a href=\"#图片lazyload\" class=\"headerlink\" title=\"图片lazyload\"></a>图片lazyload</h2><p>图片lazyload是常见的性能优化的一种方式。如果页面图片数量较多，一次性加载比较耗时，还会导致页面卡顿，所以，建议根据需要去加载部门图片，待页面滚动时再加载下面的图片。<br>可以使用一个轻量级的<a href=\"https://github.com/verlok/lazyload\" target=\"_blank\" rel=\"noopener\">lazyload库</a>，具体使用可以参考GitHub。<br>通过<code>npm</code>安装<code>vanilla-lazyload</code>包，推荐的版本有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vanilla-lazyload@8.17.0</span><br><span class=\"line\">npm install vanilla-lazyload@10.19.0</span><br></pre></td></tr></table></figure></p>\n<p>注意：10.x版本使用了<code>IntersectionObserver API</code>，IE和safari不支持，所有图片会一次性加载。<br>简单粘贴一个示例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lazy\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"...\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">data-src</span>=<span class=\"string\">\"../img/44721746JJ_15_a.jpg\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">width</span>=<span class=\"string\">\"220\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"280\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> LazyLoad <span class=\"keyword\">from</span> <span class=\"string\">\"vanilla-lazyload\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myLazyLoad = <span class=\"keyword\">new</span> LazyLoad(&#123;</span><br><span class=\"line\">    elements_selector: <span class=\"string\">\".lazy\"</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在线demo可以访问：<a href=\"https://www.andreaverlicchi.eu/lazyload/demos/container_single.html\" target=\"_blank\" rel=\"noopener\">https://www.andreaverlicchi.eu/lazyload/demos/container_single.html</a><br>REFS:<br><a href=\"https://github.com/verlok/lazyload\" target=\"_blank\" rel=\"noopener\">https://github.com/verlok/lazyload</a><br><a href=\"https://www.haorooms.com/post/webp_bigpipe\" target=\"_blank\" rel=\"noopener\">https://www.haorooms.com/post/webp_bigpipe</a><br><a href=\"https://www.zhangxinxu.com/php/microCodeDetail?id=3\" target=\"_blank\" rel=\"noopener\">https://www.zhangxinxu.com/php/microCodeDetail?id=3</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"webp图片优化\"><a href=\"#webp图片优化\" class=\"headerlink\" title=\"webp图片优化\"></a>webp图片优化</h2><p>WebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。<br><a href=\"https://caniuse.com/#search=webp\" target=\"_blank\" rel=\"noopener\">webp兼容性</a>见下图<br><img src=\"/image/webp_caniuse.png\" width=\"800px\"><br>其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。</p>\n<h2 id=\"检测浏览器是否支持webp格式\"><a href=\"#检测浏览器是否支持webp格式\" class=\"headerlink\" title=\"检测浏览器是否支持webp格式\"></a>检测浏览器是否支持webp格式</h2><h3 id=\"方法1-canvas的toDataURL\"><a href=\"#方法1-canvas的toDataURL\" class=\"headerlink\" title=\"方法1: canvas的toDataURL\"></a>方法1: canvas的toDataURL</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkWebp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>).toDataURL(<span class=\"string\">'image/webp'</span>).indexOf(<span class=\"string\">'data:image/webp'</span>) == <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//or</span></span><br><span class=\"line\">    !![].map &amp;&amp; <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>).toDataURL(<span class=\"string\">'image/webp'</span>).indexOf(<span class=\"string\">'data:image/webp'</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比一下chrome和ie下<code>document.createElement(&#39;canvas&#39;).toDataURL(&#39;image/webp&#39;)</code>下的输出：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ie</span></span><br><span class=\"line\"><span class=\"string\">\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"</span></span><br><span class=\"line\"><span class=\"comment\">//chrome</span></span><br><span class=\"line\"><span class=\"string\">\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\"</span></span><br></pre></td></tr></table></figure></p>","more":"<p>基于<code>toDataURL</code>的特性，如果请求的类型不被支持，默认返回<code>data:image/png</code>。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则<code>toDataURL</code>会返回<code>&quot;data:,&quot;</code>。)<br>所以，只有支持webp格式的浏览器调用<code>toDataURL(&#39;image/webp&#39;)</code>后返回的字符串中才包含<code>&#39;data:image/webp&#39;</code>。上面提供了两种写法，其中<code>!![].map</code>主要是判断是否是IE9+，以免toDataURL方法会报错。</p>\n<h3 id=\"方法2-图片onload\"><a href=\"#方法2-图片onload\" class=\"headerlink\" title=\"方法2: 图片onload\"></a>方法2: 图片onload</h3><p>google官网提供的，通过加载小的webp图片来判断是否支持该格式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// check_webp_feature:</span></span><br><span class=\"line\"><span class=\"comment\">//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.</span></span><br><span class=\"line\"><span class=\"comment\">//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check_webp_feature</span>(<span class=\"params\">feature, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> kTestImages = &#123;</span><br><span class=\"line\">        lossy: <span class=\"string\">\"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\"</span>,</span><br><span class=\"line\">        lossless: <span class=\"string\">\"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\"</span>,</span><br><span class=\"line\">        alpha: <span class=\"string\">\"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\"</span>,</span><br><span class=\"line\">        animation: <span class=\"string\">\"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">    img.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = (img.width &gt; <span class=\"number\">0</span>) &amp;&amp; (img.height &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        callback(feature, result);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.onerror = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback(feature, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.src = <span class=\"string\">\"data:image/webp;base64,\"</span> + kTestImages[feature];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。<br>调用方法如下，可以在<code>callback</code>方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加<code>webp</code>相关的class都可以。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">check_webp_feature(<span class=\"string\">'lossless'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">feature,result</span>)</span>&#123;</span><br><span class=\"line\">    alert(result); <span class=\"comment\">//true or false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用webp\"><a href=\"#使用webp\" class=\"headerlink\" title=\"使用webp\"></a>使用webp</h2><h3 id=\"处理webp通常有两种方式\"><a href=\"#处理webp通常有两种方式\" class=\"headerlink\" title=\"处理webp通常有两种方式\"></a>处理webp通常有两种方式</h3><ul>\n<li>服务端处理，支持webp图片的浏览器会在请求头Accept中加上<code>image/webp</code>，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了；</li>\n<li>前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型<br>我们产品使用的是网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考<a href=\"https://www.163yun.com/help/documents/114078550521466880。\" target=\"_blank\" rel=\"noopener\">https://www.163yun.com/help/documents/114078550521466880。</a><br>其中，通过在url后拼接<code>?imageView&amp;type=webp</code>就可以获得对应的webp图片。</li>\n</ul>\n<h3 id=\"在线生成\"><a href=\"#在线生成\" class=\"headerlink\" title=\"在线生成\"></a>在线生成</h3><ul>\n<li>智图 <a href=\"https://zhitu.isux.us/\" target=\"_blank\" rel=\"noopener\">zhitu.isux.us</a></li>\n<li>又拍云 <a href=\"https://www.upyun.com/webp\" target=\"_blank\" rel=\"noopener\">www.upyun.com/webp</a></li>\n<li>CloudConvert <a href=\"https://cloudconvert.com/anything-to-webp\" target=\"_blank\" rel=\"noopener\">cloudconvert.com/anything-to-webp</a></li>\n<li>iSparta <a href=\"https://isparta.github.io/index.html\" target=\"_blank\" rel=\"noopener\">isparta.github.io/index.html</a></li>\n</ul>\n<h2 id=\"图片lazyload\"><a href=\"#图片lazyload\" class=\"headerlink\" title=\"图片lazyload\"></a>图片lazyload</h2><p>图片lazyload是常见的性能优化的一种方式。如果页面图片数量较多，一次性加载比较耗时，还会导致页面卡顿，所以，建议根据需要去加载部门图片，待页面滚动时再加载下面的图片。<br>可以使用一个轻量级的<a href=\"https://github.com/verlok/lazyload\" target=\"_blank\" rel=\"noopener\">lazyload库</a>，具体使用可以参考GitHub。<br>通过<code>npm</code>安装<code>vanilla-lazyload</code>包，推荐的版本有：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install vanilla-lazyload@8.17.0</span><br><span class=\"line\">npm install vanilla-lazyload@10.19.0</span><br></pre></td></tr></table></figure></p>\n<p>注意：10.x版本使用了<code>IntersectionObserver API</code>，IE和safari不支持，所有图片会一次性加载。<br>简单粘贴一个示例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">class</span>=<span class=\"string\">\"lazy\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"...\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">data-src</span>=<span class=\"string\">\"../img/44721746JJ_15_a.jpg\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">width</span>=<span class=\"string\">\"220\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"280\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> LazyLoad <span class=\"keyword\">from</span> <span class=\"string\">\"vanilla-lazyload\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myLazyLoad = <span class=\"keyword\">new</span> LazyLoad(&#123;</span><br><span class=\"line\">    elements_selector: <span class=\"string\">\".lazy\"</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在线demo可以访问：<a href=\"https://www.andreaverlicchi.eu/lazyload/demos/container_single.html\" target=\"_blank\" rel=\"noopener\">https://www.andreaverlicchi.eu/lazyload/demos/container_single.html</a><br>REFS:<br><a href=\"https://github.com/verlok/lazyload\" target=\"_blank\" rel=\"noopener\">https://github.com/verlok/lazyload</a><br><a href=\"https://www.haorooms.com/post/webp_bigpipe\" target=\"_blank\" rel=\"noopener\">https://www.haorooms.com/post/webp_bigpipe</a><br><a href=\"https://www.zhangxinxu.com/php/microCodeDetail?id=3\" target=\"_blank\" rel=\"noopener\">https://www.zhangxinxu.com/php/microCodeDetail?id=3</a></p>"},{"title":"前端优化-蹒跚学步","date":"2018-12-24T01:38:54.000Z","_content":"# 项目背景\n项目是基于React开发，webpack打包的多页面h5应用，其中部分页面又是基于React-router的SPA。开发的过程中，也一直在尝试对项目进行优化，这儿主要记录了对`代码分片`、`持久化缓存`和`图片优化`的处理。\n\n优化之路漫漫，蹒跚而来。\n\n* * *\n\n# 动态加载组件\n## Code splitting(代码分片)\n当前端代码越来越复杂，代码体积越来越大时，需要考虑对加载的资源进行细粒度的分割，按需加载。\nwebpack支持两种语法实现动态地加载模块：\n- [require.ensure](https://webpack.js.org/api/module-methods/#require-ensure)\n给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。\n```js\nrequire.ensure(dependencies: String[], callback: function(require), chunkName: String)\n```\n\n- [import](https://webpack.js.org/api/module-methods/#import-)\n调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。\n```js\nimport(\n  /* webpackChunkName: \"my-chunk-name\" */\n  /* webpackMode: \"lazy\" (default)*/\n  'path/to/module') -> Promise\n```\n`webpackChunkName`用来设置chunk的名字；`webpackMode`默认值是`lazy`，还有`lazy-once`、`eager`、`weak`。按需加载的默认加载形式是async。\n<!-- more -->\n\n## react动态加载组件\n在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。\n直接看代码：\n``` js\nimport React, {Component} from 'react'\n\n/**\n * 异步加载模块\n * @param  {[type]} loadComponent [description]\n * @return {[type]}               [description]\n */\nexport const asyncComponent = loadComponent => (\n    class AsyncComponent extends Component {\n        state = {\n            Component: null,\n        }\n\n        componentDidMount() {\n            if (this.hasLoadedComponent()) {\n                return;\n            }\n\n            loadComponent()\n                .then(module => module.default)\n                .then((Component) => {\n                    this.setState({ Component });\n                })\n                .catch((err) => {\n                    console.error(`Cannot load component in <AsyncComponent />`);\n                    throw err;\n                });\n        }\n\n        hasLoadedComponent() {\n            return this.state.Component !== null;\n        }\n\n        render() {\n            const { Component } = this.state;\n            return (Component) ? <Component {...this.props} /> : null;\n        }\n    }\n);\n```\n\n`loadComponent`参数代表import('module')异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。\n如何调用：\n``` js\nexport const AsyncBannerSwiper = asyncComponent(() => import(/* webpackChunkName: \"bannerSwiper\" */ './BannerSwiper.jsx'))\n```\n将`BannerSwiper`组件用`asyncComponent`封装下，就返回了一个异步加载的`AsyncBannerSwiper`组件，使用方法和其他组件完全一致。其中支持`webpackChunkName`去配置chunk的名字，不配置的情况下会默认生成`[id].bundle.js`。\n\n### publicPath动态设置\n项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。\n动态设置异步chunk的publicPath，在入口entry中设置__webpack_public_path__，打包配置文件中配置的publicPath不变。\n``` js\n__webpack_public_path__ = window.cdn || '/dist/';\n\n```\n\n## webpack设置\n在webpack配置文件中，需要配置`chunkFilename`指定chunk的名字。\n``` js\nchunkFilename: '[name].js'\n```\n另外，注意webpack插件的配置：\n``` js\nnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id\nnew webpack.optimize.CommonsChunkPlugin({\n    ...\n    children: false,  // 如果设置为 `true`，所有公共 chunk 的子模块都会被选择\n    ...\n}),\nnew ExtractTextPlugin({filename: 'css/[name].css?[contenthash:8]', allChunks: true}),  //从所有chunk中提取(默认情况下，它仅从initial chunk中提取)\n```\n\n## 分离前后对比\n使用[webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：\n<img src=\"http://kms.fp.ps.netease.com/file/5c1b66436f04944f5b0bac27fkqqY7XJ\" width=\"600px\">\n可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：\n<img src=\"http://kms.fp.ps.netease.com/file/5c1b66b196dee43c91c66dc7p9XqNpke\" width=\"500px\">\n使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：\n<img src=\"http://kms.fp.ps.netease.com/file/5c1b665f7f9d2a9a4e46ed29AADJKiNf\" width=\"600px\">\n可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。线上的资源又是开启了gzip压缩，体积就更小了。\n<img src=\"http://kms.fp.ps.netease.com/file/5c1b66d0a7f2523ddac2a954og4WjVDi\" width=\"500px\">\n\n\n* * *\n\n# 持久化缓存\n为了获取持久化缓存，在配置webpack的output时，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。\n## moduleId VS chunkId\nwebpack打包后会生成`webpackJsonp`等方法，用于加载chunk和module，精简的源码如下所示：\n``` js\n(function(modules) {\n  window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n    var moduleId, result;\n    for (moduleId in moreModules) { //该chunk引用的所有模块\n      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n        // 将chunk中所包含的模块放入modules数组中\n        modules[moduleId] = moreModules[moduleId];\n      }\n    }\n    if (executeModules) { //入口module\n      for (i = 0; i < executeModules.length; i++) {\n        result = __webpack_require__(executeModules[i]);\n      }\n    }\n    return result;\n  };\n  var installedModules = {};\n\n  // 调用__webpack_require__(moduleId)时，\n  // 再将模块放入installedModules，用于保存已经加载过的模块\n  function __webpack_require__(moduleId) {\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    var module = installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {}\n    };\n    // Execute the module function:\n    // 在执行的过程中，会递归调用`__webpack_require__`加载该模块引用的其他模块\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n    // Flag the module as loaded\n    module.l = true;\n    return module.exports;\n  }\n})([]);\n```\n`webpackJsonp`方法接收三个参数`chunkIds, moreModules, executeModules`，其中`chunkIds`属于chunkId，`moreModules, executeModules`都属于moduleId。\n- chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。\n- module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前`__webpack_require__`加载的模块，同样使用数组下标作为moduleId。\n每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。\n\n## 固化过程\n### 初始状态\n以首页为例，打包后生成的index.js中会调用`webpackJsonp`方法，传入三个参数`chunkIds, moreModules, executeModules`。\n``` js\nwebpackJsonp([4],{\n/***/ 10:\n/***/ (function(module, exports, __webpack_require__) {\"use strict\";eval(\"\");\n/***/ }),\n/***/ 11:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\"use strict\";eval(\"/*actual code*/\");\n/***/ })\n//more code\n}, [348]);\n```\n若此时新增一个页面，入口为\"./src/entry/test.jsx\"，打包后，会发现所有的js内容都发生了改变，以其中一个文件为例，发现是引用的moduleId发生了变化：\n<img src=\"https://easyread.nosdn.127.net/web/trunk/1545811193495/xxxx_20181226155854.png\" />\n<img src=\"https://easyread.nosdn.127.net/web/trunk/1545811180510/xxxx_20181226155821.png\" />\n\n### 固化`moduleId`\n为了不影响其他文件，需要想办法将moduleId固定化，可以在webpack中配置`NamedModulesPlugin`，最新打包生成的index.js内部代码如下。和上面的代码比较，可以发现数字moduleId被替换成了文件的路径，这保证了moduleId的不变性。\n``` js\nwebpackJsonp([4],{\n/***/ \"./node_modules/babel-runtime/helpers/defineProperty.js\":\n/***/ (function(module, exports, __webpack_require__) {\"use strict\";eval(\"\");\n/***/ }),\n/***/ \"./node_modules/nw-detect/es/index.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\"use strict\";eval(\"/*actual code*/\");\n/***/ })\n//more code\n}, [\"./src/entry/index.jsx\"]);\n```\n`moduleId`既然不会再变，那我们重新添加test页面，打包后是不是会只新增js呢？开心的是大部分js都没有改动，但发现还有两个js有变化，包括我们提取出的公共js`common.bundle.js`。对比下，发现文件的内容只有`chunkId`发生了变化：\n<img src=\"https://easyread.nosdn.127.net/web/trunk/1545812851431/xxxx_20181226162712.png\"/>\n<img src=\"https://easyread.nosdn.127.net/web/trunk/1545812873655/xxxx_20181226162719.png\"/>\n\n### 固化`chunkId`\n再进一步，显然就是希望可以固化`chunkId`，webpack插件`NamedChunksPlugin`可以满足我们的需求，它使用webpack中唯一的entry名作为chunkId。配置好`NamedChunksPlugin`后，对比添加test页面前后js的变化，发现只有新增的js，已有的js都没有发生变化，注意到之前的`common.bundle.js`和`forbidden.js`发生改变的地方，代码分别如下：\n``` js\n/******/  // objects to store loaded and loading chunks\n/******/  var installedChunks = {\n/******/    \"common\": 0\n/******/  };\n\n```\n``` js\nwebpackJsonp([\"forbidden\"],{\n  //other code\n```\nchunkId都由数字变成了唯一的entry值，`common`对应`CommonsChunkPlugin`配置的name值。\n对于代码分离出的js，使用`webpackChunkName `设置`chunkName`，可以保证该js`chunkId`的稳定性。\n\n### 生产环境下固化`moduleId`\n前文提到的`NamedModulesPlugin`，使用的是模块的相对路径，但因为相对路径偏长，生产环境更建议使用`HashedModuleIdsPlugin`，它会根据文件的路径去生成hash，打包后的文件更小。\n``` js\nwebpackJsonp([\"index\"],\n  {\"+qWx\":function(e,t){e.exports=vendor},\"5AEV\" ...},\n  [\"qwtH\"]);\n```\n最终在生产环境下需要配置下面的代码，就可以实现moduleId和chunkId的固定，使用户端的缓存更加持久。\n```js\nnew webpack.HashedModuleIdsPlugin(), //固化 module id\nnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id\n```\n\n* * *\n\n## 图片优化\n图片的大小直接影响页面加载的速度，基础的优化操作有：对图片进行压缩、转base64减少http请求、使用srcset/sizes获取自适应图片等。这儿主要介绍如何结合webpack进行图片压缩，以及应用webp图片格式。\n\n### webpack loader图片压缩\n对图片进行压缩处理，可以选择的压缩工具有很多种，如压缩png、jpg的[tinypng](https://tinypng.com/)、[智图](https://zhitu.isux.us/)，裁剪压缩gif的[iLoveIMG](https://www.iloveimg.com/zh-cn/compress-image/compress-gif)；也可以安装psd的tinypng插件，以及pngquant、ImageAlpha、ImageOptim、Image Optimizer等其他压缩工具。\n**打包压缩**\n相比之下，配置loader或plugin打包压缩更加便捷，例如，配置好[image-webpack-loader](https://www.npmjs.com/package/image-webpack-loader)，在production模式下开启压缩，就可以在打包的时候自动压缩图片。\n>image-webpack-loader是基于[imagemin](https://github.com/kevva/imagemin)去压缩PNG、JPEG、GIF、SVG和WEBP图片。针对不同的优化项，可以自定义参数以适配项目的需求。\n``` js\n{\n    test: /\\.(png|jpg|gif)$/,\n    use: [{\n        loader: 'url-loader',\n        options: {\n            limit: 8192,\n            name: 'image/[hash:8].[name].[ext]'\n        }\n    }, {\n        loader: 'image-webpack-loader',\n        options: {\n            mozjpeg: {\n                progressive: true,\n                quality: 65\n            },\n            pngquant: {\n                quality: '65-90',\n                speed: 3\n            }\n        }\n    }]\n}\n```\nwebpack也可以支持`tinypng`的打包压缩，如[tinypng-webpack-plugin](https://www.npmjs.com/package/tinypng-webpack-plugin)，使用了`tinypng`提供的[API](https://tinypng.com/developers/reference/nodejs)。但需要注意的是，使用tinypng需要申请key值，每个key值每个月可以免费压缩500张，超出部分就要付费了。\n\n### 响应式图片\n可以通过@media、image-set或者js实现根据屏幕大小获取对应的图片，更方便的方式是使用<img srcset>和<picture>。\n#### srcset相同尺寸不同分辨率\n```html\n<img src=\"pic.png?imageView&thumbnail=202y284\"\n     srcset=\"pic.png?imageView&thumbnail=202y284 2x, pic.png?imageView&thumbnail=303y426 3x\">\n```\n当分辨率为3x时，会使用3x对应的pic.png?imageView&thumbnail=303y426图片。没有匹配到的、或者是不支持srcset属性的浏览器会正常加载src引用的图片。结合NOS提供的图片缩略功能，只需要上传一张图片，就可以实现不同分辨率下返回不同尺寸的图片。\n\n#### sizes不同尺寸\n```html\n<img srcset=\"pic-320w.jpg 320w,\n             pic-480w.jpg 480w,\n             pic-800w.jpg 800w\"\n     sizes=\"(max-width: 320px) 280px,\n            (max-width: 480px) 440px,\n            800px\"\n     src=\"pic-800w.jpg\">\n```\n当屏幕宽度为450px时，满足`sizes`定义的媒体查询`(max-width: 480px) 440px`，这时候图片宽度是440px，将从`srcset`中匹配最接近的宽度。注意不能直接把440px和480w去比较，因为srcset中的w值不是对应的像素值，而是图片真正的宽度。如在iphone8上，分辨率是2x，440px对应的图片宽度是880w，与880w最接近的是800w，所以会去加载图片'pic-800w.jpg'，而如果是在分别率为1x的设备上，则对应440w，与480w最接近，会去加载图片`pic-480w.jpg`。\n\n#### picture\n``` html\n<picture>\n  <source media=\"(max-width: 799px)\" srcset=\"elva-480w-close-portrait.jpg\">\n  <source media=\"(min-width: 800px)\" srcset=\"elva-800w.jpg\">\n  <img src=\"elva-800w.jpg\" alt=\"Chris standing up holding his daughter Elva\">\n</picture>\n```\n会按顺序加载满足条件的第一个图片，保底需要定义一个img作为默认值，已经兼容不支持<picture>标签的浏览器。source同样支持srcset和sizes属性配置多个，此外还支持type去标识不同的图片类型。\n``` html\n<picture>\n  <source type=\"image/webp\" srcset=\"snow.webp\">\n  <img src=\"snow.png\" alt=\"Hut in the snow\">\n</picture>\n```\n如果支持webp格式的，会去加载snow.webp，否则会去加载默认的snow.png。\n\n#### HTTP Client Hints\n通过`http client hints`，浏览器发起请求的时候，可以将DPR、Width、Viewport-Width等属性发送到Server端。Chrome46开始支持[Accept-CH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#The_Accept-CH_header)的配置：\n```html\n<meta http-equiv=\"Accept-CH\" content=\"DPR, Width, Viewport-Width\">\n```\n配置完成后，页面发送的请求头部都被包含下面信息：\n```\nAccept: image/webp,image/apng,image/*,*/*;q=0.8\nDPR: 3\nViewport-Width: 460\nWidth: 230\n```\n其中Width属性不是每次都被带上，它是根据Image的sizes属性计算出来的，默认还会带上Accept属性，如果支持webp格式的图片，会包含'image/webp'。Server端可以根据\n这些属性的值返回期望的图片：宽度为690px的webp图片。响应头会包含Content-Type、Content-DPR、Vary属性，浏览器会基于Content-DPR的值去计算图片最终展示的宽度，保证宽度仍为230px。demo如下所示。\n<img src=\"http://kms.fp.ps.netease.com/file/5c221d45a7f2522c896cb338a052AIYJ\" width=\"600px\">\n\n更详细的介绍，参见[automating-resource-selection-with-client-hints](https://developers.google.com/web/updates/2015/09/automating-resource-selection-with-client-hints)\n\n### webp图片\nWebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。\n[webp兼容性](https://caniuse.com/#search=webp)见下图\n<img src=\"http://kms.fp.ps.netease.com/file/5c1b671d5e60271dd96424efFDXtIaaQ\" width=\"800px\">\n其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。\n\n#### 检测浏览器是否支持webp格式\n##### 方法1: canvas的toDataURL\n```js\nfunction checkWebp() {\n    try{\n        return (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0);\n    }catch(err) {\n        return  false;\n    }\n    //or\n    !![].map && document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;\n}\n```\n对比一下chrome和ie下`document.createElement('canvas').toDataURL('image/webp')`下的输出：\n```js\n//ie\n\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"\n//chrome\n\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\"\n```\n基于`toDataURL`的特性，如果请求的类型不被支持，默认返回`data:image/png`。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则`toDataURL`会返回`\"data:,\"`。)\n所以，只有支持webp格式的浏览器调用`toDataURL('image/webp')`后返回的字符串中才包含`'data:image/webp'`。上面提供了两种写法，其中`!![].map`主要是判断是否是IE9+，以免toDataURL方法会报错。\n\n##### 方法2: 图片onload\ngoogle官网提供的，通过加载小的webp图片来判断是否支持该格式：\n```js\n// check_webp_feature:\n//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.\n//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)\nfunction check_webp_feature(feature, callback) {\n    var kTestImages = {\n        lossy: \"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\",\n        lossless: \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\",\n        alpha: \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\",\n        animation: \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"\n    };\n    var img = new Image();\n    img.onload = function () {\n        var result = (img.width > 0) && (img.height > 0);\n        callback(feature, result);\n    };\n    img.onerror = function () {\n        callback(feature, false);\n    };\n    img.src = \"data:image/webp;base64,\" + kTestImages[feature];\n}\n```\n上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。\n调用方法如下，可以在`callback`方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加`webp`相关的class都可以。\n```js\ncheck_webp_feature('lossless',function(feature,result){\n    alert(result); //true or false\n});\n\n```\n\n#### 使用webp\n处理webp通常有两种方式：\n- 服务端处理，支持webp图片的浏览器会在请求头Accept中加上`image/webp`，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了；\n- 前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型\n开心的是，基于网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考https://www.163yun.com/help/documents/114078550521466880。\n其中，通过在url后拼接`?imageView&type=webp`就可以获得对应的webp图片。\n\n\n### REFS\n[响应式图片](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images)\n[React（17）异步组件](https://blog.csdn.net/qq20004604/article/details/79318253)\n[基于 webpack 的持久化缓存方案 ](https://github.com/pigcan/blog/issues/9)\nhttps://www.imooc.com/article/21538\n[听说你用webpack处理文件名的hash？](https://www.imooc.com/article/21538)\n[简单易懂的 webpack 打包后 JS 的运行过程](https://juejin.im/post/5a23b130f265da432003101a)\n\n","source":"_posts/优化之路.md","raw":"---\ntitle: 前端优化-蹒跚学步\ndate: 2018-12-24 09:38:54\ntags:\n---\n# 项目背景\n项目是基于React开发，webpack打包的多页面h5应用，其中部分页面又是基于React-router的SPA。开发的过程中，也一直在尝试对项目进行优化，这儿主要记录了对`代码分片`、`持久化缓存`和`图片优化`的处理。\n\n优化之路漫漫，蹒跚而来。\n\n* * *\n\n# 动态加载组件\n## Code splitting(代码分片)\n当前端代码越来越复杂，代码体积越来越大时，需要考虑对加载的资源进行细粒度的分割，按需加载。\nwebpack支持两种语法实现动态地加载模块：\n- [require.ensure](https://webpack.js.org/api/module-methods/#require-ensure)\n给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。\n```js\nrequire.ensure(dependencies: String[], callback: function(require), chunkName: String)\n```\n\n- [import](https://webpack.js.org/api/module-methods/#import-)\n调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。\n```js\nimport(\n  /* webpackChunkName: \"my-chunk-name\" */\n  /* webpackMode: \"lazy\" (default)*/\n  'path/to/module') -> Promise\n```\n`webpackChunkName`用来设置chunk的名字；`webpackMode`默认值是`lazy`，还有`lazy-once`、`eager`、`weak`。按需加载的默认加载形式是async。\n<!-- more -->\n\n## react动态加载组件\n在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。\n直接看代码：\n``` js\nimport React, {Component} from 'react'\n\n/**\n * 异步加载模块\n * @param  {[type]} loadComponent [description]\n * @return {[type]}               [description]\n */\nexport const asyncComponent = loadComponent => (\n    class AsyncComponent extends Component {\n        state = {\n            Component: null,\n        }\n\n        componentDidMount() {\n            if (this.hasLoadedComponent()) {\n                return;\n            }\n\n            loadComponent()\n                .then(module => module.default)\n                .then((Component) => {\n                    this.setState({ Component });\n                })\n                .catch((err) => {\n                    console.error(`Cannot load component in <AsyncComponent />`);\n                    throw err;\n                });\n        }\n\n        hasLoadedComponent() {\n            return this.state.Component !== null;\n        }\n\n        render() {\n            const { Component } = this.state;\n            return (Component) ? <Component {...this.props} /> : null;\n        }\n    }\n);\n```\n\n`loadComponent`参数代表import('module')异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。\n如何调用：\n``` js\nexport const AsyncBannerSwiper = asyncComponent(() => import(/* webpackChunkName: \"bannerSwiper\" */ './BannerSwiper.jsx'))\n```\n将`BannerSwiper`组件用`asyncComponent`封装下，就返回了一个异步加载的`AsyncBannerSwiper`组件，使用方法和其他组件完全一致。其中支持`webpackChunkName`去配置chunk的名字，不配置的情况下会默认生成`[id].bundle.js`。\n\n### publicPath动态设置\n项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。\n动态设置异步chunk的publicPath，在入口entry中设置__webpack_public_path__，打包配置文件中配置的publicPath不变。\n``` js\n__webpack_public_path__ = window.cdn || '/dist/';\n\n```\n\n## webpack设置\n在webpack配置文件中，需要配置`chunkFilename`指定chunk的名字。\n``` js\nchunkFilename: '[name].js'\n```\n另外，注意webpack插件的配置：\n``` js\nnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id\nnew webpack.optimize.CommonsChunkPlugin({\n    ...\n    children: false,  // 如果设置为 `true`，所有公共 chunk 的子模块都会被选择\n    ...\n}),\nnew ExtractTextPlugin({filename: 'css/[name].css?[contenthash:8]', allChunks: true}),  //从所有chunk中提取(默认情况下，它仅从initial chunk中提取)\n```\n\n## 分离前后对比\n使用[webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：\n<img src=\"http://kms.fp.ps.netease.com/file/5c1b66436f04944f5b0bac27fkqqY7XJ\" width=\"600px\">\n可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：\n<img src=\"http://kms.fp.ps.netease.com/file/5c1b66b196dee43c91c66dc7p9XqNpke\" width=\"500px\">\n使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：\n<img src=\"http://kms.fp.ps.netease.com/file/5c1b665f7f9d2a9a4e46ed29AADJKiNf\" width=\"600px\">\n可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。线上的资源又是开启了gzip压缩，体积就更小了。\n<img src=\"http://kms.fp.ps.netease.com/file/5c1b66d0a7f2523ddac2a954og4WjVDi\" width=\"500px\">\n\n\n* * *\n\n# 持久化缓存\n为了获取持久化缓存，在配置webpack的output时，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。\n## moduleId VS chunkId\nwebpack打包后会生成`webpackJsonp`等方法，用于加载chunk和module，精简的源码如下所示：\n``` js\n(function(modules) {\n  window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n    var moduleId, result;\n    for (moduleId in moreModules) { //该chunk引用的所有模块\n      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n        // 将chunk中所包含的模块放入modules数组中\n        modules[moduleId] = moreModules[moduleId];\n      }\n    }\n    if (executeModules) { //入口module\n      for (i = 0; i < executeModules.length; i++) {\n        result = __webpack_require__(executeModules[i]);\n      }\n    }\n    return result;\n  };\n  var installedModules = {};\n\n  // 调用__webpack_require__(moduleId)时，\n  // 再将模块放入installedModules，用于保存已经加载过的模块\n  function __webpack_require__(moduleId) {\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    var module = installedModules[moduleId] = {\n      i: moduleId,\n      l: false,\n      exports: {}\n    };\n    // Execute the module function:\n    // 在执行的过程中，会递归调用`__webpack_require__`加载该模块引用的其他模块\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n    // Flag the module as loaded\n    module.l = true;\n    return module.exports;\n  }\n})([]);\n```\n`webpackJsonp`方法接收三个参数`chunkIds, moreModules, executeModules`，其中`chunkIds`属于chunkId，`moreModules, executeModules`都属于moduleId。\n- chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。\n- module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前`__webpack_require__`加载的模块，同样使用数组下标作为moduleId。\n每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。\n\n## 固化过程\n### 初始状态\n以首页为例，打包后生成的index.js中会调用`webpackJsonp`方法，传入三个参数`chunkIds, moreModules, executeModules`。\n``` js\nwebpackJsonp([4],{\n/***/ 10:\n/***/ (function(module, exports, __webpack_require__) {\"use strict\";eval(\"\");\n/***/ }),\n/***/ 11:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\"use strict\";eval(\"/*actual code*/\");\n/***/ })\n//more code\n}, [348]);\n```\n若此时新增一个页面，入口为\"./src/entry/test.jsx\"，打包后，会发现所有的js内容都发生了改变，以其中一个文件为例，发现是引用的moduleId发生了变化：\n<img src=\"https://easyread.nosdn.127.net/web/trunk/1545811193495/xxxx_20181226155854.png\" />\n<img src=\"https://easyread.nosdn.127.net/web/trunk/1545811180510/xxxx_20181226155821.png\" />\n\n### 固化`moduleId`\n为了不影响其他文件，需要想办法将moduleId固定化，可以在webpack中配置`NamedModulesPlugin`，最新打包生成的index.js内部代码如下。和上面的代码比较，可以发现数字moduleId被替换成了文件的路径，这保证了moduleId的不变性。\n``` js\nwebpackJsonp([4],{\n/***/ \"./node_modules/babel-runtime/helpers/defineProperty.js\":\n/***/ (function(module, exports, __webpack_require__) {\"use strict\";eval(\"\");\n/***/ }),\n/***/ \"./node_modules/nw-detect/es/index.js\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\"use strict\";eval(\"/*actual code*/\");\n/***/ })\n//more code\n}, [\"./src/entry/index.jsx\"]);\n```\n`moduleId`既然不会再变，那我们重新添加test页面，打包后是不是会只新增js呢？开心的是大部分js都没有改动，但发现还有两个js有变化，包括我们提取出的公共js`common.bundle.js`。对比下，发现文件的内容只有`chunkId`发生了变化：\n<img src=\"https://easyread.nosdn.127.net/web/trunk/1545812851431/xxxx_20181226162712.png\"/>\n<img src=\"https://easyread.nosdn.127.net/web/trunk/1545812873655/xxxx_20181226162719.png\"/>\n\n### 固化`chunkId`\n再进一步，显然就是希望可以固化`chunkId`，webpack插件`NamedChunksPlugin`可以满足我们的需求，它使用webpack中唯一的entry名作为chunkId。配置好`NamedChunksPlugin`后，对比添加test页面前后js的变化，发现只有新增的js，已有的js都没有发生变化，注意到之前的`common.bundle.js`和`forbidden.js`发生改变的地方，代码分别如下：\n``` js\n/******/  // objects to store loaded and loading chunks\n/******/  var installedChunks = {\n/******/    \"common\": 0\n/******/  };\n\n```\n``` js\nwebpackJsonp([\"forbidden\"],{\n  //other code\n```\nchunkId都由数字变成了唯一的entry值，`common`对应`CommonsChunkPlugin`配置的name值。\n对于代码分离出的js，使用`webpackChunkName `设置`chunkName`，可以保证该js`chunkId`的稳定性。\n\n### 生产环境下固化`moduleId`\n前文提到的`NamedModulesPlugin`，使用的是模块的相对路径，但因为相对路径偏长，生产环境更建议使用`HashedModuleIdsPlugin`，它会根据文件的路径去生成hash，打包后的文件更小。\n``` js\nwebpackJsonp([\"index\"],\n  {\"+qWx\":function(e,t){e.exports=vendor},\"5AEV\" ...},\n  [\"qwtH\"]);\n```\n最终在生产环境下需要配置下面的代码，就可以实现moduleId和chunkId的固定，使用户端的缓存更加持久。\n```js\nnew webpack.HashedModuleIdsPlugin(), //固化 module id\nnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id\n```\n\n* * *\n\n## 图片优化\n图片的大小直接影响页面加载的速度，基础的优化操作有：对图片进行压缩、转base64减少http请求、使用srcset/sizes获取自适应图片等。这儿主要介绍如何结合webpack进行图片压缩，以及应用webp图片格式。\n\n### webpack loader图片压缩\n对图片进行压缩处理，可以选择的压缩工具有很多种，如压缩png、jpg的[tinypng](https://tinypng.com/)、[智图](https://zhitu.isux.us/)，裁剪压缩gif的[iLoveIMG](https://www.iloveimg.com/zh-cn/compress-image/compress-gif)；也可以安装psd的tinypng插件，以及pngquant、ImageAlpha、ImageOptim、Image Optimizer等其他压缩工具。\n**打包压缩**\n相比之下，配置loader或plugin打包压缩更加便捷，例如，配置好[image-webpack-loader](https://www.npmjs.com/package/image-webpack-loader)，在production模式下开启压缩，就可以在打包的时候自动压缩图片。\n>image-webpack-loader是基于[imagemin](https://github.com/kevva/imagemin)去压缩PNG、JPEG、GIF、SVG和WEBP图片。针对不同的优化项，可以自定义参数以适配项目的需求。\n``` js\n{\n    test: /\\.(png|jpg|gif)$/,\n    use: [{\n        loader: 'url-loader',\n        options: {\n            limit: 8192,\n            name: 'image/[hash:8].[name].[ext]'\n        }\n    }, {\n        loader: 'image-webpack-loader',\n        options: {\n            mozjpeg: {\n                progressive: true,\n                quality: 65\n            },\n            pngquant: {\n                quality: '65-90',\n                speed: 3\n            }\n        }\n    }]\n}\n```\nwebpack也可以支持`tinypng`的打包压缩，如[tinypng-webpack-plugin](https://www.npmjs.com/package/tinypng-webpack-plugin)，使用了`tinypng`提供的[API](https://tinypng.com/developers/reference/nodejs)。但需要注意的是，使用tinypng需要申请key值，每个key值每个月可以免费压缩500张，超出部分就要付费了。\n\n### 响应式图片\n可以通过@media、image-set或者js实现根据屏幕大小获取对应的图片，更方便的方式是使用<img srcset>和<picture>。\n#### srcset相同尺寸不同分辨率\n```html\n<img src=\"pic.png?imageView&thumbnail=202y284\"\n     srcset=\"pic.png?imageView&thumbnail=202y284 2x, pic.png?imageView&thumbnail=303y426 3x\">\n```\n当分辨率为3x时，会使用3x对应的pic.png?imageView&thumbnail=303y426图片。没有匹配到的、或者是不支持srcset属性的浏览器会正常加载src引用的图片。结合NOS提供的图片缩略功能，只需要上传一张图片，就可以实现不同分辨率下返回不同尺寸的图片。\n\n#### sizes不同尺寸\n```html\n<img srcset=\"pic-320w.jpg 320w,\n             pic-480w.jpg 480w,\n             pic-800w.jpg 800w\"\n     sizes=\"(max-width: 320px) 280px,\n            (max-width: 480px) 440px,\n            800px\"\n     src=\"pic-800w.jpg\">\n```\n当屏幕宽度为450px时，满足`sizes`定义的媒体查询`(max-width: 480px) 440px`，这时候图片宽度是440px，将从`srcset`中匹配最接近的宽度。注意不能直接把440px和480w去比较，因为srcset中的w值不是对应的像素值，而是图片真正的宽度。如在iphone8上，分辨率是2x，440px对应的图片宽度是880w，与880w最接近的是800w，所以会去加载图片'pic-800w.jpg'，而如果是在分别率为1x的设备上，则对应440w，与480w最接近，会去加载图片`pic-480w.jpg`。\n\n#### picture\n``` html\n<picture>\n  <source media=\"(max-width: 799px)\" srcset=\"elva-480w-close-portrait.jpg\">\n  <source media=\"(min-width: 800px)\" srcset=\"elva-800w.jpg\">\n  <img src=\"elva-800w.jpg\" alt=\"Chris standing up holding his daughter Elva\">\n</picture>\n```\n会按顺序加载满足条件的第一个图片，保底需要定义一个img作为默认值，已经兼容不支持<picture>标签的浏览器。source同样支持srcset和sizes属性配置多个，此外还支持type去标识不同的图片类型。\n``` html\n<picture>\n  <source type=\"image/webp\" srcset=\"snow.webp\">\n  <img src=\"snow.png\" alt=\"Hut in the snow\">\n</picture>\n```\n如果支持webp格式的，会去加载snow.webp，否则会去加载默认的snow.png。\n\n#### HTTP Client Hints\n通过`http client hints`，浏览器发起请求的时候，可以将DPR、Width、Viewport-Width等属性发送到Server端。Chrome46开始支持[Accept-CH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#The_Accept-CH_header)的配置：\n```html\n<meta http-equiv=\"Accept-CH\" content=\"DPR, Width, Viewport-Width\">\n```\n配置完成后，页面发送的请求头部都被包含下面信息：\n```\nAccept: image/webp,image/apng,image/*,*/*;q=0.8\nDPR: 3\nViewport-Width: 460\nWidth: 230\n```\n其中Width属性不是每次都被带上，它是根据Image的sizes属性计算出来的，默认还会带上Accept属性，如果支持webp格式的图片，会包含'image/webp'。Server端可以根据\n这些属性的值返回期望的图片：宽度为690px的webp图片。响应头会包含Content-Type、Content-DPR、Vary属性，浏览器会基于Content-DPR的值去计算图片最终展示的宽度，保证宽度仍为230px。demo如下所示。\n<img src=\"http://kms.fp.ps.netease.com/file/5c221d45a7f2522c896cb338a052AIYJ\" width=\"600px\">\n\n更详细的介绍，参见[automating-resource-selection-with-client-hints](https://developers.google.com/web/updates/2015/09/automating-resource-selection-with-client-hints)\n\n### webp图片\nWebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。\n[webp兼容性](https://caniuse.com/#search=webp)见下图\n<img src=\"http://kms.fp.ps.netease.com/file/5c1b671d5e60271dd96424efFDXtIaaQ\" width=\"800px\">\n其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。\n\n#### 检测浏览器是否支持webp格式\n##### 方法1: canvas的toDataURL\n```js\nfunction checkWebp() {\n    try{\n        return (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0);\n    }catch(err) {\n        return  false;\n    }\n    //or\n    !![].map && document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;\n}\n```\n对比一下chrome和ie下`document.createElement('canvas').toDataURL('image/webp')`下的输出：\n```js\n//ie\n\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"\n//chrome\n\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\"\n```\n基于`toDataURL`的特性，如果请求的类型不被支持，默认返回`data:image/png`。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则`toDataURL`会返回`\"data:,\"`。)\n所以，只有支持webp格式的浏览器调用`toDataURL('image/webp')`后返回的字符串中才包含`'data:image/webp'`。上面提供了两种写法，其中`!![].map`主要是判断是否是IE9+，以免toDataURL方法会报错。\n\n##### 方法2: 图片onload\ngoogle官网提供的，通过加载小的webp图片来判断是否支持该格式：\n```js\n// check_webp_feature:\n//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.\n//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)\nfunction check_webp_feature(feature, callback) {\n    var kTestImages = {\n        lossy: \"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\",\n        lossless: \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\",\n        alpha: \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\",\n        animation: \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"\n    };\n    var img = new Image();\n    img.onload = function () {\n        var result = (img.width > 0) && (img.height > 0);\n        callback(feature, result);\n    };\n    img.onerror = function () {\n        callback(feature, false);\n    };\n    img.src = \"data:image/webp;base64,\" + kTestImages[feature];\n}\n```\n上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。\n调用方法如下，可以在`callback`方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加`webp`相关的class都可以。\n```js\ncheck_webp_feature('lossless',function(feature,result){\n    alert(result); //true or false\n});\n\n```\n\n#### 使用webp\n处理webp通常有两种方式：\n- 服务端处理，支持webp图片的浏览器会在请求头Accept中加上`image/webp`，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了；\n- 前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型\n开心的是，基于网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考https://www.163yun.com/help/documents/114078550521466880。\n其中，通过在url后拼接`?imageView&type=webp`就可以获得对应的webp图片。\n\n\n### REFS\n[响应式图片](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images)\n[React（17）异步组件](https://blog.csdn.net/qq20004604/article/details/79318253)\n[基于 webpack 的持久化缓存方案 ](https://github.com/pigcan/blog/issues/9)\nhttps://www.imooc.com/article/21538\n[听说你用webpack处理文件名的hash？](https://www.imooc.com/article/21538)\n[简单易懂的 webpack 打包后 JS 的运行过程](https://juejin.im/post/5a23b130f265da432003101a)\n\n","slug":"优化之路","published":1,"updated":"2019-03-18T02:27:14.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx8d003aqmhfbk7vb0i4","content":"<h1 id=\"项目背景\"><a href=\"#项目背景\" class=\"headerlink\" title=\"项目背景\"></a>项目背景</h1><p>项目是基于React开发，webpack打包的多页面h5应用，其中部分页面又是基于React-router的SPA。开发的过程中，也一直在尝试对项目进行优化，这儿主要记录了对<code>代码分片</code>、<code>持久化缓存</code>和<code>图片优化</code>的处理。</p>\n<p>优化之路漫漫，蹒跚而来。</p>\n<hr>\n<h1 id=\"动态加载组件\"><a href=\"#动态加载组件\" class=\"headerlink\" title=\"动态加载组件\"></a>动态加载组件</h1><h2 id=\"Code-splitting-代码分片\"><a href=\"#Code-splitting-代码分片\" class=\"headerlink\" title=\"Code splitting(代码分片)\"></a>Code splitting(代码分片)</h2><p>当前端代码越来越复杂，代码体积越来越大时，需要考虑对加载的资源进行细粒度的分割，按需加载。<br>webpack支持两种语法实现动态地加载模块：</p>\n<ul>\n<li><p><a href=\"https://webpack.js.org/api/module-methods/#require-ensure\" target=\"_blank\" rel=\"noopener\">require.ensure</a><br>给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.ensure(dependencies: <span class=\"built_in\">String</span>[], <span class=\"attr\">callback</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>), <span class=\"title\">chunkName</span>: <span class=\"title\">String</span>)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://webpack.js.org/api/module-methods/#import-\" target=\"_blank\" rel=\"noopener\">import</a><br>调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">  <span class=\"comment\">/* webpackChunkName: \"my-chunk-name\" */</span></span><br><span class=\"line\">  <span class=\"comment\">/* webpackMode: \"lazy\" (default)*/</span></span><br><span class=\"line\">  <span class=\"string\">'path/to/module'</span>) -&gt; <span class=\"built_in\">Promise</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>webpackChunkName</code>用来设置chunk的名字；<code>webpackMode</code>默认值是<code>lazy</code>，还有<code>lazy-once</code>、<code>eager</code>、<code>weak</code>。按需加载的默认加载形式是async。<br><a id=\"more\"></a></p>\n<h2 id=\"react动态加载组件\"><a href=\"#react动态加载组件\" class=\"headerlink\" title=\"react动态加载组件\"></a>react动态加载组件</h2><p>在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。<br>直接看代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 异步加载模块</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;[type]&#125; loadComponent [description]</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;[type]&#125;               [description]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> asyncComponent = <span class=\"function\"><span class=\"params\">loadComponent</span> =&gt;</span> (</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        state = &#123;</span><br><span class=\"line\">            Component: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentDidMount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasLoadedComponent()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            loadComponent()</span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> <span class=\"built_in\">module</span>.default)</span><br><span class=\"line\">                .then(<span class=\"function\">(<span class=\"params\">Component</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.setState(&#123; Component &#125;);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.error(<span class=\"string\">`Cannot load component in &lt;AsyncComponent /&gt;`</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        hasLoadedComponent() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.state.Component !== <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; Component &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Component) ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Component</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span> : null;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">);</span></span><br></pre></td></tr></table></figure></p>\n<p><code>loadComponent</code>参数代表import(‘module’)异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。<br>如何调用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> AsyncBannerSwiper = asyncComponent(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"bannerSwiper\" */</span> <span class=\"string\">'./BannerSwiper.jsx'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>将<code>BannerSwiper</code>组件用<code>asyncComponent</code>封装下，就返回了一个异步加载的<code>AsyncBannerSwiper</code>组件，使用方法和其他组件完全一致。其中支持<code>webpackChunkName</code>去配置chunk的名字，不配置的情况下会默认生成<code>[id].bundle.js</code>。</p>\n<h3 id=\"publicPath动态设置\"><a href=\"#publicPath动态设置\" class=\"headerlink\" title=\"publicPath动态设置\"></a>publicPath动态设置</h3><p>项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。<br>动态设置异步chunk的publicPath，在入口entry中设置<strong>webpack_public_path</strong>，打包配置文件中配置的publicPath不变。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__webpack_public_path__ = <span class=\"built_in\">window</span>.cdn || <span class=\"string\">'/dist/'</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"webpack设置\"><a href=\"#webpack设置\" class=\"headerlink\" title=\"webpack设置\"></a>webpack设置</h2><p>在webpack配置文件中，需要配置<code>chunkFilename</code>指定chunk的名字。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chunkFilename: <span class=\"string\">'[name].js'</span></span><br></pre></td></tr></table></figure></p>\n<p>另外，注意webpack插件的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.NamedChunksPlugin(), <span class=\"comment\">//固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    children: <span class=\"literal\">false</span>,  <span class=\"comment\">// 如果设置为 `true`，所有公共 chunk 的子模块都会被选择</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\"><span class=\"keyword\">new</span> ExtractTextPlugin(&#123;<span class=\"attr\">filename</span>: <span class=\"string\">'css/[name].css?[contenthash:8]'</span>, <span class=\"attr\">allChunks</span>: <span class=\"literal\">true</span>&#125;),  <span class=\"comment\">//从所有chunk中提取(默认情况下，它仅从initial chunk中提取)</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"分离前后对比\"><a href=\"#分离前后对比\" class=\"headerlink\" title=\"分离前后对比\"></a>分离前后对比</h2><p>使用<a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a>分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：<br><img src=\"http://kms.fp.ps.netease.com/file/5c1b66436f04944f5b0bac27fkqqY7XJ\" width=\"600px\"><br>可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：<br><img src=\"http://kms.fp.ps.netease.com/file/5c1b66b196dee43c91c66dc7p9XqNpke\" width=\"500px\"><br>使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：<br><img src=\"http://kms.fp.ps.netease.com/file/5c1b665f7f9d2a9a4e46ed29AADJKiNf\" width=\"600px\"><br>可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。线上的资源又是开启了gzip压缩，体积就更小了。<br><img src=\"http://kms.fp.ps.netease.com/file/5c1b66d0a7f2523ddac2a954og4WjVDi\" width=\"500px\"></p>\n<hr>\n<h1 id=\"持久化缓存\"><a href=\"#持久化缓存\" class=\"headerlink\" title=\"持久化缓存\"></a>持久化缓存</h1><p>为了获取持久化缓存，在配置webpack的output时，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。</p>\n<h2 id=\"moduleId-VS-chunkId\"><a href=\"#moduleId-VS-chunkId\" class=\"headerlink\" title=\"moduleId VS chunkId\"></a>moduleId VS chunkId</h2><p>webpack打包后会生成<code>webpackJsonp</code>等方法，用于加载chunk和module，精简的源码如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>[<span class=\"string\">\"webpackJsonp\"</span>] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">webpackJsonpCallback</span>(<span class=\"params\">chunkIds, moreModules, executeModules</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> moduleId, result;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (moduleId <span class=\"keyword\">in</span> moreModules) &#123; <span class=\"comment\">//该chunk引用的所有模块</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将chunk中所包含的模块放入modules数组中</span></span><br><span class=\"line\">        modules[moduleId] = moreModules[moduleId];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executeModules) &#123; <span class=\"comment\">//入口module</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; executeModules.length; i++) &#123;</span><br><span class=\"line\">        result = __webpack_require__(executeModules[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 调用__webpack_require__(moduleId)时，</span></span><br><span class=\"line\">  <span class=\"comment\">// 再将模块放入installedModules，用于保存已经加载过的模块</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (installedModules[moduleId]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> installedModules[moduleId].exports;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Create a new module (and put it into the cache)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = installedModules[moduleId] = &#123;</span><br><span class=\"line\">      i: moduleId,</span><br><span class=\"line\">      l: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      exports: &#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Execute the module function:</span></span><br><span class=\"line\">    <span class=\"comment\">// 在执行的过程中，会递归调用`__webpack_require__`加载该模块引用的其他模块</span></span><br><span class=\"line\">    modules[moduleId].call(<span class=\"built_in\">module</span>.exports, <span class=\"built_in\">module</span>, <span class=\"built_in\">module</span>.exports, __webpack_require__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Flag the module as loaded</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.l = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)([]);</span><br></pre></td></tr></table></figure></p>\n<p><code>webpackJsonp</code>方法接收三个参数<code>chunkIds, moreModules, executeModules</code>，其中<code>chunkIds</code>属于chunkId，<code>moreModules, executeModules</code>都属于moduleId。</p>\n<ul>\n<li>chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。</li>\n<li>module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前<code>__webpack_require__</code>加载的模块，同样使用数组下标作为moduleId。<br>每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。</li>\n</ul>\n<h2 id=\"固化过程\"><a href=\"#固化过程\" class=\"headerlink\" title=\"固化过程\"></a>固化过程</h2><h3 id=\"初始状态\"><a href=\"#初始状态\" class=\"headerlink\" title=\"初始状态\"></a>初始状态</h3><p>以首页为例，打包后生成的index.js中会调用<code>webpackJsonp</code>方法，传入三个参数<code>chunkIds, moreModules, executeModules</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackJsonp([<span class=\"number\">4</span>],&#123;</span><br><span class=\"line\"><span class=\"comment\">/***/</span> <span class=\"number\">10</span>:</span><br><span class=\"line\"><span class=\"comment\">/***/</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports, __webpack_require__</span>) </span>&#123;<span class=\"string\">\"use strict\"</span>;<span class=\"built_in\">eval</span>(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/***/</span> &#125;),</span><br><span class=\"line\"><span class=\"comment\">/***/</span> <span class=\"number\">11</span>:</span><br><span class=\"line\"><span class=\"comment\">/***/</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;<span class=\"string\">\"use strict\"</span>;<span class=\"built_in\">eval</span>(<span class=\"string\">\"/*actual code*/\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/***/</span> &#125;)</span><br><span class=\"line\"><span class=\"comment\">//more code</span></span><br><span class=\"line\">&#125;, [<span class=\"number\">348</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>若此时新增一个页面，入口为”./src/entry/test.jsx”，打包后，会发现所有的js内容都发生了改变，以其中一个文件为例，发现是引用的moduleId发生了变化：<br><img src=\"https://easyread.nosdn.127.net/web/trunk/1545811193495/xxxx_20181226155854.png\"><br><img src=\"https://easyread.nosdn.127.net/web/trunk/1545811180510/xxxx_20181226155821.png\"></p>\n<h3 id=\"固化moduleId\"><a href=\"#固化moduleId\" class=\"headerlink\" title=\"固化moduleId\"></a>固化<code>moduleId</code></h3><p>为了不影响其他文件，需要想办法将moduleId固定化，可以在webpack中配置<code>NamedModulesPlugin</code>，最新打包生成的index.js内部代码如下。和上面的代码比较，可以发现数字moduleId被替换成了文件的路径，这保证了moduleId的不变性。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackJsonp([<span class=\"number\">4</span>],&#123;</span><br><span class=\"line\"><span class=\"comment\">/***/</span> <span class=\"string\">\"./node_modules/babel-runtime/helpers/defineProperty.js\"</span>:</span><br><span class=\"line\"><span class=\"comment\">/***/</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports, __webpack_require__</span>) </span>&#123;<span class=\"string\">\"use strict\"</span>;<span class=\"built_in\">eval</span>(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/***/</span> &#125;),</span><br><span class=\"line\"><span class=\"comment\">/***/</span> <span class=\"string\">\"./node_modules/nw-detect/es/index.js\"</span>:</span><br><span class=\"line\"><span class=\"comment\">/***/</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;<span class=\"string\">\"use strict\"</span>;<span class=\"built_in\">eval</span>(<span class=\"string\">\"/*actual code*/\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/***/</span> &#125;)</span><br><span class=\"line\"><span class=\"comment\">//more code</span></span><br><span class=\"line\">&#125;, [<span class=\"string\">\"./src/entry/index.jsx\"</span>]);</span><br></pre></td></tr></table></figure></p>\n<p><code>moduleId</code>既然不会再变，那我们重新添加test页面，打包后是不是会只新增js呢？开心的是大部分js都没有改动，但发现还有两个js有变化，包括我们提取出的公共js<code>common.bundle.js</code>。对比下，发现文件的内容只有<code>chunkId</code>发生了变化：<br><img src=\"https://easyread.nosdn.127.net/web/trunk/1545812851431/xxxx_20181226162712.png\"><br><img src=\"https://easyread.nosdn.127.net/web/trunk/1545812873655/xxxx_20181226162719.png\"></p>\n<h3 id=\"固化chunkId\"><a href=\"#固化chunkId\" class=\"headerlink\" title=\"固化chunkId\"></a>固化<code>chunkId</code></h3><p>再进一步，显然就是希望可以固化<code>chunkId</code>，webpack插件<code>NamedChunksPlugin</code>可以满足我们的需求，它使用webpack中唯一的entry名作为chunkId。配置好<code>NamedChunksPlugin</code>后，对比添加test页面前后js的变化，发现只有新增的js，已有的js都没有发生变化，注意到之前的<code>common.bundle.js</code>和<code>forbidden.js</code>发生改变的地方，代码分别如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/******/</span>  <span class=\"comment\">// objects to store loaded and loading chunks</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span>  <span class=\"keyword\">var</span> installedChunks = &#123;</span><br><span class=\"line\"><span class=\"comment\">/******/</span>    <span class=\"string\">\"common\"</span>: <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span>  &#125;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackJsonp([<span class=\"string\">\"forbidden\"</span>],&#123;</span><br><span class=\"line\">  <span class=\"comment\">//other code</span></span><br></pre></td></tr></table></figure>\n<p>chunkId都由数字变成了唯一的entry值，<code>common</code>对应<code>CommonsChunkPlugin</code>配置的name值。<br>对于代码分离出的js，使用<code>webpackChunkName</code>设置<code>chunkName</code>，可以保证该js<code>chunkId</code>的稳定性。</p>\n<h3 id=\"生产环境下固化moduleId\"><a href=\"#生产环境下固化moduleId\" class=\"headerlink\" title=\"生产环境下固化moduleId\"></a>生产环境下固化<code>moduleId</code></h3><p>前文提到的<code>NamedModulesPlugin</code>，使用的是模块的相对路径，但因为相对路径偏长，生产环境更建议使用<code>HashedModuleIdsPlugin</code>，它会根据文件的路径去生成hash，打包后的文件更小。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackJsonp([<span class=\"string\">\"index\"</span>],</span><br><span class=\"line\">  &#123;<span class=\"string\">\"+qWx\"</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e,t</span>)</span>&#123;e.exports=vendor&#125;,<span class=\"string\">\"5AEV\"</span> ...&#125;,</span><br><span class=\"line\">  [<span class=\"string\">\"qwtH\"</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>最终在生产环境下需要配置下面的代码，就可以实现moduleId和chunkId的固定，使用户端的缓存更加持久。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.HashedModuleIdsPlugin(), <span class=\"comment\">//固化 module id</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> webpack.NamedChunksPlugin(), <span class=\"comment\">//固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"图片优化\"><a href=\"#图片优化\" class=\"headerlink\" title=\"图片优化\"></a>图片优化</h2><p>图片的大小直接影响页面加载的速度，基础的优化操作有：对图片进行压缩、转base64减少http请求、使用srcset/sizes获取自适应图片等。这儿主要介绍如何结合webpack进行图片压缩，以及应用webp图片格式。</p>\n<h3 id=\"webpack-loader图片压缩\"><a href=\"#webpack-loader图片压缩\" class=\"headerlink\" title=\"webpack loader图片压缩\"></a>webpack loader图片压缩</h3><p>对图片进行压缩处理，可以选择的压缩工具有很多种，如压缩png、jpg的<a href=\"https://tinypng.com/\" target=\"_blank\" rel=\"noopener\">tinypng</a>、<a href=\"https://zhitu.isux.us/\" target=\"_blank\" rel=\"noopener\">智图</a>，裁剪压缩gif的<a href=\"https://www.iloveimg.com/zh-cn/compress-image/compress-gif\" target=\"_blank\" rel=\"noopener\">iLoveIMG</a>；也可以安装psd的tinypng插件，以及pngquant、ImageAlpha、ImageOptim、Image Optimizer等其他压缩工具。<br><strong>打包压缩</strong><br>相比之下，配置loader或plugin打包压缩更加便捷，例如，配置好<a href=\"https://www.npmjs.com/package/image-webpack-loader\" target=\"_blank\" rel=\"noopener\">image-webpack-loader</a>，在production模式下开启压缩，就可以在打包的时候自动压缩图片。</p>\n<blockquote>\n<p>image-webpack-loader是基于<a href=\"https://github.com/kevva/imagemin\" target=\"_blank\" rel=\"noopener\">imagemin</a>去压缩PNG、JPEG、GIF、SVG和WEBP图片。针对不同的优化项，可以自定义参数以适配项目的需求。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">    use: [&#123;</span><br><span class=\"line\">        loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">            limit: <span class=\"number\">8192</span>,</span><br><span class=\"line\">            name: <span class=\"string\">'image/[hash:8].[name].[ext]'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        loader: <span class=\"string\">'image-webpack-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">            mozjpeg: &#123;</span><br><span class=\"line\">                progressive: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                quality: <span class=\"number\">65</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            pngquant: &#123;</span><br><span class=\"line\">                quality: <span class=\"string\">'65-90'</span>,</span><br><span class=\"line\">                speed: <span class=\"number\">3</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>webpack也可以支持<code>tinypng</code>的打包压缩，如<a href=\"https://www.npmjs.com/package/tinypng-webpack-plugin\" target=\"_blank\" rel=\"noopener\">tinypng-webpack-plugin</a>，使用了<code>tinypng</code>提供的<a href=\"https://tinypng.com/developers/reference/nodejs\" target=\"_blank\" rel=\"noopener\">API</a>。但需要注意的是，使用tinypng需要申请key值，每个key值每个月可以免费压缩500张，超出部分就要付费了。</p>\n<h3 id=\"响应式图片\"><a href=\"#响应式图片\" class=\"headerlink\" title=\"响应式图片\"></a>响应式图片</h3><p>可以通过@media、image-set或者js实现根据屏幕大小获取对应的图片，更方便的方式是使用<img srcset>和<picture>。</picture></p>\n<h4 id=\"srcset相同尺寸不同分辨率\"><a href=\"#srcset相同尺寸不同分辨率\" class=\"headerlink\" title=\"srcset相同尺寸不同分辨率\"></a>srcset相同尺寸不同分辨率</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"pic.png?imageView&amp;thumbnail=202y284\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">srcset</span>=<span class=\"string\">\"pic.png?imageView&amp;thumbnail=202y284 2x, pic.png?imageView&amp;thumbnail=303y426 3x\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当分辨率为3x时，会使用3x对应的pic.png?imageView&amp;thumbnail=303y426图片。没有匹配到的、或者是不支持srcset属性的浏览器会正常加载src引用的图片。结合NOS提供的图片缩略功能，只需要上传一张图片，就可以实现不同分辨率下返回不同尺寸的图片。</p>\n<h4 id=\"sizes不同尺寸\"><a href=\"#sizes不同尺寸\" class=\"headerlink\" title=\"sizes不同尺寸\"></a>sizes不同尺寸</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">srcset</span>=<span class=\"string\">\"pic-320w.jpg 320w,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">             pic-480w.jpg 480w,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">             pic-800w.jpg 800w\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">sizes</span>=<span class=\"string\">\"(max-width: 320px) 280px,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">            (max-width: 480px) 440px,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">            800px\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">src</span>=<span class=\"string\">\"pic-800w.jpg\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当屏幕宽度为450px时，满足<code>sizes</code>定义的媒体查询<code>(max-width: 480px) 440px</code>，这时候图片宽度是440px，将从<code>srcset</code>中匹配最接近的宽度。注意不能直接把440px和480w去比较，因为srcset中的w值不是对应的像素值，而是图片真正的宽度。如在iphone8上，分辨率是2x，440px对应的图片宽度是880w，与880w最接近的是800w，所以会去加载图片’pic-800w.jpg’，而如果是在分别率为1x的设备上，则对应440w，与480w最接近，会去加载图片<code>pic-480w.jpg</code>。</p>\n<h4 id=\"picture\"><a href=\"#picture\" class=\"headerlink\" title=\"picture\"></a>picture</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">picture</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">media</span>=<span class=\"string\">\"(max-width: 799px)\"</span> <span class=\"attr\">srcset</span>=<span class=\"string\">\"elva-480w-close-portrait.jpg\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">media</span>=<span class=\"string\">\"(min-width: 800px)\"</span> <span class=\"attr\">srcset</span>=<span class=\"string\">\"elva-800w.jpg\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"elva-800w.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Chris standing up holding his daughter Elva\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>会按顺序加载满足条件的第一个图片，保底需要定义一个img作为默认值，已经兼容不支持<picture>标签的浏览器。source同样支持srcset和sizes属性配置多个，此外还支持type去标识不同的图片类型。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">picture</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">type</span>=<span class=\"string\">\"image/webp\"</span> <span class=\"attr\">srcset</span>=<span class=\"string\">\"snow.webp\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"snow.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Hut in the snow\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">picture</span>&gt;</span></span><br></pre></td></tr></table></figure></picture></p>\n<p>如果支持webp格式的，会去加载snow.webp，否则会去加载默认的snow.png。</p>\n<h4 id=\"HTTP-Client-Hints\"><a href=\"#HTTP-Client-Hints\" class=\"headerlink\" title=\"HTTP Client Hints\"></a>HTTP Client Hints</h4><p>通过<code>http client hints</code>，浏览器发起请求的时候，可以将DPR、Width、Viewport-Width等属性发送到Server端。Chrome46开始支持<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#The_Accept-CH_header\" target=\"_blank\" rel=\"noopener\">Accept-CH</a>的配置：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Accept-CH\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"DPR, Width, Viewport-Width\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>配置完成后，页面发送的请求头部都被包含下面信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept: image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class=\"line\">DPR: 3</span><br><span class=\"line\">Viewport-Width: 460</span><br><span class=\"line\">Width: 230</span><br></pre></td></tr></table></figure></p>\n<p>其中Width属性不是每次都被带上，它是根据Image的sizes属性计算出来的，默认还会带上Accept属性，如果支持webp格式的图片，会包含’image/webp’。Server端可以根据<br>这些属性的值返回期望的图片：宽度为690px的webp图片。响应头会包含Content-Type、Content-DPR、Vary属性，浏览器会基于Content-DPR的值去计算图片最终展示的宽度，保证宽度仍为230px。demo如下所示。<br><img src=\"http://kms.fp.ps.netease.com/file/5c221d45a7f2522c896cb338a052AIYJ\" width=\"600px\"></p>\n<p>更详细的介绍，参见<a href=\"https://developers.google.com/web/updates/2015/09/automating-resource-selection-with-client-hints\" target=\"_blank\" rel=\"noopener\">automating-resource-selection-with-client-hints</a></p>\n<h3 id=\"webp图片\"><a href=\"#webp图片\" class=\"headerlink\" title=\"webp图片\"></a>webp图片</h3><p>WebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。<br><a href=\"https://caniuse.com/#search=webp\" target=\"_blank\" rel=\"noopener\">webp兼容性</a>见下图<br><img src=\"http://kms.fp.ps.netease.com/file/5c1b671d5e60271dd96424efFDXtIaaQ\" width=\"800px\"><br>其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。</p>\n<h4 id=\"检测浏览器是否支持webp格式\"><a href=\"#检测浏览器是否支持webp格式\" class=\"headerlink\" title=\"检测浏览器是否支持webp格式\"></a>检测浏览器是否支持webp格式</h4><h5 id=\"方法1-canvas的toDataURL\"><a href=\"#方法1-canvas的toDataURL\" class=\"headerlink\" title=\"方法1: canvas的toDataURL\"></a>方法1: canvas的toDataURL</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkWebp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>).toDataURL(<span class=\"string\">'image/webp'</span>).indexOf(<span class=\"string\">'data:image/webp'</span>) == <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//or</span></span><br><span class=\"line\">    !![].map &amp;&amp; <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>).toDataURL(<span class=\"string\">'image/webp'</span>).indexOf(<span class=\"string\">'data:image/webp'</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比一下chrome和ie下<code>document.createElement(&#39;canvas&#39;).toDataURL(&#39;image/webp&#39;)</code>下的输出：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ie</span></span><br><span class=\"line\"><span class=\"string\">\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"</span></span><br><span class=\"line\"><span class=\"comment\">//chrome</span></span><br><span class=\"line\"><span class=\"string\">\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\"</span></span><br></pre></td></tr></table></figure></p>\n<p>基于<code>toDataURL</code>的特性，如果请求的类型不被支持，默认返回<code>data:image/png</code>。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则<code>toDataURL</code>会返回<code>&quot;data:,&quot;</code>。)<br>所以，只有支持webp格式的浏览器调用<code>toDataURL(&#39;image/webp&#39;)</code>后返回的字符串中才包含<code>&#39;data:image/webp&#39;</code>。上面提供了两种写法，其中<code>!![].map</code>主要是判断是否是IE9+，以免toDataURL方法会报错。</p>\n<h5 id=\"方法2-图片onload\"><a href=\"#方法2-图片onload\" class=\"headerlink\" title=\"方法2: 图片onload\"></a>方法2: 图片onload</h5><p>google官网提供的，通过加载小的webp图片来判断是否支持该格式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// check_webp_feature:</span></span><br><span class=\"line\"><span class=\"comment\">//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.</span></span><br><span class=\"line\"><span class=\"comment\">//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check_webp_feature</span>(<span class=\"params\">feature, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> kTestImages = &#123;</span><br><span class=\"line\">        lossy: <span class=\"string\">\"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\"</span>,</span><br><span class=\"line\">        lossless: <span class=\"string\">\"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\"</span>,</span><br><span class=\"line\">        alpha: <span class=\"string\">\"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\"</span>,</span><br><span class=\"line\">        animation: <span class=\"string\">\"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">    img.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = (img.width &gt; <span class=\"number\">0</span>) &amp;&amp; (img.height &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        callback(feature, result);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.onerror = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback(feature, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.src = <span class=\"string\">\"data:image/webp;base64,\"</span> + kTestImages[feature];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。<br>调用方法如下，可以在<code>callback</code>方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加<code>webp</code>相关的class都可以。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">check_webp_feature(<span class=\"string\">'lossless'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">feature,result</span>)</span>&#123;</span><br><span class=\"line\">    alert(result); <span class=\"comment\">//true or false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用webp\"><a href=\"#使用webp\" class=\"headerlink\" title=\"使用webp\"></a>使用webp</h4><p>处理webp通常有两种方式：</p>\n<ul>\n<li>服务端处理，支持webp图片的浏览器会在请求头Accept中加上<code>image/webp</code>，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了；</li>\n<li>前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型<br>开心的是，基于网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考<a href=\"https://www.163yun.com/help/documents/114078550521466880。\" target=\"_blank\" rel=\"noopener\">https://www.163yun.com/help/documents/114078550521466880。</a><br>其中，通过在url后拼接<code>?imageView&amp;type=webp</code>就可以获得对应的webp图片。</li>\n</ul>\n<h3 id=\"REFS\"><a href=\"#REFS\" class=\"headerlink\" title=\"REFS\"></a>REFS</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images\" target=\"_blank\" rel=\"noopener\">响应式图片</a><br><a href=\"https://blog.csdn.net/qq20004604/article/details/79318253\" target=\"_blank\" rel=\"noopener\">React（17）异步组件</a><br><a href=\"https://github.com/pigcan/blog/issues/9\" target=\"_blank\" rel=\"noopener\">基于 webpack 的持久化缓存方案 </a><br><a href=\"https://www.imooc.com/article/21538\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/article/21538</a><br><a href=\"https://www.imooc.com/article/21538\" target=\"_blank\" rel=\"noopener\">听说你用webpack处理文件名的hash？</a><br><a href=\"https://juejin.im/post/5a23b130f265da432003101a\" target=\"_blank\" rel=\"noopener\">简单易懂的 webpack 打包后 JS 的运行过程</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"项目背景\"><a href=\"#项目背景\" class=\"headerlink\" title=\"项目背景\"></a>项目背景</h1><p>项目是基于React开发，webpack打包的多页面h5应用，其中部分页面又是基于React-router的SPA。开发的过程中，也一直在尝试对项目进行优化，这儿主要记录了对<code>代码分片</code>、<code>持久化缓存</code>和<code>图片优化</code>的处理。</p>\n<p>优化之路漫漫，蹒跚而来。</p>\n<hr>\n<h1 id=\"动态加载组件\"><a href=\"#动态加载组件\" class=\"headerlink\" title=\"动态加载组件\"></a>动态加载组件</h1><h2 id=\"Code-splitting-代码分片\"><a href=\"#Code-splitting-代码分片\" class=\"headerlink\" title=\"Code splitting(代码分片)\"></a>Code splitting(代码分片)</h2><p>当前端代码越来越复杂，代码体积越来越大时，需要考虑对加载的资源进行细粒度的分割，按需加载。<br>webpack支持两种语法实现动态地加载模块：</p>\n<ul>\n<li><p><a href=\"https://webpack.js.org/api/module-methods/#require-ensure\" target=\"_blank\" rel=\"noopener\">require.ensure</a><br>给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.ensure(dependencies: <span class=\"built_in\">String</span>[], <span class=\"attr\">callback</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>), <span class=\"title\">chunkName</span>: <span class=\"title\">String</span>)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://webpack.js.org/api/module-methods/#import-\" target=\"_blank\" rel=\"noopener\">import</a><br>调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">  <span class=\"comment\">/* webpackChunkName: \"my-chunk-name\" */</span></span><br><span class=\"line\">  <span class=\"comment\">/* webpackMode: \"lazy\" (default)*/</span></span><br><span class=\"line\">  <span class=\"string\">'path/to/module'</span>) -&gt; <span class=\"built_in\">Promise</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>webpackChunkName</code>用来设置chunk的名字；<code>webpackMode</code>默认值是<code>lazy</code>，还有<code>lazy-once</code>、<code>eager</code>、<code>weak</code>。按需加载的默认加载形式是async。<br>","more":"</p>\n<h2 id=\"react动态加载组件\"><a href=\"#react动态加载组件\" class=\"headerlink\" title=\"react动态加载组件\"></a>react动态加载组件</h2><p>在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。<br>直接看代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 异步加载模块</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;[type]&#125; loadComponent [description]</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;[type]&#125;               [description]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> asyncComponent = <span class=\"function\"><span class=\"params\">loadComponent</span> =&gt;</span> (</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        state = &#123;</span><br><span class=\"line\">            Component: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentDidMount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasLoadedComponent()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            loadComponent()</span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> <span class=\"built_in\">module</span>.default)</span><br><span class=\"line\">                .then(<span class=\"function\">(<span class=\"params\">Component</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.setState(&#123; Component &#125;);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.error(<span class=\"string\">`Cannot load component in &lt;AsyncComponent /&gt;`</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        hasLoadedComponent() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.state.Component !== <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; Component &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Component) ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Component</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span> : null;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">);</span></span><br></pre></td></tr></table></figure></p>\n<p><code>loadComponent</code>参数代表import(‘module’)异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。<br>如何调用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> AsyncBannerSwiper = asyncComponent(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"bannerSwiper\" */</span> <span class=\"string\">'./BannerSwiper.jsx'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>将<code>BannerSwiper</code>组件用<code>asyncComponent</code>封装下，就返回了一个异步加载的<code>AsyncBannerSwiper</code>组件，使用方法和其他组件完全一致。其中支持<code>webpackChunkName</code>去配置chunk的名字，不配置的情况下会默认生成<code>[id].bundle.js</code>。</p>\n<h3 id=\"publicPath动态设置\"><a href=\"#publicPath动态设置\" class=\"headerlink\" title=\"publicPath动态设置\"></a>publicPath动态设置</h3><p>项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。<br>动态设置异步chunk的publicPath，在入口entry中设置<strong>webpack_public_path</strong>，打包配置文件中配置的publicPath不变。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__webpack_public_path__ = <span class=\"built_in\">window</span>.cdn || <span class=\"string\">'/dist/'</span>;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"webpack设置\"><a href=\"#webpack设置\" class=\"headerlink\" title=\"webpack设置\"></a>webpack设置</h2><p>在webpack配置文件中，需要配置<code>chunkFilename</code>指定chunk的名字。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chunkFilename: <span class=\"string\">'[name].js'</span></span><br></pre></td></tr></table></figure></p>\n<p>另外，注意webpack插件的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.NamedChunksPlugin(), <span class=\"comment\">//固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    children: <span class=\"literal\">false</span>,  <span class=\"comment\">// 如果设置为 `true`，所有公共 chunk 的子模块都会被选择</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\"><span class=\"keyword\">new</span> ExtractTextPlugin(&#123;<span class=\"attr\">filename</span>: <span class=\"string\">'css/[name].css?[contenthash:8]'</span>, <span class=\"attr\">allChunks</span>: <span class=\"literal\">true</span>&#125;),  <span class=\"comment\">//从所有chunk中提取(默认情况下，它仅从initial chunk中提取)</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"分离前后对比\"><a href=\"#分离前后对比\" class=\"headerlink\" title=\"分离前后对比\"></a>分离前后对比</h2><p>使用<a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a>分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：<br><img src=\"http://kms.fp.ps.netease.com/file/5c1b66436f04944f5b0bac27fkqqY7XJ\" width=\"600px\"><br>可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：<br><img src=\"http://kms.fp.ps.netease.com/file/5c1b66b196dee43c91c66dc7p9XqNpke\" width=\"500px\"><br>使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：<br><img src=\"http://kms.fp.ps.netease.com/file/5c1b665f7f9d2a9a4e46ed29AADJKiNf\" width=\"600px\"><br>可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。线上的资源又是开启了gzip压缩，体积就更小了。<br><img src=\"http://kms.fp.ps.netease.com/file/5c1b66d0a7f2523ddac2a954og4WjVDi\" width=\"500px\"></p>\n<hr>\n<h1 id=\"持久化缓存\"><a href=\"#持久化缓存\" class=\"headerlink\" title=\"持久化缓存\"></a>持久化缓存</h1><p>为了获取持久化缓存，在配置webpack的output时，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。</p>\n<h2 id=\"moduleId-VS-chunkId\"><a href=\"#moduleId-VS-chunkId\" class=\"headerlink\" title=\"moduleId VS chunkId\"></a>moduleId VS chunkId</h2><p>webpack打包后会生成<code>webpackJsonp</code>等方法，用于加载chunk和module，精简的源码如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>[<span class=\"string\">\"webpackJsonp\"</span>] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">webpackJsonpCallback</span>(<span class=\"params\">chunkIds, moreModules, executeModules</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> moduleId, result;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (moduleId <span class=\"keyword\">in</span> moreModules) &#123; <span class=\"comment\">//该chunk引用的所有模块</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将chunk中所包含的模块放入modules数组中</span></span><br><span class=\"line\">        modules[moduleId] = moreModules[moduleId];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executeModules) &#123; <span class=\"comment\">//入口module</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; executeModules.length; i++) &#123;</span><br><span class=\"line\">        result = __webpack_require__(executeModules[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 调用__webpack_require__(moduleId)时，</span></span><br><span class=\"line\">  <span class=\"comment\">// 再将模块放入installedModules，用于保存已经加载过的模块</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (installedModules[moduleId]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> installedModules[moduleId].exports;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Create a new module (and put it into the cache)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = installedModules[moduleId] = &#123;</span><br><span class=\"line\">      i: moduleId,</span><br><span class=\"line\">      l: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      exports: &#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// Execute the module function:</span></span><br><span class=\"line\">    <span class=\"comment\">// 在执行的过程中，会递归调用`__webpack_require__`加载该模块引用的其他模块</span></span><br><span class=\"line\">    modules[moduleId].call(<span class=\"built_in\">module</span>.exports, <span class=\"built_in\">module</span>, <span class=\"built_in\">module</span>.exports, __webpack_require__);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Flag the module as loaded</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.l = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)([]);</span><br></pre></td></tr></table></figure></p>\n<p><code>webpackJsonp</code>方法接收三个参数<code>chunkIds, moreModules, executeModules</code>，其中<code>chunkIds</code>属于chunkId，<code>moreModules, executeModules</code>都属于moduleId。</p>\n<ul>\n<li>chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。</li>\n<li>module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前<code>__webpack_require__</code>加载的模块，同样使用数组下标作为moduleId。<br>每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。</li>\n</ul>\n<h2 id=\"固化过程\"><a href=\"#固化过程\" class=\"headerlink\" title=\"固化过程\"></a>固化过程</h2><h3 id=\"初始状态\"><a href=\"#初始状态\" class=\"headerlink\" title=\"初始状态\"></a>初始状态</h3><p>以首页为例，打包后生成的index.js中会调用<code>webpackJsonp</code>方法，传入三个参数<code>chunkIds, moreModules, executeModules</code>。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackJsonp([<span class=\"number\">4</span>],&#123;</span><br><span class=\"line\"><span class=\"comment\">/***/</span> <span class=\"number\">10</span>:</span><br><span class=\"line\"><span class=\"comment\">/***/</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports, __webpack_require__</span>) </span>&#123;<span class=\"string\">\"use strict\"</span>;<span class=\"built_in\">eval</span>(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/***/</span> &#125;),</span><br><span class=\"line\"><span class=\"comment\">/***/</span> <span class=\"number\">11</span>:</span><br><span class=\"line\"><span class=\"comment\">/***/</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;<span class=\"string\">\"use strict\"</span>;<span class=\"built_in\">eval</span>(<span class=\"string\">\"/*actual code*/\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/***/</span> &#125;)</span><br><span class=\"line\"><span class=\"comment\">//more code</span></span><br><span class=\"line\">&#125;, [<span class=\"number\">348</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>若此时新增一个页面，入口为”./src/entry/test.jsx”，打包后，会发现所有的js内容都发生了改变，以其中一个文件为例，发现是引用的moduleId发生了变化：<br><img src=\"https://easyread.nosdn.127.net/web/trunk/1545811193495/xxxx_20181226155854.png\"><br><img src=\"https://easyread.nosdn.127.net/web/trunk/1545811180510/xxxx_20181226155821.png\"></p>\n<h3 id=\"固化moduleId\"><a href=\"#固化moduleId\" class=\"headerlink\" title=\"固化moduleId\"></a>固化<code>moduleId</code></h3><p>为了不影响其他文件，需要想办法将moduleId固定化，可以在webpack中配置<code>NamedModulesPlugin</code>，最新打包生成的index.js内部代码如下。和上面的代码比较，可以发现数字moduleId被替换成了文件的路径，这保证了moduleId的不变性。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackJsonp([<span class=\"number\">4</span>],&#123;</span><br><span class=\"line\"><span class=\"comment\">/***/</span> <span class=\"string\">\"./node_modules/babel-runtime/helpers/defineProperty.js\"</span>:</span><br><span class=\"line\"><span class=\"comment\">/***/</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports, __webpack_require__</span>) </span>&#123;<span class=\"string\">\"use strict\"</span>;<span class=\"built_in\">eval</span>(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/***/</span> &#125;),</span><br><span class=\"line\"><span class=\"comment\">/***/</span> <span class=\"string\">\"./node_modules/nw-detect/es/index.js\"</span>:</span><br><span class=\"line\"><span class=\"comment\">/***/</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;<span class=\"string\">\"use strict\"</span>;<span class=\"built_in\">eval</span>(<span class=\"string\">\"/*actual code*/\"</span>);</span><br><span class=\"line\"><span class=\"comment\">/***/</span> &#125;)</span><br><span class=\"line\"><span class=\"comment\">//more code</span></span><br><span class=\"line\">&#125;, [<span class=\"string\">\"./src/entry/index.jsx\"</span>]);</span><br></pre></td></tr></table></figure></p>\n<p><code>moduleId</code>既然不会再变，那我们重新添加test页面，打包后是不是会只新增js呢？开心的是大部分js都没有改动，但发现还有两个js有变化，包括我们提取出的公共js<code>common.bundle.js</code>。对比下，发现文件的内容只有<code>chunkId</code>发生了变化：<br><img src=\"https://easyread.nosdn.127.net/web/trunk/1545812851431/xxxx_20181226162712.png\"><br><img src=\"https://easyread.nosdn.127.net/web/trunk/1545812873655/xxxx_20181226162719.png\"></p>\n<h3 id=\"固化chunkId\"><a href=\"#固化chunkId\" class=\"headerlink\" title=\"固化chunkId\"></a>固化<code>chunkId</code></h3><p>再进一步，显然就是希望可以固化<code>chunkId</code>，webpack插件<code>NamedChunksPlugin</code>可以满足我们的需求，它使用webpack中唯一的entry名作为chunkId。配置好<code>NamedChunksPlugin</code>后，对比添加test页面前后js的变化，发现只有新增的js，已有的js都没有发生变化，注意到之前的<code>common.bundle.js</code>和<code>forbidden.js</code>发生改变的地方，代码分别如下：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/******/</span>  <span class=\"comment\">// objects to store loaded and loading chunks</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span>  <span class=\"keyword\">var</span> installedChunks = &#123;</span><br><span class=\"line\"><span class=\"comment\">/******/</span>    <span class=\"string\">\"common\"</span>: <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"comment\">/******/</span>  &#125;;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackJsonp([<span class=\"string\">\"forbidden\"</span>],&#123;</span><br><span class=\"line\">  <span class=\"comment\">//other code</span></span><br></pre></td></tr></table></figure>\n<p>chunkId都由数字变成了唯一的entry值，<code>common</code>对应<code>CommonsChunkPlugin</code>配置的name值。<br>对于代码分离出的js，使用<code>webpackChunkName</code>设置<code>chunkName</code>，可以保证该js<code>chunkId</code>的稳定性。</p>\n<h3 id=\"生产环境下固化moduleId\"><a href=\"#生产环境下固化moduleId\" class=\"headerlink\" title=\"生产环境下固化moduleId\"></a>生产环境下固化<code>moduleId</code></h3><p>前文提到的<code>NamedModulesPlugin</code>，使用的是模块的相对路径，但因为相对路径偏长，生产环境更建议使用<code>HashedModuleIdsPlugin</code>，它会根据文件的路径去生成hash，打包后的文件更小。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpackJsonp([<span class=\"string\">\"index\"</span>],</span><br><span class=\"line\">  &#123;<span class=\"string\">\"+qWx\"</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e,t</span>)</span>&#123;e.exports=vendor&#125;,<span class=\"string\">\"5AEV\"</span> ...&#125;,</span><br><span class=\"line\">  [<span class=\"string\">\"qwtH\"</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>最终在生产环境下需要配置下面的代码，就可以实现moduleId和chunkId的固定，使用户端的缓存更加持久。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.HashedModuleIdsPlugin(), <span class=\"comment\">//固化 module id</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> webpack.NamedChunksPlugin(), <span class=\"comment\">//固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"图片优化\"><a href=\"#图片优化\" class=\"headerlink\" title=\"图片优化\"></a>图片优化</h2><p>图片的大小直接影响页面加载的速度，基础的优化操作有：对图片进行压缩、转base64减少http请求、使用srcset/sizes获取自适应图片等。这儿主要介绍如何结合webpack进行图片压缩，以及应用webp图片格式。</p>\n<h3 id=\"webpack-loader图片压缩\"><a href=\"#webpack-loader图片压缩\" class=\"headerlink\" title=\"webpack loader图片压缩\"></a>webpack loader图片压缩</h3><p>对图片进行压缩处理，可以选择的压缩工具有很多种，如压缩png、jpg的<a href=\"https://tinypng.com/\" target=\"_blank\" rel=\"noopener\">tinypng</a>、<a href=\"https://zhitu.isux.us/\" target=\"_blank\" rel=\"noopener\">智图</a>，裁剪压缩gif的<a href=\"https://www.iloveimg.com/zh-cn/compress-image/compress-gif\" target=\"_blank\" rel=\"noopener\">iLoveIMG</a>；也可以安装psd的tinypng插件，以及pngquant、ImageAlpha、ImageOptim、Image Optimizer等其他压缩工具。<br><strong>打包压缩</strong><br>相比之下，配置loader或plugin打包压缩更加便捷，例如，配置好<a href=\"https://www.npmjs.com/package/image-webpack-loader\" target=\"_blank\" rel=\"noopener\">image-webpack-loader</a>，在production模式下开启压缩，就可以在打包的时候自动压缩图片。</p>\n<blockquote>\n<p>image-webpack-loader是基于<a href=\"https://github.com/kevva/imagemin\" target=\"_blank\" rel=\"noopener\">imagemin</a>去压缩PNG、JPEG、GIF、SVG和WEBP图片。针对不同的优化项，可以自定义参数以适配项目的需求。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: <span class=\"regexp\">/\\.(png|jpg|gif)$/</span>,</span><br><span class=\"line\">    use: [&#123;</span><br><span class=\"line\">        loader: <span class=\"string\">'url-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">            limit: <span class=\"number\">8192</span>,</span><br><span class=\"line\">            name: <span class=\"string\">'image/[hash:8].[name].[ext]'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        loader: <span class=\"string\">'image-webpack-loader'</span>,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">            mozjpeg: &#123;</span><br><span class=\"line\">                progressive: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                quality: <span class=\"number\">65</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            pngquant: &#123;</span><br><span class=\"line\">                quality: <span class=\"string\">'65-90'</span>,</span><br><span class=\"line\">                speed: <span class=\"number\">3</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>webpack也可以支持<code>tinypng</code>的打包压缩，如<a href=\"https://www.npmjs.com/package/tinypng-webpack-plugin\" target=\"_blank\" rel=\"noopener\">tinypng-webpack-plugin</a>，使用了<code>tinypng</code>提供的<a href=\"https://tinypng.com/developers/reference/nodejs\" target=\"_blank\" rel=\"noopener\">API</a>。但需要注意的是，使用tinypng需要申请key值，每个key值每个月可以免费压缩500张，超出部分就要付费了。</p>\n<h3 id=\"响应式图片\"><a href=\"#响应式图片\" class=\"headerlink\" title=\"响应式图片\"></a>响应式图片</h3><p>可以通过@media、image-set或者js实现根据屏幕大小获取对应的图片，更方便的方式是使用<img srcset>和<picture>。</picture></p>\n<h4 id=\"srcset相同尺寸不同分辨率\"><a href=\"#srcset相同尺寸不同分辨率\" class=\"headerlink\" title=\"srcset相同尺寸不同分辨率\"></a>srcset相同尺寸不同分辨率</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"pic.png?imageView&amp;thumbnail=202y284\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">srcset</span>=<span class=\"string\">\"pic.png?imageView&amp;thumbnail=202y284 2x, pic.png?imageView&amp;thumbnail=303y426 3x\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当分辨率为3x时，会使用3x对应的pic.png?imageView&amp;thumbnail=303y426图片。没有匹配到的、或者是不支持srcset属性的浏览器会正常加载src引用的图片。结合NOS提供的图片缩略功能，只需要上传一张图片，就可以实现不同分辨率下返回不同尺寸的图片。</p>\n<h4 id=\"sizes不同尺寸\"><a href=\"#sizes不同尺寸\" class=\"headerlink\" title=\"sizes不同尺寸\"></a>sizes不同尺寸</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">srcset</span>=<span class=\"string\">\"pic-320w.jpg 320w,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">             pic-480w.jpg 480w,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">             pic-800w.jpg 800w\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">sizes</span>=<span class=\"string\">\"(max-width: 320px) 280px,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">            (max-width: 480px) 440px,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"string\">            800px\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">src</span>=<span class=\"string\">\"pic-800w.jpg\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>当屏幕宽度为450px时，满足<code>sizes</code>定义的媒体查询<code>(max-width: 480px) 440px</code>，这时候图片宽度是440px，将从<code>srcset</code>中匹配最接近的宽度。注意不能直接把440px和480w去比较，因为srcset中的w值不是对应的像素值，而是图片真正的宽度。如在iphone8上，分辨率是2x，440px对应的图片宽度是880w，与880w最接近的是800w，所以会去加载图片’pic-800w.jpg’，而如果是在分别率为1x的设备上，则对应440w，与480w最接近，会去加载图片<code>pic-480w.jpg</code>。</p>\n<h4 id=\"picture\"><a href=\"#picture\" class=\"headerlink\" title=\"picture\"></a>picture</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">picture</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">media</span>=<span class=\"string\">\"(max-width: 799px)\"</span> <span class=\"attr\">srcset</span>=<span class=\"string\">\"elva-480w-close-portrait.jpg\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">media</span>=<span class=\"string\">\"(min-width: 800px)\"</span> <span class=\"attr\">srcset</span>=<span class=\"string\">\"elva-800w.jpg\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"elva-800w.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Chris standing up holding his daughter Elva\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">picture</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>会按顺序加载满足条件的第一个图片，保底需要定义一个img作为默认值，已经兼容不支持<picture>标签的浏览器。source同样支持srcset和sizes属性配置多个，此外还支持type去标识不同的图片类型。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">picture</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">source</span> <span class=\"attr\">type</span>=<span class=\"string\">\"image/webp\"</span> <span class=\"attr\">srcset</span>=<span class=\"string\">\"snow.webp\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"snow.png\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Hut in the snow\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">picture</span>&gt;</span></span><br></pre></td></tr></table></figure></picture></p>\n<p>如果支持webp格式的，会去加载snow.webp，否则会去加载默认的snow.png。</p>\n<h4 id=\"HTTP-Client-Hints\"><a href=\"#HTTP-Client-Hints\" class=\"headerlink\" title=\"HTTP Client Hints\"></a>HTTP Client Hints</h4><p>通过<code>http client hints</code>，浏览器发起请求的时候，可以将DPR、Width、Viewport-Width等属性发送到Server端。Chrome46开始支持<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#The_Accept-CH_header\" target=\"_blank\" rel=\"noopener\">Accept-CH</a>的配置：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Accept-CH\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"DPR, Width, Viewport-Width\"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>配置完成后，页面发送的请求头部都被包含下面信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Accept: image/webp,image/apng,image/*,*/*;q=0.8</span><br><span class=\"line\">DPR: 3</span><br><span class=\"line\">Viewport-Width: 460</span><br><span class=\"line\">Width: 230</span><br></pre></td></tr></table></figure></p>\n<p>其中Width属性不是每次都被带上，它是根据Image的sizes属性计算出来的，默认还会带上Accept属性，如果支持webp格式的图片，会包含’image/webp’。Server端可以根据<br>这些属性的值返回期望的图片：宽度为690px的webp图片。响应头会包含Content-Type、Content-DPR、Vary属性，浏览器会基于Content-DPR的值去计算图片最终展示的宽度，保证宽度仍为230px。demo如下所示。<br><img src=\"http://kms.fp.ps.netease.com/file/5c221d45a7f2522c896cb338a052AIYJ\" width=\"600px\"></p>\n<p>更详细的介绍，参见<a href=\"https://developers.google.com/web/updates/2015/09/automating-resource-selection-with-client-hints\" target=\"_blank\" rel=\"noopener\">automating-resource-selection-with-client-hints</a></p>\n<h3 id=\"webp图片\"><a href=\"#webp图片\" class=\"headerlink\" title=\"webp图片\"></a>webp图片</h3><p>WebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。<br><a href=\"https://caniuse.com/#search=webp\" target=\"_blank\" rel=\"noopener\">webp兼容性</a>见下图<br><img src=\"http://kms.fp.ps.netease.com/file/5c1b671d5e60271dd96424efFDXtIaaQ\" width=\"800px\"><br>其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。</p>\n<h4 id=\"检测浏览器是否支持webp格式\"><a href=\"#检测浏览器是否支持webp格式\" class=\"headerlink\" title=\"检测浏览器是否支持webp格式\"></a>检测浏览器是否支持webp格式</h4><h5 id=\"方法1-canvas的toDataURL\"><a href=\"#方法1-canvas的toDataURL\" class=\"headerlink\" title=\"方法1: canvas的toDataURL\"></a>方法1: canvas的toDataURL</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkWebp</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>).toDataURL(<span class=\"string\">'image/webp'</span>).indexOf(<span class=\"string\">'data:image/webp'</span>) == <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//or</span></span><br><span class=\"line\">    !![].map &amp;&amp; <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>).toDataURL(<span class=\"string\">'image/webp'</span>).indexOf(<span class=\"string\">'data:image/webp'</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比一下chrome和ie下<code>document.createElement(&#39;canvas&#39;).toDataURL(&#39;image/webp&#39;)</code>下的输出：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ie</span></span><br><span class=\"line\"><span class=\"string\">\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"</span></span><br><span class=\"line\"><span class=\"comment\">//chrome</span></span><br><span class=\"line\"><span class=\"string\">\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\"</span></span><br></pre></td></tr></table></figure></p>\n<p>基于<code>toDataURL</code>的特性，如果请求的类型不被支持，默认返回<code>data:image/png</code>。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则<code>toDataURL</code>会返回<code>&quot;data:,&quot;</code>。)<br>所以，只有支持webp格式的浏览器调用<code>toDataURL(&#39;image/webp&#39;)</code>后返回的字符串中才包含<code>&#39;data:image/webp&#39;</code>。上面提供了两种写法，其中<code>!![].map</code>主要是判断是否是IE9+，以免toDataURL方法会报错。</p>\n<h5 id=\"方法2-图片onload\"><a href=\"#方法2-图片onload\" class=\"headerlink\" title=\"方法2: 图片onload\"></a>方法2: 图片onload</h5><p>google官网提供的，通过加载小的webp图片来判断是否支持该格式：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// check_webp_feature:</span></span><br><span class=\"line\"><span class=\"comment\">//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.</span></span><br><span class=\"line\"><span class=\"comment\">//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check_webp_feature</span>(<span class=\"params\">feature, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> kTestImages = &#123;</span><br><span class=\"line\">        lossy: <span class=\"string\">\"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\"</span>,</span><br><span class=\"line\">        lossless: <span class=\"string\">\"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\"</span>,</span><br><span class=\"line\">        alpha: <span class=\"string\">\"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\"</span>,</span><br><span class=\"line\">        animation: <span class=\"string\">\"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\"</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">    img.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = (img.width &gt; <span class=\"number\">0</span>) &amp;&amp; (img.height &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        callback(feature, result);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.onerror = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        callback(feature, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    img.src = <span class=\"string\">\"data:image/webp;base64,\"</span> + kTestImages[feature];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。<br>调用方法如下，可以在<code>callback</code>方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加<code>webp</code>相关的class都可以。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">check_webp_feature(<span class=\"string\">'lossless'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">feature,result</span>)</span>&#123;</span><br><span class=\"line\">    alert(result); <span class=\"comment\">//true or false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"使用webp\"><a href=\"#使用webp\" class=\"headerlink\" title=\"使用webp\"></a>使用webp</h4><p>处理webp通常有两种方式：</p>\n<ul>\n<li>服务端处理，支持webp图片的浏览器会在请求头Accept中加上<code>image/webp</code>，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了；</li>\n<li>前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型<br>开心的是，基于网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考<a href=\"https://www.163yun.com/help/documents/114078550521466880。\" target=\"_blank\" rel=\"noopener\">https://www.163yun.com/help/documents/114078550521466880。</a><br>其中，通过在url后拼接<code>?imageView&amp;type=webp</code>就可以获得对应的webp图片。</li>\n</ul>\n<h3 id=\"REFS\"><a href=\"#REFS\" class=\"headerlink\" title=\"REFS\"></a>REFS</h3><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images\" target=\"_blank\" rel=\"noopener\">响应式图片</a><br><a href=\"https://blog.csdn.net/qq20004604/article/details/79318253\" target=\"_blank\" rel=\"noopener\">React（17）异步组件</a><br><a href=\"https://github.com/pigcan/blog/issues/9\" target=\"_blank\" rel=\"noopener\">基于 webpack 的持久化缓存方案 </a><br><a href=\"https://www.imooc.com/article/21538\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/article/21538</a><br><a href=\"https://www.imooc.com/article/21538\" target=\"_blank\" rel=\"noopener\">听说你用webpack处理文件名的hash？</a><br><a href=\"https://juejin.im/post/5a23b130f265da432003101a\" target=\"_blank\" rel=\"noopener\">简单易懂的 webpack 打包后 JS 的运行过程</a></p>"},{"title":"项目开发record","date":"2017-07-27T01:38:34.000Z","_content":"###  前端目录结构\n基于React + React-Router + Sass开发的webpack打包的多页面应用，其中正文页面和搜索页面是基于React-Router开发的单页面应用。路由类型采用的是BrowserRouter，在移动端pushState/replaceState没有兼容问题，可以放心使用。如果是要兼容IE9及以下，则不能使用BrowserRouter，建议使用HashRouter。此外，使用BrowserRouter后，可以借助history的特性帮助我们实现记录每个页面的历史停留位置。\n```\n|-- assets\n  |\n  |-- config //webpack编译\n  |    |-- base.js //基础编译配置\n  |    |-- dev.js  //开发环境编译配置\n  |    |-- dll.js  //动态链接库编译配置\n  |    |-- hot.js  //热替换编译配置\n  |    |-- prod.js //开发环境编译配置\n  |    |-- util.js //定义配置相关的通用方法和变量\n  |\n  |-- src                //源码目录\n  |    |-- component        // 组件\n  |    |      |-- common      //公共组件\n  |    |      |--             //其他子组件\n  |    |-- entry              //入口js，与静态html文件相对应\n  |    |-- util               //通用方法\n  |    |-- image            //图片资源\n  |    |-- style            //样式\n  |\n  |-- template              //html模板，动态生成html文件\n  |\n  |-- mock.json      // mock数据\n  |-- server_hot.js  //实现热更新、拦截并处理前端请求(返回本地页面、mock数据，其他请求转发到服务端处理)  \n  |\n|-- dist //构建目录\n```\n其中，模板中是静态html文件，在没有添加后端路由的情况下，通过server_hot.js中的页面映射去访问前端页面，例如当匹配到路径/index时，返回index.html页面，结合mock数据，真正实现了前后端分离。\n``` javascript\nlet templateMap = {\n    '/search': 'search.html',\n    '/search/book': 'search.html',\n    '/index': 'index.html',\n    '/history': 'history.html',\n    '/rank': 'rank.html',\n    '/home/more': 'more.html',\n    '/category': 'category.html',\n    '/info': 'info.html',\n    '/detail': 'detail.html',\n    '/book/reader': 'reader.html',\n    '/recharge': 'recharge.html',\n    '/catalog': 'catalog.html'\n}\n\nfor (let mapItem in templateMap) {\n    app.get(mapItem, function(req, res) {\n        res.sendFile(__dirname + '/template/' + templateMap[mapItem]);\n    });\n}\n```\n\n#### API转发后获取服务端数据失败的问题\n在使用http-proxy-middleware转发请求到后端时，发现有部分请求无法获得返回数据，首先可以确定的是请求被转发到后端了。调试发现后端会验证站点相关信息，在验证host的时候报错。猜测可能是请求转发后header里的host信息丢失，查询[API](https://www.npmjs.com/package/http-proxy-middleware#http-proxy-middleware-options)发现可以设置option.headers，如下所示。\n``` javascript\nvar proxyMiddleware = require('http-proxy-middleware');\nvar apiProxy = proxyMiddleware('/api', { target: 'http://ypxst.kuxuanbook.yuedu.163.com', headers: {host: 'ypxst.kuxuanbook.yuedu.163.com'}});\n```\n设置好host后，就可以正常获取接口返回数据了。\n\n#### POST请求验证XSRF-TOKEN\n之前阅读常用的方式是后端写入freemarker模板或者通过异步接口获得，这次和后端约定统一放在cookie中。\n``` javascript\n headers: {\n     'Content-Type': 'application/x-www-form-urlencoded',\n     'X-XSRF-TOKEN': csrf_token\n }\n```\n从cookie中读取token后封装在post接口中，写在headers里面，这样在使用的时候就直接调用post方法，无需关注token验证。\n\n#### 使用git subtree同步assets工程\nassets资源存在于novel-webapp-wap和novel-webapp-recharge两个工程下面，recharge工程下面用到的是充值页面，其他页面都在wap工程下，之所以分开为两个工程是因为涉及到支付，充值的域名需要是唯一的，而分站的域名很多。为了保证二者资源的同步，可以使用git subtree实现子工程的同步。\n``` bash\n# 获取远端novel-webapp-assets的更新\ngit subtree pull --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash\n\n# 将本地assets更新推送到远端novel-webapp-assets\ngit subtree push --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash\n```\n<!-- more -->\n#### webpack替换文件链接的资源\n通过给chunk filename添加[chunkhash]去有效地缓存文件，每次修改后生成新的chunkhash值，手动替换很麻烦，所以结合done plugin去完成html文件中资源名字的自动替换。\nstats记录了打包信息和相应的chunkhash值，其中assetsByChunkName包含了以chunkname作为key，filename作为值的对象，结构如下：\n``` json\n  \"assetsByChunkName\": {\n    \"reader\": [\n      \"js/reader-60b54d52.js\",\n      \"css/reader-60b54d52.css\"\n    ],\n    //...\n    \"common\": [\n      \"js/common-a814792a.bundle.js\",\n      \"css/common-a814792a.css\"\n    ]\n  }\n```\n遍历stats对象中的entrypoints，这里的entrypoints的key值和html文件名一致、且一一对应的，根据key值读取可以读取对应的html文件，通过正则匹配的方式将对应的js、css文件替换为本次打包生成的文件。\n``` javascript\nfunction () {\n    this.plugin('done', function (stats) {\n       for(var key in stats.toJson().entrypoints) {\n          var htmlPath = path.join(ROOT_PATH, 'template', key + '.html');\n          var htmlContent = fs.readFileSync(htmlPath, 'utf8');\n          var keyJSRegExp = new RegExp('js\\/' + key + '(.*?)\\.js');\n          var keyCSSRegExp = new RegExp('css\\/' + key + '(.*?)\\.css');\n          var keyAssets = [].concat(stats.toJson().assetsByChunkName[key]);\n          var commonAssets = [].concat(stats.toJson().assetsByChunkName['common']);\n          var htmlOutput = '';\n          var keyJS = keyAssets.filter(path => path.endsWith('.js'))[0];\n          var keyCSS = keyAssets.filter(path => path.endsWith('.css'))[0];\n          if(keyJS) {\n               htmlOutput = htmlContent.replace(keyJSRegExp, keyJS);\n          }\n          if(keyCSS) {\n               htmlOutput = htmlOutput.replace(keyCSSRegExp, keyCSS);\n          }\n          var commonJS = commonAssets.filter(path => path.endsWith('.js'))[0];\n          var commonCSS = commonAssets.filter(path => path.endsWith('.css'))[0];\n          if(commonJS) {\n               htmlOutput = htmlOutput.replace(/js\\/common(.*?)\\.js/g, commonJS);\n          }\n          if(commonCSS) {\n               htmlOutput = htmlOutput.replace(/css\\/common(.*?)\\.css/g, commonCSS);\n          }\n          fs.writeFileSync(htmlPath, htmlOutput);\n       }\n    });\n}\n```\n\n**Refs:**\n[LOADING WEBPACK BUNDLES WITH HASH VALUE](http://www.weicon9.com/2016/11/Loading-Webpack-Bundles-With-Hash-Value/)\n\n\n### polyfill引入方式比较\nbabel-core/babel-preset-*等插件可以将语法从 es6 转成 es5，但没有提供 api 的转码功能，如 Promise、Set、Map 等新增对象，Object.assign、Object.entries 等全局对象上的新增方法都不会转码， babel-runtime 和 babel-polyfill 就是为此而生。这两个模块功能几乎相同，就是转码新增 api，模拟 es6 环境，但实现方法完全不同。\n\n#### babel-polyfill库\nbabel-polyfill 的做法是将全局对象通通污染一遍，比如相应使用includes方法，会通过Array.prototype.includes() 的方式去注入污染原型。对于普通的业务代码没有关系，如果不在意略大的体积（min后86kb），推荐使用；但如果用在开发library，则不推荐使用，会污染该library使用者的环境。\n\n#### babel-runtime库和babel-plugin-transform-runtime 插件\nbabel-runtime 的做法是自己手动引入 helper 函数，const Promise = require('babel-runtime/core-js/promise') 就可以引入 Promise，但是很不方便。\n借助babel-plugin-transform-runtime插件，可以帮助我们按需加载polyfill，这个模块会将我们的代码重写，如将 Promise 重写成 _Promise（只是打比方），然后引入_Promise helper 函数。此外，babel-runtime 不能转码实例方法，比如这样的代码：\n``` javascript\n'!!!'.repeat(3);\n'hello'.includes('h');\n```\n这只能通过 babel-polyfill 来转码，因为 babel-polyfill 是直接在原型链上增加方法。\n\n如果在开发library，为了避免污染使用者的环境，只能用 babel-runtime + babel-plugin-transform-runtime。虽然是业务开发，但是因为移动端比较介意babel-polyfill的体积，所以我还是选择了babel-runtime。\n\n\n#####  .babelrc中的相关配置\n``` json\n{\n    \"plugins\": [\n        [\"transform-runtime\", {\n            \"helper\": false,  //开启helper后，统一引用了helper\n            \"polyfill\": true,  //Map, Set, Promise,Object.assign等\n            \"regenerator\": true, //主要是实现generator/yeild，async/await\n            \"moduleName\": \"babel-runtime\"\n        }]\n    ]\n}\n```\n`helper`设为true时，会引入一些 helper 来代替每次都生成的通用函数，原来构建好的代码每个模块都有类似这种代码：\n``` javascript\n    function _classCallCheck(instance, Constructor)...\n    function _possibleConstructorReturn(self, call)...\n    function _inherits(subClass, superClass)...\n```\n`开启helper后`\n``` javascript\n  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n  var _inherits2 = require('babel-runtime/helpers/inherits');\n```\n在v6.12.0 (2016-07-27) 后增加了 helper 的配置，原因是从 babel-runtime 里引入的 helper 依赖很多，全部都是兼容最底层的。比如 Object.create typeof 这种方法全部被重写了，会导致构建模块变大。\n`开启polyfill后`，Object.assign方法会被改写为`__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()`。\n`regenerator设为true`，使我们可以使用generator/yeild，async/await。如果你只需要用 regenerator，不需要 core-js 里面的 polyfill 那你就可以在 options 中把 polyfill 设为 false。\n\n#### babel-preset-env插件\n> 版本支持：babel 7.0beta版、babel-loader 8.0 beta版和babel-preset-env 2.0beta版\n```bash\nnpm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env  --save-dev\n```\n首先需要安装babel-polyfill\n``` bash\nnpm install @babel/polyfill --save\n```\n配置\"useBuiltIns\": \n- false: 不对polyfills做任何操作\n- entry: 根据target中浏览器版本的支持，将polyfills拆分引入，仅引入有浏览器不支持的polyfill，通过`import 'babel-polyfill'`方式在代码中一次性引入\n- usage(新)：检测代码中ES6/7/8等的使用情况，仅仅加载代码中用到的polyfills\n\n这种方式配置非常方便，并且可以按需加载，后续会替换成该插件。\n\n**Refs:**\n[babel-preset-env](https://github.com/babel/babel/tree/master/experimental/babel-preset-env)\n[按需加载polyfill——babel7的正确打开方式](https://erasermeng.github.io/2017/11/02/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BDpolyfill%E2%80%94%E2%80%94babel7%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/)\n[ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍](http://blog.csdn.net/a324539017/article/details/52824189)\n[再见，babel-preset-2015](https://zhuanlan.zhihu.com/p/29506685)\n\n### 记录正文页历史滚动位置\n在开发过程中，发现每次返回到历史页面时，都不是上次访问到的页面位置，而是重置到了顶部，react并没有去维护历史页面的滚动位置。所以我们需要手动去记录页面的历史滚动位置。\n##### 可能的方案\n1.  使用window的onpopstate、onload、onunload事件监听页面的前进、返回，利用command模式维护posUndoStack和posRedoStack栈，记录并保存页面的历史位置\n  问题：结合了history.length去判断页面是前进、返回or新进了一个页面，但是当从b页面返回到a页面后，又点击进入了b页面后，history.length不变，链接不变，这个时候无法辨别浏览器的行为\n2. [react-router-scroll组件](http://npm.taobao.org/package/react-router-scroll)\n   问题：基于react-router，基于router middleware实现的，使用的Router V4没有中间件的概念\n3. 基于history.location.key属性的实现\n  问题：基于react-router\n\n##### 最终方案\n由于目前没有好的办法去记录所有页面的位置，而记录正文页阅读位置的需求最为必要，所以使用第三个方案，暂时忽略其他页面。使用BrowserRouter的页面支持location.key属性，这个location是react-router引用的history库中的location对象，每个页面有唯一标识的key值。\n\n> React-router官网: 使用 hash 的方式记录导航历史不支持 location.key，在以前的版本中，我们为这种行为提供了shim，但是仍有一些问题我们无法解决。\n\nreact-router使用的history库在createBrowserHistory时，会调用createKey方法创建页面的key值，key的长度默认为6，可以设置。\n``` javascript\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n```\ncreateBrowserHistory类中维护了一个数组allkeys，里面记录了所有页面的location.key。\n``` javascript\nvar allKeys = [initialLocation.key];\n```\n在SPA中的每个页面的history的state中则记录了该页面的key。\n``` javascript\nglobalHistory.pushState({ key: key, state: state }, null, href);\n```\n在监听到popState事件后，会通过event拿到进入页面的state，里面记录了key值。\n``` javascript\nwindow.onpopstate = function(event) {\n  alert(state: \" + JSON.stringify(event.state));\n};\n```\n所以在页面返回、前进的时候，同一页面的location.key不变，据此可以在页面离开的时候，用key-value的形式保存当前key值和对应的滚动位置在sessionStorage中。页面离开的情况有：\n``` javascript\n//SPA页面内路由到其他章节\ncomponentWillReceiveProps(nextProps) {\n    posReserve.onLeave(this.props.location.key);\n}\n//页面unload\nwindow.onunload = () => {\n    posReserve.onLeave(this.props.location.key);\n}\n```\n在页面前进、返回的时候，去sessionStorage中读取历史位置，并滚动页面到对应位置。\n\n\n### ios微信中SPA正文页返回问题\n#### 问题1：正文内部返回白屏\n在IOS微信浏览器中阅读正文，返回上一章的时候期望显示上一章内容，但是会出现白屏的问题，需要上滑或者下滑页面，正文才会出现。\n在寻找解决方案的时候，发现Vue存在相似的问题：\n  [iOS Safari renders blank page](https://github.com/vuejs/vue/issues/5533)\n  [ios 组件点返回白屏遮挡问题](https://github.com/ElemeFE/mint-ui/issues/937)\n参考了其中的解决方案，在正文内容加载完成后通过js去触发scroll滚动，正文显示就恢复正常了。代码如下所示，尝试了下面两种方式，都可以解决问题。\n``` javascript\n    componentDidMount() {\n        window.scrollTo(0, 1)\n        window.scrollTo(0, 0)\n        //或者\n        setTimeout(() => {\n          window.scrollTo(0, 0)\n        }, 100)\n    }\n```\n\n#### 问题2: 从其他页面返回正文问题\n使用`Preact`的时候，从其他页面返回到正文页后，部分请求没有发出。\n在debug的时候发现正文页setState没有触发componentWillUpdate，不会rerender，setState的callback不被执行。当从Preact替换为React的时候，页面显示正常。\n- 猜测1: 可能和preact的diff机制有关。因为'对一个虚拟DOM子树是否继续更新下去，如果它们的type, props,key都一样，或者它们的引用也一样，可能也会继续diff，官方还会比较context!!!!这个许多react-like没有考虑到。`React-Router就非常依赖context对象进行多层的组件间传递`'。\n- 猜测2: setState回调延后\n知乎问答‘[如何看待 React 的替代框架 Preact](https://www.zhihu.com/question/65479147/answer/231505912?utm_source=wechat_session&utm_medium=social&utm_campaign=ge13_2&utm_division=ge13_3)’中蓝面小生和司徒正美的回答中列出了Preact存在的一些问题。\n\n##### 解决方案\n如果继续使用Preact可以通过reload页面解决问题，当从正文页跳转到其他页面时候，记录下当前页面的`location.key`在sessionStorage中，返回页面时在componentWillMount方法中判断当前key值是否存储在'N_reader_locKeys'，若存在，则说明是页面返回，reload页面，并且从'N_reader_locKeys'中删掉对应的key值。\n``` javascript\n    componentWillMount() {\n        let _key = this.props.location.key;\n        let locKeys = sessionStorage.getItem('N_reader_locKeys');\n        if(isIos && _key && locKeys){\n            sessionStorage.removeItem('N_reader_locKey')\n            let index = locKeys.indexOf(_key);\n            if(~index && this.props.history.action === 'POP') {\n                sessionStorage.setItem('N_reader_locKeys', locKeys.slice(0, index) + locKeys.slice(index + _key.length + 1));\n                location.reload();\n                return false;\n            }\n        }\n    }\n\n    //[IOS微信返回bug处理]记录所有点击跳到其他页面(结合href和isexternal值)\n    bindEvent() {\n        document.addEventListener('click', e => {\n            let targetEle = e.target;\n            if(targetEle.tagName.toLowerCase() === 'a') {\n                if(targetEle.href.indexOf('.do') !== -1 || (targetEle.getAttribute('isexternal') === 'true')) {\n                    e.preventDefault();\n                    let _key = this.props.location.key;\n                    let keys = sessionStorage.getItem('N_reader_locKeys') || '';\n                    if(_key && keys.indexOf(_key) === -1) {\n                        keys += _key + ','\n                        sessionStorage.setItem('N_reader_locKeys', keys);\n                    }\n                    if(targetEle.href.indexOf('.do') !== -1) {\n                        location.href = targetEle.href;\n                    }\n                }\n            }\n        })\n    }\n```\n鉴于在某ios9版本的iphone5s上正常打开正文一直会出现上述问题，且考虑逻辑的复杂性、未来的需求扩展，最终还是**`使用React替换了Preact`**。逻辑越复杂，Preact暴露的问题越多。\n\n#### 问题3：微信url地址问题\n在IOS微信中，使用history的replaceState、pushState，url栏不变，分享或者通过浏览器打开都还是之前的url。\n##### 详情\n从首页进入正文，通常只带sourceUuid不带articleUuid，在加载当前章节的时候期望通过history.replaceState去更新当前url为带articleUuid，这样当从下一章返回的时候，可以正确显示当前内容，不然会自动获取当前进度，无法显示正确章节。安卓可以正常返回，但ios微信返回的时候url还是不带articleUuid。\n##### 解决方案\n原因是使用H5的history API并不能改变url栏地址内容，分享或通过浏览器打开都是旧的地址，是ios微信的一个bug。改用react-router的history.replace去更新章节可以解决返回问题。\n原理是虽然地址栏不变，但通过location.href获得的是正确的地址，BrowserRouter单页面应用在切换页面的时候会从window.location中读取`{pathname,search,hash}`，创建自己的location对象，依据location对象去渲染页面。\n\n**Refs: **\n[H5 history.pushState 在微信内修改url后点击用safari打开/复制链接是修改之前的页面](https://github.com/Tencent/weui/issues/125)\n\n\n### lib.flexible方案\n使用淘宝`lib.flexible`的rem方案，会遇到一个**问题**：在ios微信内长按扫描二维码，会有无法识别二维码的问题。[微信已修复该问题]\n> [微信识别二维码的原理机制](http://mp.weixin.qq.com/s?__biz=NzA3OTQ2OTgw&mid=205918916&idx=1&sn=d729ef70ea1e7fc50e649352a63a2564&scene=1&key=c76941211a49ab586ba4831f2f6fa42fbb2525460003fa8e19bc205b9b25facbf60da78977da071ddbc41a5be6a7b9fa&ascene=0&uin=NTE3ODg0NjE1&devicetype=iMac%20MacBookPro12,1%20OSX%20OSX%2010.10.3%20build%2814D136%29&version=11020012&pass_ticket=WPa8XnvIzBrBOA6RHy2RMECcrsuN2QiksK8Y1Z/D3Odk49uIsXOex7EV2NXN9m5X)\n> 这里采用的逻辑是截屏识别，当客户端发现用户在网页的img标签内进行长按操作时，会立刻截屏并且启动二维码识别算法。所以这里用于二维码识别的图片是截屏，而不是之前有人提到的img标签中的图片。\n\n实践发现meta scale指定为1的时候，无该问题。`问题产生的原因`应该是：在iOS下，对于dpr(设备像素比)2和3的屏，用2倍和3倍的方案，其余的用1倍方案。使用高清屏方案后，viewport的scale值会设为1/dpr，页面发生了缩放，二维码的位置实际发生了偏移，因而微信无法准确识别出二维码。\n设备像素比 = 物理像素 / 设备独立像素；\n- 物理像素：一个物理像素是显示器(手机屏幕)上最小的物理显示单元；\n- 设备独立像素：设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。\n在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。 在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。\n\n为了解决二维码识别问题，在html中手动添加viewport的meta标签，这样页面就会根据已有的meta标签设置缩放比例，不会使用高清方案。不使用高清方案一个不好的地方是1px边框问题，不过可以通过伪元素搭配transform:scale(0.5)解决。\n``` javascript\n    var metaEl = doc.querySelector('meta[name=\"viewport\"]');\n    if (metaEl) {\n        console.warn('将根据已有的meta标签来设置缩放比例');\n        var match = metaEl.getAttribute('content').match(/initial\\-scale=([\\d\\.]+)/);\n        if (match) {\n            scale = parseFloat(match[1]);\n            dpr = parseInt(1 / scale);\n        }\n    }\n```\n``` css\n.method-list:after{\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 200%;\n    height: 200%;\n    border-bottom: 1px solid #E1E1E1;\n    -webkit-transform: scale(0.5);\n    transform: scale(0.5);\n    -webkit-transform-origin: 0 0;\n    transform-origin: 0 0;\n    box-sizing: border-box;;\n}\n```\n","source":"_posts/分站开发总结.md","raw":"---\ntitle: 项目开发record\ndate: 2017-07-27 09:38:34\ntags: [总结, react, webpack]\n---\n###  前端目录结构\n基于React + React-Router + Sass开发的webpack打包的多页面应用，其中正文页面和搜索页面是基于React-Router开发的单页面应用。路由类型采用的是BrowserRouter，在移动端pushState/replaceState没有兼容问题，可以放心使用。如果是要兼容IE9及以下，则不能使用BrowserRouter，建议使用HashRouter。此外，使用BrowserRouter后，可以借助history的特性帮助我们实现记录每个页面的历史停留位置。\n```\n|-- assets\n  |\n  |-- config //webpack编译\n  |    |-- base.js //基础编译配置\n  |    |-- dev.js  //开发环境编译配置\n  |    |-- dll.js  //动态链接库编译配置\n  |    |-- hot.js  //热替换编译配置\n  |    |-- prod.js //开发环境编译配置\n  |    |-- util.js //定义配置相关的通用方法和变量\n  |\n  |-- src                //源码目录\n  |    |-- component        // 组件\n  |    |      |-- common      //公共组件\n  |    |      |--             //其他子组件\n  |    |-- entry              //入口js，与静态html文件相对应\n  |    |-- util               //通用方法\n  |    |-- image            //图片资源\n  |    |-- style            //样式\n  |\n  |-- template              //html模板，动态生成html文件\n  |\n  |-- mock.json      // mock数据\n  |-- server_hot.js  //实现热更新、拦截并处理前端请求(返回本地页面、mock数据，其他请求转发到服务端处理)  \n  |\n|-- dist //构建目录\n```\n其中，模板中是静态html文件，在没有添加后端路由的情况下，通过server_hot.js中的页面映射去访问前端页面，例如当匹配到路径/index时，返回index.html页面，结合mock数据，真正实现了前后端分离。\n``` javascript\nlet templateMap = {\n    '/search': 'search.html',\n    '/search/book': 'search.html',\n    '/index': 'index.html',\n    '/history': 'history.html',\n    '/rank': 'rank.html',\n    '/home/more': 'more.html',\n    '/category': 'category.html',\n    '/info': 'info.html',\n    '/detail': 'detail.html',\n    '/book/reader': 'reader.html',\n    '/recharge': 'recharge.html',\n    '/catalog': 'catalog.html'\n}\n\nfor (let mapItem in templateMap) {\n    app.get(mapItem, function(req, res) {\n        res.sendFile(__dirname + '/template/' + templateMap[mapItem]);\n    });\n}\n```\n\n#### API转发后获取服务端数据失败的问题\n在使用http-proxy-middleware转发请求到后端时，发现有部分请求无法获得返回数据，首先可以确定的是请求被转发到后端了。调试发现后端会验证站点相关信息，在验证host的时候报错。猜测可能是请求转发后header里的host信息丢失，查询[API](https://www.npmjs.com/package/http-proxy-middleware#http-proxy-middleware-options)发现可以设置option.headers，如下所示。\n``` javascript\nvar proxyMiddleware = require('http-proxy-middleware');\nvar apiProxy = proxyMiddleware('/api', { target: 'http://ypxst.kuxuanbook.yuedu.163.com', headers: {host: 'ypxst.kuxuanbook.yuedu.163.com'}});\n```\n设置好host后，就可以正常获取接口返回数据了。\n\n#### POST请求验证XSRF-TOKEN\n之前阅读常用的方式是后端写入freemarker模板或者通过异步接口获得，这次和后端约定统一放在cookie中。\n``` javascript\n headers: {\n     'Content-Type': 'application/x-www-form-urlencoded',\n     'X-XSRF-TOKEN': csrf_token\n }\n```\n从cookie中读取token后封装在post接口中，写在headers里面，这样在使用的时候就直接调用post方法，无需关注token验证。\n\n#### 使用git subtree同步assets工程\nassets资源存在于novel-webapp-wap和novel-webapp-recharge两个工程下面，recharge工程下面用到的是充值页面，其他页面都在wap工程下，之所以分开为两个工程是因为涉及到支付，充值的域名需要是唯一的，而分站的域名很多。为了保证二者资源的同步，可以使用git subtree实现子工程的同步。\n``` bash\n# 获取远端novel-webapp-assets的更新\ngit subtree pull --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash\n\n# 将本地assets更新推送到远端novel-webapp-assets\ngit subtree push --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash\n```\n<!-- more -->\n#### webpack替换文件链接的资源\n通过给chunk filename添加[chunkhash]去有效地缓存文件，每次修改后生成新的chunkhash值，手动替换很麻烦，所以结合done plugin去完成html文件中资源名字的自动替换。\nstats记录了打包信息和相应的chunkhash值，其中assetsByChunkName包含了以chunkname作为key，filename作为值的对象，结构如下：\n``` json\n  \"assetsByChunkName\": {\n    \"reader\": [\n      \"js/reader-60b54d52.js\",\n      \"css/reader-60b54d52.css\"\n    ],\n    //...\n    \"common\": [\n      \"js/common-a814792a.bundle.js\",\n      \"css/common-a814792a.css\"\n    ]\n  }\n```\n遍历stats对象中的entrypoints，这里的entrypoints的key值和html文件名一致、且一一对应的，根据key值读取可以读取对应的html文件，通过正则匹配的方式将对应的js、css文件替换为本次打包生成的文件。\n``` javascript\nfunction () {\n    this.plugin('done', function (stats) {\n       for(var key in stats.toJson().entrypoints) {\n          var htmlPath = path.join(ROOT_PATH, 'template', key + '.html');\n          var htmlContent = fs.readFileSync(htmlPath, 'utf8');\n          var keyJSRegExp = new RegExp('js\\/' + key + '(.*?)\\.js');\n          var keyCSSRegExp = new RegExp('css\\/' + key + '(.*?)\\.css');\n          var keyAssets = [].concat(stats.toJson().assetsByChunkName[key]);\n          var commonAssets = [].concat(stats.toJson().assetsByChunkName['common']);\n          var htmlOutput = '';\n          var keyJS = keyAssets.filter(path => path.endsWith('.js'))[0];\n          var keyCSS = keyAssets.filter(path => path.endsWith('.css'))[0];\n          if(keyJS) {\n               htmlOutput = htmlContent.replace(keyJSRegExp, keyJS);\n          }\n          if(keyCSS) {\n               htmlOutput = htmlOutput.replace(keyCSSRegExp, keyCSS);\n          }\n          var commonJS = commonAssets.filter(path => path.endsWith('.js'))[0];\n          var commonCSS = commonAssets.filter(path => path.endsWith('.css'))[0];\n          if(commonJS) {\n               htmlOutput = htmlOutput.replace(/js\\/common(.*?)\\.js/g, commonJS);\n          }\n          if(commonCSS) {\n               htmlOutput = htmlOutput.replace(/css\\/common(.*?)\\.css/g, commonCSS);\n          }\n          fs.writeFileSync(htmlPath, htmlOutput);\n       }\n    });\n}\n```\n\n**Refs:**\n[LOADING WEBPACK BUNDLES WITH HASH VALUE](http://www.weicon9.com/2016/11/Loading-Webpack-Bundles-With-Hash-Value/)\n\n\n### polyfill引入方式比较\nbabel-core/babel-preset-*等插件可以将语法从 es6 转成 es5，但没有提供 api 的转码功能，如 Promise、Set、Map 等新增对象，Object.assign、Object.entries 等全局对象上的新增方法都不会转码， babel-runtime 和 babel-polyfill 就是为此而生。这两个模块功能几乎相同，就是转码新增 api，模拟 es6 环境，但实现方法完全不同。\n\n#### babel-polyfill库\nbabel-polyfill 的做法是将全局对象通通污染一遍，比如相应使用includes方法，会通过Array.prototype.includes() 的方式去注入污染原型。对于普通的业务代码没有关系，如果不在意略大的体积（min后86kb），推荐使用；但如果用在开发library，则不推荐使用，会污染该library使用者的环境。\n\n#### babel-runtime库和babel-plugin-transform-runtime 插件\nbabel-runtime 的做法是自己手动引入 helper 函数，const Promise = require('babel-runtime/core-js/promise') 就可以引入 Promise，但是很不方便。\n借助babel-plugin-transform-runtime插件，可以帮助我们按需加载polyfill，这个模块会将我们的代码重写，如将 Promise 重写成 _Promise（只是打比方），然后引入_Promise helper 函数。此外，babel-runtime 不能转码实例方法，比如这样的代码：\n``` javascript\n'!!!'.repeat(3);\n'hello'.includes('h');\n```\n这只能通过 babel-polyfill 来转码，因为 babel-polyfill 是直接在原型链上增加方法。\n\n如果在开发library，为了避免污染使用者的环境，只能用 babel-runtime + babel-plugin-transform-runtime。虽然是业务开发，但是因为移动端比较介意babel-polyfill的体积，所以我还是选择了babel-runtime。\n\n\n#####  .babelrc中的相关配置\n``` json\n{\n    \"plugins\": [\n        [\"transform-runtime\", {\n            \"helper\": false,  //开启helper后，统一引用了helper\n            \"polyfill\": true,  //Map, Set, Promise,Object.assign等\n            \"regenerator\": true, //主要是实现generator/yeild，async/await\n            \"moduleName\": \"babel-runtime\"\n        }]\n    ]\n}\n```\n`helper`设为true时，会引入一些 helper 来代替每次都生成的通用函数，原来构建好的代码每个模块都有类似这种代码：\n``` javascript\n    function _classCallCheck(instance, Constructor)...\n    function _possibleConstructorReturn(self, call)...\n    function _inherits(subClass, superClass)...\n```\n`开启helper后`\n``` javascript\n  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n  var _inherits2 = require('babel-runtime/helpers/inherits');\n```\n在v6.12.0 (2016-07-27) 后增加了 helper 的配置，原因是从 babel-runtime 里引入的 helper 依赖很多，全部都是兼容最底层的。比如 Object.create typeof 这种方法全部被重写了，会导致构建模块变大。\n`开启polyfill后`，Object.assign方法会被改写为`__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()`。\n`regenerator设为true`，使我们可以使用generator/yeild，async/await。如果你只需要用 regenerator，不需要 core-js 里面的 polyfill 那你就可以在 options 中把 polyfill 设为 false。\n\n#### babel-preset-env插件\n> 版本支持：babel 7.0beta版、babel-loader 8.0 beta版和babel-preset-env 2.0beta版\n```bash\nnpm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env  --save-dev\n```\n首先需要安装babel-polyfill\n``` bash\nnpm install @babel/polyfill --save\n```\n配置\"useBuiltIns\": \n- false: 不对polyfills做任何操作\n- entry: 根据target中浏览器版本的支持，将polyfills拆分引入，仅引入有浏览器不支持的polyfill，通过`import 'babel-polyfill'`方式在代码中一次性引入\n- usage(新)：检测代码中ES6/7/8等的使用情况，仅仅加载代码中用到的polyfills\n\n这种方式配置非常方便，并且可以按需加载，后续会替换成该插件。\n\n**Refs:**\n[babel-preset-env](https://github.com/babel/babel/tree/master/experimental/babel-preset-env)\n[按需加载polyfill——babel7的正确打开方式](https://erasermeng.github.io/2017/11/02/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BDpolyfill%E2%80%94%E2%80%94babel7%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/)\n[ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍](http://blog.csdn.net/a324539017/article/details/52824189)\n[再见，babel-preset-2015](https://zhuanlan.zhihu.com/p/29506685)\n\n### 记录正文页历史滚动位置\n在开发过程中，发现每次返回到历史页面时，都不是上次访问到的页面位置，而是重置到了顶部，react并没有去维护历史页面的滚动位置。所以我们需要手动去记录页面的历史滚动位置。\n##### 可能的方案\n1.  使用window的onpopstate、onload、onunload事件监听页面的前进、返回，利用command模式维护posUndoStack和posRedoStack栈，记录并保存页面的历史位置\n  问题：结合了history.length去判断页面是前进、返回or新进了一个页面，但是当从b页面返回到a页面后，又点击进入了b页面后，history.length不变，链接不变，这个时候无法辨别浏览器的行为\n2. [react-router-scroll组件](http://npm.taobao.org/package/react-router-scroll)\n   问题：基于react-router，基于router middleware实现的，使用的Router V4没有中间件的概念\n3. 基于history.location.key属性的实现\n  问题：基于react-router\n\n##### 最终方案\n由于目前没有好的办法去记录所有页面的位置，而记录正文页阅读位置的需求最为必要，所以使用第三个方案，暂时忽略其他页面。使用BrowserRouter的页面支持location.key属性，这个location是react-router引用的history库中的location对象，每个页面有唯一标识的key值。\n\n> React-router官网: 使用 hash 的方式记录导航历史不支持 location.key，在以前的版本中，我们为这种行为提供了shim，但是仍有一些问题我们无法解决。\n\nreact-router使用的history库在createBrowserHistory时，会调用createKey方法创建页面的key值，key的长度默认为6，可以设置。\n``` javascript\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n```\ncreateBrowserHistory类中维护了一个数组allkeys，里面记录了所有页面的location.key。\n``` javascript\nvar allKeys = [initialLocation.key];\n```\n在SPA中的每个页面的history的state中则记录了该页面的key。\n``` javascript\nglobalHistory.pushState({ key: key, state: state }, null, href);\n```\n在监听到popState事件后，会通过event拿到进入页面的state，里面记录了key值。\n``` javascript\nwindow.onpopstate = function(event) {\n  alert(state: \" + JSON.stringify(event.state));\n};\n```\n所以在页面返回、前进的时候，同一页面的location.key不变，据此可以在页面离开的时候，用key-value的形式保存当前key值和对应的滚动位置在sessionStorage中。页面离开的情况有：\n``` javascript\n//SPA页面内路由到其他章节\ncomponentWillReceiveProps(nextProps) {\n    posReserve.onLeave(this.props.location.key);\n}\n//页面unload\nwindow.onunload = () => {\n    posReserve.onLeave(this.props.location.key);\n}\n```\n在页面前进、返回的时候，去sessionStorage中读取历史位置，并滚动页面到对应位置。\n\n\n### ios微信中SPA正文页返回问题\n#### 问题1：正文内部返回白屏\n在IOS微信浏览器中阅读正文，返回上一章的时候期望显示上一章内容，但是会出现白屏的问题，需要上滑或者下滑页面，正文才会出现。\n在寻找解决方案的时候，发现Vue存在相似的问题：\n  [iOS Safari renders blank page](https://github.com/vuejs/vue/issues/5533)\n  [ios 组件点返回白屏遮挡问题](https://github.com/ElemeFE/mint-ui/issues/937)\n参考了其中的解决方案，在正文内容加载完成后通过js去触发scroll滚动，正文显示就恢复正常了。代码如下所示，尝试了下面两种方式，都可以解决问题。\n``` javascript\n    componentDidMount() {\n        window.scrollTo(0, 1)\n        window.scrollTo(0, 0)\n        //或者\n        setTimeout(() => {\n          window.scrollTo(0, 0)\n        }, 100)\n    }\n```\n\n#### 问题2: 从其他页面返回正文问题\n使用`Preact`的时候，从其他页面返回到正文页后，部分请求没有发出。\n在debug的时候发现正文页setState没有触发componentWillUpdate，不会rerender，setState的callback不被执行。当从Preact替换为React的时候，页面显示正常。\n- 猜测1: 可能和preact的diff机制有关。因为'对一个虚拟DOM子树是否继续更新下去，如果它们的type, props,key都一样，或者它们的引用也一样，可能也会继续diff，官方还会比较context!!!!这个许多react-like没有考虑到。`React-Router就非常依赖context对象进行多层的组件间传递`'。\n- 猜测2: setState回调延后\n知乎问答‘[如何看待 React 的替代框架 Preact](https://www.zhihu.com/question/65479147/answer/231505912?utm_source=wechat_session&utm_medium=social&utm_campaign=ge13_2&utm_division=ge13_3)’中蓝面小生和司徒正美的回答中列出了Preact存在的一些问题。\n\n##### 解决方案\n如果继续使用Preact可以通过reload页面解决问题，当从正文页跳转到其他页面时候，记录下当前页面的`location.key`在sessionStorage中，返回页面时在componentWillMount方法中判断当前key值是否存储在'N_reader_locKeys'，若存在，则说明是页面返回，reload页面，并且从'N_reader_locKeys'中删掉对应的key值。\n``` javascript\n    componentWillMount() {\n        let _key = this.props.location.key;\n        let locKeys = sessionStorage.getItem('N_reader_locKeys');\n        if(isIos && _key && locKeys){\n            sessionStorage.removeItem('N_reader_locKey')\n            let index = locKeys.indexOf(_key);\n            if(~index && this.props.history.action === 'POP') {\n                sessionStorage.setItem('N_reader_locKeys', locKeys.slice(0, index) + locKeys.slice(index + _key.length + 1));\n                location.reload();\n                return false;\n            }\n        }\n    }\n\n    //[IOS微信返回bug处理]记录所有点击跳到其他页面(结合href和isexternal值)\n    bindEvent() {\n        document.addEventListener('click', e => {\n            let targetEle = e.target;\n            if(targetEle.tagName.toLowerCase() === 'a') {\n                if(targetEle.href.indexOf('.do') !== -1 || (targetEle.getAttribute('isexternal') === 'true')) {\n                    e.preventDefault();\n                    let _key = this.props.location.key;\n                    let keys = sessionStorage.getItem('N_reader_locKeys') || '';\n                    if(_key && keys.indexOf(_key) === -1) {\n                        keys += _key + ','\n                        sessionStorage.setItem('N_reader_locKeys', keys);\n                    }\n                    if(targetEle.href.indexOf('.do') !== -1) {\n                        location.href = targetEle.href;\n                    }\n                }\n            }\n        })\n    }\n```\n鉴于在某ios9版本的iphone5s上正常打开正文一直会出现上述问题，且考虑逻辑的复杂性、未来的需求扩展，最终还是**`使用React替换了Preact`**。逻辑越复杂，Preact暴露的问题越多。\n\n#### 问题3：微信url地址问题\n在IOS微信中，使用history的replaceState、pushState，url栏不变，分享或者通过浏览器打开都还是之前的url。\n##### 详情\n从首页进入正文，通常只带sourceUuid不带articleUuid，在加载当前章节的时候期望通过history.replaceState去更新当前url为带articleUuid，这样当从下一章返回的时候，可以正确显示当前内容，不然会自动获取当前进度，无法显示正确章节。安卓可以正常返回，但ios微信返回的时候url还是不带articleUuid。\n##### 解决方案\n原因是使用H5的history API并不能改变url栏地址内容，分享或通过浏览器打开都是旧的地址，是ios微信的一个bug。改用react-router的history.replace去更新章节可以解决返回问题。\n原理是虽然地址栏不变，但通过location.href获得的是正确的地址，BrowserRouter单页面应用在切换页面的时候会从window.location中读取`{pathname,search,hash}`，创建自己的location对象，依据location对象去渲染页面。\n\n**Refs: **\n[H5 history.pushState 在微信内修改url后点击用safari打开/复制链接是修改之前的页面](https://github.com/Tencent/weui/issues/125)\n\n\n### lib.flexible方案\n使用淘宝`lib.flexible`的rem方案，会遇到一个**问题**：在ios微信内长按扫描二维码，会有无法识别二维码的问题。[微信已修复该问题]\n> [微信识别二维码的原理机制](http://mp.weixin.qq.com/s?__biz=NzA3OTQ2OTgw&mid=205918916&idx=1&sn=d729ef70ea1e7fc50e649352a63a2564&scene=1&key=c76941211a49ab586ba4831f2f6fa42fbb2525460003fa8e19bc205b9b25facbf60da78977da071ddbc41a5be6a7b9fa&ascene=0&uin=NTE3ODg0NjE1&devicetype=iMac%20MacBookPro12,1%20OSX%20OSX%2010.10.3%20build%2814D136%29&version=11020012&pass_ticket=WPa8XnvIzBrBOA6RHy2RMECcrsuN2QiksK8Y1Z/D3Odk49uIsXOex7EV2NXN9m5X)\n> 这里采用的逻辑是截屏识别，当客户端发现用户在网页的img标签内进行长按操作时，会立刻截屏并且启动二维码识别算法。所以这里用于二维码识别的图片是截屏，而不是之前有人提到的img标签中的图片。\n\n实践发现meta scale指定为1的时候，无该问题。`问题产生的原因`应该是：在iOS下，对于dpr(设备像素比)2和3的屏，用2倍和3倍的方案，其余的用1倍方案。使用高清屏方案后，viewport的scale值会设为1/dpr，页面发生了缩放，二维码的位置实际发生了偏移，因而微信无法准确识别出二维码。\n设备像素比 = 物理像素 / 设备独立像素；\n- 物理像素：一个物理像素是显示器(手机屏幕)上最小的物理显示单元；\n- 设备独立像素：设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。\n在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。 在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。\n\n为了解决二维码识别问题，在html中手动添加viewport的meta标签，这样页面就会根据已有的meta标签设置缩放比例，不会使用高清方案。不使用高清方案一个不好的地方是1px边框问题，不过可以通过伪元素搭配transform:scale(0.5)解决。\n``` javascript\n    var metaEl = doc.querySelector('meta[name=\"viewport\"]');\n    if (metaEl) {\n        console.warn('将根据已有的meta标签来设置缩放比例');\n        var match = metaEl.getAttribute('content').match(/initial\\-scale=([\\d\\.]+)/);\n        if (match) {\n            scale = parseFloat(match[1]);\n            dpr = parseInt(1 / scale);\n        }\n    }\n```\n``` css\n.method-list:after{\n    content: '';\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 200%;\n    height: 200%;\n    border-bottom: 1px solid #E1E1E1;\n    -webkit-transform: scale(0.5);\n    transform: scale(0.5);\n    -webkit-transform-origin: 0 0;\n    transform-origin: 0 0;\n    box-sizing: border-box;;\n}\n```\n","slug":"分站开发总结","published":1,"updated":"2019-03-18T08:38:47.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx8e003bqmhf6wve4uo1","content":"<h3 id=\"前端目录结构\"><a href=\"#前端目录结构\" class=\"headerlink\" title=\"前端目录结构\"></a>前端目录结构</h3><p>基于React + React-Router + Sass开发的webpack打包的多页面应用，其中正文页面和搜索页面是基于React-Router开发的单页面应用。路由类型采用的是BrowserRouter，在移动端pushState/replaceState没有兼容问题，可以放心使用。如果是要兼容IE9及以下，则不能使用BrowserRouter，建议使用HashRouter。此外，使用BrowserRouter后，可以借助history的特性帮助我们实现记录每个页面的历史停留位置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- assets</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- config //webpack编译</span><br><span class=\"line\">  |    |-- base.js //基础编译配置</span><br><span class=\"line\">  |    |-- dev.js  //开发环境编译配置</span><br><span class=\"line\">  |    |-- dll.js  //动态链接库编译配置</span><br><span class=\"line\">  |    |-- hot.js  //热替换编译配置</span><br><span class=\"line\">  |    |-- prod.js //开发环境编译配置</span><br><span class=\"line\">  |    |-- util.js //定义配置相关的通用方法和变量</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- src                //源码目录</span><br><span class=\"line\">  |    |-- component        // 组件</span><br><span class=\"line\">  |    |      |-- common      //公共组件</span><br><span class=\"line\">  |    |      |--             //其他子组件</span><br><span class=\"line\">  |    |-- entry              //入口js，与静态html文件相对应</span><br><span class=\"line\">  |    |-- util               //通用方法</span><br><span class=\"line\">  |    |-- image            //图片资源</span><br><span class=\"line\">  |    |-- style            //样式</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- template              //html模板，动态生成html文件</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- mock.json      // mock数据</span><br><span class=\"line\">  |-- server_hot.js  //实现热更新、拦截并处理前端请求(返回本地页面、mock数据，其他请求转发到服务端处理)  </span><br><span class=\"line\">  |</span><br><span class=\"line\">|-- dist //构建目录</span><br></pre></td></tr></table></figure></p>\n<p>其中，模板中是静态html文件，在没有添加后端路由的情况下，通过server_hot.js中的页面映射去访问前端页面，例如当匹配到路径/index时，返回index.html页面，结合mock数据，真正实现了前后端分离。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> templateMap = &#123;</span><br><span class=\"line\">    <span class=\"string\">'/search'</span>: <span class=\"string\">'search.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/search/book'</span>: <span class=\"string\">'search.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/index'</span>: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/history'</span>: <span class=\"string\">'history.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/rank'</span>: <span class=\"string\">'rank.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/home/more'</span>: <span class=\"string\">'more.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/category'</span>: <span class=\"string\">'category.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/info'</span>: <span class=\"string\">'info.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/detail'</span>: <span class=\"string\">'detail.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/book/reader'</span>: <span class=\"string\">'reader.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/recharge'</span>: <span class=\"string\">'recharge.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/catalog'</span>: <span class=\"string\">'catalog.html'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> mapItem <span class=\"keyword\">in</span> templateMap) &#123;</span><br><span class=\"line\">    app.get(mapItem, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">        res.sendFile(__dirname + <span class=\"string\">'/template/'</span> + templateMap[mapItem]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"API转发后获取服务端数据失败的问题\"><a href=\"#API转发后获取服务端数据失败的问题\" class=\"headerlink\" title=\"API转发后获取服务端数据失败的问题\"></a>API转发后获取服务端数据失败的问题</h4><p>在使用http-proxy-middleware转发请求到后端时，发现有部分请求无法获得返回数据，首先可以确定的是请求被转发到后端了。调试发现后端会验证站点相关信息，在验证host的时候报错。猜测可能是请求转发后header里的host信息丢失，查询<a href=\"https://www.npmjs.com/package/http-proxy-middleware#http-proxy-middleware-options\" target=\"_blank\" rel=\"noopener\">API</a>发现可以设置option.headers，如下所示。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxyMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'http-proxy-middleware'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> apiProxy = proxyMiddleware(<span class=\"string\">'/api'</span>, &#123; <span class=\"attr\">target</span>: <span class=\"string\">'http://ypxst.kuxuanbook.yuedu.163.com'</span>, <span class=\"attr\">headers</span>: &#123;<span class=\"attr\">host</span>: <span class=\"string\">'ypxst.kuxuanbook.yuedu.163.com'</span>&#125;&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>设置好host后，就可以正常获取接口返回数据了。</p>\n<h4 id=\"POST请求验证XSRF-TOKEN\"><a href=\"#POST请求验证XSRF-TOKEN\" class=\"headerlink\" title=\"POST请求验证XSRF-TOKEN\"></a>POST请求验证XSRF-TOKEN</h4><p>之前阅读常用的方式是后端写入freemarker模板或者通过异步接口获得，这次和后端约定统一放在cookie中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">headers: &#123;</span><br><span class=\"line\">    <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span>,</span><br><span class=\"line\">    <span class=\"string\">'X-XSRF-TOKEN'</span>: csrf_token</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从cookie中读取token后封装在post接口中，写在headers里面，这样在使用的时候就直接调用post方法，无需关注token验证。</p>\n<h4 id=\"使用git-subtree同步assets工程\"><a href=\"#使用git-subtree同步assets工程\" class=\"headerlink\" title=\"使用git subtree同步assets工程\"></a>使用git subtree同步assets工程</h4><p>assets资源存在于novel-webapp-wap和novel-webapp-recharge两个工程下面，recharge工程下面用到的是充值页面，其他页面都在wap工程下，之所以分开为两个工程是因为涉及到支付，充值的域名需要是唯一的，而分站的域名很多。为了保证二者资源的同步，可以使用git subtree实现子工程的同步。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取远端novel-webapp-assets的更新</span></span><br><span class=\"line\">git subtree pull --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将本地assets更新推送到远端novel-webapp-assets</span></span><br><span class=\"line\">git subtree push --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h4 id=\"webpack替换文件链接的资源\"><a href=\"#webpack替换文件链接的资源\" class=\"headerlink\" title=\"webpack替换文件链接的资源\"></a>webpack替换文件链接的资源</h4><p>通过给chunk filename添加[chunkhash]去有效地缓存文件，每次修改后生成新的chunkhash值，手动替换很麻烦，所以结合done plugin去完成html文件中资源名字的自动替换。<br>stats记录了打包信息和相应的chunkhash值，其中assetsByChunkName包含了以chunkname作为key，filename作为值的对象，结构如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"assetsByChunkName\": &#123;</span><br><span class=\"line\">  \"reader\": [</span><br><span class=\"line\">    \"js/reader-60b54d52.js\",</span><br><span class=\"line\">    <span class=\"string\">\"css/reader-60b54d52.css\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  //...</span><br><span class=\"line\">  \"common\": [</span><br><span class=\"line\">    \"js/common-a814792a.bundle.js\",</span><br><span class=\"line\">    <span class=\"string\">\"css/common-a814792a.css\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>遍历stats对象中的entrypoints，这里的entrypoints的key值和html文件名一致、且一一对应的，根据key值读取可以读取对应的html文件，通过正则匹配的方式将对应的js、css文件替换为本次打包生成的文件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.plugin(<span class=\"string\">'done'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">stats</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> stats.toJson().entrypoints) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> htmlPath = path.join(ROOT_PATH, <span class=\"string\">'template'</span>, key + <span class=\"string\">'.html'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> htmlContent = fs.readFileSync(htmlPath, <span class=\"string\">'utf8'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> keyJSRegExp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'js\\/'</span> + key + <span class=\"string\">'(.*?)\\.js'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> keyCSSRegExp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'css\\/'</span> + key + <span class=\"string\">'(.*?)\\.css'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> keyAssets = [].concat(stats.toJson().assetsByChunkName[key]);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> commonAssets = [].concat(stats.toJson().assetsByChunkName[<span class=\"string\">'common'</span>]);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> htmlOutput = <span class=\"string\">''</span>;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> keyJS = keyAssets.filter(<span class=\"function\"><span class=\"params\">path</span> =&gt;</span> path.endsWith(<span class=\"string\">'.js'</span>))[<span class=\"number\">0</span>];</span><br><span class=\"line\">          <span class=\"keyword\">var</span> keyCSS = keyAssets.filter(<span class=\"function\"><span class=\"params\">path</span> =&gt;</span> path.endsWith(<span class=\"string\">'.css'</span>))[<span class=\"number\">0</span>];</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(keyJS) &#123;</span><br><span class=\"line\">               htmlOutput = htmlContent.replace(keyJSRegExp, keyJS);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(keyCSS) &#123;</span><br><span class=\"line\">               htmlOutput = htmlOutput.replace(keyCSSRegExp, keyCSS);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> commonJS = commonAssets.filter(<span class=\"function\"><span class=\"params\">path</span> =&gt;</span> path.endsWith(<span class=\"string\">'.js'</span>))[<span class=\"number\">0</span>];</span><br><span class=\"line\">          <span class=\"keyword\">var</span> commonCSS = commonAssets.filter(<span class=\"function\"><span class=\"params\">path</span> =&gt;</span> path.endsWith(<span class=\"string\">'.css'</span>))[<span class=\"number\">0</span>];</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(commonJS) &#123;</span><br><span class=\"line\">               htmlOutput = htmlOutput.replace(<span class=\"regexp\">/js\\/common(.*?)\\.js/g</span>, commonJS);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(commonCSS) &#123;</span><br><span class=\"line\">               htmlOutput = htmlOutput.replace(<span class=\"regexp\">/css\\/common(.*?)\\.css/g</span>, commonCSS);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          fs.writeFileSync(htmlPath, htmlOutput);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Refs:</strong><br><a href=\"http://www.weicon9.com/2016/11/Loading-Webpack-Bundles-With-Hash-Value/\" target=\"_blank\" rel=\"noopener\">LOADING WEBPACK BUNDLES WITH HASH VALUE</a></p>\n<h3 id=\"polyfill引入方式比较\"><a href=\"#polyfill引入方式比较\" class=\"headerlink\" title=\"polyfill引入方式比较\"></a>polyfill引入方式比较</h3><p>babel-core/babel-preset-*等插件可以将语法从 es6 转成 es5，但没有提供 api 的转码功能，如 Promise、Set、Map 等新增对象，Object.assign、Object.entries 等全局对象上的新增方法都不会转码， babel-runtime 和 babel-polyfill 就是为此而生。这两个模块功能几乎相同，就是转码新增 api，模拟 es6 环境，但实现方法完全不同。</p>\n<h4 id=\"babel-polyfill库\"><a href=\"#babel-polyfill库\" class=\"headerlink\" title=\"babel-polyfill库\"></a>babel-polyfill库</h4><p>babel-polyfill 的做法是将全局对象通通污染一遍，比如相应使用includes方法，会通过Array.prototype.includes() 的方式去注入污染原型。对于普通的业务代码没有关系，如果不在意略大的体积（min后86kb），推荐使用；但如果用在开发library，则不推荐使用，会污染该library使用者的环境。</p>\n<h4 id=\"babel-runtime库和babel-plugin-transform-runtime-插件\"><a href=\"#babel-runtime库和babel-plugin-transform-runtime-插件\" class=\"headerlink\" title=\"babel-runtime库和babel-plugin-transform-runtime 插件\"></a>babel-runtime库和babel-plugin-transform-runtime 插件</h4><p>babel-runtime 的做法是自己手动引入 helper 函数，const Promise = require(‘babel-runtime/core-js/promise’) 就可以引入 Promise，但是很不方便。<br>借助babel-plugin-transform-runtime插件，可以帮助我们按需加载polyfill，这个模块会将我们的代码重写，如将 Promise 重写成 _Promise（只是打比方），然后引入_Promise helper 函数。此外，babel-runtime 不能转码实例方法，比如这样的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'!!!'</span>.repeat(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"string\">'hello'</span>.includes(<span class=\"string\">'h'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这只能通过 babel-polyfill 来转码，因为 babel-polyfill 是直接在原型链上增加方法。</p>\n<p>如果在开发library，为了避免污染使用者的环境，只能用 babel-runtime + babel-plugin-transform-runtime。虽然是业务开发，但是因为移动端比较介意babel-polyfill的体积，所以我还是选择了babel-runtime。</p>\n<h5 id=\"babelrc中的相关配置\"><a href=\"#babelrc中的相关配置\" class=\"headerlink\" title=\".babelrc中的相关配置\"></a>.babelrc中的相关配置</h5><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"plugins\"</span>: [</span><br><span class=\"line\">        [<span class=\"string\">\"transform-runtime\"</span>, &#123;</span><br><span class=\"line\">            \"helper\": false,  //开启helper后，统一引用了helper</span><br><span class=\"line\">            \"polyfill\": true,  //Map, Set, Promise,Object.assign等</span><br><span class=\"line\">            \"regenerator\": true, //主要是实现generator/yeild，async/await</span><br><span class=\"line\">            \"moduleName\": \"babel-runtime\"</span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>helper</code>设为true时，会引入一些 helper 来代替每次都生成的通用函数，原来构建好的代码每个模块都有类似这种代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_classCallCheck</span>(<span class=\"params\">instance, Constructor</span>)...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">_possibleConstructorReturn</span>(<span class=\"params\">self, call</span>)...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">_inherits</span>(<span class=\"params\">subClass, superClass</span>)...</span></span><br></pre></td></tr></table></figure></p>\n<p><code>开启helper后</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _classCallCheck2 = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-runtime/helpers/classCallCheck'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> _possibleConstructorReturn2 = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-runtime/helpers/possibleConstructorReturn'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> _inherits2 = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-runtime/helpers/inherits'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>在v6.12.0 (2016-07-27) 后增加了 helper 的配置，原因是从 babel-runtime 里引入的 helper 依赖很多，全部都是兼容最底层的。比如 Object.create typeof 这种方法全部被重写了，会导致构建模块变大。<br><code>开启polyfill后</code>，Object.assign方法会被改写为<code>__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()</code>。<br><code>regenerator设为true</code>，使我们可以使用generator/yeild，async/await。如果你只需要用 regenerator，不需要 core-js 里面的 polyfill 那你就可以在 options 中把 polyfill 设为 false。</p>\n<h4 id=\"babel-preset-env插件\"><a href=\"#babel-preset-env插件\" class=\"headerlink\" title=\"babel-preset-env插件\"></a>babel-preset-env插件</h4><blockquote>\n<p>版本支持：babel 7.0beta版、babel-loader 8.0 beta版和babel-preset-env 2.0beta版<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env  --save-dev</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>首先需要安装babel-polyfill<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @babel/polyfill --save</span><br></pre></td></tr></table></figure></p>\n<p>配置”useBuiltIns”: </p>\n<ul>\n<li>false: 不对polyfills做任何操作</li>\n<li>entry: 根据target中浏览器版本的支持，将polyfills拆分引入，仅引入有浏览器不支持的polyfill，通过<code>import &#39;babel-polyfill&#39;</code>方式在代码中一次性引入</li>\n<li>usage(新)：检测代码中ES6/7/8等的使用情况，仅仅加载代码中用到的polyfills</li>\n</ul>\n<p>这种方式配置非常方便，并且可以按需加载，后续会替换成该插件。</p>\n<p><strong>Refs:</strong><br><a href=\"https://github.com/babel/babel/tree/master/experimental/babel-preset-env\" target=\"_blank\" rel=\"noopener\">babel-preset-env</a><br><a href=\"https://erasermeng.github.io/2017/11/02/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BDpolyfill%E2%80%94%E2%80%94babel7%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/\" target=\"_blank\" rel=\"noopener\">按需加载polyfill——babel7的正确打开方式</a><br><a href=\"http://blog.csdn.net/a324539017/article/details/52824189\" target=\"_blank\" rel=\"noopener\">ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍</a><br><a href=\"https://zhuanlan.zhihu.com/p/29506685\" target=\"_blank\" rel=\"noopener\">再见，babel-preset-2015</a></p>\n<h3 id=\"记录正文页历史滚动位置\"><a href=\"#记录正文页历史滚动位置\" class=\"headerlink\" title=\"记录正文页历史滚动位置\"></a>记录正文页历史滚动位置</h3><p>在开发过程中，发现每次返回到历史页面时，都不是上次访问到的页面位置，而是重置到了顶部，react并没有去维护历史页面的滚动位置。所以我们需要手动去记录页面的历史滚动位置。</p>\n<h5 id=\"可能的方案\"><a href=\"#可能的方案\" class=\"headerlink\" title=\"可能的方案\"></a>可能的方案</h5><ol>\n<li>使用window的onpopstate、onload、onunload事件监听页面的前进、返回，利用command模式维护posUndoStack和posRedoStack栈，记录并保存页面的历史位置<br>问题：结合了history.length去判断页面是前进、返回or新进了一个页面，但是当从b页面返回到a页面后，又点击进入了b页面后，history.length不变，链接不变，这个时候无法辨别浏览器的行为</li>\n<li><a href=\"http://npm.taobao.org/package/react-router-scroll\" target=\"_blank\" rel=\"noopener\">react-router-scroll组件</a><br>问题：基于react-router，基于router middleware实现的，使用的Router V4没有中间件的概念</li>\n<li>基于history.location.key属性的实现<br>问题：基于react-router</li>\n</ol>\n<h5 id=\"最终方案\"><a href=\"#最终方案\" class=\"headerlink\" title=\"最终方案\"></a>最终方案</h5><p>由于目前没有好的办法去记录所有页面的位置，而记录正文页阅读位置的需求最为必要，所以使用第三个方案，暂时忽略其他页面。使用BrowserRouter的页面支持location.key属性，这个location是react-router引用的history库中的location对象，每个页面有唯一标识的key值。</p>\n<blockquote>\n<p>React-router官网: 使用 hash 的方式记录导航历史不支持 location.key，在以前的版本中，我们为这种行为提供了shim，但是仍有一些问题我们无法解决。</p>\n</blockquote>\n<p>react-router使用的history库在createBrowserHistory时，会调用createKey方法创建页面的key值，key的长度默认为6，可以设置。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createKey = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createKey</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random().toString(<span class=\"number\">36</span>).substr(<span class=\"number\">2</span>, keyLength);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>createBrowserHistory类中维护了一个数组allkeys，里面记录了所有页面的location.key。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> allKeys = [initialLocation.key];</span><br></pre></td></tr></table></figure></p>\n<p>在SPA中的每个页面的history的state中则记录了该页面的key。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globalHistory.pushState(&#123; <span class=\"attr\">key</span>: key, <span class=\"attr\">state</span>: state &#125;, <span class=\"literal\">null</span>, href);</span><br></pre></td></tr></table></figure></p>\n<p>在监听到popState事件后，会通过event拿到进入页面的state，里面记录了key值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onpopstate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  alert(state: <span class=\"string\">\" + JSON.stringify(event.state));</span></span><br><span class=\"line\"><span class=\"string\">&#125;;</span></span><br></pre></td></tr></table></figure></p>\n<p>所以在页面返回、前进的时候，同一页面的location.key不变，据此可以在页面离开的时候，用key-value的形式保存当前key值和对应的滚动位置在sessionStorage中。页面离开的情况有：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//SPA页面内路由到其他章节</span></span><br><span class=\"line\">componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">    posReserve.onLeave(<span class=\"keyword\">this</span>.props.location.key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//页面unload</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onunload = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    posReserve.onLeave(<span class=\"keyword\">this</span>.props.location.key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在页面前进、返回的时候，去sessionStorage中读取历史位置，并滚动页面到对应位置。</p>\n<h3 id=\"ios微信中SPA正文页返回问题\"><a href=\"#ios微信中SPA正文页返回问题\" class=\"headerlink\" title=\"ios微信中SPA正文页返回问题\"></a>ios微信中SPA正文页返回问题</h3><h4 id=\"问题1：正文内部返回白屏\"><a href=\"#问题1：正文内部返回白屏\" class=\"headerlink\" title=\"问题1：正文内部返回白屏\"></a>问题1：正文内部返回白屏</h4><p>在IOS微信浏览器中阅读正文，返回上一章的时候期望显示上一章内容，但是会出现白屏的问题，需要上滑或者下滑页面，正文才会出现。<br>在寻找解决方案的时候，发现Vue存在相似的问题：<br>  <a href=\"https://github.com/vuejs/vue/issues/5533\" target=\"_blank\" rel=\"noopener\">iOS Safari renders blank page</a><br>  <a href=\"https://github.com/ElemeFE/mint-ui/issues/937\" target=\"_blank\" rel=\"noopener\">ios 组件点返回白屏遮挡问题</a><br>参考了其中的解决方案，在正文内容加载完成后通过js去触发scroll滚动，正文显示就恢复正常了。代码如下所示，尝试了下面两种方式，都可以解决问题。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//或者</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"问题2-从其他页面返回正文问题\"><a href=\"#问题2-从其他页面返回正文问题\" class=\"headerlink\" title=\"问题2: 从其他页面返回正文问题\"></a>问题2: 从其他页面返回正文问题</h4><p>使用<code>Preact</code>的时候，从其他页面返回到正文页后，部分请求没有发出。<br>在debug的时候发现正文页setState没有触发componentWillUpdate，不会rerender，setState的callback不被执行。当从Preact替换为React的时候，页面显示正常。</p>\n<ul>\n<li>猜测1: 可能和preact的diff机制有关。因为’对一个虚拟DOM子树是否继续更新下去，如果它们的type, props,key都一样，或者它们的引用也一样，可能也会继续diff，官方还会比较context!!!!这个许多react-like没有考虑到。<code>React-Router就非常依赖context对象进行多层的组件间传递</code>‘。</li>\n<li>猜测2: setState回调延后<br>知乎问答‘<a href=\"https://www.zhihu.com/question/65479147/answer/231505912?utm_source=wechat_session&amp;utm_medium=social&amp;utm_campaign=ge13_2&amp;utm_division=ge13_3\" target=\"_blank\" rel=\"noopener\">如何看待 React 的替代框架 Preact</a>’中蓝面小生和司徒正美的回答中列出了Preact存在的一些问题。</li>\n</ul>\n<h5 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h5><p>如果继续使用Preact可以通过reload页面解决问题，当从正文页跳转到其他页面时候，记录下当前页面的<code>location.key</code>在sessionStorage中，返回页面时在componentWillMount方法中判断当前key值是否存储在’N_reader_locKeys’，若存在，则说明是页面返回，reload页面，并且从’N_reader_locKeys’中删掉对应的key值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _key = <span class=\"keyword\">this</span>.props.location.key;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> locKeys = sessionStorage.getItem(<span class=\"string\">'N_reader_locKeys'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isIos &amp;&amp; _key &amp;&amp; locKeys)&#123;</span><br><span class=\"line\">        sessionStorage.removeItem(<span class=\"string\">'N_reader_locKey'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> index = locKeys.indexOf(_key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(~index &amp;&amp; <span class=\"keyword\">this</span>.props.history.action === <span class=\"string\">'POP'</span>) &#123;</span><br><span class=\"line\">            sessionStorage.setItem(<span class=\"string\">'N_reader_locKeys'</span>, locKeys.slice(<span class=\"number\">0</span>, index) + locKeys.slice(index + _key.length + <span class=\"number\">1</span>));</span><br><span class=\"line\">            location.reload();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//[IOS微信返回bug处理]记录所有点击跳到其他页面(结合href和isexternal值)</span></span><br><span class=\"line\">bindEvent() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>, e =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> targetEle = e.target;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(targetEle.tagName.toLowerCase() === <span class=\"string\">'a'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(targetEle.href.indexOf(<span class=\"string\">'.do'</span>) !== <span class=\"number\">-1</span> || (targetEle.getAttribute(<span class=\"string\">'isexternal'</span>) === <span class=\"string\">'true'</span>)) &#123;</span><br><span class=\"line\">                e.preventDefault();</span><br><span class=\"line\">                <span class=\"keyword\">let</span> _key = <span class=\"keyword\">this</span>.props.location.key;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> keys = sessionStorage.getItem(<span class=\"string\">'N_reader_locKeys'</span>) || <span class=\"string\">''</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(_key &amp;&amp; keys.indexOf(_key) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                    keys += _key + <span class=\"string\">','</span></span><br><span class=\"line\">                    sessionStorage.setItem(<span class=\"string\">'N_reader_locKeys'</span>, keys);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(targetEle.href.indexOf(<span class=\"string\">'.do'</span>) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                    location.href = targetEle.href;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>鉴于在某ios9版本的iphone5s上正常打开正文一直会出现上述问题，且考虑逻辑的复杂性、未来的需求扩展，最终还是<strong><code>使用React替换了Preact</code></strong>。逻辑越复杂，Preact暴露的问题越多。</p>\n<h4 id=\"问题3：微信url地址问题\"><a href=\"#问题3：微信url地址问题\" class=\"headerlink\" title=\"问题3：微信url地址问题\"></a>问题3：微信url地址问题</h4><p>在IOS微信中，使用history的replaceState、pushState，url栏不变，分享或者通过浏览器打开都还是之前的url。</p>\n<h5 id=\"详情\"><a href=\"#详情\" class=\"headerlink\" title=\"详情\"></a>详情</h5><p>从首页进入正文，通常只带sourceUuid不带articleUuid，在加载当前章节的时候期望通过history.replaceState去更新当前url为带articleUuid，这样当从下一章返回的时候，可以正确显示当前内容，不然会自动获取当前进度，无法显示正确章节。安卓可以正常返回，但ios微信返回的时候url还是不带articleUuid。</p>\n<h5 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h5><p>原因是使用H5的history API并不能改变url栏地址内容，分享或通过浏览器打开都是旧的地址，是ios微信的一个bug。改用react-router的history.replace去更新章节可以解决返回问题。<br>原理是虽然地址栏不变，但通过location.href获得的是正确的地址，BrowserRouter单页面应用在切换页面的时候会从window.location中读取<code>{pathname,search,hash}</code>，创建自己的location对象，依据location对象去渲染页面。</p>\n<p><strong>Refs: </strong><br><a href=\"https://github.com/Tencent/weui/issues/125\" target=\"_blank\" rel=\"noopener\">H5 history.pushState 在微信内修改url后点击用safari打开/复制链接是修改之前的页面</a></p>\n<h3 id=\"lib-flexible方案\"><a href=\"#lib-flexible方案\" class=\"headerlink\" title=\"lib.flexible方案\"></a>lib.flexible方案</h3><p>使用淘宝<code>lib.flexible</code>的rem方案，会遇到一个<strong>问题</strong>：在ios微信内长按扫描二维码，会有无法识别二维码的问题。[微信已修复该问题]</p>\n<blockquote>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=NzA3OTQ2OTgw&amp;mid=205918916&amp;idx=1&amp;sn=d729ef70ea1e7fc50e649352a63a2564&amp;scene=1&amp;key=c76941211a49ab586ba4831f2f6fa42fbb2525460003fa8e19bc205b9b25facbf60da78977da071ddbc41a5be6a7b9fa&amp;ascene=0&amp;uin=NTE3ODg0NjE1&amp;devicetype=iMac%20MacBookPro12,1%20OSX%20OSX%2010.10.3%20build%2814D136%29&amp;version=11020012&amp;pass_ticket=WPa8XnvIzBrBOA6RHy2RMECcrsuN2QiksK8Y1Z/D3Odk49uIsXOex7EV2NXN9m5X\" target=\"_blank\" rel=\"noopener\">微信识别二维码的原理机制</a><br>这里采用的逻辑是截屏识别，当客户端发现用户在网页的img标签内进行长按操作时，会立刻截屏并且启动二维码识别算法。所以这里用于二维码识别的图片是截屏，而不是之前有人提到的img标签中的图片。</p>\n</blockquote>\n<p>实践发现meta scale指定为1的时候，无该问题。<code>问题产生的原因</code>应该是：在iOS下，对于dpr(设备像素比)2和3的屏，用2倍和3倍的方案，其余的用1倍方案。使用高清屏方案后，viewport的scale值会设为1/dpr，页面发生了缩放，二维码的位置实际发生了偏移，因而微信无法准确识别出二维码。<br>设备像素比 = 物理像素 / 设备独立像素；</p>\n<ul>\n<li>物理像素：一个物理像素是显示器(手机屏幕)上最小的物理显示单元；</li>\n<li>设备独立像素：设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。<br>在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。 在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。</li>\n</ul>\n<p>为了解决二维码识别问题，在html中手动添加viewport的meta标签，这样页面就会根据已有的meta标签设置缩放比例，不会使用高清方案。不使用高清方案一个不好的地方是1px边框问题，不过可以通过伪元素搭配transform:scale(0.5)解决。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> metaEl = doc.querySelector(<span class=\"string\">'meta[name=\"viewport\"]'</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (metaEl) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.warn(<span class=\"string\">'将根据已有的meta标签来设置缩放比例'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> match = metaEl.getAttribute(<span class=\"string\">'content'</span>).match(<span class=\"regexp\">/initial\\-scale=([\\d\\.]+)/</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (match) &#123;</span><br><span class=\"line\">        scale = <span class=\"built_in\">parseFloat</span>(match[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        dpr = <span class=\"built_in\">parseInt</span>(<span class=\"number\">1</span> / scale);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.method-list</span><span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#E1E1E1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">scale</span>(0.5);</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0.5);</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    box-sizing: border-box;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"前端目录结构\"><a href=\"#前端目录结构\" class=\"headerlink\" title=\"前端目录结构\"></a>前端目录结构</h3><p>基于React + React-Router + Sass开发的webpack打包的多页面应用，其中正文页面和搜索页面是基于React-Router开发的单页面应用。路由类型采用的是BrowserRouter，在移动端pushState/replaceState没有兼容问题，可以放心使用。如果是要兼容IE9及以下，则不能使用BrowserRouter，建议使用HashRouter。此外，使用BrowserRouter后，可以借助history的特性帮助我们实现记录每个页面的历史停留位置。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|-- assets</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- config //webpack编译</span><br><span class=\"line\">  |    |-- base.js //基础编译配置</span><br><span class=\"line\">  |    |-- dev.js  //开发环境编译配置</span><br><span class=\"line\">  |    |-- dll.js  //动态链接库编译配置</span><br><span class=\"line\">  |    |-- hot.js  //热替换编译配置</span><br><span class=\"line\">  |    |-- prod.js //开发环境编译配置</span><br><span class=\"line\">  |    |-- util.js //定义配置相关的通用方法和变量</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- src                //源码目录</span><br><span class=\"line\">  |    |-- component        // 组件</span><br><span class=\"line\">  |    |      |-- common      //公共组件</span><br><span class=\"line\">  |    |      |--             //其他子组件</span><br><span class=\"line\">  |    |-- entry              //入口js，与静态html文件相对应</span><br><span class=\"line\">  |    |-- util               //通用方法</span><br><span class=\"line\">  |    |-- image            //图片资源</span><br><span class=\"line\">  |    |-- style            //样式</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- template              //html模板，动态生成html文件</span><br><span class=\"line\">  |</span><br><span class=\"line\">  |-- mock.json      // mock数据</span><br><span class=\"line\">  |-- server_hot.js  //实现热更新、拦截并处理前端请求(返回本地页面、mock数据，其他请求转发到服务端处理)  </span><br><span class=\"line\">  |</span><br><span class=\"line\">|-- dist //构建目录</span><br></pre></td></tr></table></figure></p>\n<p>其中，模板中是静态html文件，在没有添加后端路由的情况下，通过server_hot.js中的页面映射去访问前端页面，例如当匹配到路径/index时，返回index.html页面，结合mock数据，真正实现了前后端分离。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> templateMap = &#123;</span><br><span class=\"line\">    <span class=\"string\">'/search'</span>: <span class=\"string\">'search.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/search/book'</span>: <span class=\"string\">'search.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/index'</span>: <span class=\"string\">'index.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/history'</span>: <span class=\"string\">'history.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/rank'</span>: <span class=\"string\">'rank.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/home/more'</span>: <span class=\"string\">'more.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/category'</span>: <span class=\"string\">'category.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/info'</span>: <span class=\"string\">'info.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/detail'</span>: <span class=\"string\">'detail.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/book/reader'</span>: <span class=\"string\">'reader.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/recharge'</span>: <span class=\"string\">'recharge.html'</span>,</span><br><span class=\"line\">    <span class=\"string\">'/catalog'</span>: <span class=\"string\">'catalog.html'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> mapItem <span class=\"keyword\">in</span> templateMap) &#123;</span><br><span class=\"line\">    app.get(mapItem, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">        res.sendFile(__dirname + <span class=\"string\">'/template/'</span> + templateMap[mapItem]);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"API转发后获取服务端数据失败的问题\"><a href=\"#API转发后获取服务端数据失败的问题\" class=\"headerlink\" title=\"API转发后获取服务端数据失败的问题\"></a>API转发后获取服务端数据失败的问题</h4><p>在使用http-proxy-middleware转发请求到后端时，发现有部分请求无法获得返回数据，首先可以确定的是请求被转发到后端了。调试发现后端会验证站点相关信息，在验证host的时候报错。猜测可能是请求转发后header里的host信息丢失，查询<a href=\"https://www.npmjs.com/package/http-proxy-middleware#http-proxy-middleware-options\" target=\"_blank\" rel=\"noopener\">API</a>发现可以设置option.headers，如下所示。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> proxyMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'http-proxy-middleware'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> apiProxy = proxyMiddleware(<span class=\"string\">'/api'</span>, &#123; <span class=\"attr\">target</span>: <span class=\"string\">'http://ypxst.kuxuanbook.yuedu.163.com'</span>, <span class=\"attr\">headers</span>: &#123;<span class=\"attr\">host</span>: <span class=\"string\">'ypxst.kuxuanbook.yuedu.163.com'</span>&#125;&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>设置好host后，就可以正常获取接口返回数据了。</p>\n<h4 id=\"POST请求验证XSRF-TOKEN\"><a href=\"#POST请求验证XSRF-TOKEN\" class=\"headerlink\" title=\"POST请求验证XSRF-TOKEN\"></a>POST请求验证XSRF-TOKEN</h4><p>之前阅读常用的方式是后端写入freemarker模板或者通过异步接口获得，这次和后端约定统一放在cookie中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">headers: &#123;</span><br><span class=\"line\">    <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span>,</span><br><span class=\"line\">    <span class=\"string\">'X-XSRF-TOKEN'</span>: csrf_token</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从cookie中读取token后封装在post接口中，写在headers里面，这样在使用的时候就直接调用post方法，无需关注token验证。</p>\n<h4 id=\"使用git-subtree同步assets工程\"><a href=\"#使用git-subtree同步assets工程\" class=\"headerlink\" title=\"使用git subtree同步assets工程\"></a>使用git subtree同步assets工程</h4><p>assets资源存在于novel-webapp-wap和novel-webapp-recharge两个工程下面，recharge工程下面用到的是充值页面，其他页面都在wap工程下，之所以分开为两个工程是因为涉及到支付，充值的域名需要是唯一的，而分站的域名很多。为了保证二者资源的同步，可以使用git subtree实现子工程的同步。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取远端novel-webapp-assets的更新</span></span><br><span class=\"line\">git subtree pull --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将本地assets更新推送到远端novel-webapp-assets</span></span><br><span class=\"line\">git subtree push --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash</span><br></pre></td></tr></table></figure></p>","more":"<h4 id=\"webpack替换文件链接的资源\"><a href=\"#webpack替换文件链接的资源\" class=\"headerlink\" title=\"webpack替换文件链接的资源\"></a>webpack替换文件链接的资源</h4><p>通过给chunk filename添加[chunkhash]去有效地缓存文件，每次修改后生成新的chunkhash值，手动替换很麻烦，所以结合done plugin去完成html文件中资源名字的自动替换。<br>stats记录了打包信息和相应的chunkhash值，其中assetsByChunkName包含了以chunkname作为key，filename作为值的对象，结构如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\"assetsByChunkName\": &#123;</span><br><span class=\"line\">  \"reader\": [</span><br><span class=\"line\">    \"js/reader-60b54d52.js\",</span><br><span class=\"line\">    <span class=\"string\">\"css/reader-60b54d52.css\"</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  //...</span><br><span class=\"line\">  \"common\": [</span><br><span class=\"line\">    \"js/common-a814792a.bundle.js\",</span><br><span class=\"line\">    <span class=\"string\">\"css/common-a814792a.css\"</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>遍历stats对象中的entrypoints，这里的entrypoints的key值和html文件名一致、且一一对应的，根据key值读取可以读取对应的html文件，通过正则匹配的方式将对应的js、css文件替换为本次打包生成的文件。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.plugin(<span class=\"string\">'done'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">stats</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> stats.toJson().entrypoints) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> htmlPath = path.join(ROOT_PATH, <span class=\"string\">'template'</span>, key + <span class=\"string\">'.html'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> htmlContent = fs.readFileSync(htmlPath, <span class=\"string\">'utf8'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> keyJSRegExp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'js\\/'</span> + key + <span class=\"string\">'(.*?)\\.js'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> keyCSSRegExp = <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'css\\/'</span> + key + <span class=\"string\">'(.*?)\\.css'</span>);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> keyAssets = [].concat(stats.toJson().assetsByChunkName[key]);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> commonAssets = [].concat(stats.toJson().assetsByChunkName[<span class=\"string\">'common'</span>]);</span><br><span class=\"line\">          <span class=\"keyword\">var</span> htmlOutput = <span class=\"string\">''</span>;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> keyJS = keyAssets.filter(<span class=\"function\"><span class=\"params\">path</span> =&gt;</span> path.endsWith(<span class=\"string\">'.js'</span>))[<span class=\"number\">0</span>];</span><br><span class=\"line\">          <span class=\"keyword\">var</span> keyCSS = keyAssets.filter(<span class=\"function\"><span class=\"params\">path</span> =&gt;</span> path.endsWith(<span class=\"string\">'.css'</span>))[<span class=\"number\">0</span>];</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(keyJS) &#123;</span><br><span class=\"line\">               htmlOutput = htmlContent.replace(keyJSRegExp, keyJS);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(keyCSS) &#123;</span><br><span class=\"line\">               htmlOutput = htmlOutput.replace(keyCSSRegExp, keyCSS);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> commonJS = commonAssets.filter(<span class=\"function\"><span class=\"params\">path</span> =&gt;</span> path.endsWith(<span class=\"string\">'.js'</span>))[<span class=\"number\">0</span>];</span><br><span class=\"line\">          <span class=\"keyword\">var</span> commonCSS = commonAssets.filter(<span class=\"function\"><span class=\"params\">path</span> =&gt;</span> path.endsWith(<span class=\"string\">'.css'</span>))[<span class=\"number\">0</span>];</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(commonJS) &#123;</span><br><span class=\"line\">               htmlOutput = htmlOutput.replace(<span class=\"regexp\">/js\\/common(.*?)\\.js/g</span>, commonJS);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(commonCSS) &#123;</span><br><span class=\"line\">               htmlOutput = htmlOutput.replace(<span class=\"regexp\">/css\\/common(.*?)\\.css/g</span>, commonCSS);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          fs.writeFileSync(htmlPath, htmlOutput);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>Refs:</strong><br><a href=\"http://www.weicon9.com/2016/11/Loading-Webpack-Bundles-With-Hash-Value/\" target=\"_blank\" rel=\"noopener\">LOADING WEBPACK BUNDLES WITH HASH VALUE</a></p>\n<h3 id=\"polyfill引入方式比较\"><a href=\"#polyfill引入方式比较\" class=\"headerlink\" title=\"polyfill引入方式比较\"></a>polyfill引入方式比较</h3><p>babel-core/babel-preset-*等插件可以将语法从 es6 转成 es5，但没有提供 api 的转码功能，如 Promise、Set、Map 等新增对象，Object.assign、Object.entries 等全局对象上的新增方法都不会转码， babel-runtime 和 babel-polyfill 就是为此而生。这两个模块功能几乎相同，就是转码新增 api，模拟 es6 环境，但实现方法完全不同。</p>\n<h4 id=\"babel-polyfill库\"><a href=\"#babel-polyfill库\" class=\"headerlink\" title=\"babel-polyfill库\"></a>babel-polyfill库</h4><p>babel-polyfill 的做法是将全局对象通通污染一遍，比如相应使用includes方法，会通过Array.prototype.includes() 的方式去注入污染原型。对于普通的业务代码没有关系，如果不在意略大的体积（min后86kb），推荐使用；但如果用在开发library，则不推荐使用，会污染该library使用者的环境。</p>\n<h4 id=\"babel-runtime库和babel-plugin-transform-runtime-插件\"><a href=\"#babel-runtime库和babel-plugin-transform-runtime-插件\" class=\"headerlink\" title=\"babel-runtime库和babel-plugin-transform-runtime 插件\"></a>babel-runtime库和babel-plugin-transform-runtime 插件</h4><p>babel-runtime 的做法是自己手动引入 helper 函数，const Promise = require(‘babel-runtime/core-js/promise’) 就可以引入 Promise，但是很不方便。<br>借助babel-plugin-transform-runtime插件，可以帮助我们按需加载polyfill，这个模块会将我们的代码重写，如将 Promise 重写成 _Promise（只是打比方），然后引入_Promise helper 函数。此外，babel-runtime 不能转码实例方法，比如这样的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'!!!'</span>.repeat(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"string\">'hello'</span>.includes(<span class=\"string\">'h'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这只能通过 babel-polyfill 来转码，因为 babel-polyfill 是直接在原型链上增加方法。</p>\n<p>如果在开发library，为了避免污染使用者的环境，只能用 babel-runtime + babel-plugin-transform-runtime。虽然是业务开发，但是因为移动端比较介意babel-polyfill的体积，所以我还是选择了babel-runtime。</p>\n<h5 id=\"babelrc中的相关配置\"><a href=\"#babelrc中的相关配置\" class=\"headerlink\" title=\".babelrc中的相关配置\"></a>.babelrc中的相关配置</h5><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"plugins\"</span>: [</span><br><span class=\"line\">        [<span class=\"string\">\"transform-runtime\"</span>, &#123;</span><br><span class=\"line\">            \"helper\": false,  //开启helper后，统一引用了helper</span><br><span class=\"line\">            \"polyfill\": true,  //Map, Set, Promise,Object.assign等</span><br><span class=\"line\">            \"regenerator\": true, //主要是实现generator/yeild，async/await</span><br><span class=\"line\">            \"moduleName\": \"babel-runtime\"</span><br><span class=\"line\">        &#125;]</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>helper</code>设为true时，会引入一些 helper 来代替每次都生成的通用函数，原来构建好的代码每个模块都有类似这种代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_classCallCheck</span>(<span class=\"params\">instance, Constructor</span>)...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">_possibleConstructorReturn</span>(<span class=\"params\">self, call</span>)...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">function</span> <span class=\"title\">_inherits</span>(<span class=\"params\">subClass, superClass</span>)...</span></span><br></pre></td></tr></table></figure></p>\n<p><code>开启helper后</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _classCallCheck2 = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-runtime/helpers/classCallCheck'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> _possibleConstructorReturn2 = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-runtime/helpers/possibleConstructorReturn'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> _inherits2 = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-runtime/helpers/inherits'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>在v6.12.0 (2016-07-27) 后增加了 helper 的配置，原因是从 babel-runtime 里引入的 helper 依赖很多，全部都是兼容最底层的。比如 Object.create typeof 这种方法全部被重写了，会导致构建模块变大。<br><code>开启polyfill后</code>，Object.assign方法会被改写为<code>__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()</code>。<br><code>regenerator设为true</code>，使我们可以使用generator/yeild，async/await。如果你只需要用 regenerator，不需要 core-js 里面的 polyfill 那你就可以在 options 中把 polyfill 设为 false。</p>\n<h4 id=\"babel-preset-env插件\"><a href=\"#babel-preset-env插件\" class=\"headerlink\" title=\"babel-preset-env插件\"></a>babel-preset-env插件</h4><blockquote>\n<p>版本支持：babel 7.0beta版、babel-loader 8.0 beta版和babel-preset-env 2.0beta版<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env  --save-dev</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>首先需要安装babel-polyfill<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @babel/polyfill --save</span><br></pre></td></tr></table></figure></p>\n<p>配置”useBuiltIns”: </p>\n<ul>\n<li>false: 不对polyfills做任何操作</li>\n<li>entry: 根据target中浏览器版本的支持，将polyfills拆分引入，仅引入有浏览器不支持的polyfill，通过<code>import &#39;babel-polyfill&#39;</code>方式在代码中一次性引入</li>\n<li>usage(新)：检测代码中ES6/7/8等的使用情况，仅仅加载代码中用到的polyfills</li>\n</ul>\n<p>这种方式配置非常方便，并且可以按需加载，后续会替换成该插件。</p>\n<p><strong>Refs:</strong><br><a href=\"https://github.com/babel/babel/tree/master/experimental/babel-preset-env\" target=\"_blank\" rel=\"noopener\">babel-preset-env</a><br><a href=\"https://erasermeng.github.io/2017/11/02/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BDpolyfill%E2%80%94%E2%80%94babel7%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/\" target=\"_blank\" rel=\"noopener\">按需加载polyfill——babel7的正确打开方式</a><br><a href=\"http://blog.csdn.net/a324539017/article/details/52824189\" target=\"_blank\" rel=\"noopener\">ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍</a><br><a href=\"https://zhuanlan.zhihu.com/p/29506685\" target=\"_blank\" rel=\"noopener\">再见，babel-preset-2015</a></p>\n<h3 id=\"记录正文页历史滚动位置\"><a href=\"#记录正文页历史滚动位置\" class=\"headerlink\" title=\"记录正文页历史滚动位置\"></a>记录正文页历史滚动位置</h3><p>在开发过程中，发现每次返回到历史页面时，都不是上次访问到的页面位置，而是重置到了顶部，react并没有去维护历史页面的滚动位置。所以我们需要手动去记录页面的历史滚动位置。</p>\n<h5 id=\"可能的方案\"><a href=\"#可能的方案\" class=\"headerlink\" title=\"可能的方案\"></a>可能的方案</h5><ol>\n<li>使用window的onpopstate、onload、onunload事件监听页面的前进、返回，利用command模式维护posUndoStack和posRedoStack栈，记录并保存页面的历史位置<br>问题：结合了history.length去判断页面是前进、返回or新进了一个页面，但是当从b页面返回到a页面后，又点击进入了b页面后，history.length不变，链接不变，这个时候无法辨别浏览器的行为</li>\n<li><a href=\"http://npm.taobao.org/package/react-router-scroll\" target=\"_blank\" rel=\"noopener\">react-router-scroll组件</a><br>问题：基于react-router，基于router middleware实现的，使用的Router V4没有中间件的概念</li>\n<li>基于history.location.key属性的实现<br>问题：基于react-router</li>\n</ol>\n<h5 id=\"最终方案\"><a href=\"#最终方案\" class=\"headerlink\" title=\"最终方案\"></a>最终方案</h5><p>由于目前没有好的办法去记录所有页面的位置，而记录正文页阅读位置的需求最为必要，所以使用第三个方案，暂时忽略其他页面。使用BrowserRouter的页面支持location.key属性，这个location是react-router引用的history库中的location对象，每个页面有唯一标识的key值。</p>\n<blockquote>\n<p>React-router官网: 使用 hash 的方式记录导航历史不支持 location.key，在以前的版本中，我们为这种行为提供了shim，但是仍有一些问题我们无法解决。</p>\n</blockquote>\n<p>react-router使用的history库在createBrowserHistory时，会调用createKey方法创建页面的key值，key的长度默认为6，可以设置。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> createKey = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createKey</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random().toString(<span class=\"number\">36</span>).substr(<span class=\"number\">2</span>, keyLength);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>createBrowserHistory类中维护了一个数组allkeys，里面记录了所有页面的location.key。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> allKeys = [initialLocation.key];</span><br></pre></td></tr></table></figure></p>\n<p>在SPA中的每个页面的history的state中则记录了该页面的key。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globalHistory.pushState(&#123; <span class=\"attr\">key</span>: key, <span class=\"attr\">state</span>: state &#125;, <span class=\"literal\">null</span>, href);</span><br></pre></td></tr></table></figure></p>\n<p>在监听到popState事件后，会通过event拿到进入页面的state，里面记录了key值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onpopstate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  alert(state: <span class=\"string\">\" + JSON.stringify(event.state));</span></span><br><span class=\"line\"><span class=\"string\">&#125;;</span></span><br></pre></td></tr></table></figure></p>\n<p>所以在页面返回、前进的时候，同一页面的location.key不变，据此可以在页面离开的时候，用key-value的形式保存当前key值和对应的滚动位置在sessionStorage中。页面离开的情况有：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//SPA页面内路由到其他章节</span></span><br><span class=\"line\">componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">    posReserve.onLeave(<span class=\"keyword\">this</span>.props.location.key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//页面unload</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.onunload = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    posReserve.onLeave(<span class=\"keyword\">this</span>.props.location.key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在页面前进、返回的时候，去sessionStorage中读取历史位置，并滚动页面到对应位置。</p>\n<h3 id=\"ios微信中SPA正文页返回问题\"><a href=\"#ios微信中SPA正文页返回问题\" class=\"headerlink\" title=\"ios微信中SPA正文页返回问题\"></a>ios微信中SPA正文页返回问题</h3><h4 id=\"问题1：正文内部返回白屏\"><a href=\"#问题1：正文内部返回白屏\" class=\"headerlink\" title=\"问题1：正文内部返回白屏\"></a>问题1：正文内部返回白屏</h4><p>在IOS微信浏览器中阅读正文，返回上一章的时候期望显示上一章内容，但是会出现白屏的问题，需要上滑或者下滑页面，正文才会出现。<br>在寻找解决方案的时候，发现Vue存在相似的问题：<br>  <a href=\"https://github.com/vuejs/vue/issues/5533\" target=\"_blank\" rel=\"noopener\">iOS Safari renders blank page</a><br>  <a href=\"https://github.com/ElemeFE/mint-ui/issues/937\" target=\"_blank\" rel=\"noopener\">ios 组件点返回白屏遮挡问题</a><br>参考了其中的解决方案，在正文内容加载完成后通过js去触发scroll滚动，正文显示就恢复正常了。代码如下所示，尝试了下面两种方式，都可以解决问题。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"comment\">//或者</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">window</span>.scrollTo(<span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"问题2-从其他页面返回正文问题\"><a href=\"#问题2-从其他页面返回正文问题\" class=\"headerlink\" title=\"问题2: 从其他页面返回正文问题\"></a>问题2: 从其他页面返回正文问题</h4><p>使用<code>Preact</code>的时候，从其他页面返回到正文页后，部分请求没有发出。<br>在debug的时候发现正文页setState没有触发componentWillUpdate，不会rerender，setState的callback不被执行。当从Preact替换为React的时候，页面显示正常。</p>\n<ul>\n<li>猜测1: 可能和preact的diff机制有关。因为’对一个虚拟DOM子树是否继续更新下去，如果它们的type, props,key都一样，或者它们的引用也一样，可能也会继续diff，官方还会比较context!!!!这个许多react-like没有考虑到。<code>React-Router就非常依赖context对象进行多层的组件间传递</code>‘。</li>\n<li>猜测2: setState回调延后<br>知乎问答‘<a href=\"https://www.zhihu.com/question/65479147/answer/231505912?utm_source=wechat_session&amp;utm_medium=social&amp;utm_campaign=ge13_2&amp;utm_division=ge13_3\" target=\"_blank\" rel=\"noopener\">如何看待 React 的替代框架 Preact</a>’中蓝面小生和司徒正美的回答中列出了Preact存在的一些问题。</li>\n</ul>\n<h5 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h5><p>如果继续使用Preact可以通过reload页面解决问题，当从正文页跳转到其他页面时候，记录下当前页面的<code>location.key</code>在sessionStorage中，返回页面时在componentWillMount方法中判断当前key值是否存储在’N_reader_locKeys’，若存在，则说明是页面返回，reload页面，并且从’N_reader_locKeys’中删掉对应的key值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> _key = <span class=\"keyword\">this</span>.props.location.key;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> locKeys = sessionStorage.getItem(<span class=\"string\">'N_reader_locKeys'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isIos &amp;&amp; _key &amp;&amp; locKeys)&#123;</span><br><span class=\"line\">        sessionStorage.removeItem(<span class=\"string\">'N_reader_locKey'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> index = locKeys.indexOf(_key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(~index &amp;&amp; <span class=\"keyword\">this</span>.props.history.action === <span class=\"string\">'POP'</span>) &#123;</span><br><span class=\"line\">            sessionStorage.setItem(<span class=\"string\">'N_reader_locKeys'</span>, locKeys.slice(<span class=\"number\">0</span>, index) + locKeys.slice(index + _key.length + <span class=\"number\">1</span>));</span><br><span class=\"line\">            location.reload();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//[IOS微信返回bug处理]记录所有点击跳到其他页面(结合href和isexternal值)</span></span><br><span class=\"line\">bindEvent() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>, e =&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> targetEle = e.target;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(targetEle.tagName.toLowerCase() === <span class=\"string\">'a'</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(targetEle.href.indexOf(<span class=\"string\">'.do'</span>) !== <span class=\"number\">-1</span> || (targetEle.getAttribute(<span class=\"string\">'isexternal'</span>) === <span class=\"string\">'true'</span>)) &#123;</span><br><span class=\"line\">                e.preventDefault();</span><br><span class=\"line\">                <span class=\"keyword\">let</span> _key = <span class=\"keyword\">this</span>.props.location.key;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> keys = sessionStorage.getItem(<span class=\"string\">'N_reader_locKeys'</span>) || <span class=\"string\">''</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(_key &amp;&amp; keys.indexOf(_key) === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                    keys += _key + <span class=\"string\">','</span></span><br><span class=\"line\">                    sessionStorage.setItem(<span class=\"string\">'N_reader_locKeys'</span>, keys);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(targetEle.href.indexOf(<span class=\"string\">'.do'</span>) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                    location.href = targetEle.href;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>鉴于在某ios9版本的iphone5s上正常打开正文一直会出现上述问题，且考虑逻辑的复杂性、未来的需求扩展，最终还是<strong><code>使用React替换了Preact</code></strong>。逻辑越复杂，Preact暴露的问题越多。</p>\n<h4 id=\"问题3：微信url地址问题\"><a href=\"#问题3：微信url地址问题\" class=\"headerlink\" title=\"问题3：微信url地址问题\"></a>问题3：微信url地址问题</h4><p>在IOS微信中，使用history的replaceState、pushState，url栏不变，分享或者通过浏览器打开都还是之前的url。</p>\n<h5 id=\"详情\"><a href=\"#详情\" class=\"headerlink\" title=\"详情\"></a>详情</h5><p>从首页进入正文，通常只带sourceUuid不带articleUuid，在加载当前章节的时候期望通过history.replaceState去更新当前url为带articleUuid，这样当从下一章返回的时候，可以正确显示当前内容，不然会自动获取当前进度，无法显示正确章节。安卓可以正常返回，但ios微信返回的时候url还是不带articleUuid。</p>\n<h5 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h5><p>原因是使用H5的history API并不能改变url栏地址内容，分享或通过浏览器打开都是旧的地址，是ios微信的一个bug。改用react-router的history.replace去更新章节可以解决返回问题。<br>原理是虽然地址栏不变，但通过location.href获得的是正确的地址，BrowserRouter单页面应用在切换页面的时候会从window.location中读取<code>{pathname,search,hash}</code>，创建自己的location对象，依据location对象去渲染页面。</p>\n<p><strong>Refs: </strong><br><a href=\"https://github.com/Tencent/weui/issues/125\" target=\"_blank\" rel=\"noopener\">H5 history.pushState 在微信内修改url后点击用safari打开/复制链接是修改之前的页面</a></p>\n<h3 id=\"lib-flexible方案\"><a href=\"#lib-flexible方案\" class=\"headerlink\" title=\"lib.flexible方案\"></a>lib.flexible方案</h3><p>使用淘宝<code>lib.flexible</code>的rem方案，会遇到一个<strong>问题</strong>：在ios微信内长按扫描二维码，会有无法识别二维码的问题。[微信已修复该问题]</p>\n<blockquote>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=NzA3OTQ2OTgw&amp;mid=205918916&amp;idx=1&amp;sn=d729ef70ea1e7fc50e649352a63a2564&amp;scene=1&amp;key=c76941211a49ab586ba4831f2f6fa42fbb2525460003fa8e19bc205b9b25facbf60da78977da071ddbc41a5be6a7b9fa&amp;ascene=0&amp;uin=NTE3ODg0NjE1&amp;devicetype=iMac%20MacBookPro12,1%20OSX%20OSX%2010.10.3%20build%2814D136%29&amp;version=11020012&amp;pass_ticket=WPa8XnvIzBrBOA6RHy2RMECcrsuN2QiksK8Y1Z/D3Odk49uIsXOex7EV2NXN9m5X\" target=\"_blank\" rel=\"noopener\">微信识别二维码的原理机制</a><br>这里采用的逻辑是截屏识别，当客户端发现用户在网页的img标签内进行长按操作时，会立刻截屏并且启动二维码识别算法。所以这里用于二维码识别的图片是截屏，而不是之前有人提到的img标签中的图片。</p>\n</blockquote>\n<p>实践发现meta scale指定为1的时候，无该问题。<code>问题产生的原因</code>应该是：在iOS下，对于dpr(设备像素比)2和3的屏，用2倍和3倍的方案，其余的用1倍方案。使用高清屏方案后，viewport的scale值会设为1/dpr，页面发生了缩放，二维码的位置实际发生了偏移，因而微信无法准确识别出二维码。<br>设备像素比 = 物理像素 / 设备独立像素；</p>\n<ul>\n<li>物理像素：一个物理像素是显示器(手机屏幕)上最小的物理显示单元；</li>\n<li>设备独立像素：设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。<br>在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。 在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。</li>\n</ul>\n<p>为了解决二维码识别问题，在html中手动添加viewport的meta标签，这样页面就会根据已有的meta标签设置缩放比例，不会使用高清方案。不使用高清方案一个不好的地方是1px边框问题，不过可以通过伪元素搭配transform:scale(0.5)解决。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> metaEl = doc.querySelector(<span class=\"string\">'meta[name=\"viewport\"]'</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (metaEl) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.warn(<span class=\"string\">'将根据已有的meta标签来设置缩放比例'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> match = metaEl.getAttribute(<span class=\"string\">'content'</span>).match(<span class=\"regexp\">/initial\\-scale=([\\d\\.]+)/</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (match) &#123;</span><br><span class=\"line\">        scale = <span class=\"built_in\">parseFloat</span>(match[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        dpr = <span class=\"built_in\">parseInt</span>(<span class=\"number\">1</span> / scale);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.method-list</span><span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#E1E1E1</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-transform</span>: <span class=\"built_in\">scale</span>(0.5);</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(0.5);</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    box-sizing: border-box;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"菜鸟优化之路-前端性能测试工具sitespeed.io","date":"2018-10-09T12:08:27.000Z","_content":"## 制定优化目标\n### 度量标准\n- 首次有效绘制（First Meaningful Paint，简称FMP，当主要内容呈现在页面上）\n- 英雄渲染时间（Hero Rendering Times，度量用户体验的新指标，当用户最关心的内容渲染完成）\n- 可交互时间（Time to Interactive，简称TTI，指页面布局已经稳定，关键的页面字体是可见的，并且主进程可用于处理用户输入，基本上用户可以点击UI并与其交互）\n- 输入响应（Input responsiveness，界面响应用户输入所需的时间）\n- 感知速度指数（Perceptual Speed Index，简称PSI，测量页面在加载过程中视觉上的变化速度，分数越低越好）\n- 自定义指标，由业务需求和用户体验来决定。\nFMP与英雄渲染时间非常相似，但它们不一样的地方在于FMP不区分内容是否有用，不区分渲染出的内容是否是用户关心的。\n\n### 设定目标\n基于[RAIL](https://developers.google.com/web/fundamentals/performance/rail?hl=zh-cn)模型去制定优化的目标，`RAIL`是一种以用户为中心的性能模型，主要从响应、动画、空闲、加载四个层面去衡量页面性能。\n<!-- more -->\n**1. 100 毫秒的响应时间 + 每秒60帧**\n每帧动画应在少于 16 毫秒（理想情况下为 10 毫秒）内完成，从而达到每秒 60 帧（1 秒 ÷ 60 = 16.6毫秒）。保持乐观，明智地利用空闲时间。对于像动画这样的高压点，只要能，就不要做任何其它事情。预计输入延迟时间（Estimated Input Latency）应低于 50 毫秒。\n\n**2. 速度指数（SpeedIndex）小于 1250，可交互时间（Time-To-Interactive）在 3G 上小于 5 秒**\nSpeed Index是指获取可见页面加载的视觉进度，并计算内容绘制速度的总得分，分数越低，性能越好，具体的计算可参考[speed-index](https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index)。\n目标是在 1 秒内（在高速网络下）完成首次绘制（FMP），速度指数（SpeedIndex）低于 1250 毫秒。考虑速度基线是一台有着 3G 网络的，价格为 200 美元左右的 Android 手机（译注：国产千元机水平），那么可以以 400 毫秒 RTT 和 400kb/s 的传输速度进行网络模拟，以达成可交互时间（Time-To-Interactive）小于 5 秒，第二次打开的速度低于 2 秒。尽你所能地降低这些指标。\n\n**3. 核心块 = 15kb，关键文件 < 170 kb**\nHTML 的前 14~15kb 是最关键的核心块（chunk），也是整个文件中唯一可以在第一个 RTT 内被下载的部分。要实现上述目标，请设定关键文件的最大尺寸“预算”。170kb gzip 后的文件（原始文件尺寸 0.8~1mb），在普通手机上可能需要 1 秒才能解析和编译完成。\n\n## sitespeed.io工具\n[Sitespeed.io](https://www.sitespeed.io/)是一个基于最佳实践以及一些加载时序等量化标准的开源工具，有助于开发者分析网页的加载速度和渲染性能。它拥有一套插件，如[Coach](https://www.sitespeed.io/documentation/coach/)、[Broswertime](https://www.sitespeed.io/documentation/browsertime/)、[Chrome-HAR](https://github.com/sitespeedio/chrome-har)等，帮助sitespeed搜集浏览器debug状态下的数据，并基于网站最佳实践给出相应的打分和意见，最后把数据可视化展示。\nsitespeed.io评价网页的主要依据是：浏览器的网络请求和TimeLine中的Time Event。\n与[webpageTest](https://www.webpagetest.org/)、[PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights/)等只能测试线上站点不同，**`sitespeed.io`可以测试本地运行的，以及测试环境绑定代理的站点**。\n\n### 安装\n可以直接安装`sitespeed.io`的npm包。\n``` bash\nnpm install -g sitespeed.io\nyarn add global sitespeed.io\n```\n也可以使用`docker`或者`git clone`的方式安装，具体可参考[npm-sitespeed.io](https://www.npmjs.com/package/sitespeed.io)。\n\n#### 安装遇到的问题\n在安装过程中有遇到一些问题，具体的问题和解决办法记录在这儿。\n1.修复npm安装时报VCBuild不存在的错误，参考[stackoverflow](https://stackoverflow.com/questions/21658832/npm-install-error-msb3428-could-not-load-the-visual-c-component-vcbuild-ex/39235952#39235952)给出的解决方案。\n``` bash\nnpm install --global --production windows-build-tools\n```\n\n2.`Browser failed to start, could not find ...alto-saxophone\\vendor\\chromedriver.exe`\n查看node-modules/alto-saxophone目录，发现该目录下对应的文件缺失，可以在该目录下运行`npm run install`命令手动安装`chromedriver.exe`。\n``` bash\nnpm run install\n```\n\n3.运行sitespeed.io报错\n``` bash\n$ sitespeed.io https://www.sitespeed.io/\nmodule.js:682\n  return process.dlopen(module, path._makeLong(filename));\nError: The specified module could not be found.\n\\\\?\\C:\\Users\\hzwushuoshuo\\AppData\\Roaming\\npm\\node_modules\\sitespeed.io\\node_modules\\sharp\\build\\Release\\sharp.node\n```\n查看安装`sitespeed.io`的过程，发现在安装`sharp`包时报错`UnhandledPromiseRejectionWarning`，需要在admin模式下去安装文件。\n\n### 运行\n``` bash\nsitespeed.io -n 5 -v https://www.baidu.com\n```\n该命令将会在chrome浏览器下调起URL为https://www.baidu.com 5次。如果期望一次检测多个页面，可以继续拼接参数，如下所示。\n```\nsitespeed.io -n 5 -v https://www.baidu.com -v https://www.baidu.com/s?wd=test\n```\n生成的文件可以在`sitespeed-result`文件夹中查看。\n<img src=\"/image/sitespeed_result.png\">\n\n### 运行结果\n打开`sitespeed.io`输出的html文件，可以查看`Summary`、`Detailed Summary`、`Pages`、`Domains`、`Toplist`和`Assets`六个维度的信息。\n**Summary**\n<img src=\"/image/sitespeed_summary.png\"  width=\"900px\">\n`Summary`是对网页性能数据的一个整体展示。站点得分主要根据页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标进行打分，每个核心指标考核的内容可以在help.html文件中查找。\n页面中的其他指标，如文件压缩、文件大小、请求数、缓存时间、请求状态码、首次渲染时间、前端渲染用时、页面加载用时、DNS解析时长等，这些指标都有详细的统计，而且不同等级用相应的颜色表示。\n\n**Detailed Summary**\n<img src=\"/image/sitespeed_details.png\"  width=\"900px\">\n点击左侧具体的指标，都可以在帮助文档中查看对该指标的解释。针对每个指标都计算除了最小(min)、最大(max)、平均值(mean)、中位数(median)和加载90%(p90)时的数据。\n\n**Pages**\n<img src=\"/image/sitespeed_pages.png\"  width=\"900px\">\n如果一次测试多个页面，可以在`Pages`tab下面查看到不同的页面。点击某个页面的URL可以查看到页面的加载细节，包括资源请求的waterfall瀑布流图：\n<img src=\"/image/sitespeed_waterfall.png\"  width=\"900px\">\n在上图的`coach`Tab下有页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标下各个细分项的得分，并给出了优化建议，如下图所示。\n<img src=\"/image/sitespeed_coach.png\"  width=\"900px\">\n\n**Domains**\n<img src=\"/image/sitespeed_domains.png\"  width=\"900px\">\n`Domains`tab下主要是对按域名统计，各个域名下的请求时间和请求数。\n\n**Toplist**\n<img src=\"/image/sitespeed_toplist.png\"  width=\"900px\">\n`Toplist`会列出所有大的文件，包括JS、CSS、HTML和图片，此外还会列出所有慢的请求。\n\n**Assets**\n<img src=\"/image/sitespeed_assets.png\"  width=\"900px\">\n`Assets`显示了所有被加载资源的前20个，包括文件类型、last-modified时间、缓存时间、文件大小等数据。\n\nREFS:\n[2018 前端性能检查表](https://juejin.im/post/5ac1d117f265da2396128b9f)\n[嗨，送你一张Web性能优化地图](https://zhuanlan.zhihu.com/p/40197752)\n[好用的前端页面性能检测工具—sitespeed.io](https://cloud.tencent.com/developer/article/1033153)\n","source":"_posts/菜鸟优化之路-前端性能测试工具.md","raw":"---\ntitle: 菜鸟优化之路-前端性能测试工具sitespeed.io\ndate: 2018-10-09 20:08:27\ntags: [前端性能优化, sitespeed.io]\n---\n## 制定优化目标\n### 度量标准\n- 首次有效绘制（First Meaningful Paint，简称FMP，当主要内容呈现在页面上）\n- 英雄渲染时间（Hero Rendering Times，度量用户体验的新指标，当用户最关心的内容渲染完成）\n- 可交互时间（Time to Interactive，简称TTI，指页面布局已经稳定，关键的页面字体是可见的，并且主进程可用于处理用户输入，基本上用户可以点击UI并与其交互）\n- 输入响应（Input responsiveness，界面响应用户输入所需的时间）\n- 感知速度指数（Perceptual Speed Index，简称PSI，测量页面在加载过程中视觉上的变化速度，分数越低越好）\n- 自定义指标，由业务需求和用户体验来决定。\nFMP与英雄渲染时间非常相似，但它们不一样的地方在于FMP不区分内容是否有用，不区分渲染出的内容是否是用户关心的。\n\n### 设定目标\n基于[RAIL](https://developers.google.com/web/fundamentals/performance/rail?hl=zh-cn)模型去制定优化的目标，`RAIL`是一种以用户为中心的性能模型，主要从响应、动画、空闲、加载四个层面去衡量页面性能。\n<!-- more -->\n**1. 100 毫秒的响应时间 + 每秒60帧**\n每帧动画应在少于 16 毫秒（理想情况下为 10 毫秒）内完成，从而达到每秒 60 帧（1 秒 ÷ 60 = 16.6毫秒）。保持乐观，明智地利用空闲时间。对于像动画这样的高压点，只要能，就不要做任何其它事情。预计输入延迟时间（Estimated Input Latency）应低于 50 毫秒。\n\n**2. 速度指数（SpeedIndex）小于 1250，可交互时间（Time-To-Interactive）在 3G 上小于 5 秒**\nSpeed Index是指获取可见页面加载的视觉进度，并计算内容绘制速度的总得分，分数越低，性能越好，具体的计算可参考[speed-index](https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index)。\n目标是在 1 秒内（在高速网络下）完成首次绘制（FMP），速度指数（SpeedIndex）低于 1250 毫秒。考虑速度基线是一台有着 3G 网络的，价格为 200 美元左右的 Android 手机（译注：国产千元机水平），那么可以以 400 毫秒 RTT 和 400kb/s 的传输速度进行网络模拟，以达成可交互时间（Time-To-Interactive）小于 5 秒，第二次打开的速度低于 2 秒。尽你所能地降低这些指标。\n\n**3. 核心块 = 15kb，关键文件 < 170 kb**\nHTML 的前 14~15kb 是最关键的核心块（chunk），也是整个文件中唯一可以在第一个 RTT 内被下载的部分。要实现上述目标，请设定关键文件的最大尺寸“预算”。170kb gzip 后的文件（原始文件尺寸 0.8~1mb），在普通手机上可能需要 1 秒才能解析和编译完成。\n\n## sitespeed.io工具\n[Sitespeed.io](https://www.sitespeed.io/)是一个基于最佳实践以及一些加载时序等量化标准的开源工具，有助于开发者分析网页的加载速度和渲染性能。它拥有一套插件，如[Coach](https://www.sitespeed.io/documentation/coach/)、[Broswertime](https://www.sitespeed.io/documentation/browsertime/)、[Chrome-HAR](https://github.com/sitespeedio/chrome-har)等，帮助sitespeed搜集浏览器debug状态下的数据，并基于网站最佳实践给出相应的打分和意见，最后把数据可视化展示。\nsitespeed.io评价网页的主要依据是：浏览器的网络请求和TimeLine中的Time Event。\n与[webpageTest](https://www.webpagetest.org/)、[PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights/)等只能测试线上站点不同，**`sitespeed.io`可以测试本地运行的，以及测试环境绑定代理的站点**。\n\n### 安装\n可以直接安装`sitespeed.io`的npm包。\n``` bash\nnpm install -g sitespeed.io\nyarn add global sitespeed.io\n```\n也可以使用`docker`或者`git clone`的方式安装，具体可参考[npm-sitespeed.io](https://www.npmjs.com/package/sitespeed.io)。\n\n#### 安装遇到的问题\n在安装过程中有遇到一些问题，具体的问题和解决办法记录在这儿。\n1.修复npm安装时报VCBuild不存在的错误，参考[stackoverflow](https://stackoverflow.com/questions/21658832/npm-install-error-msb3428-could-not-load-the-visual-c-component-vcbuild-ex/39235952#39235952)给出的解决方案。\n``` bash\nnpm install --global --production windows-build-tools\n```\n\n2.`Browser failed to start, could not find ...alto-saxophone\\vendor\\chromedriver.exe`\n查看node-modules/alto-saxophone目录，发现该目录下对应的文件缺失，可以在该目录下运行`npm run install`命令手动安装`chromedriver.exe`。\n``` bash\nnpm run install\n```\n\n3.运行sitespeed.io报错\n``` bash\n$ sitespeed.io https://www.sitespeed.io/\nmodule.js:682\n  return process.dlopen(module, path._makeLong(filename));\nError: The specified module could not be found.\n\\\\?\\C:\\Users\\hzwushuoshuo\\AppData\\Roaming\\npm\\node_modules\\sitespeed.io\\node_modules\\sharp\\build\\Release\\sharp.node\n```\n查看安装`sitespeed.io`的过程，发现在安装`sharp`包时报错`UnhandledPromiseRejectionWarning`，需要在admin模式下去安装文件。\n\n### 运行\n``` bash\nsitespeed.io -n 5 -v https://www.baidu.com\n```\n该命令将会在chrome浏览器下调起URL为https://www.baidu.com 5次。如果期望一次检测多个页面，可以继续拼接参数，如下所示。\n```\nsitespeed.io -n 5 -v https://www.baidu.com -v https://www.baidu.com/s?wd=test\n```\n生成的文件可以在`sitespeed-result`文件夹中查看。\n<img src=\"/image/sitespeed_result.png\">\n\n### 运行结果\n打开`sitespeed.io`输出的html文件，可以查看`Summary`、`Detailed Summary`、`Pages`、`Domains`、`Toplist`和`Assets`六个维度的信息。\n**Summary**\n<img src=\"/image/sitespeed_summary.png\"  width=\"900px\">\n`Summary`是对网页性能数据的一个整体展示。站点得分主要根据页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标进行打分，每个核心指标考核的内容可以在help.html文件中查找。\n页面中的其他指标，如文件压缩、文件大小、请求数、缓存时间、请求状态码、首次渲染时间、前端渲染用时、页面加载用时、DNS解析时长等，这些指标都有详细的统计，而且不同等级用相应的颜色表示。\n\n**Detailed Summary**\n<img src=\"/image/sitespeed_details.png\"  width=\"900px\">\n点击左侧具体的指标，都可以在帮助文档中查看对该指标的解释。针对每个指标都计算除了最小(min)、最大(max)、平均值(mean)、中位数(median)和加载90%(p90)时的数据。\n\n**Pages**\n<img src=\"/image/sitespeed_pages.png\"  width=\"900px\">\n如果一次测试多个页面，可以在`Pages`tab下面查看到不同的页面。点击某个页面的URL可以查看到页面的加载细节，包括资源请求的waterfall瀑布流图：\n<img src=\"/image/sitespeed_waterfall.png\"  width=\"900px\">\n在上图的`coach`Tab下有页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标下各个细分项的得分，并给出了优化建议，如下图所示。\n<img src=\"/image/sitespeed_coach.png\"  width=\"900px\">\n\n**Domains**\n<img src=\"/image/sitespeed_domains.png\"  width=\"900px\">\n`Domains`tab下主要是对按域名统计，各个域名下的请求时间和请求数。\n\n**Toplist**\n<img src=\"/image/sitespeed_toplist.png\"  width=\"900px\">\n`Toplist`会列出所有大的文件，包括JS、CSS、HTML和图片，此外还会列出所有慢的请求。\n\n**Assets**\n<img src=\"/image/sitespeed_assets.png\"  width=\"900px\">\n`Assets`显示了所有被加载资源的前20个，包括文件类型、last-modified时间、缓存时间、文件大小等数据。\n\nREFS:\n[2018 前端性能检查表](https://juejin.im/post/5ac1d117f265da2396128b9f)\n[嗨，送你一张Web性能优化地图](https://zhuanlan.zhihu.com/p/40197752)\n[好用的前端页面性能检测工具—sitespeed.io](https://cloud.tencent.com/developer/article/1033153)\n","slug":"菜鸟优化之路-前端性能测试工具","published":1,"updated":"2019-03-18T02:27:14.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx8g003cqmhfghcb44yc","content":"<h2 id=\"制定优化目标\"><a href=\"#制定优化目标\" class=\"headerlink\" title=\"制定优化目标\"></a>制定优化目标</h2><h3 id=\"度量标准\"><a href=\"#度量标准\" class=\"headerlink\" title=\"度量标准\"></a>度量标准</h3><ul>\n<li>首次有效绘制（First Meaningful Paint，简称FMP，当主要内容呈现在页面上）</li>\n<li>英雄渲染时间（Hero Rendering Times，度量用户体验的新指标，当用户最关心的内容渲染完成）</li>\n<li>可交互时间（Time to Interactive，简称TTI，指页面布局已经稳定，关键的页面字体是可见的，并且主进程可用于处理用户输入，基本上用户可以点击UI并与其交互）</li>\n<li>输入响应（Input responsiveness，界面响应用户输入所需的时间）</li>\n<li>感知速度指数（Perceptual Speed Index，简称PSI，测量页面在加载过程中视觉上的变化速度，分数越低越好）</li>\n<li>自定义指标，由业务需求和用户体验来决定。<br>FMP与英雄渲染时间非常相似，但它们不一样的地方在于FMP不区分内容是否有用，不区分渲染出的内容是否是用户关心的。</li>\n</ul>\n<h3 id=\"设定目标\"><a href=\"#设定目标\" class=\"headerlink\" title=\"设定目标\"></a>设定目标</h3><p>基于<a href=\"https://developers.google.com/web/fundamentals/performance/rail?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">RAIL</a>模型去制定优化的目标，<code>RAIL</code>是一种以用户为中心的性能模型，主要从响应、动画、空闲、加载四个层面去衡量页面性能。<br><a id=\"more\"></a><br><strong>1. 100 毫秒的响应时间 + 每秒60帧</strong><br>每帧动画应在少于 16 毫秒（理想情况下为 10 毫秒）内完成，从而达到每秒 60 帧（1 秒 ÷ 60 = 16.6毫秒）。保持乐观，明智地利用空闲时间。对于像动画这样的高压点，只要能，就不要做任何其它事情。预计输入延迟时间（Estimated Input Latency）应低于 50 毫秒。</p>\n<p><strong>2. 速度指数（SpeedIndex）小于 1250，可交互时间（Time-To-Interactive）在 3G 上小于 5 秒</strong><br>Speed Index是指获取可见页面加载的视觉进度，并计算内容绘制速度的总得分，分数越低，性能越好，具体的计算可参考<a href=\"https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index\" target=\"_blank\" rel=\"noopener\">speed-index</a>。<br>目标是在 1 秒内（在高速网络下）完成首次绘制（FMP），速度指数（SpeedIndex）低于 1250 毫秒。考虑速度基线是一台有着 3G 网络的，价格为 200 美元左右的 Android 手机（译注：国产千元机水平），那么可以以 400 毫秒 RTT 和 400kb/s 的传输速度进行网络模拟，以达成可交互时间（Time-To-Interactive）小于 5 秒，第二次打开的速度低于 2 秒。尽你所能地降低这些指标。</p>\n<p><strong>3. 核心块 = 15kb，关键文件 &lt; 170 kb</strong><br>HTML 的前 14~15kb 是最关键的核心块（chunk），也是整个文件中唯一可以在第一个 RTT 内被下载的部分。要实现上述目标，请设定关键文件的最大尺寸“预算”。170kb gzip 后的文件（原始文件尺寸 0.8~1mb），在普通手机上可能需要 1 秒才能解析和编译完成。</p>\n<h2 id=\"sitespeed-io工具\"><a href=\"#sitespeed-io工具\" class=\"headerlink\" title=\"sitespeed.io工具\"></a>sitespeed.io工具</h2><p><a href=\"https://www.sitespeed.io/\" target=\"_blank\" rel=\"noopener\">Sitespeed.io</a>是一个基于最佳实践以及一些加载时序等量化标准的开源工具，有助于开发者分析网页的加载速度和渲染性能。它拥有一套插件，如<a href=\"https://www.sitespeed.io/documentation/coach/\" target=\"_blank\" rel=\"noopener\">Coach</a>、<a href=\"https://www.sitespeed.io/documentation/browsertime/\" target=\"_blank\" rel=\"noopener\">Broswertime</a>、<a href=\"https://github.com/sitespeedio/chrome-har\" target=\"_blank\" rel=\"noopener\">Chrome-HAR</a>等，帮助sitespeed搜集浏览器debug状态下的数据，并基于网站最佳实践给出相应的打分和意见，最后把数据可视化展示。<br>sitespeed.io评价网页的主要依据是：浏览器的网络请求和TimeLine中的Time Event。<br>与<a href=\"https://www.webpagetest.org/\" target=\"_blank\" rel=\"noopener\">webpageTest</a>、<a href=\"https://developers.google.com/speed/pagespeed/insights/\" target=\"_blank\" rel=\"noopener\">PageSpeed Insights</a>等只能测试线上站点不同，<strong><code>sitespeed.io</code>可以测试本地运行的，以及测试环境绑定代理的站点</strong>。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>可以直接安装<code>sitespeed.io</code>的npm包。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g sitespeed.io</span><br><span class=\"line\">yarn add global sitespeed.io</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用<code>docker</code>或者<code>git clone</code>的方式安装，具体可参考<a href=\"https://www.npmjs.com/package/sitespeed.io\" target=\"_blank\" rel=\"noopener\">npm-sitespeed.io</a>。</p>\n<h4 id=\"安装遇到的问题\"><a href=\"#安装遇到的问题\" class=\"headerlink\" title=\"安装遇到的问题\"></a>安装遇到的问题</h4><p>在安装过程中有遇到一些问题，具体的问题和解决办法记录在这儿。<br>1.修复npm安装时报VCBuild不存在的错误，参考<a href=\"https://stackoverflow.com/questions/21658832/npm-install-error-msb3428-could-not-load-the-visual-c-component-vcbuild-ex/39235952#39235952\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>给出的解决方案。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --global --production windows-build-tools</span><br></pre></td></tr></table></figure></p>\n<p>2.<code>Browser failed to start, could not find ...alto-saxophone\\vendor\\chromedriver.exe</code><br>查看node-modules/alto-saxophone目录，发现该目录下对应的文件缺失，可以在该目录下运行<code>npm run install</code>命令手动安装<code>chromedriver.exe</code>。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run install</span><br></pre></td></tr></table></figure></p>\n<p>3.运行sitespeed.io报错<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sitespeed.io https://www.sitespeed.io/</span><br><span class=\"line\">module.js:682</span><br><span class=\"line\">  <span class=\"built_in\">return</span> process.dlopen(module, path._makeLong(filename));</span><br><span class=\"line\">Error: The specified module could not be found.</span><br><span class=\"line\">\\\\?\\C:\\Users\\hzwushuoshuo\\AppData\\Roaming\\npm\\node_modules\\sitespeed.io\\node_modules\\sharp\\build\\Release\\sharp.node</span><br></pre></td></tr></table></figure></p>\n<p>查看安装<code>sitespeed.io</code>的过程，发现在安装<code>sharp</code>包时报错<code>UnhandledPromiseRejectionWarning</code>，需要在admin模式下去安装文件。</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sitespeed.io -n 5 -v https://www.baidu.com</span><br></pre></td></tr></table></figure>\n<p>该命令将会在chrome浏览器下调起URL为<a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com</a> 5次。如果期望一次检测多个页面，可以继续拼接参数，如下所示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sitespeed.io -n 5 -v https://www.baidu.com -v https://www.baidu.com/s?wd=test</span><br></pre></td></tr></table></figure></p>\n<p>生成的文件可以在<code>sitespeed-result</code>文件夹中查看。<br><img src=\"/image/sitespeed_result.png\"></p>\n<h3 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h3><p>打开<code>sitespeed.io</code>输出的html文件，可以查看<code>Summary</code>、<code>Detailed Summary</code>、<code>Pages</code>、<code>Domains</code>、<code>Toplist</code>和<code>Assets</code>六个维度的信息。<br><strong>Summary</strong><br><img src=\"/image/sitespeed_summary.png\" width=\"900px\"><br><code>Summary</code>是对网页性能数据的一个整体展示。站点得分主要根据页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标进行打分，每个核心指标考核的内容可以在help.html文件中查找。<br>页面中的其他指标，如文件压缩、文件大小、请求数、缓存时间、请求状态码、首次渲染时间、前端渲染用时、页面加载用时、DNS解析时长等，这些指标都有详细的统计，而且不同等级用相应的颜色表示。</p>\n<p><strong>Detailed Summary</strong><br><img src=\"/image/sitespeed_details.png\" width=\"900px\"><br>点击左侧具体的指标，都可以在帮助文档中查看对该指标的解释。针对每个指标都计算除了最小(min)、最大(max)、平均值(mean)、中位数(median)和加载90%(p90)时的数据。</p>\n<p><strong>Pages</strong><br><img src=\"/image/sitespeed_pages.png\" width=\"900px\"><br>如果一次测试多个页面，可以在<code>Pages</code>tab下面查看到不同的页面。点击某个页面的URL可以查看到页面的加载细节，包括资源请求的waterfall瀑布流图：<br><img src=\"/image/sitespeed_waterfall.png\" width=\"900px\"><br>在上图的<code>coach</code>Tab下有页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标下各个细分项的得分，并给出了优化建议，如下图所示。<br><img src=\"/image/sitespeed_coach.png\" width=\"900px\"></p>\n<p><strong>Domains</strong><br><img src=\"/image/sitespeed_domains.png\" width=\"900px\"><br><code>Domains</code>tab下主要是对按域名统计，各个域名下的请求时间和请求数。</p>\n<p><strong>Toplist</strong><br><img src=\"/image/sitespeed_toplist.png\" width=\"900px\"><br><code>Toplist</code>会列出所有大的文件，包括JS、CSS、HTML和图片，此外还会列出所有慢的请求。</p>\n<p><strong>Assets</strong><br><img src=\"/image/sitespeed_assets.png\" width=\"900px\"><br><code>Assets</code>显示了所有被加载资源的前20个，包括文件类型、last-modified时间、缓存时间、文件大小等数据。</p>\n<p>REFS:<br><a href=\"https://juejin.im/post/5ac1d117f265da2396128b9f\" target=\"_blank\" rel=\"noopener\">2018 前端性能检查表</a><br><a href=\"https://zhuanlan.zhihu.com/p/40197752\" target=\"_blank\" rel=\"noopener\">嗨，送你一张Web性能优化地图</a><br><a href=\"https://cloud.tencent.com/developer/article/1033153\" target=\"_blank\" rel=\"noopener\">好用的前端页面性能检测工具—sitespeed.io</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"制定优化目标\"><a href=\"#制定优化目标\" class=\"headerlink\" title=\"制定优化目标\"></a>制定优化目标</h2><h3 id=\"度量标准\"><a href=\"#度量标准\" class=\"headerlink\" title=\"度量标准\"></a>度量标准</h3><ul>\n<li>首次有效绘制（First Meaningful Paint，简称FMP，当主要内容呈现在页面上）</li>\n<li>英雄渲染时间（Hero Rendering Times，度量用户体验的新指标，当用户最关心的内容渲染完成）</li>\n<li>可交互时间（Time to Interactive，简称TTI，指页面布局已经稳定，关键的页面字体是可见的，并且主进程可用于处理用户输入，基本上用户可以点击UI并与其交互）</li>\n<li>输入响应（Input responsiveness，界面响应用户输入所需的时间）</li>\n<li>感知速度指数（Perceptual Speed Index，简称PSI，测量页面在加载过程中视觉上的变化速度，分数越低越好）</li>\n<li>自定义指标，由业务需求和用户体验来决定。<br>FMP与英雄渲染时间非常相似，但它们不一样的地方在于FMP不区分内容是否有用，不区分渲染出的内容是否是用户关心的。</li>\n</ul>\n<h3 id=\"设定目标\"><a href=\"#设定目标\" class=\"headerlink\" title=\"设定目标\"></a>设定目标</h3><p>基于<a href=\"https://developers.google.com/web/fundamentals/performance/rail?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">RAIL</a>模型去制定优化的目标，<code>RAIL</code>是一种以用户为中心的性能模型，主要从响应、动画、空闲、加载四个层面去衡量页面性能。<br>","more":"<br><strong>1. 100 毫秒的响应时间 + 每秒60帧</strong><br>每帧动画应在少于 16 毫秒（理想情况下为 10 毫秒）内完成，从而达到每秒 60 帧（1 秒 ÷ 60 = 16.6毫秒）。保持乐观，明智地利用空闲时间。对于像动画这样的高压点，只要能，就不要做任何其它事情。预计输入延迟时间（Estimated Input Latency）应低于 50 毫秒。</p>\n<p><strong>2. 速度指数（SpeedIndex）小于 1250，可交互时间（Time-To-Interactive）在 3G 上小于 5 秒</strong><br>Speed Index是指获取可见页面加载的视觉进度，并计算内容绘制速度的总得分，分数越低，性能越好，具体的计算可参考<a href=\"https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index\" target=\"_blank\" rel=\"noopener\">speed-index</a>。<br>目标是在 1 秒内（在高速网络下）完成首次绘制（FMP），速度指数（SpeedIndex）低于 1250 毫秒。考虑速度基线是一台有着 3G 网络的，价格为 200 美元左右的 Android 手机（译注：国产千元机水平），那么可以以 400 毫秒 RTT 和 400kb/s 的传输速度进行网络模拟，以达成可交互时间（Time-To-Interactive）小于 5 秒，第二次打开的速度低于 2 秒。尽你所能地降低这些指标。</p>\n<p><strong>3. 核心块 = 15kb，关键文件 &lt; 170 kb</strong><br>HTML 的前 14~15kb 是最关键的核心块（chunk），也是整个文件中唯一可以在第一个 RTT 内被下载的部分。要实现上述目标，请设定关键文件的最大尺寸“预算”。170kb gzip 后的文件（原始文件尺寸 0.8~1mb），在普通手机上可能需要 1 秒才能解析和编译完成。</p>\n<h2 id=\"sitespeed-io工具\"><a href=\"#sitespeed-io工具\" class=\"headerlink\" title=\"sitespeed.io工具\"></a>sitespeed.io工具</h2><p><a href=\"https://www.sitespeed.io/\" target=\"_blank\" rel=\"noopener\">Sitespeed.io</a>是一个基于最佳实践以及一些加载时序等量化标准的开源工具，有助于开发者分析网页的加载速度和渲染性能。它拥有一套插件，如<a href=\"https://www.sitespeed.io/documentation/coach/\" target=\"_blank\" rel=\"noopener\">Coach</a>、<a href=\"https://www.sitespeed.io/documentation/browsertime/\" target=\"_blank\" rel=\"noopener\">Broswertime</a>、<a href=\"https://github.com/sitespeedio/chrome-har\" target=\"_blank\" rel=\"noopener\">Chrome-HAR</a>等，帮助sitespeed搜集浏览器debug状态下的数据，并基于网站最佳实践给出相应的打分和意见，最后把数据可视化展示。<br>sitespeed.io评价网页的主要依据是：浏览器的网络请求和TimeLine中的Time Event。<br>与<a href=\"https://www.webpagetest.org/\" target=\"_blank\" rel=\"noopener\">webpageTest</a>、<a href=\"https://developers.google.com/speed/pagespeed/insights/\" target=\"_blank\" rel=\"noopener\">PageSpeed Insights</a>等只能测试线上站点不同，<strong><code>sitespeed.io</code>可以测试本地运行的，以及测试环境绑定代理的站点</strong>。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>可以直接安装<code>sitespeed.io</code>的npm包。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g sitespeed.io</span><br><span class=\"line\">yarn add global sitespeed.io</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用<code>docker</code>或者<code>git clone</code>的方式安装，具体可参考<a href=\"https://www.npmjs.com/package/sitespeed.io\" target=\"_blank\" rel=\"noopener\">npm-sitespeed.io</a>。</p>\n<h4 id=\"安装遇到的问题\"><a href=\"#安装遇到的问题\" class=\"headerlink\" title=\"安装遇到的问题\"></a>安装遇到的问题</h4><p>在安装过程中有遇到一些问题，具体的问题和解决办法记录在这儿。<br>1.修复npm安装时报VCBuild不存在的错误，参考<a href=\"https://stackoverflow.com/questions/21658832/npm-install-error-msb3428-could-not-load-the-visual-c-component-vcbuild-ex/39235952#39235952\" target=\"_blank\" rel=\"noopener\">stackoverflow</a>给出的解决方案。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --global --production windows-build-tools</span><br></pre></td></tr></table></figure></p>\n<p>2.<code>Browser failed to start, could not find ...alto-saxophone\\vendor\\chromedriver.exe</code><br>查看node-modules/alto-saxophone目录，发现该目录下对应的文件缺失，可以在该目录下运行<code>npm run install</code>命令手动安装<code>chromedriver.exe</code>。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run install</span><br></pre></td></tr></table></figure></p>\n<p>3.运行sitespeed.io报错<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sitespeed.io https://www.sitespeed.io/</span><br><span class=\"line\">module.js:682</span><br><span class=\"line\">  <span class=\"built_in\">return</span> process.dlopen(module, path._makeLong(filename));</span><br><span class=\"line\">Error: The specified module could not be found.</span><br><span class=\"line\">\\\\?\\C:\\Users\\hzwushuoshuo\\AppData\\Roaming\\npm\\node_modules\\sitespeed.io\\node_modules\\sharp\\build\\Release\\sharp.node</span><br></pre></td></tr></table></figure></p>\n<p>查看安装<code>sitespeed.io</code>的过程，发现在安装<code>sharp</code>包时报错<code>UnhandledPromiseRejectionWarning</code>，需要在admin模式下去安装文件。</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sitespeed.io -n 5 -v https://www.baidu.com</span><br></pre></td></tr></table></figure>\n<p>该命令将会在chrome浏览器下调起URL为<a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com</a> 5次。如果期望一次检测多个页面，可以继续拼接参数，如下所示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sitespeed.io -n 5 -v https://www.baidu.com -v https://www.baidu.com/s?wd=test</span><br></pre></td></tr></table></figure></p>\n<p>生成的文件可以在<code>sitespeed-result</code>文件夹中查看。<br><img src=\"/image/sitespeed_result.png\"></p>\n<h3 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h3><p>打开<code>sitespeed.io</code>输出的html文件，可以查看<code>Summary</code>、<code>Detailed Summary</code>、<code>Pages</code>、<code>Domains</code>、<code>Toplist</code>和<code>Assets</code>六个维度的信息。<br><strong>Summary</strong><br><img src=\"/image/sitespeed_summary.png\" width=\"900px\"><br><code>Summary</code>是对网页性能数据的一个整体展示。站点得分主要根据页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标进行打分，每个核心指标考核的内容可以在help.html文件中查找。<br>页面中的其他指标，如文件压缩、文件大小、请求数、缓存时间、请求状态码、首次渲染时间、前端渲染用时、页面加载用时、DNS解析时长等，这些指标都有详细的统计，而且不同等级用相应的颜色表示。</p>\n<p><strong>Detailed Summary</strong><br><img src=\"/image/sitespeed_details.png\" width=\"900px\"><br>点击左侧具体的指标，都可以在帮助文档中查看对该指标的解释。针对每个指标都计算除了最小(min)、最大(max)、平均值(mean)、中位数(median)和加载90%(p90)时的数据。</p>\n<p><strong>Pages</strong><br><img src=\"/image/sitespeed_pages.png\" width=\"900px\"><br>如果一次测试多个页面，可以在<code>Pages</code>tab下面查看到不同的页面。点击某个页面的URL可以查看到页面的加载细节，包括资源请求的waterfall瀑布流图：<br><img src=\"/image/sitespeed_waterfall.png\" width=\"900px\"><br>在上图的<code>coach</code>Tab下有页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标下各个细分项的得分，并给出了优化建议，如下图所示。<br><img src=\"/image/sitespeed_coach.png\" width=\"900px\"></p>\n<p><strong>Domains</strong><br><img src=\"/image/sitespeed_domains.png\" width=\"900px\"><br><code>Domains</code>tab下主要是对按域名统计，各个域名下的请求时间和请求数。</p>\n<p><strong>Toplist</strong><br><img src=\"/image/sitespeed_toplist.png\" width=\"900px\"><br><code>Toplist</code>会列出所有大的文件，包括JS、CSS、HTML和图片，此外还会列出所有慢的请求。</p>\n<p><strong>Assets</strong><br><img src=\"/image/sitespeed_assets.png\" width=\"900px\"><br><code>Assets</code>显示了所有被加载资源的前20个，包括文件类型、last-modified时间、缓存时间、文件大小等数据。</p>\n<p>REFS:<br><a href=\"https://juejin.im/post/5ac1d117f265da2396128b9f\" target=\"_blank\" rel=\"noopener\">2018 前端性能检查表</a><br><a href=\"https://zhuanlan.zhihu.com/p/40197752\" target=\"_blank\" rel=\"noopener\">嗨，送你一张Web性能优化地图</a><br><a href=\"https://cloud.tencent.com/developer/article/1033153\" target=\"_blank\" rel=\"noopener\">好用的前端页面性能检测工具—sitespeed.io</a></p>"},{"title":"菜鸟优化之路","date":"2018-08-08T08:21:21.000Z","_content":"# DeviceTiming工具\n最近了解到[DeviceTiming](https://github.com/danielmendel/DeviceTiming)工具，可以帮助我们监测js在不同设备上的解析和执行时间，运行环境是在开发环境下。\n搬运下git上的安装、运行命令：\n``` bash\n//安装\ngit clone https://github.com/etsy/DeviceTiming.git\ncd DeviceTiming\nnpm install\n\n//运行\n./devicetiming server /path/to/your/js\n```\n** 注意：devicetiming会改变被监控的js，要先备份好，不过有git记录的就不用担心了 **\n运行了之后，用不同的设备访问开发环境下的站点，最后reload`http://localhost:8537/`页面，可以看到不同设备对js的解析和执行时间，如下图所示：\n<img src=\"/image/deviceTiming.png\" width=\"1200px\">\n可以看到不同设备的ua信息，每个js的parse和exec时间。从上到下，三个设备分别是微信开发者工具、iphone、安卓机。从数据上看，安卓机parse和exec花费的时间最久，花费时间越长，用户的体验就会越差。\n该站点面向的用户中安卓机份额更高，`how to optimize`显得比较重要。\n\n# how to optimize\n## 尾部调用优化（TCO）\n尾调用概念就是在函数最后一步调用其他函数。\n``` js\nfunction foo(x) {\n    return x;\n}\n\nfunction bar(y) {\n    return foo( y + 1 );    // 尾部调用\n}\n\nfunction baz() {\n    return 1 + bar( 40 );   // 不是尾部调用\n}\n\nbaz();                      // 42\n```\n`bar`函数的最后一步是调用`foo( y + 1 )`，属于尾部调用；而在`baz`函数中，调用完`bar(40)`后，还有执行`+ 1`的操作，就不属于尾部调用了。\n<!-- more -->\n\n> 函数调用会在内存形成一个\"调用记录\"，又称\"调用帧\"（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个\"调用栈\"（call stack）。\n\n<img src=\"/image/callstack.png\" width=\"555px\">\n\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。\n``` js\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n```\n如果函数`g`不是尾部调用，函数`f`就需要保存内部变量m和n的值、g的调用位置等信息。\n`尾部调用优化`，即只保留内层函数的调用记录，运用这一思想可以去优化递归，不需要再保存每次的调用记录，始终只存在一个调用记录，可以避免'栈溢出'。\n\n## 动态加载组件\n### 代码分片\n当前端代码越来越复杂，代码体积越来越大时，考虑对加载的资源进行细粒度的分割，按需加载。\nwebpack支持两种语法实现动态地加载模块：\n- [require.ensure](https://webpack.js.org/api/module-methods/#require-ensure)\n给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。\n```js\nrequire.ensure(dependencies: String[], callback: function(require), chunkName: String)\n```\n\n- [import](https://webpack.js.org/api/module-methods/#import-)\n调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。\n```js\nimport(\n  /* webpackChunkName: \"my-chunk-name\" */\n  /* webpackMode: \"lazy\" (default)*/\n  'path/to/module') -> Promise\n```\n`webpackChunkName`用来设置chunk的名字；`webpackMode`默认值是`lazy`，还有`lazy-once`、`eager`、`weak`。\n\n按需加载的默认加载形式是async。\n\n### react动态加载组件\n在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。\n直接看代码：\n``` js\nimport React, {Component} from 'react'\n\n/**\n * 异步加载模块\n * @param  {[type]} loadComponent [description]\n * @return {[type]}               [description]\n */\nexport const asyncComponent = loadComponent => (\n    class AsyncComponent extends Component {\n        state = {\n            Component: null,\n        }\n\n        componentDidMount() {\n            if (this.hasLoadedComponent()) {\n                return;\n            }\n\n            loadComponent()\n                .then(module => module.default)\n                .then((Component) => {\n                    this.setState({ Component });\n                })\n                .catch((err) => {\n                    console.error(`Cannot load component in <AsyncComponent />`);\n                    throw err;\n                });\n        }\n\n        hasLoadedComponent() {\n            return this.state.Component !== null;\n        }\n\n        render() {\n            const { Component } = this.state;\n            return (Component) ? <Component {...this.props} /> : null;\n        }\n    }\n);\n```\n\n`loadComponent`参数代表import('module')异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。\n如何调用：\n``` js\nexport const AsyncBannerSwiper = asyncComponent(() => import(/* webpackChunkName: \"bannerSwiper\" */ './BannerSwiper.jsx'))\n```\n将`BannerSwiper`组件用`asyncComponent`封装下，就返回了一个异步加载的`AsyncBannerSwiper`组件，使用方法和其他组件完全一致。\n\n#### publicPath动态设置\n项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。\n动态设置异步chunk的publicPath，在入口entry中设置__webpack_public_path__，打包配置文件中配置的publicPath不变。\n``` js\n__webpack_public_path__ = window.cdn || '/dist/';\n\n```\n\n### webpack设置\n在webpack配置文件中，需要配置`chunkFilename`指定chunk的名字。\n``` js\nchunkFilename: '[name].js'\n```\n另外，注意webpack插件的配置：\n``` js\nnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id\nnew webpack.optimize.CommonsChunkPlugin({\n    ...\n    children: false,  // 如果设置为 `true`，所有公共 chunk 的子模块都会被选择\n    ...\n}),\nnew ExtractTextPlugin({filename: 'css/[name].css?[contenthash:8]', allChunks: true}),  //从所有chunk中提取(默认情况下，它仅从initial chunk中提取)\n```\n\n### 分离前后对比\n使用[webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：\n<img src=\"/image/codesplit_before.png\" width=\"600px\">\n可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：\n<img src=\"/image/codesplit_before1.png\" width=\"500px\">\n\n使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：\n<img src=\"/image/codesplit_after.png\" width=\"600px\">\n可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。\n<img src=\"/image/codesplit_after1.png\" width=\"500px\">\n\nREFS:\nhttps://blog.csdn.net/qq20004604/article/details/79318253\nhttps://segmentfault.com/a/1190000009820646\n\n## 持久化内存\n为了获取持久化内存，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。\n#### moduleId VS chunkId\n看打包后的`manifest.js`，精简的源码如下所示：\n``` js\n(function(modules) {\n  window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n    var moduleId, result;\n    for (moduleId in moreModules) {\n      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n        // 将chunk中所包含的模块放入modules数组中\n        modules[moduleId] = moreModules[moduleId]; \n      }\n    }\n    if (executeModules) {\n      for (i = 0; i < executeModules.length; i++) {\n        result = __webpack_require__(executeModules[i]);\n      }\n    }\n    return result;\n  };\n  var installedModules = {};\n\n  // 调用__webpack_require__(moduleId)时，\n  //再将模块放入installedModules，用于保存已经加载过的模块\n  function __webpack_require__(moduleId) {\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    var module = installedModules[moduleId] = {\n      exports: {}\n    };\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    return module.exports;\n  }\n})([]);\n```\n`webpackJsonp`方法接收三个参数`chunkIds, moreModules, executeModules`，分别属于chunkId和moduleId两种类型:\n- chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。\n- module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前`__webpack_require__`加载的模块，同样使用数组下标作为moduleId。\n每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。\n\n### 固化moduleId和chunkId\n- 固化moduleId：`HashedModuleIdsPlugin`会根据文件的路径去生成hash，可以用在生成环境。开发环境可以使用`NamedModulesPlugin`，hash直接是模块的相对路径，更加清晰，便于debug。\n- 固化chunkId：webpack中entry的唯一的，所以可以直接使用entry名作为chunkId，使用`NamedChunksPlugin`可以帮助我们达成该目标，如果是代码分离出的chunk可以使用`/* webpackChunkName: \"bannerSwiper\" */`指定chunk的名字，或者可以在`NamedChunksPlugin`插件中去配置。\n```js\nnew webpack.HashedModuleIdsPlugin(), //固化 module id\nnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id\n```\n\nREFS:\nhttps://github.com/pigcan/blog/issues/9\nhttps://www.imooc.com/article/21538\nhttps://juejin.im/post/5a23b130f265da432003101a\nhttps://github.com/happylindz/blog/issues/6\n\n## 内存泄露排查\n> 内存泄露：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。\n> JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。\n\n### JavaScript内存泄露\n垃圾回收语言的内存泄漏主因是不需要的引用。大部分垃圾回收语言用的算法称之为 Mark-and-sweep 。算法由以下几步组成：\n- 垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；\n- 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。\n- 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。\n现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。\n\n### 四种常见的JavaScript内存泄漏类型：\n- 意外的window全局变量\n- 被遗忘的计时器或回调函数\n- 脱离 DOM 的引用\n- 闭包\n\n### 实例分析\n#### 浏览器performance\n切换到该tab下，勾选memory，并点击记录按钮，不断点击阅读下一章，持续一段时间。\n<img src=\"/image/memory_0.png\" width=\"900px\">\n三种迹象显示出现了内存泄漏，图中的 Nodes（绿线）、Listeners（黄线）和 JS heap（蓝线）。Nodes、Listeners稳定增长，并未下降，这是个显著的信号。\n\n#### 浏览器 heap profile\n切换到memory tab下，等待页面刷新完成，点击take heap snapshot保存当前快照。切换到下一章节，重复之前操作，保存快照。\n选择Comparison，将快照与之前的进行对比，可以发现有的对象如content只增不减。\n<img src=\"/image/heap_1.png\" width=\"800px\">\n仔细分析代码，发现Content组件中有注册事件代理，监听`fontChange`事件变化，作为一个SPA，`EventProxy`一直存在于内存中，每次创建新的content时候，都会给`fontChange`事件新注册一个回调方法，之前的回调方法一直保存在回调数组中，没有被回收，导致content组件也不能被正确回收：\n``` js\nconst eventProxy = {\n  //...\n  off: function(key) {\n    this.onObj[key] = [];\n    this.oneObj[key] = [];\n  },\n  //...\n}\n\ncomponentDidMount() {\n    EventProxy.on('fontChange', diff => this.handleFontChange(diff));\n}\n\ncomponentWillUnmount() {\n    EventProxy.off('fontChange'); //Release memory\n    this.listener && window.removeEventListener('scroll', this.listener, false); //Release memory\n}\n```\n调用`EventProxy.off('fontChange')`解除eventProxy对象对`this.handleFontChange`的引用，这样this对应的content的对象才能被正确回收；和`removeEventListener`一样的原理。\n``` js\nthis.listener = () => {\n    if(this.contentWrap && (window.pageYOffset > this.contentWrap.offsetHeight / 2)) {\n        //...\n        window.removeEventListener('scroll', this.listener, false); //Release memory(事件不一定被触发)\n    }\n}\nwindow.addEventListener('scroll', this.listener, false)\n```\n虽然在`this.listener`内部有解除scroll事件监听的代码，但是要满足一定条件才会触发，所以在`componentWillUnmount`方法中也添加了`removeEventListener`，实现对scroll事件的解绑。\n\n经过上面的优化后，再次对比，发现content对象可以被正常回收。\n<img src=\"/image/heap_2_content.png\" width=\"800px\">\n\nREFs: https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/\n\n## cpu占比探测\n``` js\nvar data = []\nvar t\n\nfunction pulse() {\n  t && data.push(Date.now() - t)\n  t = Date.now()\n  setTimeout(pulse, 50)\n}\n\npulse()\n```\n就是每隔 50ms 打一下点。理想情况下，data 的值应该是\n``` js\ndata = [50, 50, 50, 50, ...]\n```\n但实际情况，data会是\n``` js\ndata = [51, 52, 50, 52, ...]\n```\ncpu越忙，data的数据项会越大。这样，记录一系列 data 值，就可以绘制出 CPU 占比趋势图，和通过任务管理器看到的 CPU 趋势图非常接近。\n\n上面只是原理说明，实际情况没这么简单。但很明显，通过这么一个简单的规律，就能实现用纯 JavaScript 来探测 CPU 占比。\n","source":"_posts/菜鸟优化之路.md","raw":"---\ntitle: 菜鸟优化之路\ndate: 2018-08-08 16:21:21\ntags: [前端性能优化]\n---\n# DeviceTiming工具\n最近了解到[DeviceTiming](https://github.com/danielmendel/DeviceTiming)工具，可以帮助我们监测js在不同设备上的解析和执行时间，运行环境是在开发环境下。\n搬运下git上的安装、运行命令：\n``` bash\n//安装\ngit clone https://github.com/etsy/DeviceTiming.git\ncd DeviceTiming\nnpm install\n\n//运行\n./devicetiming server /path/to/your/js\n```\n** 注意：devicetiming会改变被监控的js，要先备份好，不过有git记录的就不用担心了 **\n运行了之后，用不同的设备访问开发环境下的站点，最后reload`http://localhost:8537/`页面，可以看到不同设备对js的解析和执行时间，如下图所示：\n<img src=\"/image/deviceTiming.png\" width=\"1200px\">\n可以看到不同设备的ua信息，每个js的parse和exec时间。从上到下，三个设备分别是微信开发者工具、iphone、安卓机。从数据上看，安卓机parse和exec花费的时间最久，花费时间越长，用户的体验就会越差。\n该站点面向的用户中安卓机份额更高，`how to optimize`显得比较重要。\n\n# how to optimize\n## 尾部调用优化（TCO）\n尾调用概念就是在函数最后一步调用其他函数。\n``` js\nfunction foo(x) {\n    return x;\n}\n\nfunction bar(y) {\n    return foo( y + 1 );    // 尾部调用\n}\n\nfunction baz() {\n    return 1 + bar( 40 );   // 不是尾部调用\n}\n\nbaz();                      // 42\n```\n`bar`函数的最后一步是调用`foo( y + 1 )`，属于尾部调用；而在`baz`函数中，调用完`bar(40)`后，还有执行`+ 1`的操作，就不属于尾部调用了。\n<!-- more -->\n\n> 函数调用会在内存形成一个\"调用记录\"，又称\"调用帧\"（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个\"调用栈\"（call stack）。\n\n<img src=\"/image/callstack.png\" width=\"555px\">\n\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。\n``` js\nfunction f() {\n  let m = 1;\n  let n = 2;\n  return g(m + n);\n}\nf();\n\n// 等同于\nfunction f() {\n  return g(3);\n}\nf();\n\n// 等同于\ng(3);\n```\n如果函数`g`不是尾部调用，函数`f`就需要保存内部变量m和n的值、g的调用位置等信息。\n`尾部调用优化`，即只保留内层函数的调用记录，运用这一思想可以去优化递归，不需要再保存每次的调用记录，始终只存在一个调用记录，可以避免'栈溢出'。\n\n## 动态加载组件\n### 代码分片\n当前端代码越来越复杂，代码体积越来越大时，考虑对加载的资源进行细粒度的分割，按需加载。\nwebpack支持两种语法实现动态地加载模块：\n- [require.ensure](https://webpack.js.org/api/module-methods/#require-ensure)\n给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。\n```js\nrequire.ensure(dependencies: String[], callback: function(require), chunkName: String)\n```\n\n- [import](https://webpack.js.org/api/module-methods/#import-)\n调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。\n```js\nimport(\n  /* webpackChunkName: \"my-chunk-name\" */\n  /* webpackMode: \"lazy\" (default)*/\n  'path/to/module') -> Promise\n```\n`webpackChunkName`用来设置chunk的名字；`webpackMode`默认值是`lazy`，还有`lazy-once`、`eager`、`weak`。\n\n按需加载的默认加载形式是async。\n\n### react动态加载组件\n在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。\n直接看代码：\n``` js\nimport React, {Component} from 'react'\n\n/**\n * 异步加载模块\n * @param  {[type]} loadComponent [description]\n * @return {[type]}               [description]\n */\nexport const asyncComponent = loadComponent => (\n    class AsyncComponent extends Component {\n        state = {\n            Component: null,\n        }\n\n        componentDidMount() {\n            if (this.hasLoadedComponent()) {\n                return;\n            }\n\n            loadComponent()\n                .then(module => module.default)\n                .then((Component) => {\n                    this.setState({ Component });\n                })\n                .catch((err) => {\n                    console.error(`Cannot load component in <AsyncComponent />`);\n                    throw err;\n                });\n        }\n\n        hasLoadedComponent() {\n            return this.state.Component !== null;\n        }\n\n        render() {\n            const { Component } = this.state;\n            return (Component) ? <Component {...this.props} /> : null;\n        }\n    }\n);\n```\n\n`loadComponent`参数代表import('module')异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。\n如何调用：\n``` js\nexport const AsyncBannerSwiper = asyncComponent(() => import(/* webpackChunkName: \"bannerSwiper\" */ './BannerSwiper.jsx'))\n```\n将`BannerSwiper`组件用`asyncComponent`封装下，就返回了一个异步加载的`AsyncBannerSwiper`组件，使用方法和其他组件完全一致。\n\n#### publicPath动态设置\n项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。\n动态设置异步chunk的publicPath，在入口entry中设置__webpack_public_path__，打包配置文件中配置的publicPath不变。\n``` js\n__webpack_public_path__ = window.cdn || '/dist/';\n\n```\n\n### webpack设置\n在webpack配置文件中，需要配置`chunkFilename`指定chunk的名字。\n``` js\nchunkFilename: '[name].js'\n```\n另外，注意webpack插件的配置：\n``` js\nnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id\nnew webpack.optimize.CommonsChunkPlugin({\n    ...\n    children: false,  // 如果设置为 `true`，所有公共 chunk 的子模块都会被选择\n    ...\n}),\nnew ExtractTextPlugin({filename: 'css/[name].css?[contenthash:8]', allChunks: true}),  //从所有chunk中提取(默认情况下，它仅从initial chunk中提取)\n```\n\n### 分离前后对比\n使用[webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：\n<img src=\"/image/codesplit_before.png\" width=\"600px\">\n可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：\n<img src=\"/image/codesplit_before1.png\" width=\"500px\">\n\n使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：\n<img src=\"/image/codesplit_after.png\" width=\"600px\">\n可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。\n<img src=\"/image/codesplit_after1.png\" width=\"500px\">\n\nREFS:\nhttps://blog.csdn.net/qq20004604/article/details/79318253\nhttps://segmentfault.com/a/1190000009820646\n\n## 持久化内存\n为了获取持久化内存，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。\n#### moduleId VS chunkId\n看打包后的`manifest.js`，精简的源码如下所示：\n``` js\n(function(modules) {\n  window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {\n    var moduleId, result;\n    for (moduleId in moreModules) {\n      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n        // 将chunk中所包含的模块放入modules数组中\n        modules[moduleId] = moreModules[moduleId]; \n      }\n    }\n    if (executeModules) {\n      for (i = 0; i < executeModules.length; i++) {\n        result = __webpack_require__(executeModules[i]);\n      }\n    }\n    return result;\n  };\n  var installedModules = {};\n\n  // 调用__webpack_require__(moduleId)时，\n  //再将模块放入installedModules，用于保存已经加载过的模块\n  function __webpack_require__(moduleId) {\n    if (installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    var module = installedModules[moduleId] = {\n      exports: {}\n    };\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    return module.exports;\n  }\n})([]);\n```\n`webpackJsonp`方法接收三个参数`chunkIds, moreModules, executeModules`，分别属于chunkId和moduleId两种类型:\n- chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。\n- module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前`__webpack_require__`加载的模块，同样使用数组下标作为moduleId。\n每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。\n\n### 固化moduleId和chunkId\n- 固化moduleId：`HashedModuleIdsPlugin`会根据文件的路径去生成hash，可以用在生成环境。开发环境可以使用`NamedModulesPlugin`，hash直接是模块的相对路径，更加清晰，便于debug。\n- 固化chunkId：webpack中entry的唯一的，所以可以直接使用entry名作为chunkId，使用`NamedChunksPlugin`可以帮助我们达成该目标，如果是代码分离出的chunk可以使用`/* webpackChunkName: \"bannerSwiper\" */`指定chunk的名字，或者可以在`NamedChunksPlugin`插件中去配置。\n```js\nnew webpack.HashedModuleIdsPlugin(), //固化 module id\nnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id\n```\n\nREFS:\nhttps://github.com/pigcan/blog/issues/9\nhttps://www.imooc.com/article/21538\nhttps://juejin.im/post/5a23b130f265da432003101a\nhttps://github.com/happylindz/blog/issues/6\n\n## 内存泄露排查\n> 内存泄露：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。\n> JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。\n\n### JavaScript内存泄露\n垃圾回收语言的内存泄漏主因是不需要的引用。大部分垃圾回收语言用的算法称之为 Mark-and-sweep 。算法由以下几步组成：\n- 垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；\n- 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。\n- 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。\n现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。\n\n### 四种常见的JavaScript内存泄漏类型：\n- 意外的window全局变量\n- 被遗忘的计时器或回调函数\n- 脱离 DOM 的引用\n- 闭包\n\n### 实例分析\n#### 浏览器performance\n切换到该tab下，勾选memory，并点击记录按钮，不断点击阅读下一章，持续一段时间。\n<img src=\"/image/memory_0.png\" width=\"900px\">\n三种迹象显示出现了内存泄漏，图中的 Nodes（绿线）、Listeners（黄线）和 JS heap（蓝线）。Nodes、Listeners稳定增长，并未下降，这是个显著的信号。\n\n#### 浏览器 heap profile\n切换到memory tab下，等待页面刷新完成，点击take heap snapshot保存当前快照。切换到下一章节，重复之前操作，保存快照。\n选择Comparison，将快照与之前的进行对比，可以发现有的对象如content只增不减。\n<img src=\"/image/heap_1.png\" width=\"800px\">\n仔细分析代码，发现Content组件中有注册事件代理，监听`fontChange`事件变化，作为一个SPA，`EventProxy`一直存在于内存中，每次创建新的content时候，都会给`fontChange`事件新注册一个回调方法，之前的回调方法一直保存在回调数组中，没有被回收，导致content组件也不能被正确回收：\n``` js\nconst eventProxy = {\n  //...\n  off: function(key) {\n    this.onObj[key] = [];\n    this.oneObj[key] = [];\n  },\n  //...\n}\n\ncomponentDidMount() {\n    EventProxy.on('fontChange', diff => this.handleFontChange(diff));\n}\n\ncomponentWillUnmount() {\n    EventProxy.off('fontChange'); //Release memory\n    this.listener && window.removeEventListener('scroll', this.listener, false); //Release memory\n}\n```\n调用`EventProxy.off('fontChange')`解除eventProxy对象对`this.handleFontChange`的引用，这样this对应的content的对象才能被正确回收；和`removeEventListener`一样的原理。\n``` js\nthis.listener = () => {\n    if(this.contentWrap && (window.pageYOffset > this.contentWrap.offsetHeight / 2)) {\n        //...\n        window.removeEventListener('scroll', this.listener, false); //Release memory(事件不一定被触发)\n    }\n}\nwindow.addEventListener('scroll', this.listener, false)\n```\n虽然在`this.listener`内部有解除scroll事件监听的代码，但是要满足一定条件才会触发，所以在`componentWillUnmount`方法中也添加了`removeEventListener`，实现对scroll事件的解绑。\n\n经过上面的优化后，再次对比，发现content对象可以被正常回收。\n<img src=\"/image/heap_2_content.png\" width=\"800px\">\n\nREFs: https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/\n\n## cpu占比探测\n``` js\nvar data = []\nvar t\n\nfunction pulse() {\n  t && data.push(Date.now() - t)\n  t = Date.now()\n  setTimeout(pulse, 50)\n}\n\npulse()\n```\n就是每隔 50ms 打一下点。理想情况下，data 的值应该是\n``` js\ndata = [50, 50, 50, 50, ...]\n```\n但实际情况，data会是\n``` js\ndata = [51, 52, 50, 52, ...]\n```\ncpu越忙，data的数据项会越大。这样，记录一系列 data 值，就可以绘制出 CPU 占比趋势图，和通过任务管理器看到的 CPU 趋势图非常接近。\n\n上面只是原理说明，实际情况没这么简单。但很明显，通过这么一个简单的规律，就能实现用纯 JavaScript 来探测 CPU 占比。\n","slug":"菜鸟优化之路","published":1,"updated":"2019-03-18T02:27:14.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtjvgx8i003eqmhfepzvzp6f","content":"<h1 id=\"DeviceTiming工具\"><a href=\"#DeviceTiming工具\" class=\"headerlink\" title=\"DeviceTiming工具\"></a>DeviceTiming工具</h1><p>最近了解到<a href=\"https://github.com/danielmendel/DeviceTiming\" target=\"_blank\" rel=\"noopener\">DeviceTiming</a>工具，可以帮助我们监测js在不同设备上的解析和执行时间，运行环境是在开发环境下。<br>搬运下git上的安装、运行命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//安装</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/etsy/DeviceTiming.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> DeviceTiming</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">//运行</span><br><span class=\"line\">./devicetiming server /path/to/your/js</span><br></pre></td></tr></table></figure></p>\n<p><strong> 注意：devicetiming会改变被监控的js，要先备份好，不过有git记录的就不用担心了 </strong><br>运行了之后，用不同的设备访问开发环境下的站点，最后reload<code>http://localhost:8537/</code>页面，可以看到不同设备对js的解析和执行时间，如下图所示：<br><img src=\"/image/deviceTiming.png\" width=\"1200px\"><br>可以看到不同设备的ua信息，每个js的parse和exec时间。从上到下，三个设备分别是微信开发者工具、iphone、安卓机。从数据上看，安卓机parse和exec花费的时间最久，花费时间越长，用户的体验就会越差。<br>该站点面向的用户中安卓机份额更高，<code>how to optimize</code>显得比较重要。</p>\n<h1 id=\"how-to-optimize\"><a href=\"#how-to-optimize\" class=\"headerlink\" title=\"how to optimize\"></a>how to optimize</h1><h2 id=\"尾部调用优化（TCO）\"><a href=\"#尾部调用优化（TCO）\" class=\"headerlink\" title=\"尾部调用优化（TCO）\"></a>尾部调用优化（TCO）</h2><p>尾调用概念就是在函数最后一步调用其他函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo( y + <span class=\"number\">1</span> );    <span class=\"comment\">// 尾部调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> + bar( <span class=\"number\">40</span> );   <span class=\"comment\">// 不是尾部调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">baz();                      <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure></p>\n<p><code>bar</code>函数的最后一步是调用<code>foo( y + 1 )</code>，属于尾部调用；而在<code>baz</code>函数中，调用完<code>bar(40)</code>后，还有执行<code>+ 1</code>的操作，就不属于尾部调用了。<br><a id=\"more\"></a></p>\n<blockquote>\n<p>函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。</p>\n</blockquote>\n<p><img src=\"/image/callstack.png\" width=\"555px\"></p>\n<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(m + n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">g(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure></p>\n<p>如果函数<code>g</code>不是尾部调用，函数<code>f</code>就需要保存内部变量m和n的值、g的调用位置等信息。<br><code>尾部调用优化</code>，即只保留内层函数的调用记录，运用这一思想可以去优化递归，不需要再保存每次的调用记录，始终只存在一个调用记录，可以避免’栈溢出’。</p>\n<h2 id=\"动态加载组件\"><a href=\"#动态加载组件\" class=\"headerlink\" title=\"动态加载组件\"></a>动态加载组件</h2><h3 id=\"代码分片\"><a href=\"#代码分片\" class=\"headerlink\" title=\"代码分片\"></a>代码分片</h3><p>当前端代码越来越复杂，代码体积越来越大时，考虑对加载的资源进行细粒度的分割，按需加载。<br>webpack支持两种语法实现动态地加载模块：</p>\n<ul>\n<li><p><a href=\"https://webpack.js.org/api/module-methods/#require-ensure\" target=\"_blank\" rel=\"noopener\">require.ensure</a><br>给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.ensure(dependencies: <span class=\"built_in\">String</span>[], <span class=\"attr\">callback</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>), <span class=\"title\">chunkName</span>: <span class=\"title\">String</span>)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://webpack.js.org/api/module-methods/#import-\" target=\"_blank\" rel=\"noopener\">import</a><br>调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">  <span class=\"comment\">/* webpackChunkName: \"my-chunk-name\" */</span></span><br><span class=\"line\">  <span class=\"comment\">/* webpackMode: \"lazy\" (default)*/</span></span><br><span class=\"line\">  <span class=\"string\">'path/to/module'</span>) -&gt; <span class=\"built_in\">Promise</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>webpackChunkName</code>用来设置chunk的名字；<code>webpackMode</code>默认值是<code>lazy</code>，还有<code>lazy-once</code>、<code>eager</code>、<code>weak</code>。</p>\n<p>按需加载的默认加载形式是async。</p>\n<h3 id=\"react动态加载组件\"><a href=\"#react动态加载组件\" class=\"headerlink\" title=\"react动态加载组件\"></a>react动态加载组件</h3><p>在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。<br>直接看代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 异步加载模块</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;[type]&#125; loadComponent [description]</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;[type]&#125;               [description]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> asyncComponent = <span class=\"function\"><span class=\"params\">loadComponent</span> =&gt;</span> (</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        state = &#123;</span><br><span class=\"line\">            Component: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentDidMount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasLoadedComponent()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            loadComponent()</span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> <span class=\"built_in\">module</span>.default)</span><br><span class=\"line\">                .then(<span class=\"function\">(<span class=\"params\">Component</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.setState(&#123; Component &#125;);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.error(<span class=\"string\">`Cannot load component in &lt;AsyncComponent /&gt;`</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        hasLoadedComponent() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.state.Component !== <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; Component &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Component) ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Component</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span> : null;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">);</span></span><br></pre></td></tr></table></figure></p>\n<p><code>loadComponent</code>参数代表import(‘module’)异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。<br>如何调用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> AsyncBannerSwiper = asyncComponent(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"bannerSwiper\" */</span> <span class=\"string\">'./BannerSwiper.jsx'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>将<code>BannerSwiper</code>组件用<code>asyncComponent</code>封装下，就返回了一个异步加载的<code>AsyncBannerSwiper</code>组件，使用方法和其他组件完全一致。</p>\n<h4 id=\"publicPath动态设置\"><a href=\"#publicPath动态设置\" class=\"headerlink\" title=\"publicPath动态设置\"></a>publicPath动态设置</h4><p>项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。<br>动态设置异步chunk的publicPath，在入口entry中设置<strong>webpack_public_path</strong>，打包配置文件中配置的publicPath不变。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__webpack_public_path__ = <span class=\"built_in\">window</span>.cdn || <span class=\"string\">'/dist/'</span>;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"webpack设置\"><a href=\"#webpack设置\" class=\"headerlink\" title=\"webpack设置\"></a>webpack设置</h3><p>在webpack配置文件中，需要配置<code>chunkFilename</code>指定chunk的名字。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chunkFilename: <span class=\"string\">'[name].js'</span></span><br></pre></td></tr></table></figure></p>\n<p>另外，注意webpack插件的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.NamedChunksPlugin(), <span class=\"comment\">//固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    children: <span class=\"literal\">false</span>,  <span class=\"comment\">// 如果设置为 `true`，所有公共 chunk 的子模块都会被选择</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\"><span class=\"keyword\">new</span> ExtractTextPlugin(&#123;<span class=\"attr\">filename</span>: <span class=\"string\">'css/[name].css?[contenthash:8]'</span>, <span class=\"attr\">allChunks</span>: <span class=\"literal\">true</span>&#125;),  <span class=\"comment\">//从所有chunk中提取(默认情况下，它仅从initial chunk中提取)</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"分离前后对比\"><a href=\"#分离前后对比\" class=\"headerlink\" title=\"分离前后对比\"></a>分离前后对比</h3><p>使用<a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a>分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：<br><img src=\"/image/codesplit_before.png\" width=\"600px\"><br>可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：<br><img src=\"/image/codesplit_before1.png\" width=\"500px\"></p>\n<p>使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：<br><img src=\"/image/codesplit_after.png\" width=\"600px\"><br>可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。<br><img src=\"/image/codesplit_after1.png\" width=\"500px\"></p>\n<p>REFS:<br><a href=\"https://blog.csdn.net/qq20004604/article/details/79318253\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq20004604/article/details/79318253</a><br><a href=\"https://segmentfault.com/a/1190000009820646\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000009820646</a></p>\n<h2 id=\"持久化内存\"><a href=\"#持久化内存\" class=\"headerlink\" title=\"持久化内存\"></a>持久化内存</h2><p>为了获取持久化内存，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。</p>\n<h4 id=\"moduleId-VS-chunkId\"><a href=\"#moduleId-VS-chunkId\" class=\"headerlink\" title=\"moduleId VS chunkId\"></a>moduleId VS chunkId</h4><p>看打包后的<code>manifest.js</code>，精简的源码如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>[<span class=\"string\">\"webpackJsonp\"</span>] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">webpackJsonpCallback</span>(<span class=\"params\">chunkIds, moreModules, executeModules</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> moduleId, result;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (moduleId <span class=\"keyword\">in</span> moreModules) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将chunk中所包含的模块放入modules数组中</span></span><br><span class=\"line\">        modules[moduleId] = moreModules[moduleId]; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executeModules) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; executeModules.length; i++) &#123;</span><br><span class=\"line\">        result = __webpack_require__(executeModules[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 调用__webpack_require__(moduleId)时，</span></span><br><span class=\"line\">  <span class=\"comment\">//再将模块放入installedModules，用于保存已经加载过的模块</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (installedModules[moduleId]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> installedModules[moduleId].exports;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = installedModules[moduleId] = &#123;</span><br><span class=\"line\">      exports: &#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    modules[moduleId].call(<span class=\"built_in\">module</span>.exports, <span class=\"built_in\">module</span>, <span class=\"built_in\">module</span>.exports, __webpack_require__);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)([]);</span><br></pre></td></tr></table></figure></p>\n<p><code>webpackJsonp</code>方法接收三个参数<code>chunkIds, moreModules, executeModules</code>，分别属于chunkId和moduleId两种类型:</p>\n<ul>\n<li>chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。</li>\n<li>module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前<code>__webpack_require__</code>加载的模块，同样使用数组下标作为moduleId。<br>每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。</li>\n</ul>\n<h3 id=\"固化moduleId和chunkId\"><a href=\"#固化moduleId和chunkId\" class=\"headerlink\" title=\"固化moduleId和chunkId\"></a>固化moduleId和chunkId</h3><ul>\n<li>固化moduleId：<code>HashedModuleIdsPlugin</code>会根据文件的路径去生成hash，可以用在生成环境。开发环境可以使用<code>NamedModulesPlugin</code>，hash直接是模块的相对路径，更加清晰，便于debug。</li>\n<li>固化chunkId：webpack中entry的唯一的，所以可以直接使用entry名作为chunkId，使用<code>NamedChunksPlugin</code>可以帮助我们达成该目标，如果是代码分离出的chunk可以使用<code>/* webpackChunkName: &quot;bannerSwiper&quot; */</code>指定chunk的名字，或者可以在<code>NamedChunksPlugin</code>插件中去配置。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.HashedModuleIdsPlugin(), <span class=\"comment\">//固化 module id</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> webpack.NamedChunksPlugin(), <span class=\"comment\">//固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>REFS:<br><a href=\"https://github.com/pigcan/blog/issues/9\" target=\"_blank\" rel=\"noopener\">https://github.com/pigcan/blog/issues/9</a><br><a href=\"https://www.imooc.com/article/21538\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/article/21538</a><br><a href=\"https://juejin.im/post/5a23b130f265da432003101a\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a23b130f265da432003101a</a><br><a href=\"https://github.com/happylindz/blog/issues/6\" target=\"_blank\" rel=\"noopener\">https://github.com/happylindz/blog/issues/6</a></p>\n<h2 id=\"内存泄露排查\"><a href=\"#内存泄露排查\" class=\"headerlink\" title=\"内存泄露排查\"></a>内存泄露排查</h2><blockquote>\n<p>内存泄露：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。<br>JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。</p>\n</blockquote>\n<h3 id=\"JavaScript内存泄露\"><a href=\"#JavaScript内存泄露\" class=\"headerlink\" title=\"JavaScript内存泄露\"></a>JavaScript内存泄露</h3><p>垃圾回收语言的内存泄漏主因是不需要的引用。大部分垃圾回收语言用的算法称之为 Mark-and-sweep 。算法由以下几步组成：</p>\n<ul>\n<li>垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</li>\n<li>所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。</li>\n<li>所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。<br>现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。</li>\n</ul>\n<h3 id=\"四种常见的JavaScript内存泄漏类型：\"><a href=\"#四种常见的JavaScript内存泄漏类型：\" class=\"headerlink\" title=\"四种常见的JavaScript内存泄漏类型：\"></a>四种常见的JavaScript内存泄漏类型：</h3><ul>\n<li>意外的window全局变量</li>\n<li>被遗忘的计时器或回调函数</li>\n<li>脱离 DOM 的引用</li>\n<li>闭包</li>\n</ul>\n<h3 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h3><h4 id=\"浏览器performance\"><a href=\"#浏览器performance\" class=\"headerlink\" title=\"浏览器performance\"></a>浏览器performance</h4><p>切换到该tab下，勾选memory，并点击记录按钮，不断点击阅读下一章，持续一段时间。<br><img src=\"/image/memory_0.png\" width=\"900px\"><br>三种迹象显示出现了内存泄漏，图中的 Nodes（绿线）、Listeners（黄线）和 JS heap（蓝线）。Nodes、Listeners稳定增长，并未下降，这是个显著的信号。</p>\n<h4 id=\"浏览器-heap-profile\"><a href=\"#浏览器-heap-profile\" class=\"headerlink\" title=\"浏览器 heap profile\"></a>浏览器 heap profile</h4><p>切换到memory tab下，等待页面刷新完成，点击take heap snapshot保存当前快照。切换到下一章节，重复之前操作，保存快照。<br>选择Comparison，将快照与之前的进行对比，可以发现有的对象如content只增不减。<br><img src=\"/image/heap_1.png\" width=\"800px\"><br>仔细分析代码，发现Content组件中有注册事件代理，监听<code>fontChange</code>事件变化，作为一个SPA，<code>EventProxy</code>一直存在于内存中，每次创建新的content时候，都会给<code>fontChange</code>事件新注册一个回调方法，之前的回调方法一直保存在回调数组中，没有被回收，导致content组件也不能被正确回收：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> eventProxy = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  off: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onObj[key] = [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.oneObj[key] = [];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    EventProxy.on(<span class=\"string\">'fontChange'</span>, diff =&gt; <span class=\"keyword\">this</span>.handleFontChange(diff));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentWillUnmount() &#123;</span><br><span class=\"line\">    EventProxy.off(<span class=\"string\">'fontChange'</span>); <span class=\"comment\">//Release memory</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listener &amp;&amp; <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'scroll'</span>, <span class=\"keyword\">this</span>.listener, <span class=\"literal\">false</span>); <span class=\"comment\">//Release memory</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用<code>EventProxy.off(&#39;fontChange&#39;)</code>解除eventProxy对象对<code>this.handleFontChange</code>的引用，这样this对应的content的对象才能被正确回收；和<code>removeEventListener</code>一样的原理。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.listener = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.contentWrap &amp;&amp; (<span class=\"built_in\">window</span>.pageYOffset &gt; <span class=\"keyword\">this</span>.contentWrap.offsetHeight / <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'scroll'</span>, <span class=\"keyword\">this</span>.listener, <span class=\"literal\">false</span>); <span class=\"comment\">//Release memory(事件不一定被触发)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'scroll'</span>, <span class=\"keyword\">this</span>.listener, <span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure></p>\n<p>虽然在<code>this.listener</code>内部有解除scroll事件监听的代码，但是要满足一定条件才会触发，所以在<code>componentWillUnmount</code>方法中也添加了<code>removeEventListener</code>，实现对scroll事件的解绑。</p>\n<p>经过上面的优化后，再次对比，发现content对象可以被正常回收。<br><img src=\"/image/heap_2_content.png\" width=\"800px\"></p>\n<p>REFs: <a href=\"https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/\" target=\"_blank\" rel=\"noopener\">https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/</a></p>\n<h2 id=\"cpu占比探测\"><a href=\"#cpu占比探测\" class=\"headerlink\" title=\"cpu占比探测\"></a>cpu占比探测</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = []</span><br><span class=\"line\"><span class=\"keyword\">var</span> t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pulse</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  t &amp;&amp; data.push(<span class=\"built_in\">Date</span>.now() - t)</span><br><span class=\"line\">  t = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">  setTimeout(pulse, <span class=\"number\">50</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">pulse()</span><br></pre></td></tr></table></figure>\n<p>就是每隔 50ms 打一下点。理想情况下，data 的值应该是<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = [<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>, ...]</span><br></pre></td></tr></table></figure></p>\n<p>但实际情况，data会是<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = [<span class=\"number\">51</span>, <span class=\"number\">52</span>, <span class=\"number\">50</span>, <span class=\"number\">52</span>, ...]</span><br></pre></td></tr></table></figure></p>\n<p>cpu越忙，data的数据项会越大。这样，记录一系列 data 值，就可以绘制出 CPU 占比趋势图，和通过任务管理器看到的 CPU 趋势图非常接近。</p>\n<p>上面只是原理说明，实际情况没这么简单。但很明显，通过这么一个简单的规律，就能实现用纯 JavaScript 来探测 CPU 占比。</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"DeviceTiming工具\"><a href=\"#DeviceTiming工具\" class=\"headerlink\" title=\"DeviceTiming工具\"></a>DeviceTiming工具</h1><p>最近了解到<a href=\"https://github.com/danielmendel/DeviceTiming\" target=\"_blank\" rel=\"noopener\">DeviceTiming</a>工具，可以帮助我们监测js在不同设备上的解析和执行时间，运行环境是在开发环境下。<br>搬运下git上的安装、运行命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//安装</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/etsy/DeviceTiming.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> DeviceTiming</span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\">//运行</span><br><span class=\"line\">./devicetiming server /path/to/your/js</span><br></pre></td></tr></table></figure></p>\n<p><strong> 注意：devicetiming会改变被监控的js，要先备份好，不过有git记录的就不用担心了 </strong><br>运行了之后，用不同的设备访问开发环境下的站点，最后reload<code>http://localhost:8537/</code>页面，可以看到不同设备对js的解析和执行时间，如下图所示：<br><img src=\"/image/deviceTiming.png\" width=\"1200px\"><br>可以看到不同设备的ua信息，每个js的parse和exec时间。从上到下，三个设备分别是微信开发者工具、iphone、安卓机。从数据上看，安卓机parse和exec花费的时间最久，花费时间越长，用户的体验就会越差。<br>该站点面向的用户中安卓机份额更高，<code>how to optimize</code>显得比较重要。</p>\n<h1 id=\"how-to-optimize\"><a href=\"#how-to-optimize\" class=\"headerlink\" title=\"how to optimize\"></a>how to optimize</h1><h2 id=\"尾部调用优化（TCO）\"><a href=\"#尾部调用优化（TCO）\" class=\"headerlink\" title=\"尾部调用优化（TCO）\"></a>尾部调用优化（TCO）</h2><p>尾调用概念就是在函数最后一步调用其他函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo( y + <span class=\"number\">1</span> );    <span class=\"comment\">// 尾部调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baz</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span> + bar( <span class=\"number\">40</span> );   <span class=\"comment\">// 不是尾部调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">baz();                      <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure></p>\n<p><code>bar</code>函数的最后一步是调用<code>foo( y + 1 )</code>，属于尾部调用；而在<code>baz</code>函数中，调用完<code>bar(40)</code>后，还有执行<code>+ 1</code>的操作，就不属于尾部调用了。<br>","more":"</p>\n<blockquote>\n<p>函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。</p>\n</blockquote>\n<p><img src=\"/image/callstack.png\" width=\"555px\"></p>\n<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> m = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(m + n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\">g(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure></p>\n<p>如果函数<code>g</code>不是尾部调用，函数<code>f</code>就需要保存内部变量m和n的值、g的调用位置等信息。<br><code>尾部调用优化</code>，即只保留内层函数的调用记录，运用这一思想可以去优化递归，不需要再保存每次的调用记录，始终只存在一个调用记录，可以避免’栈溢出’。</p>\n<h2 id=\"动态加载组件\"><a href=\"#动态加载组件\" class=\"headerlink\" title=\"动态加载组件\"></a>动态加载组件</h2><h3 id=\"代码分片\"><a href=\"#代码分片\" class=\"headerlink\" title=\"代码分片\"></a>代码分片</h3><p>当前端代码越来越复杂，代码体积越来越大时，考虑对加载的资源进行细粒度的分割，按需加载。<br>webpack支持两种语法实现动态地加载模块：</p>\n<ul>\n<li><p><a href=\"https://webpack.js.org/api/module-methods/#require-ensure\" target=\"_blank\" rel=\"noopener\">require.ensure</a><br>给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.ensure(dependencies: <span class=\"built_in\">String</span>[], <span class=\"attr\">callback</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>), <span class=\"title\">chunkName</span>: <span class=\"title\">String</span>)</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a href=\"https://webpack.js.org/api/module-methods/#import-\" target=\"_blank\" rel=\"noopener\">import</a><br>调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(</span><br><span class=\"line\">  <span class=\"comment\">/* webpackChunkName: \"my-chunk-name\" */</span></span><br><span class=\"line\">  <span class=\"comment\">/* webpackMode: \"lazy\" (default)*/</span></span><br><span class=\"line\">  <span class=\"string\">'path/to/module'</span>) -&gt; <span class=\"built_in\">Promise</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>webpackChunkName</code>用来设置chunk的名字；<code>webpackMode</code>默认值是<code>lazy</code>，还有<code>lazy-once</code>、<code>eager</code>、<code>weak</code>。</p>\n<p>按需加载的默认加载形式是async。</p>\n<h3 id=\"react动态加载组件\"><a href=\"#react动态加载组件\" class=\"headerlink\" title=\"react动态加载组件\"></a>react动态加载组件</h3><p>在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。<br>直接看代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 异步加载模块</span></span><br><span class=\"line\"><span class=\"comment\"> * @param  &#123;[type]&#125; loadComponent [description]</span></span><br><span class=\"line\"><span class=\"comment\"> * @return &#123;[type]&#125;               [description]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> asyncComponent = <span class=\"function\"><span class=\"params\">loadComponent</span> =&gt;</span> (</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AsyncComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        state = &#123;</span><br><span class=\"line\">            Component: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentDidMount() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasLoadedComponent()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            loadComponent()</span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"params\">module</span> =&gt;</span> <span class=\"built_in\">module</span>.default)</span><br><span class=\"line\">                .then(<span class=\"function\">(<span class=\"params\">Component</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.setState(&#123; Component &#125;);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.error(<span class=\"string\">`Cannot load component in &lt;AsyncComponent /&gt;`</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        hasLoadedComponent() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.state.Component !== <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> &#123; Component &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Component) ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Component</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span> : null;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">);</span></span><br></pre></td></tr></table></figure></p>\n<p><code>loadComponent</code>参数代表import(‘module’)异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。<br>如何调用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> AsyncBannerSwiper = asyncComponent(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: \"bannerSwiper\" */</span> <span class=\"string\">'./BannerSwiper.jsx'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>将<code>BannerSwiper</code>组件用<code>asyncComponent</code>封装下，就返回了一个异步加载的<code>AsyncBannerSwiper</code>组件，使用方法和其他组件完全一致。</p>\n<h4 id=\"publicPath动态设置\"><a href=\"#publicPath动态设置\" class=\"headerlink\" title=\"publicPath动态设置\"></a>publicPath动态设置</h4><p>项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。<br>动态设置异步chunk的publicPath，在入口entry中设置<strong>webpack_public_path</strong>，打包配置文件中配置的publicPath不变。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__webpack_public_path__ = <span class=\"built_in\">window</span>.cdn || <span class=\"string\">'/dist/'</span>;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"webpack设置\"><a href=\"#webpack设置\" class=\"headerlink\" title=\"webpack设置\"></a>webpack设置</h3><p>在webpack配置文件中，需要配置<code>chunkFilename</code>指定chunk的名字。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chunkFilename: <span class=\"string\">'[name].js'</span></span><br></pre></td></tr></table></figure></p>\n<p>另外，注意webpack插件的配置：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.NamedChunksPlugin(), <span class=\"comment\">//固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    children: <span class=\"literal\">false</span>,  <span class=\"comment\">// 如果设置为 `true`，所有公共 chunk 的子模块都会被选择</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\"><span class=\"keyword\">new</span> ExtractTextPlugin(&#123;<span class=\"attr\">filename</span>: <span class=\"string\">'css/[name].css?[contenthash:8]'</span>, <span class=\"attr\">allChunks</span>: <span class=\"literal\">true</span>&#125;),  <span class=\"comment\">//从所有chunk中提取(默认情况下，它仅从initial chunk中提取)</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"分离前后对比\"><a href=\"#分离前后对比\" class=\"headerlink\" title=\"分离前后对比\"></a>分离前后对比</h3><p>使用<a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">webpack-bundle-analyzer</a>分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：<br><img src=\"/image/codesplit_before.png\" width=\"600px\"><br>可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：<br><img src=\"/image/codesplit_before1.png\" width=\"500px\"></p>\n<p>使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：<br><img src=\"/image/codesplit_after.png\" width=\"600px\"><br>可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。<br><img src=\"/image/codesplit_after1.png\" width=\"500px\"></p>\n<p>REFS:<br><a href=\"https://blog.csdn.net/qq20004604/article/details/79318253\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq20004604/article/details/79318253</a><br><a href=\"https://segmentfault.com/a/1190000009820646\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000009820646</a></p>\n<h2 id=\"持久化内存\"><a href=\"#持久化内存\" class=\"headerlink\" title=\"持久化内存\"></a>持久化内存</h2><p>为了获取持久化内存，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。</p>\n<h4 id=\"moduleId-VS-chunkId\"><a href=\"#moduleId-VS-chunkId\" class=\"headerlink\" title=\"moduleId VS chunkId\"></a>moduleId VS chunkId</h4><p>看打包后的<code>manifest.js</code>，精简的源码如下所示：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>[<span class=\"string\">\"webpackJsonp\"</span>] = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">webpackJsonpCallback</span>(<span class=\"params\">chunkIds, moreModules, executeModules</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> moduleId, result;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (moduleId <span class=\"keyword\">in</span> moreModules) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将chunk中所包含的模块放入modules数组中</span></span><br><span class=\"line\">        modules[moduleId] = moreModules[moduleId]; </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executeModules) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; executeModules.length; i++) &#123;</span><br><span class=\"line\">        result = __webpack_require__(executeModules[i]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 调用__webpack_require__(moduleId)时，</span></span><br><span class=\"line\">  <span class=\"comment\">//再将模块放入installedModules，用于保存已经加载过的模块</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (installedModules[moduleId]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> installedModules[moduleId].exports;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = installedModules[moduleId] = &#123;</span><br><span class=\"line\">      exports: &#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    modules[moduleId].call(<span class=\"built_in\">module</span>.exports, <span class=\"built_in\">module</span>, <span class=\"built_in\">module</span>.exports, __webpack_require__);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)([]);</span><br></pre></td></tr></table></figure></p>\n<p><code>webpackJsonp</code>方法接收三个参数<code>chunkIds, moreModules, executeModules</code>，分别属于chunkId和moduleId两种类型:</p>\n<ul>\n<li>chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。</li>\n<li>module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前<code>__webpack_require__</code>加载的模块，同样使用数组下标作为moduleId。<br>每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。</li>\n</ul>\n<h3 id=\"固化moduleId和chunkId\"><a href=\"#固化moduleId和chunkId\" class=\"headerlink\" title=\"固化moduleId和chunkId\"></a>固化moduleId和chunkId</h3><ul>\n<li>固化moduleId：<code>HashedModuleIdsPlugin</code>会根据文件的路径去生成hash，可以用在生成环境。开发环境可以使用<code>NamedModulesPlugin</code>，hash直接是模块的相对路径，更加清晰，便于debug。</li>\n<li>固化chunkId：webpack中entry的唯一的，所以可以直接使用entry名作为chunkId，使用<code>NamedChunksPlugin</code>可以帮助我们达成该目标，如果是代码分离出的chunk可以使用<code>/* webpackChunkName: &quot;bannerSwiper&quot; */</code>指定chunk的名字，或者可以在<code>NamedChunksPlugin</code>插件中去配置。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> webpack.HashedModuleIdsPlugin(), <span class=\"comment\">//固化 module id</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> webpack.NamedChunksPlugin(), <span class=\"comment\">//固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>REFS:<br><a href=\"https://github.com/pigcan/blog/issues/9\" target=\"_blank\" rel=\"noopener\">https://github.com/pigcan/blog/issues/9</a><br><a href=\"https://www.imooc.com/article/21538\" target=\"_blank\" rel=\"noopener\">https://www.imooc.com/article/21538</a><br><a href=\"https://juejin.im/post/5a23b130f265da432003101a\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a23b130f265da432003101a</a><br><a href=\"https://github.com/happylindz/blog/issues/6\" target=\"_blank\" rel=\"noopener\">https://github.com/happylindz/blog/issues/6</a></p>\n<h2 id=\"内存泄露排查\"><a href=\"#内存泄露排查\" class=\"headerlink\" title=\"内存泄露排查\"></a>内存泄露排查</h2><blockquote>\n<p>内存泄露：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。<br>JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。</p>\n</blockquote>\n<h3 id=\"JavaScript内存泄露\"><a href=\"#JavaScript内存泄露\" class=\"headerlink\" title=\"JavaScript内存泄露\"></a>JavaScript内存泄露</h3><p>垃圾回收语言的内存泄漏主因是不需要的引用。大部分垃圾回收语言用的算法称之为 Mark-and-sweep 。算法由以下几步组成：</p>\n<ul>\n<li>垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</li>\n<li>所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。</li>\n<li>所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。<br>现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。</li>\n</ul>\n<h3 id=\"四种常见的JavaScript内存泄漏类型：\"><a href=\"#四种常见的JavaScript内存泄漏类型：\" class=\"headerlink\" title=\"四种常见的JavaScript内存泄漏类型：\"></a>四种常见的JavaScript内存泄漏类型：</h3><ul>\n<li>意外的window全局变量</li>\n<li>被遗忘的计时器或回调函数</li>\n<li>脱离 DOM 的引用</li>\n<li>闭包</li>\n</ul>\n<h3 id=\"实例分析\"><a href=\"#实例分析\" class=\"headerlink\" title=\"实例分析\"></a>实例分析</h3><h4 id=\"浏览器performance\"><a href=\"#浏览器performance\" class=\"headerlink\" title=\"浏览器performance\"></a>浏览器performance</h4><p>切换到该tab下，勾选memory，并点击记录按钮，不断点击阅读下一章，持续一段时间。<br><img src=\"/image/memory_0.png\" width=\"900px\"><br>三种迹象显示出现了内存泄漏，图中的 Nodes（绿线）、Listeners（黄线）和 JS heap（蓝线）。Nodes、Listeners稳定增长，并未下降，这是个显著的信号。</p>\n<h4 id=\"浏览器-heap-profile\"><a href=\"#浏览器-heap-profile\" class=\"headerlink\" title=\"浏览器 heap profile\"></a>浏览器 heap profile</h4><p>切换到memory tab下，等待页面刷新完成，点击take heap snapshot保存当前快照。切换到下一章节，重复之前操作，保存快照。<br>选择Comparison，将快照与之前的进行对比，可以发现有的对象如content只增不减。<br><img src=\"/image/heap_1.png\" width=\"800px\"><br>仔细分析代码，发现Content组件中有注册事件代理，监听<code>fontChange</code>事件变化，作为一个SPA，<code>EventProxy</code>一直存在于内存中，每次创建新的content时候，都会给<code>fontChange</code>事件新注册一个回调方法，之前的回调方法一直保存在回调数组中，没有被回收，导致content组件也不能被正确回收：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> eventProxy = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  off: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onObj[key] = [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.oneObj[key] = [];</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">    EventProxy.on(<span class=\"string\">'fontChange'</span>, diff =&gt; <span class=\"keyword\">this</span>.handleFontChange(diff));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">componentWillUnmount() &#123;</span><br><span class=\"line\">    EventProxy.off(<span class=\"string\">'fontChange'</span>); <span class=\"comment\">//Release memory</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.listener &amp;&amp; <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'scroll'</span>, <span class=\"keyword\">this</span>.listener, <span class=\"literal\">false</span>); <span class=\"comment\">//Release memory</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>调用<code>EventProxy.off(&#39;fontChange&#39;)</code>解除eventProxy对象对<code>this.handleFontChange</code>的引用，这样this对应的content的对象才能被正确回收；和<code>removeEventListener</code>一样的原理。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.listener = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.contentWrap &amp;&amp; (<span class=\"built_in\">window</span>.pageYOffset &gt; <span class=\"keyword\">this</span>.contentWrap.offsetHeight / <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">'scroll'</span>, <span class=\"keyword\">this</span>.listener, <span class=\"literal\">false</span>); <span class=\"comment\">//Release memory(事件不一定被触发)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'scroll'</span>, <span class=\"keyword\">this</span>.listener, <span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure></p>\n<p>虽然在<code>this.listener</code>内部有解除scroll事件监听的代码，但是要满足一定条件才会触发，所以在<code>componentWillUnmount</code>方法中也添加了<code>removeEventListener</code>，实现对scroll事件的解绑。</p>\n<p>经过上面的优化后，再次对比，发现content对象可以被正常回收。<br><img src=\"/image/heap_2_content.png\" width=\"800px\"></p>\n<p>REFs: <a href=\"https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/\" target=\"_blank\" rel=\"noopener\">https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/</a></p>\n<h2 id=\"cpu占比探测\"><a href=\"#cpu占比探测\" class=\"headerlink\" title=\"cpu占比探测\"></a>cpu占比探测</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = []</span><br><span class=\"line\"><span class=\"keyword\">var</span> t</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pulse</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  t &amp;&amp; data.push(<span class=\"built_in\">Date</span>.now() - t)</span><br><span class=\"line\">  t = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">  setTimeout(pulse, <span class=\"number\">50</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">pulse()</span><br></pre></td></tr></table></figure>\n<p>就是每隔 50ms 打一下点。理想情况下，data 的值应该是<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = [<span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>, <span class=\"number\">50</span>, ...]</span><br></pre></td></tr></table></figure></p>\n<p>但实际情况，data会是<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = [<span class=\"number\">51</span>, <span class=\"number\">52</span>, <span class=\"number\">50</span>, <span class=\"number\">52</span>, ...]</span><br></pre></td></tr></table></figure></p>\n<p>cpu越忙，data的数据项会越大。这样，记录一系列 data 值，就可以绘制出 CPU 占比趋势图，和通过任务管理器看到的 CPU 趋势图非常接近。</p>\n<p>上面只是原理说明，实际情况没这么简单。但很明显，通过这么一个简单的规律，就能实现用纯 JavaScript 来探测 CPU 占比。</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjtjvgx5j0000qmhfilnk8jpj","tag_id":"cjtjvgx5t0002qmhfo4qigaie","_id":"cjtjvgx67000bqmhfuvxoto4d"},{"post_id":"cjtjvgx5j0000qmhfilnk8jpj","tag_id":"cjtjvgx610006qmhfnefang9q","_id":"cjtjvgx6a000dqmhfg9f8k9ml"},{"post_id":"cjtjvgx5q0001qmhf4jhz38au","tag_id":"cjtjvgx650009qmhfcr17fm1o","_id":"cjtjvgx6d000gqmhfk1fev7vo"},{"post_id":"cjtjvgx600005qmhfbrith5ga","tag_id":"cjtjvgx6a000eqmhfzxo4sz5p","_id":"cjtjvgx6n000nqmhfbv7w55en"},{"post_id":"cjtjvgx600005qmhfbrith5ga","tag_id":"cjtjvgx610006qmhfnefang9q","_id":"cjtjvgx6o000pqmhfibl5i6g6"},{"post_id":"cjtjvgx640008qmhf7llyoe6y","tag_id":"cjtjvgx6l000lqmhfvkw0jl49","_id":"cjtjvgx6z000zqmhfovtcbzis"},{"post_id":"cjtjvgx640008qmhf7llyoe6y","tag_id":"cjtjvgx6p000rqmhfcb8q3hef","_id":"cjtjvgx710011qmhf2gizha6t"},{"post_id":"cjtjvgx640008qmhf7llyoe6y","tag_id":"cjtjvgx6u000uqmhff4t1ldnm","_id":"cjtjvgx730014qmhf1phnp3k3"},{"post_id":"cjtjvgx640008qmhf7llyoe6y","tag_id":"cjtjvgx610006qmhfnefang9q","_id":"cjtjvgx740016qmhfyuto54ne"},{"post_id":"cjtjvgx730015qmhfhliturow","tag_id":"cjtjvgx650009qmhfcr17fm1o","_id":"cjtjvgx760019qmhftpwkcp3r"},{"post_id":"cjtjvgx66000aqmhfeghmr5my","tag_id":"cjtjvgx6l000lqmhfvkw0jl49","_id":"cjtjvgx77001bqmhfdocdrbbv"},{"post_id":"cjtjvgx66000aqmhfeghmr5my","tag_id":"cjtjvgx6p000rqmhfcb8q3hef","_id":"cjtjvgx77001cqmhfxbrtfmdm"},{"post_id":"cjtjvgx66000aqmhfeghmr5my","tag_id":"cjtjvgx740017qmhffq29midk","_id":"cjtjvgx78001eqmhfkbym4jr4"},{"post_id":"cjtjvgx66000aqmhfeghmr5my","tag_id":"cjtjvgx610006qmhfnefang9q","_id":"cjtjvgx78001fqmhfg0uomh6a"},{"post_id":"cjtjvgx67000cqmhfek3smpe8","tag_id":"cjtjvgx6l000lqmhfvkw0jl49","_id":"cjtjvgx79001iqmhf3c19scqz"},{"post_id":"cjtjvgx67000cqmhfek3smpe8","tag_id":"cjtjvgx6p000rqmhfcb8q3hef","_id":"cjtjvgx79001jqmhfbgzc3lil"},{"post_id":"cjtjvgx67000cqmhfek3smpe8","tag_id":"cjtjvgx78001gqmhflxr61ubg","_id":"cjtjvgx7a001lqmhfuhenf0q3"},{"post_id":"cjtjvgx67000cqmhfek3smpe8","tag_id":"cjtjvgx610006qmhfnefang9q","_id":"cjtjvgx7a001mqmhfqh4rhdj3"},{"post_id":"cjtjvgx6b000fqmhfbnyav5ws","tag_id":"cjtjvgx6l000lqmhfvkw0jl49","_id":"cjtjvgx7b001pqmhfuaorj0j3"},{"post_id":"cjtjvgx6b000fqmhfbnyav5ws","tag_id":"cjtjvgx6p000rqmhfcb8q3hef","_id":"cjtjvgx7b001qqmhfyxncjr0q"},{"post_id":"cjtjvgx6b000fqmhfbnyav5ws","tag_id":"cjtjvgx6u000uqmhff4t1ldnm","_id":"cjtjvgx7c001sqmhfpt6gfqrk"},{"post_id":"cjtjvgx6b000fqmhfbnyav5ws","tag_id":"cjtjvgx610006qmhfnefang9q","_id":"cjtjvgx7c001tqmhf9msgz8y1"},{"post_id":"cjtjvgx6e000hqmhfqkx8qa0z","tag_id":"cjtjvgx7b001oqmhfplaso8vr","_id":"cjtjvgx7e001vqmhfvt8g9ma2"},{"post_id":"cjtjvgx6h000jqmhfe9zq8wl2","tag_id":"cjtjvgx6p000rqmhfcb8q3hef","_id":"cjtjvgx7f001xqmhfn5dsekdx"},{"post_id":"cjtjvgx6h000jqmhfe9zq8wl2","tag_id":"cjtjvgx7d001uqmhfp5qazagx","_id":"cjtjvgx7f001yqmhfydq9f0up"},{"post_id":"cjtjvgx6h000jqmhfe9zq8wl2","tag_id":"cjtjvgx610006qmhfnefang9q","_id":"cjtjvgx7i0020qmhfhn90on5l"},{"post_id":"cjtjvgx6k000kqmhfmpxiupfv","tag_id":"cjtjvgx7f001wqmhf9889m485","_id":"cjtjvgx7j0022qmhfas1fbehz"},{"post_id":"cjtjvgx6k000kqmhfmpxiupfv","tag_id":"cjtjvgx7b001oqmhfplaso8vr","_id":"cjtjvgx7j0023qmhf3esrdr00"},{"post_id":"cjtjvgx6m000mqmhf6k2j9qbi","tag_id":"cjtjvgx7i0021qmhfygqx7azy","_id":"cjtjvgx7k0026qmhfml6z8ea3"},{"post_id":"cjtjvgx6m000mqmhf6k2j9qbi","tag_id":"cjtjvgx7j0024qmhf152qpsi1","_id":"cjtjvgx7l0027qmhfc7sqzy54"},{"post_id":"cjtjvgx6n000oqmhf6nr79g2c","tag_id":"cjtjvgx7k0025qmhfmxpcw0nj","_id":"cjtjvgx7m0029qmhfk70c0v1j"},{"post_id":"cjtjvgx6q000sqmhfn18f9zzb","tag_id":"cjtjvgx7l0028qmhfrefkxnfn","_id":"cjtjvgx7n002cqmhf88jd6fbe"},{"post_id":"cjtjvgx6q000sqmhfn18f9zzb","tag_id":"cjtjvgx7n002aqmhfkqge0uq8","_id":"cjtjvgx7n002dqmhffqfmnmor"},{"post_id":"cjtjvgx6v000wqmhfrtoxoftg","tag_id":"cjtjvgx7n002bqmhf7l2qalkc","_id":"cjtjvgx7p002hqmhfkofivl3v"},{"post_id":"cjtjvgx6v000wqmhfrtoxoftg","tag_id":"cjtjvgx7n002eqmhftf90zi8y","_id":"cjtjvgx7q002iqmhfqt3obq2i"},{"post_id":"cjtjvgx6v000wqmhfrtoxoftg","tag_id":"cjtjvgx7o002fqmhfnfx96hui","_id":"cjtjvgx7r002kqmhf19g45vsj"},{"post_id":"cjtjvgx6x000yqmhfths1s5m9","tag_id":"cjtjvgx7j0024qmhf152qpsi1","_id":"cjtjvgx7r002lqmhfk24nu2p9"},{"post_id":"cjtjvgx750018qmhf57tqrzeq","tag_id":"cjtjvgx7r002jqmhfnsxqcv84","_id":"cjtjvgx7u002nqmhfszp6a24o"},{"post_id":"cjtjvgx750018qmhf57tqrzeq","tag_id":"cjtjvgx7t002mqmhfvejnu7yt","_id":"cjtjvgx7u002oqmhfcltm61xn"},{"post_id":"cjtjvgx80002qqmhfg2gakr0e","tag_id":"cjtjvgx6l000lqmhfvkw0jl49","_id":"cjtjvgx86002wqmhfjm049knv"},{"post_id":"cjtjvgx80002qqmhfg2gakr0e","tag_id":"cjtjvgx6p000rqmhfcb8q3hef","_id":"cjtjvgx86002xqmhfoljqzre1"},{"post_id":"cjtjvgx80002qqmhfg2gakr0e","tag_id":"cjtjvgx82002sqmhfj170ftew","_id":"cjtjvgx87002zqmhfu7qeh8rp"},{"post_id":"cjtjvgx80002qqmhfg2gakr0e","tag_id":"cjtjvgx610006qmhfnefang9q","_id":"cjtjvgx870030qmhfh5ish7sl"},{"post_id":"cjtjvgx81002rqmhfftqu3iyw","tag_id":"cjtjvgx85002vqmhfm424w2ke","_id":"cjtjvgx870032qmhfjn0j84t2"},{"post_id":"cjtjvgx81002rqmhfftqu3iyw","tag_id":"cjtjvgx86002yqmhfjojdzgvy","_id":"cjtjvgx880033qmhfyelsm9c7"},{"post_id":"cjtjvgx82002tqmhf0np683pw","tag_id":"cjtjvgx870031qmhfheqdun0t","_id":"cjtjvgx880035qmhfz7ysg9a6"},{"post_id":"cjtjvgx82002tqmhf0np683pw","tag_id":"cjtjvgx7b001oqmhfplaso8vr","_id":"cjtjvgx890036qmhfl8plbz13"},{"post_id":"cjtjvgx84002uqmhf0wnxf8zw","tag_id":"cjtjvgx880034qmhft8wn4q8w","_id":"cjtjvgx890038qmhf83a81a6x"},{"post_id":"cjtjvgx84002uqmhf0wnxf8zw","tag_id":"cjtjvgx890037qmhf4zjs4x0c","_id":"cjtjvgx8a0039qmhfvikvpp4x"},{"post_id":"cjtjvgx8e003bqmhf6wve4uo1","tag_id":"cjtjvgx650009qmhfcr17fm1o","_id":"cjtjvgx8i003dqmhf7fwpbg5o"},{"post_id":"cjtjvgx8e003bqmhf6wve4uo1","tag_id":"cjtjvgx85002vqmhfm424w2ke","_id":"cjtjvgx8j003gqmhf4iniz3ji"},{"post_id":"cjtjvgx8e003bqmhf6wve4uo1","tag_id":"cjtjvgx7n002bqmhf7l2qalkc","_id":"cjtjvgx8k003hqmhfpaimt1he"},{"post_id":"cjtjvgx8i003eqmhfepzvzp6f","tag_id":"cjtjvgx880034qmhft8wn4q8w","_id":"cjtjvgx8k003iqmhfgaw4z84m"},{"post_id":"cjtjvgx8g003cqmhfghcb44yc","tag_id":"cjtjvgx880034qmhft8wn4q8w","_id":"cjtjvgx8k003jqmhfzvwntd6w"},{"post_id":"cjtjvgx8g003cqmhfghcb44yc","tag_id":"cjtjvgx8j003fqmhf3thdzdw8","_id":"cjtjvgx8l003kqmhficzqbh5h"}],"Tag":[{"name":"es6","_id":"cjtjvgx5t0002qmhfo4qigaie"},{"name":"js","_id":"cjtjvgx610006qmhfnefang9q"},{"name":"总结","_id":"cjtjvgx650009qmhfcr17fm1o"},{"name":"函数式编程","_id":"cjtjvgx6a000eqmhfzxo4sz5p"},{"name":"core-decorators","_id":"cjtjvgx6l000lqmhfvkw0jl49"},{"name":"decorator","_id":"cjtjvgx6p000rqmhfcb8q3hef"},{"name":"decorators源码简析——debounce","_id":"cjtjvgx6u000uqmhff4t1ldnm"},{"name":"lazyInitialize","_id":"cjtjvgx740017qmhffq29midk"},{"name":"readonly","_id":"cjtjvgx78001gqmhflxr61ubg"},{"name":"css","_id":"cjtjvgx7b001oqmhfplaso8vr"},{"name":"es7","_id":"cjtjvgx7d001uqmhfp5qazagx"},{"name":"font-face","_id":"cjtjvgx7f001wqmhf9889m485"},{"name":"下载","_id":"cjtjvgx7i0021qmhfygqx7azy"},{"name":"兼容","_id":"cjtjvgx7j0024qmhf152qpsi1"},{"name":"lottie","_id":"cjtjvgx7k0025qmhfmxpcw0nj"},{"name":"npm包","_id":"cjtjvgx7l0028qmhfrefkxnfn"},{"name":"组件开发","_id":"cjtjvgx7n002aqmhfkqge0uq8"},{"name":"webpack","_id":"cjtjvgx7n002bqmhf7l2qalkc"},{"name":"前端打包","_id":"cjtjvgx7n002eqmhftf90zi8y"},{"name":"require","_id":"cjtjvgx7o002fqmhfnfx96hui"},{"name":"继承","_id":"cjtjvgx7r002jqmhfnsxqcv84"},{"name":"原型链","_id":"cjtjvgx7t002mqmhfvejnu7yt"},{"name":"autobind","_id":"cjtjvgx82002sqmhfj170ftew"},{"name":"react","_id":"cjtjvgx85002vqmhfm424w2ke"},{"name":"高阶组件","_id":"cjtjvgx86002yqmhfjojdzgvy"},{"name":"sass","_id":"cjtjvgx870031qmhfheqdun0t"},{"name":"前端性能优化","_id":"cjtjvgx880034qmhft8wn4q8w"},{"name":"webp","_id":"cjtjvgx890037qmhf4zjs4x0c"},{"name":"sitespeed.io","_id":"cjtjvgx8j003fqmhf3thdzdw8"}]}}