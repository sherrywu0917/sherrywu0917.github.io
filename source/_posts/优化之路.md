---
title: 前端优化-蹒跚学步
date: 2019-04-03 09:38:54
tags:
---
# 项目背景
项目是基于React开发，webpack打包的多页面h5应用，其中部分页面又是基于React-router的SPA。开发的过程中，也一直在尝试对项目进行优化，这儿主要记录了对`代码分片`、`持久化缓存`和`图片优化`的处理。

优化之路漫漫，蹒跚而来。

* * *

# 动态加载组件
## Code splitting(代码分片)
当前端代码越来越复杂，代码体积越来越大时，需要考虑对加载的资源进行细粒度的分割，按需加载。
webpack支持两种语法实现动态地加载模块：
- [require.ensure](https://webpack.js.org/api/module-methods/#require-ensure)
给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。
```js
require.ensure(dependencies: String[], callback: function(require), chunkName: String)
```

- [import](https://webpack.js.org/api/module-methods/#import-)
调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。
```js
import(
  /* webpackChunkName: "my-chunk-name" */
  /* webpackMode: "lazy" (default)*/
  'path/to/module') -> Promise
```
`webpackChunkName`用来设置chunk的名字；`webpackMode`默认值是`lazy`，还有`lazy-once`、`eager`、`weak`。按需加载的默认加载形式是async。
<!-- more -->

## react动态加载组件
在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。
直接看代码：
``` js
import React, {Component} from 'react'

/**
 * 异步加载模块
 * @param  {[type]} loadComponent [description]
 * @return {[type]}               [description]
 */
export const asyncComponent = loadComponent => (
    class AsyncComponent extends Component {
        state = {
            Component: null,
        }

        componentDidMount() {
            if (this.hasLoadedComponent()) {
                return;
            }

            loadComponent()
                .then(module => module.default)
                .then((Component) => {
                    this.setState({ Component });
                })
                .catch((err) => {
                    console.error(`Cannot load component in <AsyncComponent />`);
                    throw err;
                });
        }

        hasLoadedComponent() {
            return this.state.Component !== null;
        }

        render() {
            const { Component } = this.state;
            return (Component) ? <Component {...this.props} /> : null;
        }
    }
);
```

`loadComponent`参数代表import('module')异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。
如何调用：
``` js
export const AsyncBannerSwiper = asyncComponent(() => import(/* webpackChunkName: "bannerSwiper" */ './BannerSwiper.jsx'))
```
将`BannerSwiper`组件用`asyncComponent`封装下，就返回了一个异步加载的`AsyncBannerSwiper`组件，使用方法和其他组件完全一致。其中支持`webpackChunkName`去配置chunk的名字，不配置的情况下会默认生成`[id].bundle.js`。

### publicPath动态设置
项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。
动态设置异步chunk的publicPath，在入口entry中设置__webpack_public_path__，打包配置文件中配置的publicPath不变。
``` js
__webpack_public_path__ = window.cdn || '/dist/';

```

## webpack设置
在webpack配置文件中，需要配置`chunkFilename`指定chunk的名字。
``` js
chunkFilename: '[name].js'
```
另外，注意webpack插件的配置：
``` js
new webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id
new webpack.optimize.CommonsChunkPlugin({
    ...
    children: false,  // 如果设置为 `true`，所有公共 chunk 的子模块都会被选择
    ...
}),
new ExtractTextPlugin({filename: 'css/[name].css?[contenthash:8]', allChunks: true}),  //从所有chunk中提取(默认情况下，它仅从initial chunk中提取)
```

## 分离前后对比
使用[webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：
<img src="http://kms.fp.ps.netease.com/file/5c1b66436f04944f5b0bac27fkqqY7XJ" width="600px">
可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：
<img src="http://kms.fp.ps.netease.com/file/5c1b66b196dee43c91c66dc7p9XqNpke" width="500px">
使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：
<img src="http://kms.fp.ps.netease.com/file/5c1b665f7f9d2a9a4e46ed29AADJKiNf" width="600px">
可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。线上的资源又是开启了gzip压缩，体积就更小了。
<img src="http://kms.fp.ps.netease.com/file/5c1b66d0a7f2523ddac2a954og4WjVDi" width="500px">


* * *

# 持久化缓存
为了获取持久化缓存，在配置webpack的output时，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。
## moduleId VS chunkId
webpack打包后会生成`webpackJsonp`等方法，用于加载chunk和module，精简的源码如下所示：
``` js
(function(modules) {
  window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
    var moduleId, result;
    for (moduleId in moreModules) { //该chunk引用的所有模块
      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
        // 将chunk中所包含的模块放入modules数组中
        modules[moduleId] = moreModules[moduleId];
      }
    }
    if (executeModules) { //入口module
      for (i = 0; i < executeModules.length; i++) {
        result = __webpack_require__(executeModules[i]);
      }
    }
    return result;
  };
  var installedModules = {};

  // 调用__webpack_require__(moduleId)时，
  // 再将模块放入installedModules，用于保存已经加载过的模块
  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) {
      return installedModules[moduleId].exports;
    }
    // Create a new module (and put it into the cache)
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };
    // Execute the module function:
    // 在执行的过程中，会递归调用`__webpack_require__`加载该模块引用的其他模块
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

    // Flag the module as loaded
    module.l = true;
    return module.exports;
  }
})([]);
```
`webpackJsonp`方法接收三个参数`chunkIds, moreModules, executeModules`，其中`chunkIds`属于chunkId，`moreModules, executeModules`都属于moduleId。
- chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。
- module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前`__webpack_require__`加载的模块，同样使用数组下标作为moduleId。
每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。

## 固化过程
### 初始状态
以首页为例，打包后生成的index.js中会调用`webpackJsonp`方法，传入三个参数`chunkIds, moreModules, executeModules`。
``` js
webpackJsonp([4],{
/***/ 10:
/***/ (function(module, exports, __webpack_require__) {"use strict";eval("");
/***/ }),
/***/ 11:
/***/ (function(module, __webpack_exports__, __webpack_require__) {"use strict";eval("/*actual code*/");
/***/ })
//more code
}, [348]);
```
若此时新增一个页面，入口为"./src/entry/test.jsx"，打包后，会发现所有的js内容都发生了改变，以其中一个文件为例，发现是引用的moduleId发生了变化：
<img src="https://easyread.nosdn.127.net/web/trunk/1545811193495/xxxx_20181226155854.png" />
<img src="https://easyread.nosdn.127.net/web/trunk/1545811180510/xxxx_20181226155821.png" />

### 固化`moduleId`
为了不影响其他文件，需要想办法将moduleId固定化，可以在webpack中配置`NamedModulesPlugin`，最新打包生成的index.js内部代码如下。和上面的代码比较，可以发现数字moduleId被替换成了文件的路径，这保证了moduleId的不变性。
``` js
webpackJsonp([4],{
/***/ "./node_modules/babel-runtime/helpers/defineProperty.js":
/***/ (function(module, exports, __webpack_require__) {"use strict";eval("");
/***/ }),
/***/ "./node_modules/nw-detect/es/index.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {"use strict";eval("/*actual code*/");
/***/ })
//more code
}, ["./src/entry/index.jsx"]);
```
`moduleId`既然不会再变，那我们重新添加test页面，打包后是不是会只新增js呢？开心的是大部分js都没有改动，但发现还有两个js有变化，包括我们提取出的公共js`common.bundle.js`。对比下，发现文件的内容只有`chunkId`发生了变化：
<img src="https://easyread.nosdn.127.net/web/trunk/1545812851431/xxxx_20181226162712.png"/>
<img src="https://easyread.nosdn.127.net/web/trunk/1545812873655/xxxx_20181226162719.png"/>

### 固化`chunkId`
再进一步，显然就是希望可以固化`chunkId`，webpack插件`NamedChunksPlugin`可以满足我们的需求，它使用webpack中唯一的entry名作为chunkId。配置好`NamedChunksPlugin`后，对比添加test页面前后js的变化，发现只有新增的js，已有的js都没有发生变化，注意到之前的`common.bundle.js`和`forbidden.js`发生改变的地方，代码分别如下：
``` js
/******/  // objects to store loaded and loading chunks
/******/  var installedChunks = {
/******/    "common": 0
/******/  };

```
``` js
webpackJsonp(["forbidden"],{
  //other code
```
chunkId都由数字变成了唯一的entry值，`common`对应`CommonsChunkPlugin`配置的name值。
对于代码分离出的js，使用`webpackChunkName `设置`chunkName`，可以保证该js`chunkId`的稳定性。

### 生产环境下固化`moduleId`
前文提到的`NamedModulesPlugin`，使用的是模块的相对路径，但因为相对路径偏长，生产环境更建议使用`HashedModuleIdsPlugin`，它会根据文件的路径去生成hash，打包后的文件更小。
``` js
webpackJsonp(["index"],
  {"+qWx":function(e,t){e.exports=vendor},"5AEV" ...},
  ["qwtH"]);
```
最终在生产环境下需要配置下面的代码，就可以实现moduleId和chunkId的固定，使用户端的缓存更加持久。
```js
new webpack.HashedModuleIdsPlugin(), //固化 module id
new webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id
```

* * *

## 图片优化
图片的大小直接影响页面加载的速度，基础的优化操作有：对图片进行压缩、转base64减少http请求、使用srcset/sizes获取自适应图片等。这儿主要介绍如何结合webpack进行图片压缩，以及应用webp图片格式。

### webpack loader图片压缩
对图片进行压缩处理，可以选择的压缩工具有很多种，如压缩png、jpg的[tinypng](https://tinypng.com/)、[智图](https://zhitu.isux.us/)，裁剪压缩gif的[iLoveIMG](https://www.iloveimg.com/zh-cn/compress-image/compress-gif)；也可以安装psd的tinypng插件，以及pngquant、ImageAlpha、ImageOptim、Image Optimizer等其他压缩工具。
**打包压缩**
相比之下，配置loader或plugin打包压缩更加便捷，例如，配置好[image-webpack-loader](https://www.npmjs.com/package/image-webpack-loader)，在production模式下开启压缩，就可以在打包的时候自动压缩图片。
>image-webpack-loader是基于[imagemin](https://github.com/kevva/imagemin)去压缩PNG、JPEG、GIF、SVG和WEBP图片。针对不同的优化项，可以自定义参数以适配项目的需求。
``` js
{
    test: /\.(png|jpg|gif)$/,
    use: [{
        loader: 'url-loader',
        options: {
            limit: 8192,
            name: 'image/[hash:8].[name].[ext]'
        }
    }, {
        loader: 'image-webpack-loader',
        options: {
            mozjpeg: {
                progressive: true,
                quality: 65
            },
            pngquant: {
                quality: '65-90',
                speed: 3
            }
        }
    }]
}
```
webpack也可以支持`tinypng`的打包压缩，如[tinypng-webpack-plugin](https://www.npmjs.com/package/tinypng-webpack-plugin)，使用了`tinypng`提供的[API](https://tinypng.com/developers/reference/nodejs)。但需要注意的是，使用tinypng需要申请key值，每个key值每个月可以免费压缩500张，超出部分就要付费了。

### 响应式图片
可以通过@media、image-set或者js实现根据屏幕大小获取对应的图片，更方便的方式是使用<img srcset>和<picture>。
#### srcset相同尺寸不同分辨率
```html
<img src="pic.png?imageView&thumbnail=202y284"
     srcset="pic.png?imageView&thumbnail=202y284 2x, pic.png?imageView&thumbnail=303y426 3x">
```
当分辨率为3x时，会使用3x对应的pic.png?imageView&thumbnail=303y426图片。没有匹配到的、或者是不支持srcset属性的浏览器会正常加载src引用的图片。结合NOS提供的图片缩略功能，只需要上传一张图片，就可以实现不同分辨率下返回不同尺寸的图片。

#### sizes不同尺寸
```html
<img srcset="pic-320w.jpg 320w,
             pic-480w.jpg 480w,
             pic-800w.jpg 800w"
     sizes="(max-width: 320px) 280px,
            (max-width: 480px) 440px,
            800px"
     src="pic-800w.jpg">
```
当屏幕宽度为450px时，满足`sizes`定义的媒体查询`(max-width: 480px) 440px`，这时候图片宽度是440px，将从`srcset`中匹配最接近的宽度。注意不能直接把440px和480w去比较，因为srcset中的w值不是对应的像素值，而是图片真正的宽度。如在iphone8上，分辨率是2x，440px对应的图片宽度是880w，与880w最接近的是800w，所以会去加载图片'pic-800w.jpg'，而如果是在分别率为1x的设备上，则对应440w，与480w最接近，会去加载图片`pic-480w.jpg`。

#### picture
``` html
<picture>
  <source media="(max-width: 799px)" srcset="elva-480w-close-portrait.jpg">
  <source media="(min-width: 800px)" srcset="elva-800w.jpg">
  <img src="elva-800w.jpg" alt="Chris standing up holding his daughter Elva">
</picture>
```
会按顺序加载满足条件的第一个图片，保底需要定义一个img作为默认值，已经兼容不支持<picture>标签的浏览器。source同样支持srcset和sizes属性配置多个，此外还支持type去标识不同的图片类型。
``` html
<picture>
  <source type="image/webp" srcset="snow.webp">
  <img src="snow.png" alt="Hut in the snow">
</picture>
```
如果支持webp格式的，会去加载snow.webp，否则会去加载默认的snow.png。

#### HTTP Client Hints
通过`http client hints`，浏览器发起请求的时候，可以将DPR、Width、Viewport-Width等属性发送到Server端。Chrome46开始支持[Accept-CH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation#The_Accept-CH_header)的配置：
```html
<meta http-equiv="Accept-CH" content="DPR, Width, Viewport-Width">
```
配置完成后，页面发送的请求头部都被包含下面信息：
```
Accept: image/webp,image/apng,image/*,*/*;q=0.8
DPR: 3
Viewport-Width: 460
Width: 230
```
其中Width属性不是每次都被带上，它是根据Image的sizes属性计算出来的，默认还会带上Accept属性，如果支持webp格式的图片，会包含'image/webp'。Server端可以根据
这些属性的值返回期望的图片：宽度为690px的webp图片。响应头会包含Content-Type、Content-DPR、Vary属性，浏览器会基于Content-DPR的值去计算图片最终展示的宽度，保证宽度仍为230px。demo如下所示。
<img src="http://kms.fp.ps.netease.com/file/5c221d45a7f2522c896cb338a052AIYJ" width="600px">

更详细的介绍，参见[automating-resource-selection-with-client-hints](https://developers.google.com/web/updates/2015/09/automating-resource-selection-with-client-hints)

### webp图片
WebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。
[webp兼容性](https://caniuse.com/#search=webp)见下图
<img src="http://kms.fp.ps.netease.com/file/5c1b671d5e60271dd96424efFDXtIaaQ" width="800px">
其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。

#### 检测浏览器是否支持webp格式
##### 方法1: canvas的toDataURL
```js
function checkWebp() {
    try{
        return (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0);
    }catch(err) {
        return  false;
    }
    //or
    !![].map && document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;
}
```
对比一下chrome和ie下`document.createElement('canvas').toDataURL('image/webp')`下的输出：
```js
//ie
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII="
//chrome
"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA"
```
基于`toDataURL`的特性，如果请求的类型不被支持，默认返回`data:image/png`。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则`toDataURL`会返回`"data:,"`。)
所以，只有支持webp格式的浏览器调用`toDataURL('image/webp')`后返回的字符串中才包含`'data:image/webp'`。上面提供了两种写法，其中`!![].map`主要是判断是否是IE9+，以免toDataURL方法会报错。

##### 方法2: 图片onload
google官网提供的，通过加载小的webp图片来判断是否支持该格式：
```js
// check_webp_feature:
//   'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.
//   'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)
function check_webp_feature(feature, callback) {
    var kTestImages = {
        lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
        lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==",
        alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==",
        animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"
    };
    var img = new Image();
    img.onload = function () {
        var result = (img.width > 0) && (img.height > 0);
        callback(feature, result);
    };
    img.onerror = function () {
        callback(feature, false);
    };
    img.src = "data:image/webp;base64," + kTestImages[feature];
}
```
上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。
调用方法如下，可以在`callback`方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加`webp`相关的class都可以。
```js
check_webp_feature('lossless',function(feature,result){
    alert(result); //true or false
});

```

#### 使用webp
处理webp通常有两种方式：
- 服务端处理，支持webp图片的浏览器会在请求头Accept中加上`image/webp`，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了；
- 前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型
开心的是，基于网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考https://www.163yun.com/help/documents/114078550521466880。
其中，通过在url后拼接`?imageView&type=webp`就可以获得对应的webp图片。


### REFS
[响应式图片](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images)
[React（17）异步组件](https://blog.csdn.net/qq20004604/article/details/79318253)
[基于 webpack 的持久化缓存方案 ](https://github.com/pigcan/blog/issues/9)
https://www.imooc.com/article/21538
[听说你用webpack处理文件名的hash？](https://www.imooc.com/article/21538)
[简单易懂的 webpack 打包后 JS 的运行过程](https://juejin.im/post/5a23b130f265da432003101a)

