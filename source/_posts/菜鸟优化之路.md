---
title: 菜鸟优化之路
date: 2018-08-08 16:21:21
tags: [前端性能优化]
---
# DeviceTiming工具
最近了解到[DeviceTiming](https://github.com/danielmendel/DeviceTiming)工具，可以帮助我们监测js在不同设备上的解析和执行时间，运行环境是在开发环境下。
搬运下git上的安装、运行命令：
``` bash
//安装
git clone https://github.com/etsy/DeviceTiming.git
cd DeviceTiming
npm install

//运行
./devicetiming server /path/to/your/js
```
** 注意：devicetiming会改变被监控的js，要先备份好，不过有git记录的就不用担心了 **
运行了之后，用不同的设备访问开发环境下的站点，最后reload`http://localhost:8537/`页面，可以看到不同设备对js的解析和执行时间，如下图所示：
<img src="/image/deviceTiming.png" width="1200px">
可以看到不同设备的ua信息，每个js的parse和exec时间。从上到下，三个设备分别是微信开发者工具、iphone、安卓机。从数据上看，安卓机parse和exec花费的时间最久，花费时间越长，用户的体验就会越差。
该站点面向的用户中安卓机份额更高，`how to optimize`显得比较重要。

# how to optimize
## 尾部调用优化（TCO）
尾调用概念就是在函数最后一步调用其他函数。
``` js
function foo(x) {
    return x;
}

function bar(y) {
    return foo( y + 1 );    // 尾部调用
}

function baz() {
    return 1 + bar( 40 );   // 不是尾部调用
}

baz();                      // 42
```
`bar`函数的最后一步是调用`foo( y + 1 )`，属于尾部调用；而在`baz`函数中，调用完`bar(40)`后，还有执行`+ 1`的操作，就不属于尾部调用了。
<!-- more -->

> 函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个"调用栈"（call stack）。

<img src="/image/callstack.png" width="555px">

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。
``` js
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```
如果函数`g`不是尾部调用，函数`f`就需要保存内部变量m和n的值、g的调用位置等信息。
`尾部调用优化`，即只保留内层函数的调用记录，运用这一思想可以去优化递归，不需要再保存每次的调用记录，始终只存在一个调用记录，可以避免'栈溢出'。

## 动态加载组件
### 代码分片
当前端代码越来越复杂，代码体积越来越大时，考虑对加载的资源进行细粒度的分割，按需加载。
webpack支持两种语法实现动态地加载模块：
- [require.ensure](https://webpack.js.org/api/module-methods/#require-ensure)
给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。
```js
require.ensure(dependencies: String[], callback: function(require), chunkName: String)
```

- [import](https://webpack.js.org/api/module-methods/#import-)
调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。
```js
import(
  /* webpackChunkName: "my-chunk-name" */
  /* webpackMode: "lazy" (default)*/
  'path/to/module') -> Promise
```
`webpackChunkName`用来设置chunk的名字；`webpackMode`默认值是`lazy`，还有`lazy-once`、`eager`、`weak`。

按需加载的默认加载形式是async。

### react动态加载组件
在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。
直接看代码：
``` js
import React, {Component} from 'react'

/**
 * 异步加载模块
 * @param  {[type]} loadComponent [description]
 * @return {[type]}               [description]
 */
export const asyncComponent = loadComponent => (
    class AsyncComponent extends Component {
        state = {
            Component: null,
        }

        componentDidMount() {
            if (this.hasLoadedComponent()) {
                return;
            }

            loadComponent()
                .then(module => module.default)
                .then((Component) => {
                    this.setState({ Component });
                })
                .catch((err) => {
                    console.error(`Cannot load component in <AsyncComponent />`);
                    throw err;
                });
        }

        hasLoadedComponent() {
            return this.state.Component !== null;
        }

        render() {
            const { Component } = this.state;
            return (Component) ? <Component {...this.props} /> : null;
        }
    }
);
```

`loadComponent`参数代表import('module')异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。
如何调用：
``` js
export const AsyncBannerSwiper = asyncComponent(() => import(/* webpackChunkName: "bannerSwiper" */ './BannerSwiper.jsx'))
```
将`BannerSwiper`组件用`asyncComponent`封装下，就返回了一个异步加载的`AsyncBannerSwiper`组件，使用方法和其他组件完全一致。

#### publicPath动态设置
项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。
动态设置异步chunk的publicPath，在入口entry中设置__webpack_public_path__，打包配置文件中配置的publicPath不变。
``` js
__webpack_public_path__ = window.cdn || '/dist/';

```

### webpack设置
在webpack配置文件中，需要配置`chunkFilename`指定chunk的名字。
``` js
chunkFilename: '[name].js'
```
另外，注意webpack插件的配置：
``` js
new webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id
new webpack.optimize.CommonsChunkPlugin({
    ...
    children: false,  // 如果设置为 `true`，所有公共 chunk 的子模块都会被选择
    ...
}),
new ExtractTextPlugin({filename: 'css/[name].css?[contenthash:8]', allChunks: true}),  //从所有chunk中提取(默认情况下，它仅从initial chunk中提取)
```

### 分离前后对比
使用[webpack-bundle-analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：
<img src="/image/codesplit_before.png" width="600px">
可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：
<img src="/image/codesplit_before1.png" width="500px">

使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：
<img src="/image/codesplit_after.png" width="600px">
可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。
<img src="/image/codesplit_after1.png" width="500px">

REFS:
https://blog.csdn.net/qq20004604/article/details/79318253
https://segmentfault.com/a/1190000009820646

## 持久化内存
为了获取持久化内存，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。
#### moduleId VS chunkId
看打包后的`manifest.js`，精简的源码如下所示：
``` js
(function(modules) {
  window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
    var moduleId, result;
    for (moduleId in moreModules) {
      if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
        // 将chunk中所包含的模块放入modules数组中
        modules[moduleId] = moreModules[moduleId]; 
      }
    }
    if (executeModules) {
      for (i = 0; i < executeModules.length; i++) {
        result = __webpack_require__(executeModules[i]);
      }
    }
    return result;
  };
  var installedModules = {};

  // 调用__webpack_require__(moduleId)时，
  //再将模块放入installedModules，用于保存已经加载过的模块
  function __webpack_require__(moduleId) {
    if (installedModules[moduleId]) {
      return installedModules[moduleId].exports;
    }
    var module = installedModules[moduleId] = {
      exports: {}
    };
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    return module.exports;
  }
})([]);
```
`webpackJsonp`方法接收三个参数`chunkIds, moreModules, executeModules`，分别属于chunkId和moduleId两种类型:
- chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。
- module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前`__webpack_require__`加载的模块，同样使用数组下标作为moduleId。
每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。

### 固化moduleId和chunkId
- 固化moduleId：`HashedModuleIdsPlugin`会根据文件的路径去生成hash，可以用在生成环境。开发环境可以使用`NamedModulesPlugin`，hash直接是模块的相对路径，更加清晰，便于debug。
- 固化chunkId：webpack中entry的唯一的，所以可以直接使用entry名作为chunkId，使用`NamedChunksPlugin`可以帮助我们达成该目标，如果是代码分离出的chunk可以使用`/* webpackChunkName: "bannerSwiper" */`指定chunk的名字，或者可以在`NamedChunksPlugin`插件中去配置。
```js
new webpack.HashedModuleIdsPlugin(), //固化 module id
new webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id
```

REFS:
https://github.com/pigcan/blog/issues/9
https://www.imooc.com/article/21538
https://juejin.im/post/5a23b130f265da432003101a
https://github.com/happylindz/blog/issues/6

## cpu占比探测
``` js
var data = []
var t

function pulse() {
  t && data.push(Date.now() - t)
  t = Date.now()
  setTimeout(pulse, 50)
}

pulse()
```
就是每隔 50ms 打一下点。理想情况下，data 的值应该是
``` js
data = [50, 50, 50, 50, ...]
```
但实际情况，data会是
``` js
data = [51, 52, 50, 52, ...]
```
cpu越忙，data的数据项会越大。这样，记录一系列 data 值，就可以绘制出 CPU 占比趋势图，和通过任务管理器看到的 CPU 趋势图非常接近。

上面只是原理说明，实际情况没这么简单。但很明显，通过这么一个简单的规律，就能实现用纯 JavaScript 来探测 CPU 占比。
