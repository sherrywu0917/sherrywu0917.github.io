---
title: 日常经验积累
date: 2017-10-19 11:28:58
tags: [总结]
---

### 禁用复制功能
``` javascript
    document.oncontextmenu = function() { return false; }  //禁用鼠标右键功能
    document.body.oncopy = function() { return false; }    //禁用复制功能
    document.onselectstart = function() { return false; }  //禁用选择功能
```

### UC浏览器问题
UC浏览器会过滤掉top、test、ad、download等关键字
uc浏览器判断到页面上文字居多时，会自动放大字体优化移动用户体验。
添加以下头部可以禁用掉该优化
<meta name="wap-font-scale" content="no">

### Font Boosting问题
问题：字体的显示大小，与在CSS中指定的大小不一致。
通过设置max-height: 999999px;或max-height: 100%;可以解决

### ios<10 js无法实现复制
[copy-to-clipboard-using-javascript-in-ios](https://stackoverflow.com/questions/34045777/copy-to-clipboard-using-javascript-in-ios)

### 移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行

### ios微信缓存问题
问题：ios9系统下微信内(非必现)，从充值页回到正文页，正文页获取的余额没有刷新，发现get请求没有发出，应该是微信AJAX缓存的问题。可通过给ajax请求加时间戳的方式解决。
参考：[微信自带浏览器物理返回不刷新问题](https://www.jianshu.com/p/6baa49e26533)

奇怪现象：其他的ios系统下，请求也没有发出去，但是数据是正确的，可能和缓存快照有关系，正常的可能保存了这个页面上次运行的整个数据栈。

### 移动端滚动穿透问题完美解决方案
``` css
body.modal-open {
    position: fixed;
    width: 100%;
}
```
当打开modal的时候给body添加`modal-open`类，fixed让底部页面无法滚动，同时根据页面滚动位置设置top值。
在关闭modal时，再让页面恢复之前的滚动状态。
``` js
/**
  * ModalHelper helpers resolve the modal scrolling issue on mobile devices
  * https://github.com/twbs/bootstrap/issues/15852
  * requires document.scrollingElement polyfill https://github.com/yangg/scrolling-element
  */
var ModalHelper = (function(bodyCls) {
  var scrollTop;
  return {
    afterOpen: function() {
      scrollTop = document.scrollingElement.scrollTop;
      document.body.classList.add(bodyCls);
      document.body.style.top = -scrollTop + 'px';
    },
    beforeClose: function() {
      document.body.classList.remove(bodyCls);
      // scrollTop lost after set position:fixed, restore it back.
      document.scrollingElement.scrollTop = scrollTop;
    }
  };
})('modal-open');
```

### 不简单的自适应高度输入框
主要实现代码如下：
``` css
textarea {
    width: 100%;
    height: 92px;
    padding: 20px;
    line-height: 50px;
    resize: none;
    outline: none;
    border: 1px solid #ccc;
    background: #eee;
    font-size: 32px;
    box-sizing: border-box;
    overflow: hidden;  //去掉滚动条
}
```

``` html
<textarea id="textarea"></textarea>
```

``` js
var $textarea = document.getElementById('textarea');
var lastLength = 0;
var lastHeight = 0;

$textarea.addEventListener('input', function() {
    var currentLength = $textarea.value.length;

    // 判断字数如果比之前少了，说明内容正在减少，需要清除高度样式，重新获取
    if (currentLength < lastLength) {
        $textarea.style.height = '';
    }

    var currentHeight = $textarea.scrollHeight;

    // 如果内容高度发生了变化，再去设置高度值
    if (lastHeight !== currentHeight || !$textarea.style.height) {
        $textarea.style.height = currentHeight + 2 + 'px';
    }

    lastLength = currentLength;
    lastHeight = currentHeight;
});
```
原理是检测textarea.scrollHeight属性变化，并随之设置textarea的高度。

参考：https://juejin.im/post/5b7653bde51d454dba70c0b1?utm_source=gold_browser_extension

### setTimeout(fun, 0)
``` js
setTimeout(function () {
    func1();
}, 0)
func2();
```
func1和func2谁会先执行？很明显func2先执行；
setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f,0)，那么会立刻执行吗？
答案是不会。因为setTimeout运行机制说过，**必须要等到当前脚本的同步任务和“任务队列”中已有的事件，全部处理完以后，才会执行setTimeout指定的任务**。也就是说，setTimeout的真正作用是，在“任务队列”的现有事件的后面再添加一个事件，规定在指定时间执行某段代码。setTimeout添加的事件，会在下一次Event Loop执行。
setTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务——**脚本的同步任务和“任务队列”中已有的事件**，一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。
``` js
setTimeout(function() {
  console.log("Timeout");
}, 0);

function a(x) {
  console.log("a() 开始运行");
  b(x);
  console.log("a() 结束运行");
}

function b(y) {
  console.log("b() 开始运行");
  console.log("传入的值为" + y);
  console.log("b() 结束运行");
}

console.log("当前任务开始");
a(42);
console.log("当前任务结束");

// 当前任务开始
// a() 开始运行
// b() 开始运行
// 传入的值为42
// b() 结束运行
// a() 结束运行
// 当前任务结束
// Timeout
```
上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。
0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，**最少是4毫秒**。如果小于这个值，会被自动增加到4。这是为了防止多个setTimeout(f,0)语句连续执行，造成性能问题。
利用`setTimeout(func, 0)`可以帮助我们：
- 调整函数运行顺序
- 分割耗时任务

### 0.5px边框
``` css
 .scale-1px {
    position: relative;
    margin-bottom: 20px;
    border:none;
}
.scale-1px:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    border: 1px solid #000;
    box-sizing: border-box;
    width: 200%;
    height: 200%;
    transform: scale(0.5);
    transform-origin: left top;
}
```

### ios系统上active不生效问题
在iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。
可以采用下面两种方式解决：
``` js
  document.addEventListener("touchstart", function() {}, false);
```

``` html
<body ontouchstart="">
</body>
```

### beforeunload事件
兼容问题：为了优化用户体验，新式浏览器会要求有交互才会触发beforeunload事件，例如新版本的chrome浏览器。
PS: 从Firefox 4、 Chrome 51、Opera 38 和Safari 9.1开始，通用确认信息代替事件返回的字符串，即无法通过下面的方式自定义文案。
``` js
window.onbeforeunload = function (e) {
  e = e || window.event;

  // 兼容IE8和Firefox 4之前的版本
  if (e) {
    e.returnValue = '关闭提示';
  }

  // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+
  return '关闭提示';
};
```
HTML5规范中指出，在该事件中调用window.alert(), window.confirm(), 和 window.prompt()，会被忽略。详细的可参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/onbeforeunload)。
