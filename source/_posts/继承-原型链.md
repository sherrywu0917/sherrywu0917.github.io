---
title: 继承&原型链
date: 2018-04-10 17:14:43
tags: [继承, 原型链]
---
# 基于__proto__和prototype的原型链
关于`__proto__`属性，MDN上的解释如下：
> The __proto__ property of Object.prototype is an accessor property (a getter function and a setter function) that exposes the internal [[Prototype]] (either an object or null) of the object through which it is accessed.

即是说，`__proto__` 属性指向了实例对象的原型Constructor.prototype。

首先用一张图来总结`__proto__`和`prototype`的关系：
<img src="/image/jsobj_full.jpg" width="600px">

<!-- more -->

## 实例的`__proto__`
``` js
function Foo() {}
var f1 = new Foo();
f1.__proto__ == Foo.prototype; //true
```
通过new方法创建函数Foo的实例f1，`f1.__proto__`会指向`Foo.prototype`，进而继承Foo函数原型上的所有属性和方法。
在JS中，只有函数有`prototype`属性，基于`prototype`可以去模拟实现类和继承。

### 函数原型和构造器
``` js
f1.constructor === Foo.prototype.constructor; //true
Foo.prototype.constructor === Foo; //true
f1.constructor === Foo; //true
```
f1是Foo的示例，它的`constructor`就是Foo函数原型对象中的`constructor`，而Foo函数原型上的`constructor`就指向函数本身。


## 对象的`__proto__`
``` js
var one = {x: 1};
var two = new Object();
one.__proto__ === Object.prototype // true
two.__proto__ === Object.prototype // true
one.toString === one.__proto__.toString // true
```
不管是隐式还是显式创建的对象，对象的`__proto__`都是`Object.prototype`，Object实际上是一个js函数`function Object(){}`，所以拥有`prototype`属性。`two = new Object()`中Object是构造函数，所以`two.__proto__`就是`Object.prototype`。至于one，ES规范定义对象字面量的原型就是`Object.prototype`。
``` js
one.constructor === Object.prototype.constructor;
Object.prototype.constructor === Object;
one.constructor === Object;
```

## 函数的`__proto__`
``` js
Foo.constructor === Function; //true
Foo.__proto__ === Function.prototype; // true
```
函数Foo的构造函数是`function Function(){}`，所以函数Foo的`__proto__`都指向`Function.prototype`。
``` js
Function.__proto__ === Function.prototype; // true
Array.__proto__ === Function.prototype; // true
Object.__proto__ === Function.prototype; // true
String.__proto__ === Function.prototype; // true
```
而**Function本身就是函数，所以`Function.__proto__`就是`Function.prototype`，二者为同一对象**。同理，`Object/Array/String`等等构造函数本质上和Function一样，均继承于`Function.prototype`。

## Function.prototype的`__proto__`
`Function.prototype`直接继承自`Object.prototype`，`Function.prototype.__proto__`就是`Object.prototype`，二者为同一对象。
``` js
    Function.prototype.__proto__ === Object.prototype; //true
    Function.prototype instanceof Object; //true
    Function.prototype instanceof Function; //false
```
通过这点我们可以弄清**继承的原型链：Object.prototype--->Function.prototype--->Function|Object|Array...。**。
综上所述可以得出：
``` js
    Function.__proto__.__proto__ === Object.prototype;
```
所以Function是Object的实例
``` js
    Function instanceof Object; //true
```
此外Object作为函数，继承了`Function.prototype`的方法，所以Object又是Function的实例。
``` js
    Object.__proto__ === Function.prototype;
    Object instanceof Function; //true
```
哈哈，二者互为实例，这就是有名的**鸡生蛋和蛋生鸡**的关系。


## Object.prototype的`__proto__`
原型链的尽头（root）是Object.prototype。所有对象均从Object.prototype继承属性。
``` js
Object.prototype.__proto__ === null; //true
```

REFS:
> [从`__proto__`和prototype来深入理解JS对象和原型链](https://github.com/creeperyang/blog/issues/9)
> [Javascript Object Layout](http://www.mollypages.org/tutorials/js.mp)

# es6继承
class通过extends实现继承，比起es5基于原型链、借用构造函数实现继承方便很多。
``` js
class A {
  constructor() {
    this.x = 1;
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  }
}

let b = new B();
```
上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。
这是由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。
- set的时候，super为this子类实例
- get的时候，super获取的是A.prototype

大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。
``` js
function test(){}
test.__proto__ = test.constructor.prototype
```

es6中extends实现的继承，同时有prototype属性和__proto__属性，因此同时存在两条继承链。
``` js
B.__proto__ === A
B.prototype.__proto__ === A.prototype
//对应es5实现
B.prototype = new A()
```
实现继承的关键：
- 子类B.prototype的`__proto__`属性指向A.prototype，即`B.prototype.__proto__ = A.prototype`，表示将继承父类原型上的属性和方法;
- 子类B的`__proto__`属性总是指向父类A，即`B.__proto__ = A`，表示将继承父类的静态属性和方法。

这样的结果是因为，类的继承是按照下面的模式实现的。
``` js
class A {}

class B {}

// B 的实例继承 A 的实例
Object.setPrototypeOf(B.prototype, A.prototype);

// B 继承 A 的静态属性
Object.setPrototypeOf(B, A);

const b = new B();
```

Object.setPrototypeOf方法的实现，会将proto对象作为obj的原型。
``` js
Object.setPrototypeOf = function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
```
本质上，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。
