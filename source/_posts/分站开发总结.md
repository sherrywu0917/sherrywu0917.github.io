---
title: 项目开发record
date: 2017-07-27 09:38:34
tags: [总结, react, webpack]
---
## 业务背景
1. 已有的阅读产品经过多年的发展，功能已经稳定，但整体用户体量不高、用户活跃度不够，且存在UV和收益下降的趋势，无法达到部门收益的KPI；短期内，无法找到新的增长点，是为了提高收益，达成部门的KPI，迫切需要扩展新的业务线。
2. 在当时公众号兴起繁荣的大环境下，渠道分销是一个很火的模式，公众号有着大量的用户流量，而我们可以提供海量的阅读资源，所以要解决的问题是如何通过公共号引流，所以我们期望有这样一个平台将资源和用户打通，可以给公众号的用户提供书籍阅读的功能，同时可以实现收益，最终实现和公众号平台的互利共生，这样公众号也乐于和我们合作，继而有一个累积的正向收益。
基于上面两点，我们计划开发渠道小说分站，分站的整体包括：
- toA的内部结算系统、书籍编辑器等
- toB的公众号平台
- toC的H5阅读分站

## 实现
###  前端目录结构
基于React + React-Router + Sass开发的webpack打包的多页面应用，其中正文页面和搜索页面是基于React-Router开发的单页面应用。路由类型采用的是BrowserRouter，在移动端pushState/replaceState没有兼容问题，可以放心使用。如果是要兼容IE9及以下，则不能使用BrowserRouter，建议使用HashRouter。此外，使用BrowserRouter后，可以借助history的特性帮助我们实现记录每个页面的历史停留位置。
#### BrowserRouter与HashRouter主要区别
- hashRouter不支持location.key 、location.state：刷新页面或者直接浏览器回退一步，再前进时，BrowserRouter的页面依然可以获取到state中的值，而在HashRouter页面中无法获取到state的值，因为HashRouter没有使用HTML5的History API，所以刷新路由后导致state值丢失。

```
|-- assets
  |
  |-- config //webpack编译
  |    |-- base.js //基础编译配置
  |    |-- dev.js  //开发环境编译配置
  |    |-- dll.js  //动态链接库编译配置
  |    |-- hot.js  //热替换编译配置
  |    |-- prod.js //开发环境编译配置
  |    |-- util.js //定义配置相关的通用方法和变量
  |
  |-- src                //源码目录
  |    |-- component        // 组件
  |    |      |-- common      //公共组件
  |    |      |--             //其他子组件
  |    |-- entry              //入口js，与静态html文件相对应
  |    |-- util               //通用方法
  |    |-- image            //图片资源
  |    |-- style            //样式
  |
  |-- template              //html模板，动态生成html文件
  |
  |-- mock.json      // mock数据
  |-- server_hot.js  //实现热更新、拦截并处理前端请求(返回本地页面、mock数据，其他请求转发到服务端处理)  
  |
|-- dist //构建目录
```
其中，模板中是静态html文件，在没有添加后端路由的情况下，通过server_hot.js中的页面映射去访问前端页面，例如当匹配到路径/index时，返回index.html页面，结合mock数据，真正实现了前后端分离。
``` javascript
let templateMap = {
    '/search': 'search.html',
    '/search/book': 'search.html',
    '/index': 'index.html',
    '/history': 'history.html',
    '/rank': 'rank.html',
    '/home/more': 'more.html',
    '/category': 'category.html',
    '/info': 'info.html',
    '/detail': 'detail.html',
    '/book/reader': 'reader.html',
    '/recharge': 'recharge.html',
    '/catalog': 'catalog.html'
}

for (let mapItem in templateMap) {
    app.get(mapItem, function(req, res) {
        res.sendFile(__dirname + '/template/' + templateMap[mapItem]);
    });
}
```

#### API转发后获取服务端数据失败的问题
在使用http-proxy-middleware转发请求到后端时，发现有部分请求无法获得返回数据，首先可以确定的是请求被转发到后端了。调试发现后端会验证站点相关信息，在验证host的时候报错。猜测可能是请求转发后header里的host信息丢失，查询[API](https://www.npmjs.com/package/http-proxy-middleware#http-proxy-middleware-options)发现可以设置option.headers，如下所示。
``` javascript
var proxyMiddleware = require('http-proxy-middleware');
var apiProxy = proxyMiddleware('/api', { target: 'http://ypxst.kuxuanbook.yuedu.163.com', headers: {host: 'ypxst.kuxuanbook.yuedu.163.com'}});
```
设置好host后，就可以正常获取接口返回数据了。

#### POST请求验证XSRF-TOKEN
之前阅读常用的方式是后端写入freemarker模板或者通过异步接口获得，这次和后端约定统一放在cookie中。
``` javascript
 headers: {
     'Content-Type': 'application/x-www-form-urlencoded',
     'X-XSRF-TOKEN': csrf_token
 }
```
从cookie中读取token后封装在post接口中，写在headers里面，这样在使用的时候就直接调用post方法，无需关注token验证。

#### 使用git subtree同步assets工程
assets资源存在于novel-webapp-wap和novel-webapp-recharge两个工程下面，recharge工程下面用到的是充值页面，其他页面都在wap工程下，之所以分开为两个工程是因为涉及到支付，充值的域名需要是唯一的，而分站的域名很多。为了保证二者资源的同步，可以使用git subtree实现子工程的同步。
``` bash
# 获取远端novel-webapp-assets的更新
git subtree pull --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash

# 将本地assets更新推送到远端novel-webapp-assets
git subtree push --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash
```
<!-- more -->
#### webpack替换文件链接的资源
通过给chunk filename添加[chunkhash]去有效地缓存文件，每次修改后生成新的chunkhash值，手动替换很麻烦，所以结合done plugin去完成html文件中资源名字的自动替换。
stats记录了打包信息和相应的chunkhash值，其中assetsByChunkName包含了以chunkname作为key，filename作为值的对象，结构如下：
``` json
  "assetsByChunkName": {
    "reader": [
      "js/reader-60b54d52.js",
      "css/reader-60b54d52.css"
    ],
    //...
    "common": [
      "js/common-a814792a.bundle.js",
      "css/common-a814792a.css"
    ]
  }
```
遍历stats对象中的entrypoints，这里的entrypoints的key值和html文件名一致、且一一对应的，根据key值读取可以读取对应的html文件，通过正则匹配的方式将对应的js、css文件替换为本次打包生成的文件。
``` javascript
function () {
    this.plugin('done', function (stats) {
       for(var key in stats.toJson().entrypoints) {
          var htmlPath = path.join(ROOT_PATH, 'template', key + '.html');
          var htmlContent = fs.readFileSync(htmlPath, 'utf8');
          var keyJSRegExp = new RegExp('js\/' + key + '(.*?)\.js');
          var keyCSSRegExp = new RegExp('css\/' + key + '(.*?)\.css');
          var keyAssets = [].concat(stats.toJson().assetsByChunkName[key]);
          var commonAssets = [].concat(stats.toJson().assetsByChunkName['common']);
          var htmlOutput = '';
          var keyJS = keyAssets.filter(path => path.endsWith('.js'))[0];
          var keyCSS = keyAssets.filter(path => path.endsWith('.css'))[0];
          if(keyJS) {
               htmlOutput = htmlContent.replace(keyJSRegExp, keyJS);
          }
          if(keyCSS) {
               htmlOutput = htmlOutput.replace(keyCSSRegExp, keyCSS);
          }
          var commonJS = commonAssets.filter(path => path.endsWith('.js'))[0];
          var commonCSS = commonAssets.filter(path => path.endsWith('.css'))[0];
          if(commonJS) {
               htmlOutput = htmlOutput.replace(/js\/common(.*?)\.js/g, commonJS);
          }
          if(commonCSS) {
               htmlOutput = htmlOutput.replace(/css\/common(.*?)\.css/g, commonCSS);
          }
          fs.writeFileSync(htmlPath, htmlOutput);
       }
    });
}
```

**Refs:**
[LOADING WEBPACK BUNDLES WITH HASH VALUE](http://www.weicon9.com/2016/11/Loading-Webpack-Bundles-With-Hash-Value/)


### polyfill引入方式比较
babel-core/babel-preset-*等插件可以将语法从 es6 转成 es5，但没有提供 api 的转码功能，如 Promise、Set、Map 等新增对象，Object.assign、Object.entries 等全局对象上的新增方法都不会转码， babel-runtime 和 babel-polyfill 就是为此而生。这两个模块功能几乎相同，就是转码新增 api，模拟 es6 环境，但实现方法完全不同。

#### babel-polyfill库
babel-polyfill 的做法是将全局对象通通污染一遍，比如相应使用includes方法，会通过Array.prototype.includes() 的方式去注入污染原型。对于普通的业务代码没有关系，如果不在意略大的体积（min后86kb），推荐使用；但如果用在开发library，则不推荐使用，会污染该library使用者的环境。

#### babel-runtime库和babel-plugin-transform-runtime 插件
babel-runtime 的做法是自己手动引入 helper 函数，const Promise = require('babel-runtime/core-js/promise') 就可以引入 Promise，但是很不方便。
借助babel-plugin-transform-runtime插件，可以帮助我们按需加载polyfill，这个模块会将我们的代码重写，如将 Promise 重写成 _Promise（只是打比方），然后引入_Promise helper 函数。此外，babel-runtime 不能转码实例方法，比如这样的代码：
``` javascript
'!!!'.repeat(3);
'hello'.includes('h');
```
这只能通过 babel-polyfill 来转码，因为 babel-polyfill 是直接在原型链上增加方法。

如果在开发library，为了避免污染使用者的环境，只能用 babel-runtime + babel-plugin-transform-runtime。虽然是业务开发，但是因为移动端比较介意babel-polyfill的体积，所以我还是选择了babel-runtime。


#####  .babelrc中的相关配置
``` json
{
    "plugins": [
        ["transform-runtime", {
            "helper": false,  //开启helper后，统一引用了helper
            "polyfill": true,  //Map, Set, Promise,Object.assign等
            "regenerator": true, //主要是实现generator/yeild，async/await
            "moduleName": "babel-runtime"
        }]
    ]
}
```
`helper`设为true时，会引入一些 helper 来代替每次都生成的通用函数，原来构建好的代码每个模块都有类似这种代码：
``` javascript
    function _classCallCheck(instance, Constructor)...
    function _possibleConstructorReturn(self, call)...
    function _inherits(subClass, superClass)...
```
`开启helper后`
``` javascript
  var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');
  var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');
  var _inherits2 = require('babel-runtime/helpers/inherits');
```
在v6.12.0 (2016-07-27) 后增加了 helper 的配置，原因是从 babel-runtime 里引入的 helper 依赖很多，全部都是兼容最底层的。比如 Object.create typeof 这种方法全部被重写了，会导致构建模块变大。
`开启polyfill后`，Object.assign方法会被改写为`__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()`。
`regenerator设为true`，使我们可以使用generator/yeild，async/await。如果你只需要用 regenerator，不需要 core-js 里面的 polyfill 那你就可以在 options 中把 polyfill 设为 false。

#### babel-preset-env插件
> 版本支持：babel 7.0beta版、babel-loader 8.0 beta版和babel-preset-env 2.0beta版
```bash
npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env  --save-dev
```
首先需要安装babel-polyfill
``` bash
npm install @babel/polyfill --save
```
配置"useBuiltIns": 
- false: 不对polyfills做任何操作
- entry: 根据target中浏览器版本的支持，将polyfills拆分引入，仅引入有浏览器不支持的polyfill，通过`import 'babel-polyfill'`方式在代码中一次性引入
- usage(新)：检测代码中ES6/7/8等的使用情况，仅仅加载代码中用到的polyfills

这种方式配置非常方便，并且可以按需加载，后续会替换成该插件。

**Refs:**
[babel-preset-env](https://github.com/babel/babel/tree/master/experimental/babel-preset-env)
[按需加载polyfill——babel7的正确打开方式](https://erasermeng.github.io/2017/11/02/%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BDpolyfill%E2%80%94%E2%80%94babel7%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/)
[ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍](http://blog.csdn.net/a324539017/article/details/52824189)
[再见，babel-preset-2015](https://zhuanlan.zhihu.com/p/29506685)

### 记录正文页历史滚动位置
在开发过程中，发现每次返回到历史页面时，都不是上次访问到的页面位置，而是重置到了顶部，react并没有去维护历史页面的滚动位置。所以我们需要手动去记录页面的历史滚动位置。
##### 可能的方案
1.  使用window的onpopstate、onload、onunload事件监听页面的前进、返回，利用command模式维护posUndoStack和posRedoStack栈，记录并保存页面的历史位置
  问题：结合了history.length去判断页面是前进、返回or新进了一个页面，但是当从b页面返回到a页面后，又点击进入了b页面后，history.length不变，链接不变，这个时候无法辨别浏览器的行为
2. [react-router-scroll组件](http://npm.taobao.org/package/react-router-scroll)
   问题：基于react-router，基于router middleware实现的，使用的Router V4没有中间件的概念
3. 基于history.location.key属性的实现
  问题：基于react-router

##### 最终方案
由于目前没有好的办法去记录所有页面的位置，而记录正文页阅读位置的需求最为必要，所以使用第三个方案，暂时忽略其他页面。使用BrowserRouter的页面支持location.key属性，这个location是react-router引用的history库中的location对象，每个页面有唯一标识的key值。

> React-router官网: 使用 hash 的方式记录导航历史不支持 location.key，在以前的版本中，我们为这种行为提供了shim，但是仍有一些问题我们无法解决。

react-router使用的history库在createBrowserHistory时，会调用createKey方法创建页面的key值，key的长度默认为6，可以设置。
``` javascript
  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };
```
createBrowserHistory类中维护了一个数组allkeys，里面记录了所有页面的location.key。
``` javascript
var allKeys = [initialLocation.key];
```
在SPA中的每个页面的history的state中则记录了该页面的key。
``` javascript
globalHistory.pushState({ key: key, state: state }, null, href);
```
在监听到popState事件后，会通过event拿到进入页面的state，里面记录了key值。
``` javascript
window.onpopstate = function(event) {
  alert(state: " + JSON.stringify(event.state));
};
```
所以在页面返回、前进的时候，同一页面的location.key不变，据此可以在页面离开的时候，用key-value的形式保存当前key值和对应的滚动位置在sessionStorage中。页面离开的情况有：
``` javascript
//SPA页面内路由到其他章节
componentWillReceiveProps(nextProps) {
    posReserve.onLeave(this.props.location.key);
}
//页面unload
window.onunload = () => {
    posReserve.onLeave(this.props.location.key);
}
```
在页面前进、返回的时候，去sessionStorage中读取历史位置，并滚动页面到对应位置。


### ios微信中SPA正文页返回问题
#### 问题1：正文内部返回白屏
在IOS微信浏览器中阅读正文，返回上一章的时候期望显示上一章内容，但是会出现白屏的问题，需要上滑或者下滑页面，正文才会出现。
在寻找解决方案的时候，发现Vue存在相似的问题：
  [iOS Safari renders blank page](https://github.com/vuejs/vue/issues/5533)
  [ios 组件点返回白屏遮挡问题](https://github.com/ElemeFE/mint-ui/issues/937)
参考了其中的解决方案，在正文内容加载完成后通过js去触发scroll滚动，正文显示就恢复正常了。代码如下所示，尝试了下面两种方式，都可以解决问题。
``` javascript
    componentDidMount() {
        window.scrollTo(0, 1)
        window.scrollTo(0, 0)
        //或者
        setTimeout(() => {
          window.scrollTo(0, 0)
        }, 100)
    }
```

#### 问题2: 从其他页面返回正文问题
使用`Preact`的时候，从其他页面返回到正文页后，部分请求没有发出。
在debug的时候发现正文页setState没有触发componentWillUpdate，不会rerender，setState的callback不被执行。当从Preact替换为React的时候，页面显示正常。
- 猜测1: 可能和preact的diff机制有关。因为'对一个虚拟DOM子树是否继续更新下去，如果它们的type, props,key都一样，或者它们的引用也一样，可能也会继续diff，官方还会比较context!!!!这个许多react-like没有考虑到。`React-Router就非常依赖context对象进行多层的组件间传递`'。
- 猜测2: setState回调延后
知乎问答‘[如何看待 React 的替代框架 Preact](https://www.zhihu.com/question/65479147/answer/231505912?utm_source=wechat_session&utm_medium=social&utm_campaign=ge13_2&utm_division=ge13_3)’中蓝面小生和司徒正美的回答中列出了Preact存在的一些问题。

##### 解决方案
如果继续使用Preact可以通过reload页面解决问题，当从正文页跳转到其他页面时候，记录下当前页面的`location.key`在sessionStorage中，返回页面时在componentWillMount方法中判断当前key值是否存储在'N_reader_locKeys'，若存在，则说明是页面返回，reload页面，并且从'N_reader_locKeys'中删掉对应的key值。
``` javascript
    componentWillMount() {
        let _key = this.props.location.key;
        let locKeys = sessionStorage.getItem('N_reader_locKeys');
        if(isIos && _key && locKeys){
            sessionStorage.removeItem('N_reader_locKey')
            let index = locKeys.indexOf(_key);
            if(~index && this.props.history.action === 'POP') {
                sessionStorage.setItem('N_reader_locKeys', locKeys.slice(0, index) + locKeys.slice(index + _key.length + 1));
                location.reload();
                return false;
            }
        }
    }

    //[IOS微信返回bug处理]记录所有点击跳到其他页面(结合href和isexternal值)
    bindEvent() {
        document.addEventListener('click', e => {
            let targetEle = e.target;
            if(targetEle.tagName.toLowerCase() === 'a') {
                if(targetEle.href.indexOf('.do') !== -1 || (targetEle.getAttribute('isexternal') === 'true')) {
                    e.preventDefault();
                    let _key = this.props.location.key;
                    let keys = sessionStorage.getItem('N_reader_locKeys') || '';
                    if(_key && keys.indexOf(_key) === -1) {
                        keys += _key + ','
                        sessionStorage.setItem('N_reader_locKeys', keys);
                    }
                    if(targetEle.href.indexOf('.do') !== -1) {
                        location.href = targetEle.href;
                    }
                }
            }
        })
    }
```
鉴于在某ios9版本的iphone5s上正常打开正文一直会出现上述问题，且考虑逻辑的复杂性、未来的需求扩展，最终还是**`使用React替换了Preact`**。逻辑越复杂，Preact暴露的问题越多。

#### 问题3：微信url地址问题
在IOS微信中，使用history的replaceState、pushState，url栏不变，分享或者通过浏览器打开都还是之前的url。
##### 详情
从首页进入正文，通常只带sourceUuid不带articleUuid，在加载当前章节的时候期望通过history.replaceState去更新当前url为带articleUuid，这样当从下一章返回的时候，可以正确显示当前内容，不然会自动获取当前进度，无法显示正确章节。安卓可以正常返回，但ios微信返回的时候url还是不带articleUuid。
##### 解决方案
原因是使用H5的history API并不能改变url栏地址内容，分享或通过浏览器打开都是旧的地址，是ios微信的一个bug。改用react-router的history.replace去更新章节可以解决返回问题。
原理是虽然地址栏不变，但通过location.href获得的是正确的地址，BrowserRouter单页面应用在切换页面的时候会从window.location中读取`{pathname,search,hash}`，创建自己的location对象，依据location对象去渲染页面。

**Refs: **
[H5 history.pushState 在微信内修改url后点击用safari打开/复制链接是修改之前的页面](https://github.com/Tencent/weui/issues/125)


### lib.flexible方案
使用淘宝`lib.flexible`的rem方案，会遇到一个**问题**：在ios微信内长按扫描二维码，会有无法识别二维码的问题。[微信已修复该问题]
> [微信识别二维码的原理机制](http://mp.weixin.qq.com/s?__biz=NzA3OTQ2OTgw&mid=205918916&idx=1&sn=d729ef70ea1e7fc50e649352a63a2564&scene=1&key=c76941211a49ab586ba4831f2f6fa42fbb2525460003fa8e19bc205b9b25facbf60da78977da071ddbc41a5be6a7b9fa&ascene=0&uin=NTE3ODg0NjE1&devicetype=iMac%20MacBookPro12,1%20OSX%20OSX%2010.10.3%20build%2814D136%29&version=11020012&pass_ticket=WPa8XnvIzBrBOA6RHy2RMECcrsuN2QiksK8Y1Z/D3Odk49uIsXOex7EV2NXN9m5X)
> 这里采用的逻辑是截屏识别，当客户端发现用户在网页的img标签内进行长按操作时，会立刻截屏并且启动二维码识别算法。所以这里用于二维码识别的图片是截屏，而不是之前有人提到的img标签中的图片。

实践发现meta scale指定为1的时候，无该问题。`问题产生的原因`应该是：在iOS下，对于dpr(设备像素比)2和3的屏，用2倍和3倍的方案，其余的用1倍方案。使用高清屏方案后，viewport的scale值会设为1/dpr，页面发生了缩放，二维码的位置实际发生了偏移，因而微信无法准确识别出二维码。
设备像素比 = 物理像素 / 设备独立像素；
- 物理像素：一个物理像素是显示器(手机屏幕)上最小的物理显示单元；
- 设备独立像素：设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。
在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。 在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。

为了解决二维码识别问题，在html中手动添加viewport的meta标签，这样页面就会根据已有的meta标签设置缩放比例，不会使用高清方案。不使用高清方案一个不好的地方是1px边框问题，不过可以通过伪元素搭配transform:scale(0.5)解决。
``` javascript
    var metaEl = doc.querySelector('meta[name="viewport"]');
    if (metaEl) {
        console.warn('将根据已有的meta标签来设置缩放比例');
        var match = metaEl.getAttribute('content').match(/initial\-scale=([\d\.]+)/);
        if (match) {
            scale = parseFloat(match[1]);
            dpr = parseInt(1 / scale);
        }
    }
```
``` css
.method-list:after{
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 200%;
    height: 200%;
    border-bottom: 1px solid #E1E1E1;
    -webkit-transform: scale(0.5);
    transform: scale(0.5);
    -webkit-transform-origin: 0 0;
    transform-origin: 0 0;
    box-sizing: border-box;;
}
```
