---
title: 组合式继承
date: 2018-04-10 17:14:43
tags: [继承, 组合式继承]
---

## 组合式继承
``` js
function SuperType(name) {
    this.name = name;
    this.colors = ['pink', 'blue', 'green'];
}

function SuberType(name, age) {
    // 借用父类构造函数
    SuperType.call(this, name); 
    this.age = age;
}
SuberType.prototype = new SuperType();
SuberType.prototype.constructor = SuberType;

var obj = new SuberType();
```
缺点：
- 调用了两次父类构造函数
- 所有子类对象的原型共用一个父类实例

## 寄生组合式继承
``` js
function inheritPrototype(subType, superType) {
    // 创建一个对象的__proto__指向superType.prototype
    var objProto = Object.create(superType.prototype);
    // var prototype = {};
    // Object.setPrototypeOf(prototype, superType.prototype);
    // subType.prototype = prototype;
    objProto.constructor = subType // constructor是在原型上的
    subType.prototype = objProto;
}

function SuperType(name) {
    this.name = name;
    this.colors = ['pink', 'blue', 'green'];
}

function SuberType(name, age) {
    // 借用父类构造函数
    SuperType.call(this, name); 
    this.age = age;
}
inheritPrototype(SuberType, SuperType);

var obj = new SuberType();
```
- 父类原型上属性的变化还是会影响子类，因为子类prototype对象的__proto__指向父类的prototype对象

### Object.create polyfill
``` js
if (typeof Object.create !== "function") {
    Object.create = function (proto, propertiesObject) {
        if (typeof proto !== 'object' && typeof proto !== 'function') {
            throw new TypeError('Object prototype may only be an Object: ' + proto);
        } else if (proto === null) {
            throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");
        }

        if (typeof propertiesObject !== 'undefined') throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");

        function F() {}
        F.prototype = proto;

        return new F();
    };
}
```

## es6 class extends的原理
``` js
/**
 * es6 class转es5的实现
 * 寄生组合式继承V2: 更接近class的实现，因为class内部的所有方法都是不可枚举的，包括constructor方法
 */
var _inherits = (suberCls, superCls) => {
    var objProto = Object.create(superCls.prototype, {
        constructor: {
            value: suberCls,
            enumerable: false,
            configurable: true,
            writable: true
        }
    });
    suberCls.prototype = objProto;
    // 相比普通的prototype实现的继承，class的extends属性实现的继承还会处理suberCls的内置[[prototype]]属性，将其与superCls关联起来
    if (superCls) Object.setPrototypeOf ? Object.setPrototypeOf(suberCls, superCls) : suberCls.__proto__ = superCls;
}
```
### 简单对比下
1. prototype组合式继承
``` js
function A() {}
function B() {}
B.prototype = new A();
B.prototype.constructor = B;

Object.getPrototypeOf(B); // 输出"ƒ () { [native code] }"，即为Function.prototype
Object.getPrototypeOf(B) === Function.prototype; // true
```
2. extends实现的继承
``` js
class C{}
class D extends C{}

Object.getPrototypeOf(D); // 输出"class C{}"，即为C
Object.getPrototypeOf(D) === C; // true
```
总结下，传统prototype组合式继承实现的子类B，它的__proto__(内置[[prototype]])属性指向Function.prototype，这个很好理解，因为每个function对象都是通过new Function的形式创建的；而extends实现的子类D，按照约定，它的__proto__(内置[[prototype]])属性父类C。

## super原理
实例化对象的时候，通过super方法会先调用父类的constructor方法，父类的constructor方法中用的this为子类实例的this；如果父类的constructor返回了一个对象的话，执行完super(props)之后，子类中的this会被赋值为该返回对象。
ps: 通过new.target可以判断当前是否通过new指令去调用
