[{"title":"","date":"2024-02-19T04:51:45.058Z","path":"2024/02/19/继承/","text":"组合式继承1234567891011121314function SuperType(name) &#123; this.name = name; this.colors = ['pink', 'blue', 'green'];&#125;function SuberType(name, age) &#123; // 借用父类构造函数 SuperType.call(this, name); this.age = age;&#125;SuberType.prototype = new SuperType();SuberType.prototype.constructor = SuberType;var obj = new SuberType(); 缺点： 调用了两次父类构造函数 所有子类对象的原型共用一个父类实例 寄生组合式继承1234567891011121314151617181920212223function inheritPrototype(subType, superType) &#123; // 创建一个对象的__proto__指向superType.prototype var objProto = Object.create(superType.prototype); // var prototype = &#123;&#125;; // Object.setPrototypeOf(prototype, superType.prototype); // subType.prototype = prototype; objProto.constructor = subType // constructor是在原型上的 subType.prototype = objProto;&#125;function SuperType(name) &#123; this.name = name; this.colors = ['pink', 'blue', 'green'];&#125;function SuberType(name, age) &#123; // 借用父类构造函数 SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SuberType, SuperType);var obj = new SuberType(); 父类原型上属性的变化还是会影响子类，因为子类prototype对象的proto指向父类的prototype对象 Object.create polyfill12345678910111213141516if (typeof Object.create !== \"function\") &#123; Object.create = function (proto, propertiesObject) &#123; if (typeof proto !== 'object' &amp;&amp; typeof proto !== 'function') &#123; throw new TypeError('Object prototype may only be an Object: ' + proto); &#125; else if (proto === null) &#123; throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\"); &#125; if (typeof propertiesObject !== 'undefined') throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support a second argument.\"); function F() &#123;&#125; F.prototype = proto; return new F(); &#125;;&#125; es6 class extends的原理1234567891011121314151617/** * es6 class转es5的实现 * 寄生组合式继承V2: 更接近class的实现，因为class内部的所有方法都是不可枚举的，包括constructor方法 */var _inherits = (suberCls, superCls) =&gt; &#123; var objProto = Object.create(superCls.prototype, &#123; constructor: &#123; value: suberCls, enumerable: false, configurable: true, writable: true &#125; &#125;); suberCls.prototype = objProto; // 相比普通的prototype实现的继承，class的extends属性实现的继承还会处理suberCls的内置[[prototype]]属性，将其与superCls关联起来 if (superCls) Object.setPrototypeOf ? Object.setPrototypeOf(suberCls, superCls) : suberCls.__proto__ = superCls;&#125; 简单对比下 prototype组合式继承 1234567function A() &#123;&#125;function B() &#123;&#125;B.prototype = new A();B.prototype.constructor = B;Object.getPrototypeOf(B); // 输出\"ƒ () &#123; [native code] &#125;\"，即为Function.prototypeObject.getPrototypeOf(B) === Function.prototype; // true extends实现的继承 12345class C&#123;&#125;class D extends C&#123;&#125;Object.getPrototypeOf(D); // 输出\"class C&#123;&#125;\"，即为CObject.getPrototypeOf(D) === C; // true 总结下，传统prototype组合式继承实现的子类B，它的proto(内置[[prototype]])属性指向Function.prototype，这个很好理解，因为每个function对象都是通过new Function的形式创建的；而extends实现的子类D，按照约定，它的proto(内置[[prototype]])属性父类C。 super原理实例化对象的时候，通过super方法会先调用父类的constructor方法，父类的constructor方法中用的this为子类实例的this；如果父类的constructor返回了一个对象的话，执行完super(props)之后，子类中的this会被赋值为该返回对象。ps: 通过new.target可以判断当前是否通过new指令去调用","tags":[]},{"title":"rrweb带你还原问题现场","date":"2024-02-19T04:51:45.054Z","path":"2024/02/19/rrweb原理&录屏上报实践/","text":"本文作者：吴硕硕 背景云音乐内部有许多内容管理系统 (Content Management System，CMS)，用来支撑业务的运营配置等工作，运营同学在使用过程中遇到问题时，期望开发人员可以及时给予反馈并解决问题；痛点是开发人员没有问题现场，很难去快速定位到问题，通常的场景是： 运营同学 Watson：「Sherlock，我在配置 mlog 标签的时候提示该标签不存在，快帮我看下，急。」 开发同学 Sherlock：「不慌，我看看。」（打开测试环境的运营管理后台，一顿操作，一切非常的正常…） 开发同学 Sherlock：「我这儿正常的啊，你的工位在哪，我去你那看看」 运营同学 Watson：「我在北京…」 开发同学 Sherlock：「我在杭州…」 为了对运营同学在使用中遇到的相关问题及时给予反馈，尽快定位并解决 CMS 用户遇到的使用问题，设计实现了问题一键上报插件，用于还原问题现场，主要包括录制和展示两部分： ThemisRecord 插件：上报用户 uid、用户权限、API 请求 &amp; 结果、错误堆栈、录屏 倾听平台承接展示：显示录屏回放、用户、请求和错误堆栈信息 上报流程问题一键上报插件设计的主要流程如下图所示，在录屏期间，插件需要分别收集用户基础信息、API 请求数据、错误堆栈信息和录屏信息，并将数据上传到 NOS 云端和倾听平台。在整个上报的流程中，如何实现操作录屏和回放是一个难点，经过调研，发现 rrweb 开源库可以很好的满足我们的需求。本文主要介绍的是 rrweb 库的录屏回放实现原理。 rrweb 库rrweb 主要由 rrweb 、 rrweb-player 和 rrweb-snapshot 三个库组成： rrweb：提供了 record 和 replay 两个方法；record 方法用来记录页面上 DOM 的变化，replay 方法支持根据时间戳去还原 DOM 的变化。 rrweb-player：基于 svelte 模板实现，为 rrweb 提供了回放的 GUI 工具，支持暂停、倍速播放、拖拽时间轴等功能。内部调用了 rrweb 的提供的 replay 等方法。 rrweb-snapshot：包括 snapshot 和 rebuilding 两大特性，snapshot 用来序列化 DOM 和 DOM 的状态，rebuilding 负责将 snapshot 还原为 DOM。 了解 rrweb 库的原理，可以从下面几个关键问题入手： 如何实现事件监听 如何序列化 DOM 如何实现自定义计时器 如何实现事件监听基于 rrweb 去实现录屏，通常会使用下面的方式去记录 event，emit 必传，通过该方法可以拿到 DOM 变化对应所有 event。拿到 event 后，可以根据业务需求去做处理，例如我们的一键上报插件会上传到云端，开发者可以在倾听平台拉取云端的数据并回放。 12345678let events = [];rrweb.record(&#123; emit(event) &#123; // push event into the events array events.push(event); &#125;,&#125;); record 方法内部会根据事件类型去初始化事件的监听，例如 DOM 元素变化、鼠标移动、鼠标交互、滚动等都有各自专属的事件监听方法，本文主要关注的是 DOM 元素变化的监听和处理流程。要实现对 DOM 元素变化的监听，离不开浏览器提供的 MutationObserver API，该 API 会在一系列 DOM 变化后，通过批量异步的方式去触发回调，并将 DOM 变化通过 MutationRecord 数组传给回调方法。rrweb 内部也是基于该 API 去实现监听，回调方法为 MutationBuffer 类提供的 processMutations 方法： 123const observer = new MutationObserver( mutationBuffer.processMutations.bind(mutationBuffer),); mutationBuffer.processMutations 方法会根据 MutationRecord.type 值做不同的处理： type === &#39;attributes&#39;: 代表 DOM 属性变化，所有属性变化的节点会记录在 this.attributes 数组中，结构为 { node: Node, attributes: {} }，attributes 中仅记录本次变化涉及到的属性； type === &#39;characterData&#39;: 代表 characterData 节点变化，会记录在 this.texts 数组中，结构为 { node: Node, value: string }，value 为 characterData 节点的最新值； type === &#39;childList&#39;: 代表子节点树 childList 变化，比起前面两种类型，处理会较为复杂。 childList 增量快照childList 发生变化时，若每次都完整记录整个 DOM 树，数据会非常庞大，显然不是一个可行的方案，所以，rrweb 采用了增量快照的处理方式。有三个关键的 Set：addedSet、 movedSet、 droppedSet，对应三种节点操作：新增、移动、删除，这点和 React diff 机制相似。此处使用 Set 结构，实现了对 DOM 节点的去重处理。 节点新增遍历 MutationRecord.addedNodes 节点，将未被序列化的节点添加到 addedSet 中，并且若该节点存在于被删除集合 droppedSet 中，则从 droppedSet 中移除。 示例：创建节点 n1、n2，将 n2 append 在 n1 中，再将 n1 append 在 body 中。 body n1 n2 只会生成一条 MutationRecord 记录，即增加 n1，所以在遍历 MutationRecord.addedNodes 节点，也需要遍历其子节点，不然 n2 节点就会被遗漏。 遍历完所有 MutationRecord 记录数组，会统一对 addedSet 中的节点做序列化处理，每个节点序列化处理的结果是： 12345export type addedNodeMutation = &#123; parentId: number; nextId: number | null; node: serializedNodeWithId;&#125; 通过 parentId 和 nextId 建立起 DOM 的关联关系，所以若某节点的父节点、或下一个兄弟节点尚未被序列化，需要先将其存储下来，最后处理。这边使用了一个双向链表 addList 用来存储父节点尚未被添加的节点。 向 addList 中插入节点时： 若 DOM 节点的 previousSibling 已存在于链表中，则插入在 node.previousSibling 节点后 若 DOM 节点的 nextSibling 已存在于链表中，则插入在 node.nextSibling 节点前 都不在，则插入链表的头部 节点移动遍历 MutationRecord.addedNodes 节点，若记录的节点有 __sn 属性，则添加到 movedSet 中。有 __sn 属性代表是已经被序列化处理过的 DOM 节点，即意味着是对节点的移动。 在对 movedSet 中的节点序列化处理之前，会判断其父节点是否已被移除： 父节点被移除，则无需处理，跳过； 父节点未被移除，对该节点进行序列化。 节点删除遍历 MutationRecord.removedNodes 节点： 若该节点是本次新增节点，则忽略该节点，并且从 addedSet 中移除该节点，同时记录到 droppedSet 中，在处理新增节点的时候需要用到：虽然我们移除了该节点，但其子节点可能还存在于 addedSet 中，在处理 addedSet 节点时，会判断其祖先节点是否已被移除； 需要删除的节点记录在 this.removes 中，记录了 parentId 和节点 id。 如何序列化 DOMMutationBuffer 实例会调用 snapshot 的 serializeNodeWithId 方法对 DOM 节点进行序列化处理。serializeNodeWithId 内部调用 serializeNode 方法，根据 nodeType 对 Document、Doctype、Element、Text、CDATASection、Comment 等不同类型的 node 进行序列化处理，其中的关键是对 Element 的序列化处理: 遍历元素的 attributes 属性，并且调用 transformAttribute 方法将资源路径处理为绝对路径； 123for (const &#123; name, value &#125; of Array.from((n as HTMLElement).attributes)) &#123; attributes[name] = transformAttribute(doc, tagName, name, value);&#125; 通过检查元素是否包含 blockClass 类名，或是否匹配 blockSelector 选择器，去判断元素是否需要被隐藏；为了保证元素隐藏不会影响页面布局，会给返回一个同等宽高的空元素； 12345const needBlock = _isBlockedElement( n as HTMLElement, blockClass, blockSelector,); 区分外链 style 文件和内联 style，对 CSS 样式序列化，并对 css 样式中引用资源的相对路径转换为绝对路径；对于外链文件，通过 CSSStyleSheet 实例的 cssRules 读取所有的样式，拼接成一个字符串，放到 _cssText 属性中； 1234567891011121314151617if (tagName === 'link' &amp;&amp; inlineStylesheet) &#123; // document.styleSheets 获取所有的外链style const stylesheet = Array.from(doc.styleSheets).find((s) =&gt; &#123; return s.href === (n as HTMLLinkElement).href; &#125;); // 获取该条css文件对应的所有rule的字符串 const cssText = getCssRulesString(stylesheet as CSSStyleSheet); if (cssText) &#123; delete attributes.rel; delete attributes.href; // 将css文件中资源路径转换为绝对路径 attributes._cssText = absoluteToStylesheet( cssText, stylesheet!.href!, ); &#125;&#125; 对用户输入数据调用 maskInputValue 方法进行加密处理； 将 canvas 转换为 base64 图片保存，记录 media 当前播放的时间、元素的滚动位置等； 返回一个序列化后的对象 serializedNode，其中包含前面处理过的 attributes 属性，序列化的关键是每个节点都会有唯一的 id，其中 rootId 代表所属 document 的 id，帮助我们在回放的时候识别根节点。 123456789return &#123; type: NodeType.Element, tagName, attributes, childNodes: [], isSVG, needBlock, rootId,&#125;; Event 时间戳拿到序列化后的 DOM 节点，会统一调用wrapEvent方法给事件添加上时间戳，在回放的时候需要用到。123456function wrapEvent(e: event): eventWithTime &#123; return &#123; ...e, timestamp: Date.now(), &#125;;&#125; 序列化 idserializeNodeWithId 方法在序列化的时候会从 DOM 节点的 __sn.id 属性中读取 id，若不存在，就调用 genId 生成新的 id，并赋值给 __sn.id 属性，该 id 是用来唯一标识 DOM 节点，通过 id 建立起 id -&gt; DOM 的映射关系，帮助我们在回放的时候找到对应的 DOM 节点。 12345function genId(): number &#123; return _id++;&#125;const serializedNode = Object.assign(_serializedNode, &#123; id &#125;); 若 DOM 节点存在子节点，则会递归调用 serializeNodeWithId 方法，最后会返回一个下面这样的 tree 数据结构： 1234567891011121314151617&#123; type: NodeType.Document, childNodes: [&#123; &#123; type: NodeType.Element, tagName, attributes, childNodes: [&#123; //... &#125;], isSVG, needBlock, rootId, &#125; &#125;], rootId,&#125;; 如何实现自定义计时器回放的过程中为了支持进度条的随意拖拽，以及回放速度的设置，自定义实现了高精度计时器 Timer ，关键属性和方法为： 1234567891011121314export declare class Timer &#123; // 回放初始位置，对应进度条拖拽到的任意时间点 timeOffset: number; // 回放的速度 speed: number; // 回放Action队列 private actions; // 添加回放Action队列 addActions(actions: actionWithDelay[]): void; // 开始回放 start(): void; // 设置回放速度 setSpeed(speed: number): void;&#125; 回放入口通过 Replayer 提供的 play 方法可以将上文记录的事件在 iframe 中进行回放。 12const replayer = new rrweb.Replayer(events);replayer.play(); 第一步，初始化 rrweb.Replayer 实例时，会创建一个 iframe 作为承载事件回放的容器，再分别调用创建两个 service： createPlayerService 用于处理事件回放的逻辑，createSpeedService 用于控制回放的速度。 第二步，会调用 replayer.play() 方法，去触发 PLAY 事件类型，开始事件回放的处理流程。 123// this.service 为 createPlayerService 创建的回放控制service实例// timeOffset 值为鼠标拖拽后的时间偏移量this.service.send(&#123; type: 'PLAY', payload: &#123; timeOffset &#125; &#125;); 基线时间戳生成 回放支持随意拖拽的关键在于传入时间偏移量 timeOffset 参数： 回放的总时长 = events[n].timestamp - events[0].timestamp，n 为事件队列总长度减一； 时间轴的总时长为回放的总时长，鼠标拖拽的起始位置对应时间轴上的坐标为timeOffset； 根据初始事件的 timestamp 和 timeOffset 计算出拖拽后的 基线时间戳(baselineTime)； 再从所有的事件队列中根据事件的 timestamp 截取 基线时间戳(baselineTime) 后的事件队列，即需要回放的事件队列。 回放 Action 队列转换拿到事件队列后，需要遍历事件队列，根据事件类型转换为对应的回放 Action，并且添加到自定义计时器 Timer 的 Action 队列中。123456actions.push(&#123; doAction: () =&gt; &#123; castFn(); &#125;, delay: event.delay!,&#125;); doAction 为回放的时候要调用的方法，会根据不同的 EventType 去做回放处理，例如 DOM 元素的变化对应增量事件 EventType.IncrementalSnapshot。若是增量事件类型，回放 Action 会调用 applyIncremental 方法去应用增量快照，根据序列化后的节点数据构建出实际的 DOM 节点，为前面序列化 DOM 的反过程，并且添加到iframe容器中。 delay = event.timestamp - baselineTime，为当前事件的时间戳相对于基线时间戳的差值 requestAnimationFrame 定时回放Timer 自定义计时器是一个高精度计时器，主要是因为 start 方法内部使用了 requestAnimationFrame 去异步处理队列的定时回放；与浏览器原生的 setTimeout 和 setInterval 相比，requestAnimationFrame 不会被主线程任务阻塞，而执行 setTimeout 、 setInterval 都有可能会有被阻塞。 其次，使用了 performance.now() 时间函数去计算当前已播放时长；performance.now()会返回一个用浮点数表示的、精度高达微秒级的时间戳，精度高于其他可用的时间类函数，例如 Date.now()只能返回毫秒级别。 12345678910111213141516171819202122232425262728293031public start() &#123; this.timeOffset = 0; // performance.timing.navigationStart + performance.now() 约等于 Date.now() let lastTimestamp = performance.now(); // Action 队列 const &#123; actions &#125; = this; const self = this; function check() &#123; const time = performance.now(); // self.timeOffset为当前播放时长：已播放时长 * 播放速度(speed) 累加而来 // 之所以是累加，因为在播放的过程中，速度可能会更改多次 self.timeOffset += (time - lastTimestamp) * self.speed; lastTimestamp = time; // 遍历 Action 队列 while (actions.length) &#123; const action = actions[0]; // 差值是相对于`基线时间戳`的，当前已播放 &#123;timeOffset&#125;ms // 所以需要播放所有「差值 &lt;= 当前播放时长」的 action if (self.timeOffset &gt;= action.delay) &#123; actions.shift(); action.doAction(); &#125; else &#123; break; &#125; &#125; if (actions.length &gt; 0 || self.liveMode) &#123; self.raf = requestAnimationFrame(check); &#125; &#125; this.raf = requestAnimationFrame(check); &#125; 完成回放 Action 队列转换后，会调用 timer.start() 方法去按照正确的时间间隔依次执行回放，从头部开始遍历 Action 队列，若 Action 的差值小于当前的播放时长，则说明该 Action 需要会触发，需要调用 action.doAction 方法去实现本次增量快照的回放。 总结在了解了「如何实现事件监听」、「如何序列化 DOM」、「如何实现自定义计时器」这几个关键问题后，我们基本掌握了 rrweb 的工作流程，除此之外，rrweb 在回放的时候还使用的 iframe 的沙盒模式，去实现对一些 JS 行为的限制，感兴趣的同学可以进一步去了解。总之，基于 rrweb 可以方便地帮助我们开发定制化的录屏回放功能，例如现在在 CMS 业务中落地使用的一键上报功能，通过结合 API 请求、错误堆栈信息和录屏回放功能，可以帮助开发对问题进行定位并解决，让你也成为一个 Sherlock。 本文发布自 网易云音乐大前端团队，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe (at) corp.netease.com！","tags":[]},{"title":"","date":"2024-02-19T04:51:45.051Z","path":"2024/02/19/react相关问题V2/","text":"函数式组件和class组件的区别 函数式组件捕获了渲染所使用的值。 像调用函数一样，每次渲染的函数式组件有属于自己的变量，原理是闭包捕获了当前的props值; 在函数式组件中，你也可以拥有一个在所有的组件渲染帧中共享的可变变量，useRef(null); 函数式组件与类组件有何不同？ 相比class组件，可以自定义hooks，在不同组件间共享逻辑 复用逻辑，但内部的state和effects是完全隔离的 组件内的每一个函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获定义它们的那次渲染中的props和state。useEffect 完整指南 hooks中目前还不支持getSnapshotBeforeUpdate生命周期 hooks支持HOC、renderProps class组件容易阻断数据源 class组件在生命周期方法中使用props和state时很容易忘记更新 Hooks可以方便实现数据源的更新和相应，即hooks推动你做正确的事情 编写有弹性的组件 TODO: 尝试自定义hooks https://blog.logrocket.com/how-to-migrate-from-hocs-to-hooks-d0f7675fd600/ https://kentcdodds.com/blog/react-hooks-whats-going-to-happen-to-render-props render props render props是给子组件传入一个function类型的prop用作render 可以使用children prop字段，或者直接内嵌children的形式 12345&lt;Mouse&gt; &#123;mouse =&gt; ( &lt;p&gt;The mouse position is &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt; )&#125;&lt;/Mouse&gt; 注意事项：当和PureComponent使用的时候, shallowEqual始终返回false，因为每次传入的function prop都是新创建的，可以将function prop定义在一个实例方法中，例如 12345678910111213141516class MouseTracker extends React.Component &#123; // Defined as an instance method, `this.renderTheCat` always // refers to *same* function when we use it in render renderTheCat(mouse) &#123; return &lt;Cat mouse=&#123;mouse&#125; /&gt;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Move the mouse around!&lt;/h1&gt; &lt;Mouse render=&#123;this.renderTheCat&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 与HOC比较 只能使用指定传入的props|state参数 可以传入多个render props React hooks 为什么需要hooksReact很受欢迎，但class组件存在一些问题： 使用super(props)是很烦人的 this指向的绑定比较麻烦 通过生命周期方法组织组件，迫使我们将互相关联的逻辑分散到不同的函数中 同一个生命周期函数放置很多互不关联的side effect逻辑 class组件对于共享非可视逻辑没有很好的原始支持 hooks可以解决什么问题 首先function组件没有super和this绑定问题 hooks可以解决function组件缺失的state管理、模拟生命周期、自定义hooks共享非可视逻辑(例如需要用HOC实现的签到弹窗逻辑可以改成自定义hooks，HOC开发不友好、props传递丢失、陷入嵌套Hell) 提供数据和方法缓存减少渲染范围、提供全局变量 react hooks原理 初次渲染的时候，按照 useState，useEffect 的顺序，把 state，deps 等按顺序塞到 memoizedState 队列中。 更新的时候，按照顺序，从 memoizedState 中把上次记录的值拿出来。 Q：为什么只能在函数最外层调用 Hook？为什么不要在循环、条件判断或者子函数中调用。A：memoizedState 数组是按 hook定义的顺序来放置数据的，如果 hook 顺序变化，memoizedState 并不会感知到。 Q：自定义的 Hook 是如何影响使用它的函数组件的？A：共享同一个 memoizedState，共享同一个顺序。 Q：“Capture Value” 特性是如何产生的？ 闭包属性A：每一次 ReRender 的时候，都是重新去执行函数组件了，对于之前已经执行过的函数组件，并不会做任何操作。 hooks中过时的闭包 闭包创建的时候会捕获引用的外部变量的值解决办法： setCount(count =&gt; count + 1)确保将最新状态值作为参数提供给更新状态函数 (didUpdate, [dependsArr])，将依赖传入dependsArr https://codesandbox.io/s/goofy-leaf-11gmt?file=/src/index.jshttps://codesandbox.io/s/white-hooks-qgvm5?file=/src/index.jshttps://segmentfault.com/a/1190000020805789 useCallback和useMemo 性能优化不是免费的。 它们总是带来成本，但这并不总是带来好处来抵消成本。 什么时候使用 useMemo 和 useCallback 引用相等 大多数时候，你不需要考虑去优化不必要的重新渲染; 有些情况下渲染可能会花费大量时间（比如重交互的图表、动画等） 昂贵的计算 计算素数https://jancat.github.io/post/2019/translation-usememo-and-usecallback/ 将 React 作为 UI 运行时 useEffect vs useLayoutEffect useEffect 是异步执行的，而useLayoutEffect是同步执行的。 useEffect 的执行时机是浏览器完成渲染之后，而 useLayoutEffect 的执行时机是浏览器把内容真正渲染到界面之前，和 componentDidMount 等价。 官方文档：你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。useLayoutEffect和useEffect的区别 react优化 添加错误边界ErrorBoundary list添加key值 React性能优化V2React性能优化的三个方向： 减少计算的量。 -&gt; 对应到 React 中就是减少渲染的节点 或者 降低组件渲染的复杂度 利用缓存。-&gt; 对应到 React 中就是如何避免重新渲染，利用函数式编程的 memo 方式来避免组件重新渲染 精确重新计算的范围。 对应到 React 中就是绑定组件和状态关系, 精确判断更新的’时机’和’范围’. 只重新渲染’脏’的组件，或者说降低渲染范围减少计算的量 不要在render方法内部进行副作用相关的计算 减少嵌套，例如使用 React Fragments 避免额外标记 虚拟列表 惰性渲染：懒加载react-loadable | lazy Suspense12345678910111213import React, &#123; Suspense &#125; from 'react';const OtherComponent = React.lazy(() =&gt; import('./OtherComponent'));function MyComponent() &#123; return ( &lt;div&gt; &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt; &lt;OtherComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; );&#125; 利用缓存 不变的事件处理函数： 不要使用内联函数定义 在Function组件中使用useCallback来包装事件处理器，尽量给下级组件暴露一个静态的函数 设计更方便处理的 Event Props this绑定放到constructor中，或者使用autobind方法 useMemo缓存复杂的计算结果 简化props，降低props变化的影响范围 简化state，避免不必要的数据变动导致组件重新渲染 精确重新计算的范围所谓精细化渲染指的是只有一个数据来源导致组件重新渲染, 比如说 A 只依赖于 a 数据，那么只有在 a 数据变动时才渲染 A, 其他状态变化不应该影响组件 A。Vue 和 Mobx 宣称自己性能好的一部分原因是它们的’响应式系统’, 它允许我们定义一些‘响应式数据’，当这些响应数据变动时，依赖这些响应式数据视图就会重新渲染。在Vue和Mobx中，组件的依赖是自动追踪的，**。 响应式数据的精细化渲染 mobx状态管理框架 shouldComponentUpdate 生命周期事件 函数式组件React.memo | class组件PureComponent 不要滥用 Context：明确状态作用域, Context 只放置必要的，关键的，被大多数组件所共享的状态 Context API 的更新特点，它是可以穿透React.memo或者shouldComponentUpdate的比对的，也就是说，一旦 Context 的 Value 变动，所有依赖该 Context 的组件会全部 forceUpdate.context缓存问题因为 context 会使用参考标识（reference identity）来决定何时进行渲染，这里可能会有一些陷阱，当 provider 的父组件进行重渲染时，可能会在 consumers 组件中触发意外的渲染。举个例子，当每一次 Provider 重渲染时，以下的代码会重渲染所有下面的 consumers 组件，因为 value 属性总是被赋值为新的对象：123456789class App extends React.Component &#123; render() &#123; return ( &lt;MyContext.Provider value=&#123;&#123;something: 'something'&#125;&#125;&gt; &lt;Toolbar /&gt; &lt;/MyContext.Provider&gt; ); &#125;&#125; 为了防止这种情况，将 value 状态提升到父节点的 state 里：1234567891011121314151617181920212223class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &#123;something: 'something'&#125;, &#125;; &#125; render() &#123; return ( &lt;Provider value=&#123;this.state.value&#125;&gt; &lt;Toolbar /&gt; &lt;/Provider&gt; ); &#125;&#125;// Function组件export function ThemeProvider(props) &#123; const [theme, switchTheme] = useState(redTheme); const value = useMemo(() =&gt; (&#123; theme, switchTheme &#125;), [theme]); return &lt;Context.Provider value=&#123;value&#125;&gt;&#123;props.children&#125;&lt;/Context.Provider&gt;;&#125; React.StrictMode 识别不安全的生命周期 关于使用过时字符串 ref API 的警告 关于使用废弃的 findDOMNode 方法的警告 检测意外的副作用: 通过调用多次来帮助发现副作用 检测过时的 context API react-router原理： 组件初始化的时候注册history.listen的监听事件 调用history.push、history.replace之后会触发监听，调用notifyListeners 根据传递进来path,url,params等参数，最终通过setState触发组件reRender 路由相关信息的传递依赖context从Router传递到内部的Route123456789101112131415161718class Router extends React.Component &#123; componentWillMount() &#123; const &#123; children, history &#125; = this.props //调用history.listen监听方法，该方法的返回函数是一个移除监听的函数 this.unlisten = history.listen(() =&amp;gt; &#123; this.setState(&#123; match: this.computeMatch(history.location.pathname) &#125;); &#125;); &#125; componentWillUnmount() &#123; this.unlisten(); &#125; render() &#123; &#125;&#125; 123456789101112131415161718192021222324class Route extends React.Component &#123; .... constructor()&#123; &#125; render() &#123; const &#123; match &#125; = this.state; const &#123; children, component, render &#125; = this.props; const &#123; history, route, staticContext &#125; = this.context.router; const location = this.props.location || route.location; const props = &#123; match, location, history, staticContext &#125;; if (component) return match ? React.createElement(component, props) : null; if (render) return match ? render(props) : null; if (typeof children === \"function\") return children(props); if (children &amp;amp;&amp;amp; !isEmptyChildren(children)) return React.Children.only(children); return null; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839var push = function push(path, state) &#123; var action = 'PUSH'; var location = createLocation(path, state, createKey(), history.location); transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) &#123; if (!ok) return; var href = createHref(location); var key = location.key, state = location.state; if (canUseHistory) &#123; globalHistory.pushState(&#123; key: key, state: state &#125;, null, href); if (forceRefresh) &#123; window.location.href = href; &#125; else &#123; var prevIndex = allKeys.indexOf(history.location.key); var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1); nextKeys.push(location.key); allKeys = nextKeys; // 调用setState触发listeners更新 setState(&#123; action: action, location: location &#125;); &#125; &#125; else &#123; warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history'); window.location.href = href; &#125; &#125;); &#125;; var setState = function setState(nextState) &#123; _extends(history, nextState); history.length = globalHistory.length; transitionManager.notifyListeners(history.location, history.action); &#125;; callback Ref的使用场景结合callback Ref, 可以方便地获取dom节点的高度。代码示例可参考： react-measuredref-callback even if a child component displays the measured node later1234567891011121314151617181920function MeasureExample() &#123; const [height, setHeight] = useState(0); const measuredRef = useCallback((node) =&gt; &#123; if (node !== null) &#123; setHeight(node.getBoundingClientRect().height); &#125; // 1. 传入[]，保证rerender的时候不会被重新触发，只在mount和unmount的时候被调用 // 2. 不使用useRef，是因为object ref的value发生变化时，不会触发通知；使用ref callback的形式 // 可以对延迟展示的组件同样有效 // 3. 如果要支持resize，可以结合[ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) &#125;, []); return ( &lt;&gt; &lt;h1 ref=&#123;measuredRef&#125;&gt;Hello, world&lt;/h1&gt; &lt;h2&gt;The above header is &#123;Math.round(height)&#125;px tall&lt;/h2&gt; &lt;/&gt; );&#125;","tags":[]},{"title":"","date":"2024-02-19T04:51:45.049Z","path":"2024/02/19/module引入方式/","text":"UMD模式UMD (Universal Module Definition), 希望提供一个前后端跨平台的解决方案(支持AMD与CommonJS模块方式)。 实现原理 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。 前两个都不存在，则将模块公开到全局（window或global）。12345678910111213141516171819202122232425262728293031323334// if the module has no dependencies, the above pattern can be simplified to(function (root, factory) &#123; if (typeof exports===\"object\"&amp;&amp;typeof module!==\"undefined\") &#123; // Node CommonJS. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define([], factory); &#125; else &#123; // Browser globals (root is window) root.returnExports = factory(); &#125;&#125;(this, function () &#123; // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return &#123;&#125;;&#125;));``` 如果没有定义root参数，也可以通过下面的方式去赋值给全局变量：``` js var g; if(typeof window!==\"undefined\")&#123; g=window &#125;else if(typeof global!==\"undefined\")&#123; g=global &#125;else if(typeof self!==\"undefined\")&#123; g=self &#125;else&#123; g=this &#125; ES Module与CommonJS 语法差异： ES Module使用import、export CommonJS使用require、module.exports（exports） 依赖关系的确认： CommonJS模块是对象，是运行时加载，运行时才把模块挂载在exports之上（加载整个模块的所有），加载模块其实就是查找对象属性； ES Module是在编译时确定依赖关系（设计思想：尽量的静态化）。 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS模式中，exports的一个参数，即使该参数发生了变化，引入的地方拿到的值始终不变 在ES Module中，export的参数如果发生了变化，在引入的地方也会同步更新；引用的参数是read-only的（因为是引用，约定是不能在外部修改）。 只执行一次 多次require，CommonJS返回的是module的缓存 ES6 module多次import，只会在首次import中执行 加载方式： commonJS模块就是对象，整体加载模块（即加载的所有方法） ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 运行环境：AMD/CMD是CommonJS在浏览器端的解决方案。 CommonJS node端是同步加载（代码在本地，加载时间基本等于硬盘读取时间）。 AMD/CMD是异步加载（浏览器必须这么做，代码在服务端） CommonJs中exports和module.exports的差别123456var module = &#123; exports: &#123;&#125; &#125;;var exports = module.exports;// your codereturn module.exports; 这意味着exports的正确使用方法, 只有exports.A = B这种挂变量的形式。modules.exports一旦被直接赋值, 如modules.exports = 1, 也会断开它和exports之间的联系, 导致exports失去意义.参考https://www.jianshu.com/p/434c247759bc AMD vs CMDAMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。1234567891011121314151617181920212223242526/** 网页中引入require.js及main.js **/&lt;script src=\"js/require.js\" data-main=\"js/main\"&gt;&lt;/script&gt;/** main.js 入口文件/主模块 **/// 首先用config()指定各模块路径和引用名require.config(&#123; baseUrl: \"js/lib\", paths: &#123; \"jquery\": \"jquery.min\", //实际路径为js/lib/jquery.min.js \"underscore\": \"underscore.min\", &#125;&#125;);// 执行基本操作require([\"jquery\",\"underscore\"],function($,_)&#123; // some code here&#125;);// 定义模块define(function () &#123; // some code here&#125;);// 定义的模块本身也依赖其他模块define([\"jquery\"], function () &#123; // some code here&#125;); 123456789101112131415161718192021222324252627282930313233/** AMD写法 **/define([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) &#123; // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething(); if (false) &#123; // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() &#125; &#125;);/** CMD写法 **/define(function(require, exports, module) &#123; var a = require('./a'); //在需要时申明 a.doSomething(); if (false) &#123; var b = require('./b'); b.doSomething(); &#125;&#125;);/** sea.js **/// 定义模块 math.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js'); var add = function(a,b)&#123; return a+b; &#125; exports.add = add;&#125;);// 加载模块seajs.use(['math.js'], function(math)&#123; var sum = math.add(1+2);&#125;); AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行 commonjs vs es6 modules两个重大差异： CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 是否缓存数据 JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。原始值变了，import加载的值也会跟着变。因此ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。 export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 下面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式es6-modules-single-instance-pattern。12345import &#123; foo &#125; from 'my_module';import &#123; bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module';","tags":[]},{"title":"","date":"2024-02-19T04:51:45.048Z","path":"2024/02/19/js_roadmap/","text":"js基本类型js是一种弱类型或者说是动态语言，有7种基本数据类型，1种引用数据类型object。类型 typeof结果Undefined “undefined”Null “object”（见下文）Boolean “boolean”Number “number”String “string”Symbol （es 6新增——es2015年发布）”symbol” // Symbol是一种特殊的、不可变的数据类型，可以作为对象的标识符使用。BigInt “bigint” (es10 新增——es2020发布) // 之前JavaScript可以处理的最大数字是2 ^ 53 宿主对象（由JS环境提供） Implementation-dependent函数对象（[[Call]] 在ECMA-262条款中实现了） “function”任何其他对象 “object” typeof null的值不是null，而是object因为在JS的最初版本中，使用的是32位系统，为了性能考虑使用低位存储了变量的类型信息，由小型标记(1-3位)和真实值组成。000开头代表是对象，然而null表示为全零，所以将它错误的判断为object。 基础类型的特性是值本身不能被改变js中的参数传递都是按值传递： 基础类型存储在栈中，传递的是值的拷贝，不会改变传入的值 引用类型真实值存储在堆中，传递的是内存地址，指向同一块内存区域 1234567891011121314151617181920// 基本类型let foo = 5;// 定义一个貌似可以改变基本类型值的函数function addTwo(num) &#123; num += 2;&#125;// 和前面的函数一样function addTwo_v2(foo) &#123; foo += 2;&#125;// 调用第一个函数，并传入基本类型值作为参数addTwo(foo);// Getting the current Primitive valueconsole.log(foo); // 5// 尝试调用第二个函数...addTwo_v2(foo);console.log(foo); // 5 debounce vs throttle debounce 防抖，会在事件停止后100ms后再触发，‘execute this function only if 100 milliseconds have passed without it being called.’ 场景: resize、drag、keypress等事件 throttle 节流，在每100ms内最多触发一次，‘execute this function at most once every 100 milliseconds.’ 场景: scroll、click等事件 try catch finally即使在try和catch中return了，finally方法还是会执行，finally块中的内容会先于try中的return语句执行。12345678910function test() &#123; try&#123; var t = 1; return t &amp;&amp; console.log('return:', t); &#125;finally&#123; console.log(2) // 相当于 return undefined &#125;&#125;console.log('test() result:', test()); 输出顺序为: “return: 2” “2” “test() result: undefined”先执行了return后面的语句，得到return undefined，然后去执行finally里面的代码块，执行完后执行return undefined。但如果finally语句块中也有return语句的话，将直接从finally中返回，这也是不建议在finally中return的原因。 词法作用域 vs 动态作用域 词法作用域，也叫静态作用域，它的作用域是指在词法分析阶段就确定了，不会改变。 动态作用域是在运行时根据程序的流程信息来动态确定的，而不是在写代码时进行静态确定的。123456789101112var a = 2;function foo() &#123; console.log(a); // 会输出2还是3？&#125;function bar() &#123; var a = 3; foo();&#125;bar(); 如果是词法作用域，它会让 foo() 函数引用到全局作用域中的 a，因此会输出 2。我们说过，词法作用域是写代码的时候就静态确定下来的。Javascript中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的），所以这段代码在浏览器中运行的结果是输出 2。而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此，如果Javascript具有动态作用域，理论上输出结果是 3。需要明确的是，Javascript并不具有动态作用域，它只有词法作用域，简单明了。但是，它的 eval()、with、this机制某种程度上很像动态作用域，使用上要特别注意。主要区别：词法作用域是在写代码或者定义时确定的（this也是！），而动态作用域是在运行时确定的。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。最后，让我们看一个《JavaScript权威指南》中的例子：123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = \"global scope\";function checkscope()&#123; var scope = \"local scope\"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 两段代码都会打印：local scope。这两种实现的执行上下文栈不一样，具体的可以参考https://github.com/mqyqingfeng/Blog/issues/4原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。而引用《JavaScript权威指南》的回答就是：JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 从词法作用域角度解释闭包 当函数可以记住并访问所在的词法作用域，就产生了闭包。即使函数是在当前词法作用域之外执行。—— 摘自《你所不知道的js》 变量对象和活动对象对于每个执行上下文，都有三个重要属性： 变量对象 作用域链 this变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。全局对象是作用域链的头部，从上下文看可以区分为全局上下文中的变量对象和函数上下文中的变量对象。活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。全局上下文中只有变量对象？123456789101112function foo(d) &#123; // 输出 ƒ d() &#123;&#125;，进入执行上下文时，变量的声明不会覆盖函数的声明; 但函数声明会覆盖输入的形参和变量声明 console.log(d); var b = 2; function d() &#123;&#125; var d = 2; b = 3; // 输出2，代码执行阶段，同名变量的属性值会被修改 console.log(d);&#125;foo(1); 对应的变量对象和活动对象是：123456789101112var VO = &#123; // arguments: &#123; // d: undefined // &#125; // 因为被覆盖了 b: undefined, d: reference to function d()&#123;&#125;,&#125;// 代码执行完后的AOvar AO = &#123; b: 3, d: 2,&#125; VO 和 AO 的关系：未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期123456789101112function foo() &#123; console.log(a); a = 1;&#125;foo(); // Uncaught ReferenceError: a is not defined。function bar() &#123; a = 1; console.log(a);&#125;bar(); // 1 因为a没有用var声明，不会发生变量提升，所以直接console的时候是‘Uncaught ReferenceError: a is not defined。’；而在对它进行赋值操作之后，js会认为是想要隐式声明一个全局变量，所以在赋值之后再console就是输出1。","tags":[]},{"title":"webpack-loader总结","date":"2023-11-02T04:12:12.000Z","path":"2023/11/02/webpack-loader总结/","text":"css处理loadermodule css处理 style-loader: 处理css插入方式：inline或者extract，SSR模式下使用isomorphic-style-loader css-loader: 处理css中资源引用 resolve-url-loader: 处理sass中import和url()相对路径 post-loader: 添加浏览器前缀autoprefixer｜生产模式中压缩cssnano | rem转换postcss-px2rem sass-loader: 将sass/scss编译为css jsx css处理 babel-loader: 结合babel的presets和plugins配置处理js styled-jsx: 处理jsx格式写的style 123456789export default () =&gt; ( &lt;div className=\"root\"&gt; &lt;style jsx&gt;&#123;` .root &#123; color: green; &#125; `&#125;&lt;/style&gt; &lt;/div&gt;) post-loader: 添加浏览器前缀autoprefixer｜生产模式中压缩cssnano sass-loader: 将sass/scss编译为css MiniCssExtractPlugin和style-loader功能相似：This plugin should be used only on production builds without style-loader in the loaders chain, especially if you want to have HMR in development.12345678910111213141516171819202122232425262728293031const MiniCssExtractPlugin = require('mini-css-extract-plugin');const devMode = process.env.NODE_ENV !== 'production';module.exports = &#123; plugins: [ new MiniCssExtractPlugin(&#123; // Options similar to the same options in webpackOptions.output // both options are optional filename: devMode ? '[name].css' : '[name].[hash].css', chunkFilename: devMode ? '[id].css' : '[id].[hash].css', &#125;), ], module: &#123; rules: [ &#123; test: /\\.(sa|sc|c)ss$/, use: [ &#123; loader: MiniCssExtractPlugin.loader, options: &#123; hmr: process.env.NODE_ENV === 'development', &#125;, &#125;, 'css-loader', 'postcss-loader', 'sass-loader', ], &#125;, ], &#125;,&#125;; babel配置 presets预设配置@babel/env和@babel/preset-env的写法一致，babel已经知道它是一个preset，会自动加上preset-1234567891011presets: [ ['@babel/env', &#123; modules: 'commonjs', // todo 取消注释编译报错，参考：https://github.com/babel/babel/issues/8559 targets: &#123; node: true &#125; &#125;], '@babel/react', '@babel/preset-typescript',]","tags":[{"name":"webpack","slug":"webpack","permalink":"https://sherrywu0917.github.io/tags/webpack/"},{"name":"loader","slug":"loader","permalink":"https://sherrywu0917.github.io/tags/loader/"}]},{"title":"echarts支持角度渐变踩坑指南","date":"2023-10-12T11:40:59.000Z","path":"2023/10/12/echarts支持角度渐变踩坑指南/","text":"背景背景是在听歌数据主页的项目中，需要用一个圆环去表达听歌时段，圆环是基于echarts库实现的，最初的方案是使用线性渐变的方式去渲染颜色；后期UI侧对于线性渐变的效果不太满意，希望: 能够用颜色的递进来表达用户当前时段的投入程度，但目前最可行的线性渐变解决方案的效果还是不太能达到要求的，是否有更合适的方案能够满足角度渐变的效果呢？ 问题的难点在于echarts目前只支持下面两种渐变方式： 线性渐变：LinearGradient 径向渐变：RadialGradient 对于是否可以支持角度渐变，首先需要调研下可行性，大致思路是调研下是否可以基于echarts的源码去扩展，以期支持角度渐变的效果。 可行性调研首先把echarts源码下载到本地，发现主要分为两个包：echarts和zrender，渲染的逻辑主要集中在zrender，官网介绍：ZRender, a high performance 2d drawing library.。为了快速定位到渐变渲染的位置，通过canvas的createLinearGradientAPI去全局搜索(就是这么简单粗暴)，最后发现构建渐变对象的核心逻辑主要在zrender的canvas/helper.ts文件中，详情见git源码。12345678910111213export function getCanvasGradient(this: void, ctx: CanvasRenderingContext2D, obj: GradientObject, rect: RectLike) &#123; const canvasGradient = obj.type === 'radial' ? createRadialGradient(ctx, obj as RadialGradientObject, rect) : createLinearGradient(ctx, obj as LinearGradientObject, rect); const colorStops = obj.colorStops; for (let i = 0; i &lt; colorStops.length; i++) &#123; canvasGradient.addColorStop( colorStops[i].offset, colorStops[i].color ); &#125; return canvasGradient;&#125; 初步设想，在getCanvasGradient中根据obj.type去返回对应的渐变对象；为了快速验证可行性，在createLinearGradient方法中直接返回使用ctx.createConicGradient(-0.5 * Math.PI, 187, 150)创建的对象，colorStops也是固定值，事实验证是可行的。 角度渐变实现为了实现业务代码可用的角度渐变，需要在echarts.graphic的基础上去扩展，支持new echarts.graphic.ConicGradient(startAngle, colorStops)的调用方式；主要的改造包括： 在zrender/graphic文件夹下，新增ConicGradient类，继承自Gradient类，type标记为conic，后续会根据该type值去判断需要返回的渐变对象类型，关键代码: 123456789101112131415161718import &#123; __extends &#125; from \"tslib\";import Gradient from './Gradient.js';var ConicGradient = (function (_super) &#123; __extends(ConicGradient, _super); function ConicGradient(angle, colorStops, timeUnitType) &#123; var _this = _super.call(this, colorStops) || this; _this.angle = angle == null ? 0 : angle; _this.type = 'conic'; _this.timeUnitType = timeUnitType; _this.global = false; colorStops.forEach(function (colorStop) &#123; colorStop.timeUnitType = timeUnitType; &#125;); return _this; &#125; return ConicGradient;&#125;(Gradient));export default ConicGradient; 在echarts、zrender两个库中，全局查找和补充： 在需要export渐变类的地方，补充对ConicGradient类的导出； 对于源码中需要判断渐变类型的地方，补充对isConicGradient方法的调用和相关渲染逻辑 最后在关键的getCanvasGradient方法中，创建conic渐变对象并返回，注意开始角度需要设置为-0.5 * Math.PI，因为角度渐变的起始点为水平3点钟方向，而视觉要求的起始点为垂直12点方向： 12345678910111213141516171819202122232425export function getCanvasGradient(ctx, obj, rect) &#123; var canvasGradient; switch (obj.type) &#123; case 'radial': canvasGradient = createRadialGradient(ctx, obj, rect); break; case 'conic': canvasGradient = createConicGradient(ctx, obj, rect); break; default: canvasGradient = createLinearGradient(ctx, obj, rect); break; &#125; var colorStops = obj.colorStops; for (var i = 0; i &lt; colorStops.length; i++) &#123; canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color); &#125; return canvasGradient;&#125;export function createConicGradient(ctx, obj, rect) &#123; // ... // 开始角度为-0.5 * Math.PI return ctx.createConicGradient(-0.5 * Math.PI, x, y);&#125; 最后，在业务代码中通过itemStyle.color的配置，返回new echarts.graphic.ConicGradient创建的角度渐变对象。123456789itemStyle: &#123; // 每个扇形的样式 color: (params) =&gt; &#123; // 计算出每个扇形的开始角度 const startAngle = xxx; // 获取该扇形对应的渐变值 const colorStops = yyy; return new echarts.graphic.ConicGradient(startAngle, colorStops); &#125;,&#125;, 至此，在电脑端chrome浏览器上效果非常完美，满足视觉同学的预期效果（此时，我有一个小疑问，echarts为什么不支持角度渐变？）。 起始角度问题众所周知，前端在chrome上实现的效果通常很完美，但在手机端上可能是另一回事。 起始角度不同chrome上的效果： iphone上的效果： 对比上面两图，可以发现在iphone上，渐变绘制的是有角度渐变的，但渐变的色值和起始位置都不对。 通过绘制单条数据可以发现，在iphone上-0.5 * Math.PI对应的起始点并非垂直12点方向，而是水平9点方向，相比理想位置多了-0.5 * Math.PI角度，说明在该手机上起始角度0度对应的就是垂直12点方向。于是，在创建渐变对象时增加了是否是移动端设备的判断：12345export function createConicGradient(ctx, obj, rect) &#123; // ... const startAngle = isMobile() ? 0 : -0.5 * Math.PI; return ctx.createConicGradient(startAngle, x, y);&#125; 在增加上述判断后，发现在另一台iphone上绘制的效果也并不符合预期，经测试，在不同的iphone设备上起始角度不同，有的是垂直12点方向，有的是水平9点方向，应该是和ios系统有关系，但难以覆盖完全。 判断起始角度此时，需要有一个通用的方法去判断角度渐变的起始角度，在遍查API之后，发现并没有这样的方法。最后，想到可以通过绘制1/4的渐变，再去读取对应位置的颜色，进而计算出渐变的起始角度。具体的流程如下：1234567891011121314151617181920212223242526function countDirection() &#123; const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); const x = 100; const y = 100; const radius = 50; if (ctx &amp;&amp; ctx.createConicGradient) &#123; // 从默认的起始角度0度开始绘制1/4圆的渐变 const conicGradient = ctx.createConicGradient(0, x, y); conicGradient.addColorStop(0, '#000'); conicGradient.addColorStop(0.25, '#fff'); ctx.fillStyle = conicGradient; ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.fill(); // 获取右上角的颜色，若从水平方向开始则为[255, 255, 255, 255]，反之为垂直方向[135, 135, 135, 255] const imageData = ctx.getImageData(110, 90, 1, 1); const pixelData = imageData.data || []; isHorizontal = pixelData?.[0] &gt; 240; // 存在可能为254的情况，保险起见改成大于240 &#125;&#125;const isHorizontal = countDirection(); 通过ctx.getImageData去读取右上角某一个点的位置，如果起始位置是水平方向，则取到的色值应该为白色: [255, 255, 255, 255]；反之如果起始位置是垂直方向，则右上角为渐变区域：#000 -&gt; #fff 的渐变，色值必然不是白色。通过这种间接的方式，可以计算出角度渐变的起始方向。 水平方向： 垂直方向： 安卓Polyfill适配成功处理了角度问题之后，在安卓机上打开，发现页面白屏，看console日志，发现有报错ctx.createConicGradient is not defined，此时，我大概明白了echarts为什么不支持角度渐变= =！。尝试查找可用的polyfill，发现create-conical-gradient这个库大概可以满足需求。在createConicGradient方法中增加对ctx.createConicGradient是否存在的判断：123456789101112export function createConicGradient(ctx, obj, rect) &#123; //... if (ctx.createConicGradient)&#123; const startAngle = isHorizontal ? -0.5 * Math.PI : 0; canvasGradient = ctx.createConicGradient(startAngle, x, y); &#125; else &#123; canvasGradient = ctx.createConicalGradient(x, y, -0.5 * Math.PI, 1.5 * Math.PI); // 标记使用的是polyfill方式，底层对应createPattern canvasGradient.usePattern = true; &#125; return canvasGradient;&#125; 该库内部使用的是createPattern方式去渲染，最后暴露了get pattern()方式去获取，在zrender需要渲染渐变的地方，需要根据usePattern变量去判断，若为true，则设置fillStyle为canvasGradient.pattern。 Polyfill卡顿问题处理通过增加了上述Polyfill方法在安卓机上可以渲染出角度渐变的效果，但该方案实现后动画效果有问题，卡顿非常严重。 卡顿原因定位 发现zrender中帧动画掉帧严重：requestAnimationFrame回调函数执行时间过长，导致动画卡顿；使用chrome的帧工具，辅助验证了的确是掉帧： 进一步定位，发现同一个渐变被调用并创建了多次，例如起始角度为0的第一个扇形，会被重复渲染10次 添加缓存尝试使用缓存解决，先给ConicGradient创建缓存对象，使用colorStops作为cacheKey，保证唯一性。12345678910111213const conicGradientCache = &#123;&#125;; // 缓存渐变对象，避免重复创建export function createConicGradient(ctx, obj, rect) &#123; const cacheKey = JSON.stringify(obj.colorStops); if (conicGradientCache[cacheKey]) &#123; conicGradientCache[cacheKey].fromCache = true; return conicGradientCache[cacheKey]; &#125; //... // 创建canvasGradient对象代码，参考上面 conicGradientCache[cacheKey] = canvasGradient; return canvasGradient;&#125; 有点效果，但收效甚微，经过定位，发现问题出在create-conical-gradient库中；虽然canvasGradient对象是缓存了，但在使用canvasGradient.pattern时，get pattern方法内部每次都会重新创建一遍，所以canvasGradient.pattern也需要缓存。于是把该库源码pull到本地，在返回pattern的地方也加上缓存：1234get pattern() &#123; patternCache[cacheKey] = patternCache[cacheKey] || createConicalGradient(ctx2d, this.stops, ...args); return patternCache[cacheKey];&#125;, 加上缓存后的效果，虽然比不上原生API的渲染性能，但在体感上已基本流畅。 一条线问题此外，还发现在ios16.0-16.2版本的系统上，在渲染渐变时，会偶现有闪烁的一条线问题，如下图所示： 在stackoverflow上同样有人有类似的问题：Flickering horizontal lines on the animation made with canvas only on iOS 16。 目前没有找到可行的方案去解决：使用原生API的同时可以避免这样线的问题，可选的方案就是判断系统的版本，若处于有问题的版本中，则使用Polyfill的方式去渲染。 总结目前浏览器对canvas的createConicGradientAPI的支持存在诸多问题，或许在未来，浏览器的支持度会越来越高，使用起来就不会像现在这样存在诸多问题。在视觉方案的选择上，也需要再慎重些，看看是否有其他可替代的方案。","tags":[{"name":"echarts","slug":"echarts","permalink":"https://sherrywu0917.github.io/tags/echarts/"},{"name":"角度渐变","slug":"角度渐变","permalink":"https://sherrywu0917.github.io/tags/角度渐变/"}]},{"title":"SSR渲染","date":"2023-09-17T04:12:12.000Z","path":"2023/09/17/SSR渲染/","text":"webpack打包nodejs遵循 commonjs规范，文件的导入导出如下：1234// 导出module.exports = someModule// 导入const module = require('./someModule') 而我们通常所写的 react代码是遵循 esModule规范的，文件的导入导出如下：1234// 导出export default someModule// 导入import module from './someModule' 所以想要让 react代码兼容于服务器端，就必须先解决这两种规范的兼容问题，实际上 react是可以直接以 commonjs规范来书写的，例如：1const React = require('react') 使用webpack编译的作用是： 将 jsx编译为 node认识的原生 js代码 将 esModule代码编译成 commonjs的 客户端如何处理ssr渲染的数据server端ReactDOM.renderToString返回的HTML片段插入到ejs模板中，再通过node的response.render返回给浏览器 client端 ReactDOM.render()会将挂载dom节点的所有子j节点全部清空掉，再重新生成子节点。 ReactDOM.hydrate()则会复用挂载dom节点的子节点，并将其与react的virtualDom关联上。初次渲染可以调用两种方法：ReactDOM.render和ReactDOM.hydrate。后者就是直接告诉ReactDOM需要hydrate，目前来说如果你调用的是render，但是 React 会调用下面的方法检测是否可以hydrate，如果可以他会提醒你应该使用hydrate。123456789101112131415161718192021const ELEMENT_NODE = 1;const DOCUMENT_NODE = 9;const ROOT_ATTRIBUTE_NAME = 'data-reactroot';function getReactRootElementInContainer(container) &#123; if (!container) &#123; return null; &#125; if (container.nodeType === DOCUMENT_NODE) &#123; return container.documentElement; &#125; else &#123; // 检查container内是否已经返回了第一个child return container.firstChild; &#125;&#125;// container是ReactDOM.render(&lt;App/&gt;, container)传入的第二个参数function shouldHydrateDueToLegacyHeuristic(container) &#123; var rootElement = getReactRootElementInContainer(container); return !!(rootElement &amp;&amp; rootElement.nodeType === ELEMENT_NODE &amp;&amp; rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));&#125; 从根节点开始DFS遍历，dom节点从ReactDOM.render的container元素开始，检查fiber节点是否可以复用nextInstance，nextInstance对应于DOM节点，可以复用的话，会将fiber.stateNode赋值为nextInstance。另外注水阶段，会绑定事件。 流式渲染客户端识别Transfer-EncodingTransfer-Encoding 消息首部指明了将 entity 安全传递给用户所采用的编码形式。1Transfer-Encoding: chunked 数据以一系列分块的形式进行发送。 Content-Length 首部在这种情况下不被发送。。在每一个分块的开头需要添加当前分块的长度，以十六进制的形式表示，后面紧跟着 ‘\\r\\n’ ，之后是分块本身，后面也是’\\r\\n’ 。终止块是一个常规的分块，不同之处在于其长度为0。终止块后面是一个挂载（trailer），由一系列（或者为空）的实体消息首部构成。 ngnix配置开启流式渲染，首先在response的头部需要加一个X-Accel-Buffering字段，告诉浏览器我要采用流式传输；然后就可以分块输出了。首先nginx.conf需要加如下代码，让X-Accel-Buffering透传location / { proxy_pass_header X-Accel-Buffering; proxy_pass http://node;}然后在返回的时候，在response的头部设置：1234res.set(&#123; 'X-Accel-Buffering': 'no', 'Content-Type': 'text/html; charset=UTF-8'&#125;); x-accel-buffering: no设置此连接的代理缓存，将此设置为no将允许适用于Comet和HTTP流式应用程序的无缓冲响应。将此设置为yes将允许响应被缓存。默认yes。设置为no可以关闭缓存，让浏览器以chunk的形式解析。 服务端返回response.write1response.write(chunk[, encoding][, callback])# chunk | encoding 默认值: ‘utf8’。 callback 返回: 如果调用此方法并且尚未调用 response.writeHead()，则将切换到隐式响应头模式并刷新隐式响应头。这会发送一块响应主体。可以多次调用该方法以提供连续的响应主体片段。第一次调用 response.write() 时，它会将缓冲的响应头信息和主体的第一个数据块发送给客户端。 第二次调用response.write() 时，Node.js 假定数据将被流式传输，并分别发送新数据。 也就是说，响应被缓冲到主体的第一个数据块。 1response.flushHeaders() 出于效率原因，Node.js 通常会缓冲请求头，直到调用 request.end() 或写入第一个请求数据块。 然后，它尝试将请求头和数据打包到单个 TCP 数据包中。这通常是期望的（它节省了 TCP 往返），但是可能很晚才发送第一个数据。request.flushHeaders() 绕过优化并启动请求。 1response.end() 此方法向服务器发出信号，表明已发送所有响应头和主体，该服务器应该视为此消息已完成。 必须在每个响应上调用此 response.end() 方法。 response.renderapp.render负责生成视图，但是没有能力返回给客户端，需要借助res.send|res.write。res.send和res.write的区别：res.send can only be called once, since it is equivalent to res.write + res.end()伪代码：12345678res.render = function(view, locals, cb)&#123; app.render(view, locals, function(err, html)&#123; if(typeof cb !== 'undefined')&#123; return cb(err, html); &#125; res.send(html); &#125;);&#125;;","tags":[{"name":"SSR","slug":"SSR","permalink":"https://sherrywu0917.github.io/tags/SSR/"}]},{"title":"webpack常用插件","date":"2023-07-02T04:12:12.000Z","path":"2023/07/02/webpack常用插件/","text":"webpack运行机制 初始化配置参数 -&gt; 绑定事件钩子回调 -&gt; 确定Entry逐一遍历 -&gt; 使用loader编译文件 -&gt; 输出文件 html-webpack-plugin 和 script-ext-html-webpack-plugin html-webpack-plugin生成的html文件，其中都是默认同步类型的 需要使用script-ext-html-webpack-plugin，可以定义的引入类型或者inline script 自定义插件 Compiler暴露了和webpack整个生命周期相关的钩子：负责文件监听和启动编译。Compiler 实例中包含了完整的 webpack 配置，全局只有一个 Compiler 实例。 123456//基本写法compiler.hooks.someHook.tap(...)//如果希望在entry配置完毕后执行某个功能compiler.hooks.entryOption.tap(...)//如果希望在生成的资源输出到output指定目录之前执行某个功能compiler.hooks.emit.tap(...) Compilation暴露了与模块和依赖有关的粒度更小的事件钩子模块会经历加载(loaded),封存(sealed),优化(optimized),分块(chunked),哈希(hashed)和重新创建(restored);compilation是Compiler生命周期中的一个步骤，使用compilation相关钩子的通用写法为: 12345compiler.hooks.compilation.tap('SomePlugin',function(compilation, callback)&#123; compilation.hooks.someOtherHook.tap('SomeOtherPlugin',function()&#123; .... &#125;)&#125;); HtmlWebpackPlugin提供的事件钩子 开始生成HTML之前勾子(HtmlWebpackPlugin BeforeHtmlGeneration)这一阶做一些资源归类工作，主要产出物为asset资源原始对象，该对象为插入HTML头尾部的JS,CSS资源列表及其路径。 在HTML开始处理之前勾子(HtmlWebpackPlugin BeforeHtmlProcessing)生成不包括JS和CSS的纯HTML结果，产出物为html字符串。 添加资源处理HTML勾子(HtmlWebpackPluginAlterAssetTags)组装要插入HTML页面中的JS，CSS等资源结构，如果要在生成HTML页面中加入自定义或者WEBPACK不支持的标签等，可操作该对象。 HTML处理完毕勾子(HtmlWebpackPluginAfterHtmlProcessing)HTML页处理完成阶段，JS,CSS完成插入，已生成可直接打包用的文本结构，一般要输出自定义内容在此处实现。 勾子任务处理完毕发送事件时(HtmlWebpackPluginAfterEmit)处理任务最后阶段，可通过返回的html属性访问source和size属性。 webpack-dev-server vs webpack-dev-middlewarewebpack-dev-server结合了express、webpack-dev-middleware和webpack-hot-middleware的功能，其中 express负责启动node服务 webpack-dev-middleware通过webpack提供的watchAPI监听代码变化，重新编译打包，写到内存中 webpack-hot-middleware客户端使用EventSource长轮询(webpack-dev-server在服务端和客户端建立websocket长连接) 服务端监听compiler钩子的done事件，在文件打包完成后，调用监听函数 监听函数中调用eventStream.publish，将事件类型、文件hash等打包信息，通过事件流的形式通知客户端。（有趣的事，如果一直没有更新，服务端会间隔(默认)10s发生消息给客户端，是一个心形字符，代表心跳） 客户端监听onmessage事件，根据接收到的消息，去进行不同的处理 客户端调用check方法坚持是否有更新，如果配置了模块热更新，HMR runtime根据新模块代码决定是热更新还是重刷页面；如果没配置模块热更新，则直接重刷页面(HMR 是可选功能，只会影响包含 HMR 代码的模块。例如style-loader实现了HMR的module.hot接口，当它通过 HMR 接收到更新，它会使用新的样式替换旧的样式。)1234567compiler.hooks.done.tap('webpack-hot-middleware', onDone);// init方法source = new window.EventSource(options.path);source.onopen = handleOnline;source.onerror = handleDisconnect;source.onmessage = handleMessage; WebSockets or Server-Sent Events 明显的区别是：WebSockets是双向通信，Server-Sent Events是单向通信 Server-Sent Events API是服务器向客户端发送事件，客户端负责事件监听","tags":[{"name":"webpack","slug":"webpack","permalink":"https://sherrywu0917.github.io/tags/webpack/"},{"name":"插件","slug":"插件","permalink":"https://sherrywu0917.github.io/tags/插件/"}]},{"title":"Themis-CMS体验度量方案","date":"2023-05-20T04:12:12.000Z","path":"2023/05/20/Themis-CMS体验度量方案/","text":"背景Themis为CMS体验优化项目，目标是提高CMS相关的体验和性能，主要的服务用户是：策划、开发、运营，主要工作包括： 脚手架移动化改造和场景组件封装 性能监控 效能工具的开发本文主要介绍‘性能监控’的设计方案和实现，为了可以有效地衡量cms的性能数据，我们会从多个角度去度量应用相关的数据，进而分析出页面存在的体验问题并治理。 架构图Themis性能监控处理了从数据生成、收集、计算到可视化的整个链路，流程架构图如下所示，主要包括三方面： 场景指标定义 数据收集&amp;上报：ThemisLogger SDK 监控数据可视化：ThemisAnalysis 平台 场景指标定义首先明确CMS侧主要的场景可以归纳为表格和表单两种，在「场景组件封装」中，我们对这类交互进行了标准化定义，详情可以参考场景规范。那么问题的关键就转化为：如何对这两种场景进行度量？以表格场景为例，在用户操作的时候，我们会重点关注操作的易用性、页面渲染速度和高频行为等，从中我们抽象出表格场景的核心指标有： 查询效率 页码切换性能 场景初始化性能 筛选区操作效率 用户高频行为 为了度量出具体的核心指标，我们需要去定义具体的行为类型、指标计算规则，记录行为队列。 行为类型定义首先针对关注的表格核心指标，定义行为类型，例如在表格场景中搜索的点击search，表格渲染结束RenderEnd1234567const ActionType = &#123; PageChange: 'pageChange', // 页码变化 Search: 'search', // 搜索点击 SceneInit: 'sceneInit', // 场景初始化 RenderEnd: 'renderEnd', // 所有的表格内容渲染完成 FilterValueChange: 'filterValueChange', // 搜索条件变更&#125; 行为计算规则定义我们关注的表格核心指标有： 查询耗时 = 渲染完成时间 - 搜索触发时间（RenderEnd - Search） 页码切换耗时 = 渲染完成时间 - 页码切换时间（RenderEnd - PageChange) 场景初始化耗时 = 渲染完成时间 - 场景初始化时间（RenderEnd - SceneInit) 筛选表单操作时长 = 搜索开始时间 - 表单开始操作时间 (Search - filterValueChange) 用户高频行为 = sort([页面]-[表格]-[行为]) 计算前置关系针对已经定义的行为类型，如果要计算【行为1】到【行为2】之间的耗时，则可以将【行为1】放到【行为2】对应的前置行为数组。123456789/** * 定义需要计算的[行为1]_[行为2]的耗时 */window.Themis.PreActionMap = &#123; '行为2': [ '行为1', // ... ]&#125; 对于【行为2】，可能有多个行为会触发，例如针对页面渲染的场景，【RenderEnd行为】可以是Search、PageChange、SceneInit多个行为触发，这些行为都可以放到【RenderEnd行为】对应的前置行为数组。12345678window.Themis.PreActionMap = &#123; [ActionType.RenderEnd]: [ ActionType.PageChange, ActionType.Search, ActionType.SceneInit, ActionType.FilterValueChange, ]&#125; 计算顺序在计算耗时的时候，需要区分两种顺序： NEAR: 最近的触发行为去计算，如RenderEnd行为耗时的计算(RenderEnd - 最近一次触发渲染的时间) FAR: 最远的触发行为去计算，如筛选表单操作时长指标的计算（搜索开始时间 - 表单开始操作时间）1234window.Themis.CountRule = &#123; NEAR: [ActionType.RenderEnd], FAR: [ActionType.Search]&#125; 行为队列定义好行为类型和计算规则后，在触发需要打点的行为时，场景组件会将action对象push到window.Themis.ActionQueue数组中，action对象结构如下：1234567891011121314151617/** * @def &#123;object&#125; action 行为对象 * @def &#123;string&#125; action.name 行为名 必须 * @def &#123;number&#125; action.time 行为发生时间戳 必须 * @def &#123;string&#125; action.scene 所属场景 必须 * @def &#123;string&#125; action.url 所属页面 必须 location.href * @def &#123;object&#125; [action.attributes] 其他行为属性，必须是可枚举 可选 */const action = &#123; name: ActionType.FilterValueChange, time: 1605531890117, scene: 'Table' , url: 'http://cms.qa.igame.163.com/pagexxx', attributes: &#123; attr: 1 &#125;,&#125; 若用户多次触发行为，则会持续向行为队列中push action对象，该行为队列存储在本地，在满足预设的条件时会被ThemisLogger SDK收集、格式化处理并上报到服务端。 数据收集&amp;上报ThemisLogger SDK负责收集页面相关的性能数据并上报，主要工作包括： 场景行为数据收集 指标数据计算&amp;上报 异常ErrorCode捕获 请求耗时上报 页面停留时间上报该SDK可以通过Puzzle平台去接入，通过动态js下发的方式去引入SDK，无需入侵项目代码。场景指标上报场景指标上报时机可以触发场景指标上报的条件有多个，用于处理不同的场景，包括： 定时10s上报一次：最通用的上报触发条件 页面离开时触发上报：处理页面被关闭的情况 行为队列长度超过100触发上报: 用于处理数据量过大的情况定时上报、页面离开时触发上报都很好处理，难点在于如何监听行为队列长度的变化，对行为队列的修改内置在场景组件中，与SDK无直接通信，并且不希望在场景组件中耦合上报相关逻辑，保持代码职责的专一性。鉴于行为队列是一个数组，首先封装了observeArray方法对window.Themis.ActionQueue会用到的数组方法原型进行重写，这样，在对该数组进行push、pop等操作时，就可以在回调方法中去判断数据长度1234567891011121314151617181920212223242526/** * 监听数组 * @param &#123;array&#125; arr * @param &#123;function&#125; callback */export function observeArray(arr, callback) &#123; const arrayMethods = Object.create(Array.prototype); const newArrProto = []; [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse' ].forEach(method =&gt; &#123; let original = arrayMethods[method]; newArrProto[method] = function (...args) &#123; const result = original.apply(this, args); callback &amp;&amp; callback() return result; &#125; &#125;); Object.setPrototypeOf(arr, newArrProto);&#125; 此外，在SDK初始化的时候，window.Themis.ActionQueue可能尚未被初始化，针对此情况，定义了observeObj方法去监听window.Themis.ActionQueue的赋值，内部逻辑基于Object.defineProperty的setter和getter去实现。1234567891011121314151617181920212223242526272829303132333435/** * 监听对象 * @param &#123;object&#125; obj * @param &#123;string&#125; key * @param &#123;function&#125; callback */export function observoObj(obj, key, callback) &#123; if (!obj || !key) &#123; return; &#125; let newValue; Object.defineProperty(obj, key, &#123; set: function(value) &#123; newValue = value; if(Array.isArray(value)) &#123; observeArray(obj[key], callback); &#125; callback &amp;&amp; callback(newValue); &#125;, get: function() &#123; return newValue; &#125; &#125;);&#125;/** * 监听window.Themis.ActionQueue的变化 */function observeActionQueue() &#123; if (window.Themis.ActionQueue) &#123; observeArray(window.Themis.ActionQueue, onActionQueueChange); &#125; else &#123; observeObj(window.Themis, 'ActionQueue', onActionQueueChange); &#125;&#125; 场景指标计算在满足指标上报条件后，会对行为队列的数据进行计算，根据前一章定义的计算规则将其转换为Event数据结构：12345678interface IEvent &#123; name: string; // eg: 'cmsAction'｜'errorCode'|'requestTimeConsume'等 value: number; // 耗时时间戳 attributes: &#123; actionName: string; // eg: `$&#123;ActionType.Search&#125;_$&#123;ActionType.RenderEnd&#125;` ... // 其他属性 &#125;&#125; 在计算的过程中，需要对行为队列中的数据进行过滤，对于满足计算规则的行为队列上报为cmsAction类型，对于异常的行为队列也需要上报，类型为errorActionQueue，因为异常的行为队列，很可能反应了页面存在的一些问题。 请求数据处理因为CMS底层调用的fetch方法，要捕获请求耗时、异常ErrorCode、返回数据等请求相关数据，可以通过拦截fetch方法，置入功能插件去做处理，核心代码如下：123456789101112131415const interceptFetch = () =&gt; &#123; const fetch = window.fetch; window.fetch = (...args) =&gt; &#123; /** * 顺序从下向上执行 */ const config = args[1] || &#123;&#125;; const plugins = [ errorPlugin(config), dataFormatter(config), timeConsumePlugin(config), ]; return composePlugin(...plugins)(fetch.apply(window, args)); &#125;;&#125;; 设计实现了三个功能插件： timeConsumePlugin时间耗时插件 dataFormatter数据格式化插件 errorPlugin错误捕获插件 当请求发出的时候，会按顺序逐个执行功能插件，执行的顺序为：timeConsumePlugin -&gt; dataFormatter -&gt; errorPlugin，需要注意的关键点有： 在timeConsumePlugin插件中，需要通过闭包的方式去记录下当前请求的开始时间，在请求返回的时候，拿到返回时间，进而计算出请求耗时时间； dataFormatter插件对response数据处理时，不能直接调用response.json()，因为response只能做一次json处理，为了避免对CMS项目代码逻辑的影响，我们需要首先对response进行clone，再做json格式化处理，即response.clone().json()；此外，还需要注意，response返回的格式可能是blob的，不支持json转化，针对blob格式的response，做直接返回处理； errorPlugin插件负责捕获异常返回的http code，在上报收集的结果中，发现有一些已知的正常code，例如无权限异常code、未登录code，为了屏蔽这些code值对度量的影响，SDK提供了支持配置code白名单的功能； 在对请求数据的收集中，需要关注的业务相关的API，所以对于一些公共的API：日志上报、登录相关等接口，需要在上报的时候忽略这部分接口，与error code相似，SDK支持配置API白名单的功能。 监控数据可视化在收集到SDK上报的数据后，为了更好地衡量CMS平台的性能，ThemisAnalysis监控数据可视化平台对数据从不同维度做了数据聚合处理，包括指标维度、场景维度、请求维度、错误维度、页面维度等，以及抽象出CMS平台的健康模型；此外支持错误日志查询，在遇到问题的时候可以方便地查询出对应的请求数据。 健康模型健康模型综合了场景指标、请求成功率和请求耗时数据，计算出健康指数的具体得分，给开发一个比较直观的关于平台健康度的反馈。健康指数总分由场景指标性能得分、场景指标规范性、请求成功率得分、请求平均响应时间得分按照一定的占比计算得出，具体计算公式为： 健康指数总分 = 场景指标性能得分 x% + 场景指标规范性 y% + 请求成功率得分 z% + 请求平均响应时间得分 m% 各项指标具体的得分，主要是与各项指标推荐的基准值，根据我们预设的公式去计算，如果有明显不合理的地方，再去做动态调整，保证分数的合理性。以场景指标性能得分为例，简单介绍下计算方法： 场景指标性能得分 = (指标 1 得分 + 指标 2 得分 + …) / 指标数量 场景指标性能得分为所有场景指标的平均分，综合考虑了该应用相关的所有指标。其中要计算单个指标得分，首先计算出指标耗时/指标基准值的比值，再根据这个比值按照梯度线性计算而得。例如当该比值&lt;=1时，很明显得分应该为100；比值越大，说明耗时越长，页面渲染耗时越长，反映在得分上越低。 问题分析ThemisAnalysis平台会根据错误频率统计请求的高频错误，点击查看可以进一步查看错误详情，包括异常API地址、请求参数以及被影响的用户： 确认了存在的异常后，通常情况下期望可以看到用户操作的上下文，所以会将SDK上报的请求相关数据汇总，支持查询操作；通过uid可以查询到具体的某个用户的操作链路，最大程度地帮助开发复现并解决问题。除此之外，Themis项目-效能工具的开发中包括问题上报插件，目前音乐的CMS都可以使用该插件，推荐使用，入口如下：结合该插件，可以帮助我们还原问题现场，相关原理可以参考我发表的另一篇文章rrweb 带你还原问题现场。 总结本文主要介绍了CMS性能监控的方案，简要介绍了数据格式的定义、监控SDK对数据的收集以及可视化平台的实现，希望这篇文章可以在相似场景中带给你一些小小的灵感。","tags":[{"name":"Themis，CMS体验度量方案","slug":"Themis，CMS体验度量方案","permalink":"https://sherrywu0917.github.io/tags/Themis，CMS体验度量方案/"}]},{"title":"core-js3升级处理","date":"2021-10-19T03:28:58.000Z","path":"2021/10/19/core-js3升级/","text":"cms升级@babel/polyfill 删掉@babel/polyfill 升级core-js@2 到core-js@3 配置babel：在@babel/preset-env的配置中，新增corejs配置，指定版本12345678910111213 presets: [ ['@babel/preset-env', &#123; modules: false, useBuiltIns: 'usage', targets: &#123; // 根据实际情况配置 browsers: ['chrome &gt;= 62'] &#125;, corejs: &#123; version: 3, // 使用core-js@3 proposals: true, &#125;, &#125;],] 若还不行，检查下版本：babel-loader 版本升级到 8.0.0 以上，@babel/core 版本升级到 7.4.0 及以上。 参考：Babel7 转码（五）- corejs3 的更新作者的官方阐述Babel 7.4.0 版本的更新内容，及官方的升级建议core-js@2 向core-js@3 升级，官方的 Pull request","tags":[{"name":"渲染","slug":"渲染","permalink":"https://sherrywu0917.github.io/tags/渲染/"},{"name":"eventloop","slug":"eventloop","permalink":"https://sherrywu0917.github.io/tags/eventloop/"}]},{"title":"浏览器进程&EventLoop","date":"2021-08-02T03:28:58.000Z","path":"2021/08/02/渲染&EventLoop_new/","text":"浏览器进程多进程架构 浏览器单进程和多进程的架构每新开一个tab页，就会新增一个独立的浏览器进程，分配相应的CPU和内存。需要注意的是不同的浏览器有不同的优化机制，例如chrome可能会将某些进程合并，所以每一个Tab标签对应一个进程并不一定是绝对的。 进程组成每一个独立的浏览器进程包括： Browser进程（主进程） 负责浏览器界面显示，与用户交互，包括导航栏，书签，前进和后退 负责各个页面的管理，创建和销毁其他进程 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上 网络资源的管理，下载等 插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建，例如flash插件。 GPU进程：负责处理GPU相关的任务 渲染进程（浏览器内核）：负责一个 tab 内关于网页呈现的所有事情，页面渲染，脚本执行，事件处理等，包括多个线程 GUI渲染线程：负责解析 HTML,CSS,构建 DOM 树和 RenderObject 树,布局和绘制 JS引擎线程：负责处理 Javascript 脚本程序，与GUI渲染线程互斥（因为GUI渲染线程和JS引擎进程互斥，所以CSS加载会阻塞页面的渲染和JS的执行，JS的执行会阻塞DOM解析和页面渲染，但js的下载不会阻塞DOM解析和渲染） 事件触发线程：用来控制Event loop，当对应的事件符合条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 定时触发器线程：setInterval 与 setTimeout 所在线程 异步http请求线程：XMLHttpRequest 在连接后是通过浏览器新开一个线程请求 EventLoop了解了浏览器的进程和线程机制之后，可以帮助我们更好地理解Event loop的运行机制。 while(true)示例 while(true)阻止了渲染和其他的页面交互。注意：现代浏览器如chrome可能会启用GPU去处理gif的渲染，可参考Does Inifinite Javascript Loop Block The Rendering?。 loop-setTimeout示例 1234function loop() &#123; setTimeout(loop, 0);&#125;loop(); 一次只能处理一次任务，所以当它处理一个任务的时候，必须绕事件循环一圈，来接收任务队列中的下一个任务；如果有渲染任务，在任务之间会去做渲染，所以setTimeout循环没有阻止渲染。 再来看一段经典的代码，console的执行顺序应该是怎样？123456789101112131415console.log('script start');setTimeout(function () &#123; console.log('setTimeout');&#125;, 0);Promise.resolve() .then(function () &#123; console.log('promise1'); &#125;) .then(function () &#123; console.log('promise2'); &#125;);console.log('script end'); 正确的执行顺序为：script start, script end,promise1,promise2,setTimeout。 为什么是这样的顺序？想要了解为什么会是这样的执行顺序，需要先了解Event loop对宏任务(macrotask)和微任务(microtask)的处理机制。 js引擎线程负责处理js代码的执行 事件触发线程负责管理Event loop的任务队列，会将setTimeout（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等）添加到任务队列中。 宏任务：鼠标点击触发的事件、HTML解析、setTimeout、setInterval、网络请求都属于一个宏任务，在一个宏任务执行完成后，会在执行下一个宏任务执行之前触发浏览器的重新渲染。所以setTimeout会在script end之后输出，因为setTimeout属于一个新的宏任务。 微任务：微任务包括mutation observer callbacks，promise callbacks，在某一个宏任务执行完后，在重新渲染与开始下一个宏任务之前，就会将在它执行期间产生的所有微任务都执行完毕。在执行js代码时，当promise的状态变为settled，会将promise.then、promise.catch的回调添加到微任务队列中。所以promise1、promise2会在script end之后输出，但会在下一个宏任务setTimeout之前输出。 进阶版示例看下面的例子，点击中间的圆形，console会按照什么样的顺序输出呢？在线示例可以查看eventloop-demo123&lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526var outer = document.querySelector('.outer');var inner = document.querySelector('.inner');// 监听outer元素属性变化new MutationObserver(function () &#123; console.log('mutate');&#125;).observe(outer, &#123; attributes: true,&#125;);function onClick() &#123; console.log('click'); setTimeout(function () &#123; console.log('timeout'); &#125;, 0); Promise.resolve().then(function () &#123; console.log('promise'); &#125;); outer.setAttribute('data-random', Math.random());&#125;inner.addEventListener('click', onClick);outer.addEventListener('click', onClick); 正确的执行顺序为：click,promise,mutate,click,promise,mutate,timeout,timeout。Event loop执行过程 click事件首先触发inner元素的onClick事件，并且冒泡到outer元素上，将outer元素的onClick事件添加到宏任务队列中 执行inner元素的onClick函数，输出click 执行到setTimeout将其添加到宏任务队列中，此时的宏任务队列：[outer onClick, inner setTimeout] 执行到Promise.resolve()，将promise.then添加到微任务队列中，此时的微任务队列[inner promise.then] 执行到outer.setAttribute，将MutationObserver callback添加到微任务队列中，此时的微任务队列[inner promise.then, inner MutationObserver callback] onClick函数代码块执行完之后，开始按顺序执行所有的微任务队列，依次输出promise，mutate 从宏任务队列中取出outer onClick，内部执行顺序和inner一致 输出click 把setTimeout添加到宏任务队列中，此时的宏任务队列为[inner setTimeout, outer setTimeout] 依次输出promise，mutate 从宏任务队列中取出inner setTimeout，输出setTimeout 从宏任务队列中取出outer setTimeout，输出setTimeout 此外，若是通过js自动触发调用click，顺序会有什么不一样？可以通过示例EventLoop-autoClick对比手动点击触发与js自动触发click的差别。 总结最后简单总结下一次Event loop的过程： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取） REFS In The Loop - JSConf.Asia Browser Architecture 浏览器渲染过程与性能优化 MDN:Concurrency model and the event loop Accelerated Rendering in Chrome 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 (ps: MutationObserver的监听不会说同时触发多次，多次修改只会有一次回调被触发。) el元素是否会闪现一下？12document.body.appendChild(el);el.style.display = 'none'; 不会，因为js脚本作为任务的一部分必须执行结束，浏览器才会渲染。浏览器标准刷新频率60Hz，每秒更新60次。 RAF运行在处理CSS和绘制之前 无线性能优化：Composite 史上最全！图解浏览器的工作原理 CSS GPU Animation: Doing It Right Event loop: microtasks and macrotasks JavaScript Event Loop Explained","tags":[{"name":"渲染","slug":"渲染","permalink":"https://sherrywu0917.github.io/tags/渲染/"},{"name":"eventloop","slug":"eventloop","permalink":"https://sherrywu0917.github.io/tags/eventloop/"}]},{"title":"themisRecord问题录制上报","date":"2021-07-02T04:12:12.000Z","path":"2021/07/02/themisRecord问题录制上报/","text":"背景为了对用户在使用中遇到的相关问题及时给予反馈，尽快定位并解决用户遇到的使用问题。我们设计实现了问题上报工具，主要包括录制和展示两部分： ThemisRecord插件: 上报用户 uid、用户权限、API 请求&amp;结果、错误堆栈、录屏 展示平台：显示录屏回放、用户、请求和错误堆栈信息 本文主要介绍ThemisRecord问题一键上报插件的实现原理。如何接入和使用详见ThemisRecord接入使用文档。 设计方案问题一键上报插件的主要流程如下图所示，在录屏期间，插件需要分别收集用户账号信息、API请求数据、错误堆栈信息和录屏信息，并将数据上传到NOS和倾听平台。 用户账号信息用户账号信息我们都可以通过相关接口拿到，因为问题上报同时支持C端和运营后台CMS，两者属于不同的用户体系，所以在实现的时候会区分C端和CMS用户。 API请求数据Web的http请求的底层最后都会通过fetch、xhr的方式去发送请求，所以如果想要获取API的requet和response，可以从底层拦截fetch、xhr请求去实现。 错误堆栈信息错误堆栈信息可以帮助我们直观地定位到当前js出错的地方，为了实现对js运行错误的监听，首先明确js错误主要包括:1.同步错误类型error2.promise被reject之后触发的unhandledrejection可以通过window.addEventListener去监听：12window.addEventListener('error', errorEvent =&gt; &#123;&#125;);window.addEventListener('unhandledrejection', promiseRejectionEvent =&gt; &#123;&#125;); 需要注意的是errorEvent和promiseRejectionEvent两个事件对象的结构并不一致，需要针对两种错误类型进行不同的format处理。 录屏信息录屏回放基于rrweb开源库实现。rrweb提供了record和replay两个方法： record主要监听两种事件类型： DOM变化：内部基于MutationObserverAPI来监听页面DOM变化，当DOM发生变化时，会触发回调方法，将当前DOM变化通过event对象传递给事件监听者； 鼠标移动，鼠标交互，页面滚动等：通过addEventListener等事件绑定的形式去监听12345const stopFn = rrweb.record(&#123; emit(event) &#123; // 保存获取到的 event 数据 &#125;&#125;) replay负责解析拿到的事件，通过将event数组还原为DOM元素，进而还原页面的用户操作 1234const events = GET_YOUR_EVENTSconst replayer = new rrweb.Replayer(events);replayer.play(); 数据上传录屏期间产生的所有数据会存储到json文件中，结束录制后会将json文件上传到nos获得nosKey，最后将nosKey与问题描述等信息同步到倾听平台。倾听平台会根据noskey下载相关json文件，并将录屏数据可视化展示。","tags":[{"name":"react","slug":"react","permalink":"https://sherrywu0917.github.io/tags/react/"},{"name":"diff","slug":"diff","permalink":"https://sherrywu0917.github.io/tags/diff/"}]},{"title":"HTML渲染和资源加载","date":"2021-03-16T12:42:41.000Z","path":"2021/03/16/HTML渲染和资源加载/","text":"渲染树构建、布局及绘制 处理HTML标记并生成DOM树 处理CSS标记并生成CSSOM树 将DOM树和CSSOM树合成渲染树： 从 DOM 树的根节点开始遍历每个可见节点（会忽略“display: none”的元素） 对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们 发射可见节点，连同其内容和计算的样式 根据渲染树来布局，以计算每个节点的几何信息：计算它们在设备视口内的确切位置和大小 输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素 绘制：将渲染树中的每个节点转换成屏幕上的实际像素 绘制这一个过程应该是：RenderLayers渲染层 -&gt; GraphicsLayer图形层（GPU） 特殊的合成层，例如translate3d、will-change等 3D transforms：translate3d、translateZ 等 video、canvas、iframe 等元素 通过 Element.animate() 实现的 opacity 动画转换 通过 СSS 动画实现的 opacity 动画转换 position: fixed 具有 will-change 属性 对 opacity、transform、filter、backdropfilter 应用了 animation 或者 transition结论：CSS解析和DOM解析是可以并行的，二者完成后再去执行DOM渲染，但是CSS解析会阻塞JS的执行，JS的执行会阻塞DOM的解析。所以，要将CSS放在头部，JS资源放在尾部。 回流Reflow和重绘Repaint回流 页面初次渲染 添加或者删除可见的 dom 元素 元素尺寸、位置、内容发生改变 浏览器窗口大小改变 元素字体大小变化 激活 CSS 伪类（例如：:hover） 查询某些属性或调用某些方法 clientWidth、clientHeight、clientTop、clientLeft （元素可视区域的宽度） offsetWidth、offsetHeight、offsetTop、offsetLeft （元素包括滚动条的宽度） scrollWidth、scrollHeight、scrollTop、scrollLeft （元素的实际宽度） getComputedStyle() getBoundingClientRect() ({x,y,width,height,left,right,top,bottom} 其中right和bottom分别指元素相对于页面左边、上面的距离;使用document.documentElement.scrollTop和window.pageYOffset获取页面滚动的距离，window.pageYOffset IE9以下不兼容；scrollTop是该元素到视口可见内容顶部的距离，如果该元素没有垂直方向的滚动条，则该值始终为0。) scrollTo() 重绘 background color visibility border-style border-radius设置等 获取宽高的不同方式- screen.height 屏幕的高度 - screen.availHeight 浏览器窗口在屏幕上可占用的最大高度 - window.outerHeight window.innerHeight 浏览器的高度包括导航栏/不包括导航栏 - element.clientWidth offsetWidth scrollWidth 针对元素的，其中offsetTop和offsetLeft是相对于position为非static的父元素offsetParent， 如何优化 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中（virtual dom思想）。 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。 缓存布局信息避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 分离读写操作 渲染队列1234div.style.left = '10px';div.style.top = '10px';div.style.width = '10px';div.style.height = '10px'; 理论上会发生4次回流，但是实际上只会发生1次回流，因为浏览器的渲染队列机制。当我们修改了元素的几何属性时，导致浏览器的回流或重绘时，会将操作放到渲染队列中，然后在达到一定数量或者一定时间时一次性统一渲染。1234567891011div.style.left = '10px';console.log(div.offsetLeft);div.style.top = '10px';console.log(div.offsetTop);div.style.width = '20px';console.log(div.offsetWidth);div.style.height = '20px';console.log(div.offsetHeight); 会触发四次回流和重绘，因为在调用offsetLeft相关属性的时候，如果渲染队列中有数据的话，会先触发回流，因为在这样才能保证取到的数据的准确性。 为什么在DOMContentLoaded事件中添加动画不成功？DOMContentLoaded MDN上的定义： it fires when the DOM has been parsed, but before the CSSOM has been (and thus before styles have been applied)在CSSOM ready之前，所以此时css样式一定没有渲染12345678910! function() &#123; // 1. 查询offsetTop属性，强行触发回流和重绘 window.addEventListener('DOMContentLoaded', function()&#123; document.body.offsetTop; // force a CSS repaint var logo2 = document.querySelector(\"svg\"); logo2.classList.add('start'); &#125;); &#125;(); // 2. setTimeout or raf(() =&gt; raf(() =&gt; &#123;&#125;)) 改变阻塞模式：defer 与 async async 与 defer 属性对inline script是无效的。 MDN async: For classic scripts, if the async attribute is present, then the classic script will be fetched in parallel to parsing and evaluated as soon as it is available. MDN defer: This Boolean attribute is set to indicate to a browser that the script is meant to be executed after the document has been parsed, but before firing DOMContentLoaded. The defer attribute should only be used on external scripts. async文件 加载好就会立即执行—无论此刻是HTML解析阶段还是DOMContentLoaded触发之后，但会阻塞load事件。 script中代码的执行顺序不定。 执行顺序：一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。 defer文件 载入JavaScript文件时不阻塞HTML的解析，执行阶段被放到HTML标签解析完成之后 不改变script中代码的执行顺序 执行顺序：在其他没有添加defer属性的script之后执行，在DOMContentLoaded事件之前 123456console.log(document.createElement(\"script\").async); // true 动态创建的script默认是异步的。const style = document.createElement(\"link\");style.rel = \"stylesheet\"; style.href = \"index.css\";document.head.appendChild(style); // 阻塞？ 已知的是，Chrome 中已经不会阻塞渲染，Firefox、IE 在以前是阻塞的。","tags":[{"name":"渲染","slug":"渲染","permalink":"https://sherrywu0917.github.io/tags/渲染/"},{"name":"load","slug":"load","permalink":"https://sherrywu0917.github.io/tags/load/"}]},{"title":"react-hooks原理","date":"2020-12-02T04:12:12.000Z","path":"2020/12/02/react-hooks原理/","text":"TODO: https://juejin.cn/post/6944863057000529933https://www.reddit.com/r/reactjs/comments/v5ypd9/goodbye_useeffect_reactathon_2022/","tags":[{"name":"react","slug":"react","permalink":"https://sherrywu0917.github.io/tags/react/"},{"name":"hook","slug":"hook","permalink":"https://sherrywu0917.github.io/tags/hook/"}]},{"title":"react-mobx使用","date":"2020-12-02T04:12:12.000Z","path":"2020/12/02/react-mobx使用/","text":"核心 封装可观察对象——observable 1const store = observable(&#123; a: 1 &#125;); 依赖收集——派生derivation： computed表达式 when、autorun、reaction的第一个入参函数 observer组件的render方法1autorun(() =&gt; console.log(store.a); 推导——Action触发 derivation 的重新执行 1store.a = 2; // console 2 核心原理利用Object.defineProperty方法，劫持了Observable对象的get()和set()方法。 在访问Observable对象的时候，会调用get()方法，注册监听。如何绑定依赖： Observable对象调用reportObserved(this)，先将其添加到derivation监听者的可观察对象数组中observing[] derivation对象调用bindDependencies，遍历observing[]，将自身实例添加到observable对象的监听者数组中observers_ 至此，建立了双向依赖 在修改Observable对象的时候，会调用set()方法，这个时候会触发监听 Observable对象发生变化，会遍历监听者数组observers_，触发更新observe方法 显示调用addListener绑定依赖，在set()中调用notifyListeners触发更新class组件如何做到reactive1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function makeComponentReactive(render: any) &#123; if (isUsingStaticRendering() === true) return render.call(this) /** * If props are shallowly modified, react will render anyway, * so atom.reportChanged() should not result in yet another re-render */ setHiddenProp(this, skipRenderKey, false) /** * forceUpdate will re-assign this.props. We don't want that to cause a loop, * so detect these changes */ setHiddenProp(this, isForcingUpdateKey, false) const initialName = getDisplayName(this) const baseRender = render.bind(this) let isRenderingPending = false // Reaction的两个参数(name, onInvalidate) const reaction = new Reaction(`$&#123;initialName&#125;.render()`, () =&gt; &#123; if (!isRenderingPending) &#123; // N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js) // This unidiomatic React usage but React will correctly warn about this so we continue as usual // See #85 / Pull #44 isRenderingPending = true if (this[mobxIsUnmounted] !== true) &#123; let hasError = true try &#123; setHiddenProp(this, isForcingUpdateKey, true) if (!this[skipRenderKey]) Component.prototype.forceUpdate.call(this) hasError = false &#125; finally &#123; setHiddenProp(this, isForcingUpdateKey, false) if (hasError) reaction.dispose() &#125; &#125; &#125; &#125;) reaction[\"reactComponent\"] = this reactiveRender[mobxAdminProperty] = reaction this.render = reactiveRender function reactiveRender() &#123; isRenderingPending = false let exception = undefined let rendering = undefined // 调用Reaction.prototype.track方法 reaction.track(() =&gt; &#123; try &#123; // step1: 修改globalState$$1.allowStateChanges的值为false，并将之前的值保存在prev字段中， // step2: 执行baseRender()方法，结果为res // step3: 恢复globalState$$1.allowStateChanges值为prev // step4: 返回res结果，赋值给rendering rendering = _allowStateChanges(false, baseRender) &#125; catch (e) &#123; exception = e &#125; &#125;) if (exception) &#123; throw exception &#125; return rendering &#125; return reactiveRender.call(this)&#125; reaction.track流程关键代码：// 调用trackDerivedFunction方法，进一步去收集依赖，注册观察者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298Reaction$$1.prototype.track = function (fn) &#123; startBatch$$1(); // globalState$$1.inbatch++ var notify = isSpyEnabled$$1(); // !!globalState$$1.spyListeners.length var startTime; if (notify) &#123; // spy监听所有mobx中的事件（深层监听），log作用 startTime = Date.now(); spyReportStart$$1(&#123; name: this.name, type: \"reaction\" &#125;); // 触发globalState$$1.spyListeners[i][event] &#125; this._isRunning = true; var result = trackDerivedFunction$$1(this, fn, undefined); this._isRunning = false; this._isTrackPending = false; if (this.isDisposed) &#123; // disposed during last run. Clean up everything that was bound after the dispose call. clearObserving$$1(this); &#125; if (isCaughtException$$1(result)) this.reportExceptionInDerivation(result.cause); if (notify) &#123; // spy监听所有mobx中的事件（深层监听），log作用 spyReportEnd$$1(&#123; time: Date.now() - startTime &#125;); &#125; // 检查globalState$$1.pendingUnobservations数组中的observable对象是否还有观察者，即observers的长度是否为0 // 若为0，将该对象变成unobserve endBatch$$1();&#125;;/** * Executes the provided function `f` and tracks which observables are being accessed. * The tracking information is stored on the `derivation` object and the derivation is registered * as observer of any of the accessed observables. */// derivation是Reaction 或者 ComputedValue// f是render、等方法// 执行f方法，收集依赖function trackDerivedFunction$$1(derivation, f, context) &#123; // pre allocate array allocation + room for variation in deps // array will be trimmed by bindDependencies changeDependenciesStateTo0$$1(derivation); derivation.newObserving = new Array(derivation.observing.length + 100); derivation.unboundDepsCount = 0; derivation.runId = ++globalState$$1.runId; // 为什么prevTracking? var prevTracking = globalState$$1.trackingDerivation; globalState$$1.trackingDerivation = derivation; var result; if (globalState$$1.disableErrorBoundaries === true) &#123; result = f.call(context); &#125; else &#123; try &#123; result = f.call(context); &#125; catch (e) &#123; result = new CaughtException$$1(e); &#125; &#125; globalState$$1.trackingDerivation = prevTracking; bindDependencies(derivation); return result;&#125;// 如何收集依赖？// - 在访问Observable对象的时候，会调用get()方法，注册监听。如何绑定依赖：// - Observable对象的get方法中会调用`this.reportObserved()`，先将其添加到derivation观察者的可观察对象数组newObserving[]// array对象如何收集依赖？function reportObserved$$1(observable$$1) &#123; var derivation = globalState$$1.trackingDerivation; if (derivation !== null) &#123; /** * Simple optimization, give each derivation run an unique id (runId) * Check if last time this observable was accessed the same runId is used * if this is the case, the relation is already known */ if (derivation.runId !== observable$$1.lastAccessedBy) &#123; observable$$1.lastAccessedBy = derivation.runId; derivation.newObserving[derivation.unboundDepsCount++] = observable$$1; if (!observable$$1.isBeingObserved) &#123; observable$$1.isBeingObserved = true; observable$$1.onBecomeObserved(); &#125; &#125; return true; &#125; else if (observable$$1.observers.length === 0 &amp;&amp; globalState$$1.inBatch &gt; 0) &#123; queueForUnobservation$$1(observable$$1); &#125; return false;&#125;/** * diffs newObserving with observing. * update observing to be newObserving with unique observables * notify observers that become observed/unobserved */// - derivation对象调用`bindDependencies`，diff newObserving和old observing，// 1. 对于old observing中不在NewObserving中的数组，移除derivation对该对象的监听// 2. 给新增的observing，给derivation添加对每个对象的监听，将derivation添加到observable对象的监听者数组中observers_// - 至此，建立了双向依赖// - 在修改Observable对象的时候，会调用set()方法，这个时候会触发监听function bindDependencies(derivation) &#123; // invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, \"INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1\"); var prevObserving = derivation.observing; var observing = (derivation.observing = derivation.newObserving); var lowestNewObservingDerivationState = exports.IDerivationState.UP_TO_DATE; // Go through all new observables and check diffValue: (this list can contain duplicates): // 0: first occurrence, change to 1 and keep it // 1: extra occurrence, drop it var i0 = 0, l = derivation.unboundDepsCount; for (var i = 0; i &lt; l; i++) &#123; var dep = observing[i]; if (dep.diffValue === 0) &#123; dep.diffValue = 1; // 保证observing被观察者数组中前i0个都是新增的 if (i0 !== i) observing[i0] = dep; i0++; &#125; // Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined, // not hitting the condition if (dep.dependenciesState &gt; lowestNewObservingDerivationState) &#123; lowestNewObservingDerivationState = dep.dependenciesState; &#125; &#125; observing.length = i0; derivation.newObserving = null; // newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614) // Go through all old observables and check diffValue: (it is unique after last bindDependencies) // 0: it's not in new observables, unobserve it // 1: it keeps being observed, don't want to notify it. change to 0 l = prevObserving.length; while (l--) &#123; var dep = prevObserving[l]; if (dep.diffValue === 0) &#123; removeObserver$$1(dep, derivation); &#125; dep.diffValue = 0; &#125; // Go through all new observables and check diffValue: (now it should be unique) // 0: it was set to 0 in last loop. don't need to do anything. // 1: it wasn't observed, let's observe it. set back to 0 // 处理新增的observing，添加监听 while (i0--) &#123; var dep = observing[i0]; if (dep.diffValue === 1) &#123; dep.diffValue = 0; addObserver$$1(dep, derivation); &#125; &#125; // Some new observed derivations may become stale during this derivation computation // so they have had no chance to propagate staleness (#916) if (lowestNewObservingDerivationState !== exports.IDerivationState.UP_TO_DATE) &#123; derivation.dependenciesState = lowestNewObservingDerivationState; derivation.onBecomeStale(); &#125;&#125;// 如何触发依赖// - set的时候，先检查值是否发生了更新，如果更新了，就触发`this.reportChanged`方法，// - 如果有显示调用observe添加的，则hasListeners为true，也会触发notifyListeners Atom$$1.prototype.reportChanged = function () &#123; startBatch$$1(); propagateChanged$$1(this); endBatch$$1(); &#125;;/** * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly * It will propagate changes to observers from previous run * It's hard or maybe impossible (with reasonable perf) to get it right with current approach * Hopefully self reruning autoruns aren't a feature people should depend on * Also most basic use cases should be ok */// Called by Atom when its value changesfunction propagateChanged$$1(observable$$1) &#123; // invariantLOS(observable, \"changed start\"); if (observable$$1.lowestObserverState === exports.IDerivationState.STALE) return; observable$$1.lowestObserverState = exports.IDerivationState.STALE; var observers = observable$$1.observers; var i = observers.length; while (i--) &#123; var d = observers[i]; if (d.dependenciesState === exports.IDerivationState.UP_TO_DATE) &#123; if (d.isTracing !== TraceMode$$1.NONE) &#123; logTraceInfo(d, observable$$1); &#125; d.onBecomeStale(); &#125; // 修改derivation的状态，后面的shouldCompute$$1需要根据该状态判断是否需要更新 d.dependenciesState = exports.IDerivationState.STALE; &#125; // invariantLOS(observable, \"changed end\");&#125;// 调用derivation的onBecomeStale方法 -&gt; runReactions$$1 Reaction$$1.prototype.onBecomeStale = function () &#123; this.schedule(); &#125;; Reaction$$1.prototype.schedule = function () &#123; if (!this._isScheduled) &#123; this._isScheduled = true; // 将当前需要更新的reaction添加到pendingReactions数组中 globalState$$1.pendingReactions.push(this); runReactions$$1(); &#125; &#125;;/** * Magic number alert! * Defines within how many times a reaction is allowed to re-trigger itself * until it is assumed that this is gonna be a never ending loop... */// 批量更新reaction，在更新reaction的时候，可能会有新的reaction被触发。// 加了一个单次限制，最多100个reaction一起批量更新var MAX_REACTION_ITERATIONS = 100;var reactionScheduler = function (f) &#123; return f(); &#125;;function runReactions$$1() &#123; // Trampolining, if runReactions are already running, new reactions will be picked up if (globalState$$1.inBatch &gt; 0 || globalState$$1.isRunningReactions) return; reactionScheduler(runReactionsHelper);&#125;function runReactionsHelper() &#123; globalState$$1.isRunningReactions = true; var allReactions = globalState$$1.pendingReactions; var iterations = 0; // While running reactions, new reactions might be triggered. // Hence we work with two variables and check whether // we converge to no remaining reactions after a while. while (allReactions.length &gt; 0) &#123; if (++iterations === MAX_REACTION_ITERATIONS) &#123; console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0])); allReactions.splice(0); // clear reactions &#125; var remainingReactions = allReactions.splice(0); for (var i = 0, l = remainingReactions.length; i &lt; l; i++) remainingReactions[i].runReaction(); &#125; globalState$$1.isRunningReactions = false;&#125; /** * internal, use schedule() if you intend to kick off a reaction */// 调用runReaction去更新Reaction$$1.prototype.runReaction = function () &#123; if (!this.isDisposed) &#123; startBatch$$1(); this._isScheduled = false; // 根据derivation.lowestObserverState判断下是否需要更新 if (shouldCompute$$1(this)) &#123; this._isTrackPending = true; try &#123; // 触发new Reaction实例时传入的onInvalidate方法 // 对于Reaction组件是调用Component.prototype.forceUpdate方法去强制更新 this.onInvalidate(); if (this._isTrackPending &amp;&amp; isSpyEnabled$$1()) &#123; // onInvalidate didn't trigger track right away.. spyReport$$1(&#123; name: this.name, type: \"scheduled-reaction\" &#125;); &#125; &#125; catch (e) &#123; this.reportExceptionInDerivation(e); &#125; &#125; endBatch$$1(); &#125;&#125;;// Array数组依赖的收集，Object.defineProperty，属性是// 对于数据的操作，是基于ObservableArray的实例上面，ObservableArray该类自定义的一些方法被触发后，// 【spliceWithArray -&gt; notifyArraySplice ｜ 或者直接触发】 -&gt; reportChanged &amp;&amp; notifyListenersvar ENTRY_0 = createArrayEntryDescriptor(0);function createArrayEntryDescriptor(index) &#123; return &#123; enumerable: false, configurable: false, get: function () &#123; return this.get(index); &#125;, set: function (value) &#123; this.set(index, value); &#125; &#125;;&#125;function createArrayBufferItem(index) &#123; // obj的key值都会被转成string，可以通过arr[index]直接获取 Object.defineProperty(ObservableArray$$1.prototype, \"\" + index, createArrayEntryDescriptor(index));&#125; useStaticRendering我们知道可以通过使用@observer，将react组件转换成一个监听者(Reactions)，这样在被监听的应用状态变量(Observable)有更新时，react组件就会重新渲染。而对于服务端的React组件，我们只需要它被渲染一次，而不需要组件监听模型的状态。事实上，如果服务端React组件像客户端组件一样监听模型的状态变化，就会造成严重的内存泄漏问题。官方提供了useStaticRendering方法，用于避免mobx服务端渲染的内存泄漏问题; 该方法只需要在server启动时设置一次。 与Redux的区别REDUX的好处 通过action,reducer来完成应用的数据流管理，逻辑简单清晰 reducer函数式的设计，让我们代码变得可观测，可回溯 action的设计，特别适用于多数据联动的场景REDUX的弊端 啰嗦代码太多 reducer无复用性 性能优化太繁琐(当然可以引入immutable来解决，但是是不是又增加了学习成本,应用的复杂度和代码量呢) app state和store state的划分 脏检查，参考https://tech.youzan.com/mobx_vs_redux/ store数量：redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中 普通对象vsobservable对象：redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存数据，数据变化后自动处理响应的操作 状态是否可变：redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改 函数式：mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用 是否可追溯：mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易 场景辨析:基于以上区别,我们可以简单得分析一下两者的不同使用场景.mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力不从心.redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操作，由于redux不可变的特性，天然支持这些操作.mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用mobx作为组件局部状态管理器来用.","tags":[{"name":"react","slug":"react","permalink":"https://sherrywu0917.github.io/tags/react/"},{"name":"diff","slug":"diff","permalink":"https://sherrywu0917.github.io/tags/diff/"}]},{"title":"react fiber纤程","date":"2020-07-02T04:12:12.000Z","path":"2020/07/02/react-Fiber/","text":"react v16的diff算法 React Fiber 是对React核心算法的重新实现，是React团队花费了2年的研究成果。核心特性增量式渲染：the ability to split rendering work into chunks and spread it out over multiple frames. 0. react element结构React 元素（elements）是设计好的 plain object：123456789&#123; $$typeof: Symbol(react.element), // React会检测该属性，避免xss攻击 key: null, props: &#123;&#125;, ref: null, type: String | Object | Function, // 元素类型，string，function _owner: FiberNode, // 所属React Component _store: &#123; validated: false &#125;&#125; 为了避免用户模拟JSON注入xss攻击，React 0.14 修复手段是用 Symbol 标记每个 React 元素（element）：因为服务器返回的序列化JSON不支持 Symbol 类型（JSON.stringify后，symbol属性和方法会被抛弃）。所以即使服务器存在用JSON作为文本返回安全漏洞，JSON 里也不包含 Symbol.for(‘react.element’)。React 会检测 element.$$typeof，如果元素丢失或者无效，会拒绝处理该元素。特意用 Symbol.for() 的好处是 Symbols 通用于 iframes 和 workers 等环境中。一个很有趣的点：如果浏览器不支持 Symbols 怎么办？React仍然会加上 $$typeof 字段以保证一致性，但只是设置一个数字而已 —— 0xeac7。为什么？因为 0xeac7 看起来有点像 「React」 1. react fiber纤程React Fiber 是一种基于浏览器的单线程调度算法。 一种将 recocilation （递归 diff），拆分成无数个小任务的算法； 它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。 划分任务的优先级fiber是纤程颗粒化的概念，一个线程可以包含多个Fiber，主要是对react更新机制的优化。React16之前的版本，更新组件会一直占用主线程，如果组件树过大，则可能会导致浏览器失去响应。在React16中加入的fiber可以将同步任务拆解，每次执行完一小片后，都会把控制权交还给react负责任务调度的模块，如果有优先级更高的任务，就先执行高优先级的任务。 1.1 解决问题JavaScript 是单线程运行的，，同时只能做一件事情，这个和 DOS 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差。 对于’前端框架‘来说，解决这种问题有三个方向:1️⃣ 优化每个任务，让它有多快就多快。挤压CPU运算量 （Vue）2️⃣ 快速响应用户，让用户觉得够快，不能阻塞用户的交互 (React FiberNode)3️⃣ 尝试 Worker 多线程React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 Reconcilation(协调)。在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。协调是CPU密集型的操作，浏览器的渲染树构建、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行都可以看作是进程，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处: 与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。 给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正 1.2 requestIdleCallbackrequestIdleCallback：让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕。浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的: 处理用户输入事件 Javascript执行 requestAnimationFrame 调用 (会在下一次渲染之前调用) render Tree构建 布局 Layout 绘制 Paint理想的一帧时间是 16ms (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 requestIdleCallback 的回调。但是在浏览器繁忙的时候，可能不会有盈余时间，这时候requestIdleCallback回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间。所以setState触发的diff会在浏览器空闲的时候执行，即setState是批量触发的机制 任务优先级 Immediate(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断 UserBlocking(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈 Normal (5s) 应对哪些不需要立即感受到的任务，例如网络请求 Low (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知 Idle (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死 1.3 一个执行单元将它视作一个执行单元，每次执行完一个’执行单元’, React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去.执行过程是： 假设用户调用 setState 更新组件, 这个待更新的任务会先放入队列中, 然后通过 requestIdleCallback 请求浏览器调度： 123// setState的时候可以将要更新的component instance放到一个队列里，即Fiber节点，Fiber执行单元里面也有state变更相关信息updateQueue.push(updateTask);requestIdleCallback(performWork, &#123;timeout&#125;); 现在浏览器有空闲或者超时了就会调用performWork来执行任务： 12345678910111213// 1️⃣ performWork 会拿到一个Deadline，表示剩余时间function performWork(deadline) &#123; // 2️⃣ 循环取出updateQueue中的任务(这边应该是以Fiber为单位) while (updateQueue.length &gt; 0 &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123; workLoop(deadline); &#125; // 3️⃣ 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度 if (updateQueue.length &gt; 0) &#123; requestIdleCallback(performWork); &#125;&#125; workLoop 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘执行单元‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个执行单元，反之则停止执行，保存现场，等下一次有执行权时恢复。12345678910111213141516171819202122// 保存当前的处理现场let nextUnitOfWork: Fiber | undefined // 保存下一个需要处理的工作单元let topWork: Fiber | undefined // 保存第一个工作单元function workLoop(deadline: IdleDeadline) &#123; // updateQueue中获取下一个或者恢复上一次中断的执行单元 if (nextUnitOfWork == null) &#123; nextUnitOfWork = topWork = getNextUnitOfWork(); &#125; // 🔴 每执行完一个Fiber执行单元，检查一次剩余时间 // 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理 while (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123; // 下文我们再看performUnitOfWork，DFS遍历：子节点-&gt;兄弟节点-&gt;父节点 nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork); &#125; // 提交工作，下文会介绍 if (pendingCommit) &#123; commitAllWork(pendingCommit); &#125;&#125; 1.4 Fiber节点每个 VirtualDOM 节点内部现在使用 Fiber表示，Fiber的部分结构如下所示，将简单的树结构，变成了基于单链表的树结构。12345678910111213141516&#123; alternate: FiberNode|null, // 替身：指向旧树中的节点 effectTag: SideEffectTag, // 标识当前节点的副作用类型，例如节点更新、删除、移动 nextEffect: FiberNode | null, // 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来 pendingWorkPriority: PriorityLevel, // 一个数字，标记子树上待更新任务的优先级 type: any, // Fiber 类型信息 stateNode: any, // 管理 instance 自身的特性，function组件值为null return: FiberNode|null, // 指向 Fiber Tree 中的父节点 child: FiberNode|null, // 指向第一个子节点 sibling: FiberNode|null, // 指向兄弟节点 pendingProps: &#123;&#125;, // pendingProps在执行开始时设置，并在结束时设置memoizedProps。 memoizedProps: &#123;&#125;, // 当输入的pendingProps等于memoizedProps时，它表示fiber的先前输出可以重复使用，从而防止不必要的工作。 memoizedState: &#123;&#125;, // 组件实例的 state&#125; 1.5 执行顺序来看看 performUnitOfWork 的实现, 它其实就是一个深度优先的遍历：1234567891011121314151617181920212223242526272829303132/** * @params fiber 当前需要处理的节点 * @params topWork 本次更新的根节点 */function performUnitOfWork(fiber: Fiber, topWork: Fiber) &#123; // 对该节点进行处理 beginWork(fiber); // 如果存在子节点，那么下一个待处理的就是子节点 if (fiber.child) &#123; return fiber.child; &#125; // 没有子节点了，上溯查找兄弟节点 let temp = fiber; while (temp) &#123; completeWork(temp); // 到顶层节点了, 退出 if (temp === topWork) &#123; break &#125; // 找到，下一个要处理的就是兄弟节点 if (temp.sibling) &#123; return temp.sibling; &#125; // 没有, 继续上溯 temp = temp.return; &#125;&#125; 因为是单链表(A → B → C)的结构，所以在每次执行到某个节点(A → B)被中断后，下次可以从该节点(B → C)接着执行。requestIdleCallback会让一个低优先级的任务在空闲期被调用，而requestAnimationFrame会让一个高优先级的任务在下一个栈帧被调用，从而保证了主线程按照优先级执行 fiber 单元。 优先级顺序为：文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务。 因为react fiber机制，一个任务很可能执行到一半就被其他优先级更高的任务所替代，或者因为时间原因而被终止。当再次执行这个任务时，是从头开始执行一遍，就会导致组件的某些 will 生命周期可能被多次调用而影响性能。1234567891011121314function beginWork(fiber: Fiber): Fiber | undefined &#123; if (fiber.tag === WorkTag.HostComponent) &#123; // 宿主节点diff diffHostComponent(fiber) &#125; else if (fiber.tag === WorkTag.ClassComponent) &#123; // 类组件节点diff diffClassComponent(fiber) &#125; else if (fiber.tag === WorkTag.FunctionComponent) &#123; // 函数组件节点diff diffFunctionalComponent(fiber) &#125; else &#123; // ... 其他类型节点，省略 &#125;&#125; 1.6 副作用的收集和提交将所有打了 Effect 标记的节点串联起来，收集完成后再提交。在completeUnitOfWork ——&gt; completeWork方法中遍历fiber节点，将标记了EffectTag的节点通过nextEffect串联起来 1.7 两个阶段的拆分首先，看React的渲染，包括两个阶段：协调阶段(reconciliation)和提交(渲染)阶段(commit)。 调度阶段react根据数据更新virtual DOM，再运用diff算法找到需要VDOM change。这一部分的工作是可以拆分的。 constructor componentWillMount 废弃 componentWillReceiveProps 废弃 static getDerivedStateFromProps shouldComponentUpdate componentWillUpdate 废弃 render 提交阶段根据计算出的所有diff去一次性更新真实的DOM。 getSnapshotBeforeUpdate() 严格来说，这个是在进入 commit 阶段前调用 componentDidMount componentDidUpdate componentWillUnmount也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，⚠️React 协调阶段的生命周期钩子可能会被调用多次!, 例如 componentWillMount 可能会被调用两次。因此建议 协调阶段的生命周期钩子不要包含副作用. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如componentWillMount、componentWillUpdate. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移. Reconciliation完成后，会有一个旧树和一个WIP树，对于需要变更的节点，都打上了’标签’。在提交阶段，React 就会将这些打上标签的节点应用变更。 1.8 双缓冲技术WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。另外一个重要的场景就是异常的处理。你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？ 中断和恢复到目前为止：⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞但React Fiber已经实现了分片执行实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务。也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。 =》 下一步是启用 Concurrent 模式（实验版本）: 开启Concurrent 模式后，之前 deprecated 的生命周期方法就彻底不能用了。Concurrent 模式通过使渲染可中断来修复此基本限制。(React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证状态的一致性和视图的一致性，这给了 React 团队很大的考验，以致于现在都没有正式release出来。?) Concurrent Mode 快速响应用户操作和输入，提升用户交互体验 让动画更加流畅，通过调度，可以让应用保持高帧率 利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。? 用Suspense 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。? REFs: 这可能是最通俗的 React Fiber(时间分片) 打开方式 [译]以面试官的角度来看React工作面试 浅析 React Fiber 浅谈React 16中的Fiber机制 React Fiber Architecture 从 0 实现 React 系列(一)：React 的架构设计","tags":[{"name":"react","slug":"react","permalink":"https://sherrywu0917.github.io/tags/react/"},{"name":"diff","slug":"diff","permalink":"https://sherrywu0917.github.io/tags/diff/"}]},{"title":"animejs动画入门","date":"2019-12-27T03:26:12.000Z","path":"2019/12/27/animejs动画/","text":"概述anime.js是一个灵活的轻量JavaScript动画库，支持CSS属性、JS对象、DOM属性和SVG。压缩后仅6.2K，且不依赖任何第三方库，加载迅速。在git上Usedby数量8.5k, Star数量为37.5k。此外，anime遵从MIT开源协议,可应用于各种商业网站或app而无需付费。 简单的浮动动画首先看一个简单的示例，实现了气泡的上下浮动动画，效果详见浮动动画。12345678const floatAnimation = anime(&#123; targets: '.bubble', translateY: 20, // --&gt; '20px' duration: 600, loop: true, direction: 'alternate', easing: 'easeInOutSine'&#125;); 其中各个属性代表的含义如下： targets代表动画的目标对象，这边的值是css选择器，也可以是dom元素、数组，或是JS对象； translateY代表将要发生动画的属性，不带单位的时候，默认单位为px，此外还支持其他多种赋值方式： 百分比：translateY: &#39;100%&#39; 相对数值：translateY: { value: &#39;*=2.5&#39;,duration: 1000}，相对于translateY的初始值去计算 设置初始值：translateY: [100, 250]，设置数组的形式，会将translateY的初始值设置为100px，并且从100px移动到250px 函数：translateY: function(target, index, targetsLength) {return (targetsLength - index) * 50;}, target为当前动画目标元素，index为动画目标的索引，targetsLength为总动画目标数 duration代表动画的持续时间，单位为毫秒； loop定义了动画是否需要循环，默认值为false； direction的意义和animation-direction属性一致，定义是否应该轮流反向播放动画，可选的值有正向动画normal、反向动画reverse和往返动画alternate； easing定义了动画缓动函数，和css3中的animation-timing-function意义一致，设置该参数时可以参考该网站Easing Functions Cheat Sheet去选择合适的缓动函数。 点击触发抖动动画，结束后恢复浮动基于上面的漂浮动画，新增一个小功能：点击小球的时候，小球左右抖动，抖动结束后，恢复浮动动画。具体效果参见抖动动画。1234567891011121314151617181920212223const shakeAnimation = anime(&#123; targets: '.bubble', keyframes: [ &#123; translateX: '25px' &#125;, &#123; translateX: 0 &#125;, &#123; translateX: '-25px' &#125;, &#123; translateX: 0 &#125;, &#123; translateX: '15px' &#125;, &#123; translateX: 0 &#125;, &#123; translateX: '-15px' &#125;, &#123; translateX: 0 &#125; ], duration: 600, delay: 300, endDelay: 500, easing: 'linear', begin: () =&gt; &#123; floatAnimation.pause(); &#125;, complete: () =&gt; &#123; floatAnimation.play(); &#125;&#125;); 这组动画的实现有几个关键点，关键帧-keyframes、延迟设置-delay、endDelay，事件函数begin、complete以及动画控制方法play和pause。其中，keyframes是用数组定义的关键帧，和animation中用@keyframes实现动画的方式基本一致，如果关键帧内没有指定duration，则每个关键帧的持续时间将等于动画总持续时间除以关键帧数。delay和endDelay用来设置动画的延迟时间，完整的动画过程是： 先触发begin事件，暂停floatAnimation； 过了delay设置的300ms后，开始执行keyframes定义的抖动动画，持续时间是600ms； 抖动动画结束后500ms，会触发complete事件，floatAnimation会恢复执行。从start事件被触发到complete事件被触发，整个动画持续的时间为300 + 600 + 500 = 1400ms。play和pause方法用来控制动画的执行和暂停，animejs还提供了restart和reverse方法去控制动画的重新开始和反转，如果期望动画跳转到某个特定时间，可以使用seek方法去设置跳转时间。 兼容性animejs从3.x版本开始不兼容webkitTransform属性，默认只支持transform属性，在一些低版本的手机上使用，例如ios8手机上，会遇到一些动画不生效的问题。如果需要兼容这些机型，可以给animejs库增加对webkitTrannsform属性的支持，手动修改源码，重新publish一个支持webkitTransform属性的npm包。首先使用了animejs源码提供的getCSSValue方法去检测浏览器是否支持transform属性，对于不支持的，使用webkitTransform属性去替换，具体的修改可以参考下图。getCSSValue方法的实现如下：1234567function getCSSValue(el, prop, unit) &#123; if (prop in el.style) &#123; var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase(); var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0'; return unit ? convertPxToUnit(el, value, unit) : value; &#125;&#125; 关键是prop in el.style的判断，对于不支持transform属性的值，会直接返回undefined，支持该属性的会返回属性值，没有设置过transform值的默认会返回一个字符串’none’或者’0’。修改后重新发布了webkit-animejs，有需要的可以直接使用。","tags":[]},{"title":"表单和post参数总结","date":"2019-11-26T08:50:01.000Z","path":"2019/11/26/表单和post参数总结/","text":"post请求下的content-type类型: application/json12Request Payload:&#123;layouts: [&quot;1&quot;, &quot;2&quot;, &quot;5&quot;]&#125; application/x-www-form-urlencoded123456Query String ParameterssourceUuid:np_c3sEKMgU3Xau_Tl0fmsqyReIdKH9OXQpby_FSNhz__ppcy0EKQarticleUuid:np_eXoyZJwfsX-q8j5OLm0pyEbYGK0forceFollow:0isContinue:0forceAutoPurchase:1 multipart/form-data使用表单上传文件时，必须让 form 的 enctype 等于这个值。1Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryBJIFBCE2CA2Fwbyl text/xml例如XML-RPC请求。123456789&lt;?xml version=\"1.0\"?&gt;&lt;methodCall&gt; &lt;methodName&gt;examples.getStateName&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; get请求的content-type只有application/x-www-form-urlencoded这一种。 form表单中action带有参数 get表单请求1234&lt;form method=\"get\" action=\"/somePage.html?param1=foo&amp;param2=foo\"&gt; &lt;input name=\"param2\"&gt;bar&lt;/input&gt; &lt;input name=\"param3\"&gt;bar&lt;/input&gt;&lt;/form&gt; 最终得到的参数是：Query String Parametersparam2: barparam3: barget请求的表单在拼接参数的时候，会丢掉action\b指定的URL中带上的参数。 post表单请求：enctype属性默认值是’application/x-www-form-urlencoded’，还支持’multipart/form-data’和’text/plain’application/x-www-form-urlencoded1234&lt;form method=\"post\" action=\"/somePage.html?param1=foo&amp;param2=foo\"&gt; &lt;input name=\"param2\" value=\"bar\"/&gt; &lt;input name=\"param3\" value=\"baz\"/&gt;&lt;/form&gt; 最终得到的参数是：Query String Parametersparam1: fooparam2: foo Form Dataparam2: barparam3: baz text/plain1234&lt;form method=\"post\" action=\"/somePage.html?param1=foo&amp;param2=foo\" enctype=\"text/plain\"&gt; &lt;input name=\"param2\" value=\"bar\"/&gt; &lt;input name=\"param3\" value=\"baz\"/&gt;&lt;/form&gt; 最终得到的参数是：Query String Parametersparam1: fooparam2: foo Request Payloadparam2=barparam3=baz fetch的get、post请求参数 get，拼接到url上 post，参数放到body中{body: JSON.stringify({p1: 1})}","tags":[]},{"title":"代码实现Record","date":"2019-04-03T01:38:54.000Z","path":"2019/04/03/代码实现Record/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function instance(Cls, ...params) &#123; var obj = &#123;&#125;; Cls.apply(obj, params); // for(var key in Cls.prototype) &#123; // obj[key] = Cls.prototype[key]; // &#125; obj['__proto__'] = Cls.prototype; return obj&#125;function filterStr(str) &#123; let stack = []; for(var char of str) &#123; if(char !== 'b') &#123; if(char === 'c') &#123; let len = stack.length; if(stack[len -1] === 'a') &#123; stack.splice(len-2) &#125; else &#123; stack.push(char) &#125; &#125; else &#123; stack.push(char) &#125; &#125; &#125; return stack.join('');&#125;//输出0 1 2 3 4 5//https://juejin.im/post/58cf180b0ce4630057d6727c#heading-1var tasks = [];for (var i = 0; i &lt; 5; i++) &#123; (function(j) &#123; tasks.push(new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, j); resolve(); &#125;, 1000 * j); // 这里修改 0~4 的定时器时间 &#125;) ) &#125;)(i);&#125;Promise.all(tasks).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, i); &#125;, 1000)&#125;)//输出0 1 2 3 4 5var tasks = [];for (var i = 0; i &lt; 5; i++) &#123; tasks.push(((j) =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, j); resolve(); &#125;, 1000 * j); // 这里修改 0~4 的定时器时间 &#125;))(i) )&#125;Promise.all(tasks).then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(new Date, i); &#125;, 1000)&#125;)//输出0 1 2 3 4 5const sleep = (timeountMS) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(resolve, timeountMS);&#125;);(async() =&gt; &#123; for (var i = 0; i &lt; 5; i++) &#123; await sleep(1000); console.log(new Date, i); &#125; await sleep(1000); console.log(new Date, i);&#125;)()//编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];Array.from(new Set(arr.flat(Infinity))).sort((a, b) =&gt; (a - b))","tags":[]},{"title":"前端优化-蹒跚学步","date":"2019-04-03T01:38:54.000Z","path":"2019/04/03/优化之路/","text":"项目背景项目是基于React开发，webpack打包的多页面h5应用，其中部分页面又是基于React-router的SPA。开发的过程中，也一直在尝试对项目进行优化，这儿主要记录了对代码分片、持久化缓存和图片优化的处理。 优化之路漫漫，蹒跚而来。 动态加载组件Code splitting(代码分片)当前端代码越来越复杂，代码体积越来越大时，需要考虑对加载的资源进行细粒度的分割，按需加载。webpack支持两种语法实现动态地加载模块： require.ensure给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。 1require.ensure(dependencies: String[], callback: function(require), chunkName: String) import调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。 1234import( /* webpackChunkName: \"my-chunk-name\" */ /* webpackMode: \"lazy\" (default)*/ 'path/to/module') -&gt; Promise webpackChunkName用来设置chunk的名字；webpackMode默认值是lazy，还有lazy-once、eager、weak。按需加载的默认加载形式是async。 react动态加载组件在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。直接看代码：123456789101112131415161718192021222324252627282930313233343536373839import React, &#123;Component&#125; from 'react'/** * 异步加载模块 * @param &#123;[type]&#125; loadComponent [description] * @return &#123;[type]&#125; [description] */export const asyncComponent = loadComponent =&gt; ( class AsyncComponent extends Component &#123; state = &#123; Component: null, &#125; componentDidMount() &#123; if (this.hasLoadedComponent()) &#123; return; &#125; loadComponent() .then(module =&gt; module.default) .then((Component) =&gt; &#123; this.setState(&#123; Component &#125;); &#125;) .catch((err) =&gt; &#123; console.error(`Cannot load component in &lt;AsyncComponent /&gt;`); throw err; &#125;); &#125; hasLoadedComponent() &#123; return this.state.Component !== null; &#125; render() &#123; const &#123; Component &#125; = this.state; return (Component) ? &lt;Component &#123;...this.props&#125; /&gt; : null; &#125; &#125;); loadComponent参数代表import(‘module’)异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。如何调用：1export const AsyncBannerSwiper = asyncComponent(() =&gt; import(/* webpackChunkName: \"bannerSwiper\" */ './BannerSwiper.jsx')) 将BannerSwiper组件用asyncComponent封装下，就返回了一个异步加载的AsyncBannerSwiper组件，使用方法和其他组件完全一致。其中支持webpackChunkName去配置chunk的名字，不配置的情况下会默认生成[id].bundle.js。 publicPath动态设置项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。动态设置异步chunk的publicPath，在入口entry中设置webpack_public_path，打包配置文件中配置的publicPath不变。1__webpack_public_path__ = window.cdn || '/dist/'; webpack设置在webpack配置文件中，需要配置chunkFilename指定chunk的名字。1chunkFilename: '[name].js' 另外，注意webpack插件的配置：1234567new webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk idnew webpack.optimize.CommonsChunkPlugin(&#123; ... children: false, // 如果设置为 `true`，所有公共 chunk 的子模块都会被选择 ...&#125;),new ExtractTextPlugin(&#123;filename: 'css/[name].css?[contenthash:8]', allChunks: true&#125;), //从所有chunk中提取(默认情况下，它仅从initial chunk中提取) 分离前后对比使用webpack-bundle-analyzer分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。线上的资源又是开启了gzip压缩，体积就更小了。 持久化缓存为了获取持久化缓存，在配置webpack的output时，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。 moduleId VS chunkIdwebpack打包后会生成webpackJsonp等方法，用于加载chunk和module，精简的源码如下所示：123456789101112131415161718192021222324252627282930313233343536373839(function(modules) &#123; window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) &#123; var moduleId, result; for (moduleId in moreModules) &#123; //该chunk引用的所有模块 if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123; // 将chunk中所包含的模块放入modules数组中 modules[moduleId] = moreModules[moduleId]; &#125; &#125; if (executeModules) &#123; //入口module for (i = 0; i &lt; executeModules.length; i++) &#123; result = __webpack_require__(executeModules[i]); &#125; &#125; return result; &#125;; var installedModules = &#123;&#125;; // 调用__webpack_require__(moduleId)时， // 再将模块放入installedModules，用于保存已经加载过的模块 function __webpack_require__(moduleId) &#123; if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // Execute the module function: // 在执行的过程中，会递归调用`__webpack_require__`加载该模块引用的其他模块 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.l = true; return module.exports; &#125;&#125;)([]); webpackJsonp方法接收三个参数chunkIds, moreModules, executeModules，其中chunkIds属于chunkId，moreModules, executeModules都属于moduleId。 chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。 module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前__webpack_require__加载的模块，同样使用数组下标作为moduleId。每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。 固化过程初始状态以首页为例，打包后生成的index.js中会调用webpackJsonp方法，传入三个参数chunkIds, moreModules, executeModules。123456789webpackJsonp([4],&#123;/***/ 10:/***/ (function(module, exports, __webpack_require__) &#123;\"use strict\";eval(\"\");/***/ &#125;),/***/ 11:/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;\"use strict\";eval(\"/*actual code*/\");/***/ &#125;)//more code&#125;, [348]); 若此时新增一个页面，入口为”./src/entry/test.jsx”，打包后，会发现所有的js内容都发生了改变，以其中一个文件为例，发现是引用的moduleId发生了变化： 固化moduleId为了不影响其他文件，需要想办法将moduleId固定化，可以在webpack中配置NamedModulesPlugin，最新打包生成的index.js内部代码如下。和上面的代码比较，可以发现数字moduleId被替换成了文件的路径，这保证了moduleId的不变性。123456789webpackJsonp([4],&#123;/***/ \"./node_modules/babel-runtime/helpers/defineProperty.js\":/***/ (function(module, exports, __webpack_require__) &#123;\"use strict\";eval(\"\");/***/ &#125;),/***/ \"./node_modules/nw-detect/es/index.js\":/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;\"use strict\";eval(\"/*actual code*/\");/***/ &#125;)//more code&#125;, [\"./src/entry/index.jsx\"]); moduleId既然不会再变，那我们重新添加test页面，打包后是不是会只新增js呢？开心的是大部分js都没有改动，但发现还有两个js有变化，包括我们提取出的公共jscommon.bundle.js。对比下，发现文件的内容只有chunkId发生了变化： 固化chunkId再进一步，显然就是希望可以固化chunkId，webpack插件NamedChunksPlugin可以满足我们的需求，它使用webpack中唯一的entry名作为chunkId。配置好NamedChunksPlugin后，对比添加test页面前后js的变化，发现只有新增的js，已有的js都没有发生变化，注意到之前的common.bundle.js和forbidden.js发生改变的地方，代码分别如下：1234/******/ // objects to store loaded and loading chunks/******/ var installedChunks = &#123;/******/ \"common\": 0/******/ &#125;; 12webpackJsonp([\"forbidden\"],&#123; //other code chunkId都由数字变成了唯一的entry值，common对应CommonsChunkPlugin配置的name值。对于代码分离出的js，使用webpackChunkName设置chunkName，可以保证该jschunkId的稳定性。 生产环境下固化moduleId前文提到的NamedModulesPlugin，使用的是模块的相对路径，但因为相对路径偏长，生产环境更建议使用HashedModuleIdsPlugin，它会根据文件的路径去生成hash，打包后的文件更小。123webpackJsonp([\"index\"], &#123;\"+qWx\":function(e,t)&#123;e.exports=vendor&#125;,\"5AEV\" ...&#125;, [\"qwtH\"]); 最终在生产环境下需要配置下面的代码，就可以实现moduleId和chunkId的固定，使用户端的缓存更加持久。12new webpack.HashedModuleIdsPlugin(), //固化 module idnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id 图片优化图片的大小直接影响页面加载的速度，基础的优化操作有：对图片进行压缩、转base64减少http请求、使用srcset/sizes获取自适应图片等。这儿主要介绍如何结合webpack进行图片压缩，以及应用webp图片格式。 webpack loader图片压缩对图片进行压缩处理，可以选择的压缩工具有很多种，如压缩png、jpg的tinypng、智图，裁剪压缩gif的iLoveIMG；也可以安装psd的tinypng插件，以及pngquant、ImageAlpha、ImageOptim、Image Optimizer等其他压缩工具。打包压缩相比之下，配置loader或plugin打包压缩更加便捷，例如，配置好image-webpack-loader，在production模式下开启压缩，就可以在打包的时候自动压缩图片。 image-webpack-loader是基于imagemin去压缩PNG、JPEG、GIF、SVG和WEBP图片。针对不同的优化项，可以自定义参数以适配项目的需求。12345678910111213141516171819202122&#123; test: /\\.(png|jpg|gif)$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 8192, name: 'image/[hash:8].[name].[ext]' &#125; &#125;, &#123; loader: 'image-webpack-loader', options: &#123; mozjpeg: &#123; progressive: true, quality: 65 &#125;, pngquant: &#123; quality: '65-90', speed: 3 &#125; &#125; &#125;]&#125; webpack也可以支持tinypng的打包压缩，如tinypng-webpack-plugin，使用了tinypng提供的API。但需要注意的是，使用tinypng需要申请key值，每个key值每个月可以免费压缩500张，超出部分就要付费了。 响应式图片可以通过@media、image-set或者js实现根据屏幕大小获取对应的图片，更方便的方式是使用和。 srcset相同尺寸不同分辨率12&lt;img src=\"pic.png?imageView&amp;thumbnail=202y284\" srcset=\"pic.png?imageView&amp;thumbnail=202y284 2x, pic.png?imageView&amp;thumbnail=303y426 3x\"&gt; 当分辨率为3x时，会使用3x对应的pic.png?imageView&amp;thumbnail=303y426图片。没有匹配到的、或者是不支持srcset属性的浏览器会正常加载src引用的图片。结合NOS提供的图片缩略功能，只需要上传一张图片，就可以实现不同分辨率下返回不同尺寸的图片。 sizes不同尺寸1234567&lt;img srcset=\"pic-320w.jpg 320w, pic-480w.jpg 480w, pic-800w.jpg 800w\" sizes=\"(max-width: 320px) 280px, (max-width: 480px) 440px, 800px\" src=\"pic-800w.jpg\"&gt; 当屏幕宽度为450px时，满足sizes定义的媒体查询(max-width: 480px) 440px，这时候图片宽度是440px，将从srcset中匹配最接近的宽度。注意不能直接把440px和480w去比较，因为srcset中的w值不是对应的像素值，而是图片真正的宽度。如在iphone8上，分辨率是2x，440px对应的图片宽度是880w，与880w最接近的是800w，所以会去加载图片’pic-800w.jpg’，而如果是在分别率为1x的设备上，则对应440w，与480w最接近，会去加载图片pic-480w.jpg。 picture12345&lt;picture&gt; &lt;source media=\"(max-width: 799px)\" srcset=\"elva-480w-close-portrait.jpg\"&gt; &lt;source media=\"(min-width: 800px)\" srcset=\"elva-800w.jpg\"&gt; &lt;img src=\"elva-800w.jpg\" alt=\"Chris standing up holding his daughter Elva\"&gt;&lt;/picture&gt; 会按顺序加载满足条件的第一个图片，保底需要定义一个img作为默认值，已经兼容不支持标签的浏览器。source同样支持srcset和sizes属性配置多个，此外还支持type去标识不同的图片类型。1234&lt;picture&gt; &lt;source type=\"image/webp\" srcset=\"snow.webp\"&gt; &lt;img src=\"snow.png\" alt=\"Hut in the snow\"&gt;&lt;/picture&gt; 如果支持webp格式的，会去加载snow.webp，否则会去加载默认的snow.png。 HTTP Client Hints通过http client hints，浏览器发起请求的时候，可以将DPR、Width、Viewport-Width等属性发送到Server端。Chrome46开始支持Accept-CH的配置：1&lt;meta http-equiv=\"Accept-CH\" content=\"DPR, Width, Viewport-Width\"&gt; 配置完成后，页面发送的请求头部都被包含下面信息：1234Accept: image/webp,image/apng,image/*,*/*;q=0.8DPR: 3Viewport-Width: 460Width: 230 其中Width属性不是每次都被带上，它是根据Image的sizes属性计算出来的，默认还会带上Accept属性，如果支持webp格式的图片，会包含’image/webp’。Server端可以根据这些属性的值返回期望的图片：宽度为690px的webp图片。响应头会包含Content-Type、Content-DPR、Vary属性，浏览器会基于Content-DPR的值去计算图片最终展示的宽度，保证宽度仍为230px。demo如下所示。 更详细的介绍，参见automating-resource-selection-with-client-hints webp图片WebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。webp兼容性见下图其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。 检测浏览器是否支持webp格式方法1: canvas的toDataURL123456789function checkWebp() &#123; try&#123; return (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0); &#125;catch(err) &#123; return false; &#125; //or !![].map &amp;&amp; document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;&#125; 对比一下chrome和ie下document.createElement(&#39;canvas&#39;).toDataURL(&#39;image/webp&#39;)下的输出：1234//ie\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"//chrome\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\" 基于toDataURL的特性，如果请求的类型不被支持，默认返回data:image/png。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则toDataURL会返回&quot;data:,&quot;。)所以，只有支持webp格式的浏览器调用toDataURL(&#39;image/webp&#39;)后返回的字符串中才包含&#39;data:image/webp&#39;。上面提供了两种写法，其中!![].map主要是判断是否是IE9+，以免toDataURL方法会报错。 方法2: 图片onloadgoogle官网提供的，通过加载小的webp图片来判断是否支持该格式：1234567891011121314151617181920// check_webp_feature:// 'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.// 'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)function check_webp_feature(feature, callback) &#123; var kTestImages = &#123; lossy: \"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\", lossless: \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\", alpha: \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\", animation: \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\" &#125;; var img = new Image(); img.onload = function () &#123; var result = (img.width &gt; 0) &amp;&amp; (img.height &gt; 0); callback(feature, result); &#125;; img.onerror = function () &#123; callback(feature, false); &#125;; img.src = \"data:image/webp;base64,\" + kTestImages[feature];&#125; 上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。调用方法如下，可以在callback方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加webp相关的class都可以。123check_webp_feature('lossless',function(feature,result)&#123; alert(result); //true or false&#125;); 使用webp处理webp通常有两种方式： 服务端处理，支持webp图片的浏览器会在请求头Accept中加上image/webp，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了； 前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型开心的是，基于网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考https://www.163yun.com/help/documents/114078550521466880。其中，通过在url后拼接?imageView&amp;type=webp就可以获得对应的webp图片。 REFS响应式图片React（17）异步组件基于 webpack 的持久化缓存方案 https://www.imooc.com/article/21538听说你用webpack处理文件名的hash？简单易懂的 webpack 打包后 JS 的运行过程","tags":[]},{"title":"react-setState更新机制","date":"2019-04-02T02:08:50.000Z","path":"2019/04/02/react-setState更新机制/","text":"setState更新机制V16版本为例setState1234Component.prototype.setState = function (partialState, callback) &#123; !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0; this.updater.enqueueSetState(this, partialState, callback, 'setState');&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var classComponentUpdater = &#123; isMounted: isMounted, enqueueSetState: function (inst, payload, callback) &#123; var fiber = get(inst); // However, if two updates are scheduled within the same event, we // should treat their start times as simultaneous, even if the actual clock // time has advanced between the first and second call. // In other words, because expiration times determine how updates are batched, // we want all updates of like priority that occur within the same event to // receive the same expiration time. Otherwise we get tearing. // expirationTime时间决定了如何批量更新，期望是如果两个update发生在同一个event内，他们的过期时间一致 var currentTime = requestCurrentTime(); var expirationTime = computeExpirationForFiber(currentTime, fiber); // 返回一个Update节点 // &#123; // expirationTime: expirationTime, // tag: UpdateState, // payload: null, // callback: null, // next: null, // nextEffect: null // &#125; var update = createUpdate(expirationTime); // payload就是将要更新的particalState update.payload = payload; if (callback !== undefined &amp;&amp; callback !== null) &#123; &#123; warnOnInvalidCallback$1(callback, 'setState'); &#125; update.callback = callback; &#125; flushPassiveEffects(); // 将当前要更新的通过链表的形式放到fiber.updateQueue更新队列中 enqueueUpdate(fiber, update); // 在expirationTime时间内去更新，调用requestWork函数。 scheduleWork(fiber, expirationTime); &#125;, enqueueReplaceState: function (inst, payload, callback) &#123; &#125;, enqueueForceUpdate: function (inst, callback) &#123; &#125;&#125; performWork1234567891011121314151617181920212223242526272829// requestWork is called by the scheduler whenever a root receives an update.// It's up to the renderer to call renderRoot at some point in the future.function requestWork(root, expirationTime) &#123; addRootToSchedule(root, expirationTime); if (isRendering) &#123; // Prevent reentrancy. Remaining work will be scheduled at the end of // the currently rendering batch. return; &#125; if (isBatchingUpdates) &#123; // Flush work at the end of the batch. if (isUnbatchingUpdates) &#123; // ...unless we're inside unbatchedUpdates, in which case we should // flush it now. nextFlushedRoot = root; nextFlushedExpirationTime = Sync; performWorkOnRoot(root, Sync, false); &#125; return; &#125; // TODO: Get rid of Sync and use current time? if (expirationTime === Sync) &#123; performSyncWork(); &#125; else &#123; scheduleCallbackWithExpirationTime(root, expirationTime); &#125;&#125; 如果这次的setState并不是由合成事件触发的，那么isBatchingUpdates将会为false。如果为false就会直接执行performSyncWork函数了，马上对这次setState进行diff和渲染了。如果当前处在批量更新或者rendering中，直接return，不重复调用scheduleCallbackWithExpirationTime函数；会在workLoop中去检查是否还有更新任务，更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘执行单元‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个执行单元，反之则停止执行，保存现场，等下一次有执行权时恢复。123456789101112131415161718192021222324function scheduleCallbackWithExpirationTime(root, expirationTime) &#123; if (callbackExpirationTime !== NoWork) &#123; // A callback is already scheduled. Check its expiration time (timeout). if (expirationTime &lt; callbackExpirationTime) &#123; // Existing callback has sufficient timeout. Exit. return; &#125; else &#123; if (callbackID !== null) &#123; // Existing callback has insufficient timeout. Cancel and schedule a // new one. scheduler.unstable_cancelCallback(callbackID); &#125; &#125; // The request callback timer is already running. Don't start a new one. &#125; else &#123; startRequestCallbackTimer(); &#125; callbackExpirationTime = expirationTime; var currentMs = scheduler.unstable_now() - originalStartTimeMs; var expirationTimeMs = expirationTimeToMs(expirationTime); var timeout = expirationTimeMs - currentMs; callbackID = scheduler.unstable_scheduleCallback(performAsyncWork, &#123; timeout: timeout &#125;);&#125; performAsyncWork -&gt; performWork -&gt; performWorkOnRoot -&gt; renderRoot -&gt; workLoop123456789101112131415function workLoop(isYieldy) &#123; if (!isYieldy) &#123; // Flush work without yielding while (nextUnitOfWork !== null) &#123; // 如何获取下一个需要更新的Fiber节点？ // 猜测：通过dfs去遍历？ 先child -&gt; return，判断是否需要更新？ nextUnitOfWork = performUnitOfWork(nextUnitOfWork); &#125; &#125; else &#123; // Flush asynchronous work until there's a higher priority event while (nextUnitOfWork !== null &amp;&amp; !shouldYieldToRenderer()) &#123; nextUnitOfWork = performUnitOfWork(nextUnitOfWork); &#125; &#125;&#125; performUnitOfWork -&gt; updateClassComponent等diff和更新组件 -&gt; mountClassInstance|updateClassInstance|resumeMountClassInstance -&gt; processUpdateQueue去遍历fiber.updateQueue，更新payload 如何获取nextUnitOfWorkstep1: dfs先去获取需要更新的子节点child1234567891011121314151617181920212223242526272829function bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) &#123; cancelWorkTimer(workInProgress); if (current$$1 !== null) &#123; // Reuse previous context list workInProgress.contextDependencies = current$$1.contextDependencies; &#125; if (enableProfilerTimer) &#123; // Don't update \"base\" render times for bailouts. stopProfilerTimerIfRunning(workInProgress); &#125; // Check if the children have any pending work. // 通过childExpirationTime时间去检查当前Fiber节点的children是否有更新任务 // 如果children需要更新，返回child var childExpirationTime = workInProgress.childExpirationTime; if (childExpirationTime &lt; renderExpirationTime) &#123; // The children don't have any work either. We can skip them. // TODO: Once we add back resuming, we should check if the children are // a work-in-progress set. If so, we need to transfer their effects. return null; &#125; else &#123; // This fiber doesn't have work, but its subtree does. Clone the child // fibers and continue. cloneChildFibers(current$$1, workInProgress); return workInProgress.child; &#125;&#125; step2: dfs先访问兄弟节点siblings，遍历完siblings，再返回父节点return123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175function completeUnitOfWork(workInProgress) &#123; // Attempt to complete the current unit of work, then move to the // next sibling. If there are no more siblings, return to the // parent fiber. while (true) &#123; // The current, flushed, state of this fiber is the alternate. // Ideally nothing should rely on this, but relying on it here // means that we don't need an additional field on the work in // progress. var current$$1 = workInProgress.alternate; &#123; setCurrentFiber(workInProgress); &#125; var returnFiber = workInProgress.return; var siblingFiber = workInProgress.sibling; if ((workInProgress.effectTag &amp; Incomplete) === NoEffect) &#123; if (true &amp;&amp; replayFailedUnitOfWorkWithInvokeGuardedCallback) &#123; // Don't replay if it fails during completion phase. mayReplayFailedUnitOfWork = false; &#125; // This fiber completed. // Remember we're completing this unit so we can find a boundary if it fails. nextUnitOfWork = workInProgress; if (enableProfilerTimer) &#123; if (workInProgress.mode &amp; ProfileMode) &#123; startProfilerTimer(workInProgress); &#125; nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime); if (workInProgress.mode &amp; ProfileMode) &#123; // Update render duration assuming we didn't error. stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false); &#125; &#125; else &#123; nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime); &#125; if (true &amp;&amp; replayFailedUnitOfWorkWithInvokeGuardedCallback) &#123; // We're out of completion phase so replaying is fine now. mayReplayFailedUnitOfWork = true; &#125; stopWorkTimer(workInProgress); resetChildExpirationTime(workInProgress, nextRenderExpirationTime); &#123; resetCurrentFiber(); &#125; if (nextUnitOfWork !== null) &#123; // Completing this fiber spawned new work. Work on that next. return nextUnitOfWork; &#125; if (returnFiber !== null &amp;&amp; // Do not append effects to parents if a sibling failed to complete (returnFiber.effectTag &amp; Incomplete) === NoEffect) &#123; // Append all the effects of the subtree and this fiber onto the effect // list of the parent. The completion order of the children affects the // side-effect order. if (returnFiber.firstEffect === null) &#123; returnFiber.firstEffect = workInProgress.firstEffect; &#125; if (workInProgress.lastEffect !== null) &#123; if (returnFiber.lastEffect !== null) &#123; returnFiber.lastEffect.nextEffect = workInProgress.firstEffect; &#125; returnFiber.lastEffect = workInProgress.lastEffect; &#125; // If this fiber had side-effects, we append it AFTER the children's // side-effects. We can perform certain side-effects earlier if // needed, by doing multiple passes over the effect list. We don't want // to schedule our own side-effect on our own list because if end up // reusing children we'll schedule this effect onto itself since we're // at the end. var effectTag = workInProgress.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect list. // PerformedWork effect is read by React DevTools but shouldn't be committed. if (effectTag &gt; PerformedWork) &#123; if (returnFiber.lastEffect !== null) &#123; returnFiber.lastEffect.nextEffect = workInProgress; &#125; else &#123; returnFiber.firstEffect = workInProgress; &#125; returnFiber.lastEffect = workInProgress; &#125; &#125; if (true &amp;&amp; ReactFiberInstrumentation_1.debugTool) &#123; ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress); &#125; if (siblingFiber !== null) &#123; // If there is more work to do in this returnFiber, do that next. return siblingFiber; &#125; else if (returnFiber !== null) &#123; // If there's no more work in this returnFiber. Complete the returnFiber. workInProgress = returnFiber; continue; &#125; else &#123; // We've reached the root. return null; &#125; &#125; else &#123; if (enableProfilerTimer &amp;&amp; workInProgress.mode &amp; ProfileMode) &#123; // Record the render duration for the fiber that errored. stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false); // Include the time spent working on failed children before continuing. var actualDuration = workInProgress.actualDuration; var child = workInProgress.child; while (child !== null) &#123; actualDuration += child.actualDuration; child = child.sibling; &#125; workInProgress.actualDuration = actualDuration; &#125; // This fiber did not complete because something threw. Pop values off // the stack without entering the complete phase. If this is a boundary, // capture values if possible. var next = unwindWork(workInProgress, nextRenderExpirationTime); // Because this fiber did not complete, don't reset its expiration time. if (workInProgress.effectTag &amp; DidCapture) &#123; // Restarting an error boundary stopFailedWorkTimer(workInProgress); &#125; else &#123; stopWorkTimer(workInProgress); &#125; &#123; resetCurrentFiber(); &#125; if (next !== null) &#123; stopWorkTimer(workInProgress); if (true &amp;&amp; ReactFiberInstrumentation_1.debugTool) &#123; ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress); &#125; // If completing this work spawned new work, do that next. We'll come // back here again. // Since we're restarting, remove anything that is not a host effect // from the effect tag. next.effectTag &amp;= HostEffectMask; return next; &#125; if (returnFiber !== null) &#123; // Mark the parent fiber as incomplete and clear its effect list. returnFiber.firstEffect = returnFiber.lastEffect = null; returnFiber.effectTag |= Incomplete; &#125; if (true &amp;&amp; ReactFiberInstrumentation_1.debugTool) &#123; ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress); &#125; if (siblingFiber !== null) &#123; // If there is more work to do in this returnFiber, do that next. return siblingFiber; &#125; else if (returnFiber !== null) &#123; // If there's no more work in this returnFiber. Complete the returnFiber. workInProgress = returnFiber; continue; &#125; else &#123; return null; &#125; &#125; &#125; // Without this explicit null return Flow complains of invalid return type // TODO Remove the above while(true) loop // eslint-disable-next-line no-unreachable return null;&#125; 如果数据的到达速度快于帧速率，我们可以合并和批量更新如果当前处于更新中，新的setState更新就会被push到dirtyComponent中，所以setState是异步的。 V15版本为例step1: setStateReactBaseClassses.js1234567ReactComponent.prototype.setState = function (partialState, callback) &#123; // 将setState事务放进队列中 this.updater.enqueueSetState(this, partialState); if (callback) &#123; this.updater.enqueueCallback(this, callback, 'setState'); &#125;&#125;; 调用enqueueSetState将要更新的部分状态值partialState放入队列中，再将callback放到callback队列中。 step2: enqueueSetState1234567891011enqueueSetState: function (publicInstance, partialState) &#123; // 获取当前组件的instance，Q: 这边为啥有一个'setState' var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState'); // 将要更新的state放入一个数组里 var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); queue.push(partialState); // 将要更新的component instance也放在一个队列里 enqueueUpdate(internalInstance);&#125; 这段代码可以得知，enqueueSetState 做了两件事：1、将新的state放进数组里2、用enqueueUpdate来处理将要更新的实例对象partialState被放到一个数组中去维护，这个方法会获取当前组件的实例，即需要更新的组件，也放入到队列中。 step3: enqueueUpdateReactUpdates.js123456789function enqueueUpdate(component) &#123; // 如果没有处于批量创建/更新组件的阶段，则处理update state事务 if (!batchingStrategy.isBatchingUpdates) &#123; batchingStrategy.batchedUpdates(enqueueUpdate, component); return; &#125; // 如果正处于批量创建/更新组件的过程，将当前的组件放在dirtyComponents数组中 dirtyComponents.push(component);&#125; 如果isBatchingUpdates标志位是true，说明当前正处于组件更新的阶段，就不会立刻去更新组件，而是将当前组件实例push到dirtyComponents数组中；反之，立刻触发更新。所以，不是每一次的setState都会同步更新组件，setState是一个异步的过程，它会集齐一批需要更新的组件然后一起更新。 step4: batchingStrategyReactDefaultBatchingStrategy.js123456789101112131415161718var ReactDefaultBatchingStrategy = &#123; // 用于标记当前是否处于批量更新 isBatchingUpdates: false, // 当调用这个方法时，正式开始批量更新 batchedUpdates: function (callback, a, b, c, d, e) &#123; var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates; ReactDefaultBatchingStrategy.isBatchingUpdates = true; // 如果当前事务正在更新过程中，则调用callback，即enqueueUpdate if (alreadyBatchingUpdates) &#123; return callback(a, b, c, d, e); &#125; else &#123; // 否则执行更新事务 return transaction.perform(callback, null, a, b, c, d, e); &#125; &#125;&#125;; 调用batchedUpdates方法去批量更新的时候，还是会先去判断当前事务是否处于更新过程中，如果是，则调用传入的enqueueUpdate方法，将组件实例push到dirtyComponents中。反之，去执行批量更新。 step5: transaction1234567891011121314151617181920212223242526/** * &lt;pre&gt; * wrappers (injected at creation time) * + + * | | * +-----------------|--------|--------------+ * | v | | * | +---------------+ | | * | +--| wrapper1 |---|----+ | * | | +---------------+ v | | * | | +-------------+ | | * | | +----| wrapper2 |--------+ | * | | | +-------------+ | | | * | | | | | | * | v v v v | wrapper * | +---+ +---+ +---------+ +---+ +---+ | invariants * perform(anyMethod) | | | | | | | | | | | | maintained * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt; * | | | | | | | | | | | | * | | | | | | | | | | | | * | | | | | | | | | | | | * | +---+ +---+ +---------+ +---+ +---+ | * | initialize close | * +-----------------------------------------+ * &lt;/pre&gt; */ transaction对象暴露了一个perform方法，传入的anyMethod，都会被wrapper包裹，每次先执行完所有wrapper的initialize方法，再去执行anyMethod，最后去执行所有wrapper的close方法。在ReactDefaultBatchingStrategy.js,tranction 的 wrapper有两个 FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES。12345678910111213var RESET_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: function () &#123; ReactDefaultBatchingStrategy.isBatchingUpdates = false; &#125;&#125;;var FLUSH_BATCHED_UPDATES = &#123; initialize: emptyFunction, close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)&#125;;var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]; 两个wrapper的initialize方法都是空的，在callback之后，FLUSH_BATCHED_UPDATES会循环所有dirtyComponent(批量更新过程中push进来的所有组件),调用updateComponent来执行所有的生命周期方法：componentWillReceiveProps，componentShouldUpdate，componentWillUpdate，render，componentDidUpdate，完成更新，并且并执行它的pendingCallbacks，即setState设置的callback；RESET_BATCHED_UPDATES会将isBatchingUpdates标志位置为false，FLUSH_BATCHED_UPDATES 是执行flushBatchedUpdates，。 REFS: https://imweb.io/topic/5b189d04d4c96b9b1b4c4ed6 react合成事件中的setStatereact的合成事件还是会通过 ReactUpdates.batchedUpdates 去批量更新，ReactUpdate中的batchedUpdates，还是调用了batchingStrategy的batchedUpdates方法。如果在事件中调用setState方法，也会进入dirtyComponent流程，即所谓的异步。1234function batchedUpdates(callback, a, b, c, d, e) &#123; ensureInjected(); return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);&#125; 原生事件绑定和setTimeout中setState原生事件绑定不会通过合成事件的方式处理，自然也不会进入更新事务的处理流程。setTimeout也一样，在setTimeout回调执行时已经完成了原更新组件流程，不会放入dirtyComponent进行异步更新，其结果自然是同步的。 在组件生命周期中或者react事件绑定中，setState是通过异步更新的。在延时的回调(promise.then、setTimeout)或者原生事件绑定的回调中调用setState不一定是异步的。https://blog.logrocket.com/simplifying-state-management-in-react-apps-with-batched-updates/ setState为什么设计为异步？1.保证内部的一致性假设state是同步更新的，下面的代码可以按预期工作。12345console.log(this.state.value) // 0this.setState(&#123; value: this.state.value + 1 &#125;);console.log(this.state.value) // 1this.setState(&#123; value: this.state.value + 1 &#125;);console.log(this.state.value) // 2 然而，这时你需要将状态提升到父组件this.props.onIncrement()，以供多个兄弟组件共享。再重复上述代码：12345console.log(this.props.value) // 0this.props.onIncrement();console.log(this.props.value) // 0this.props.onIncrement();console.log(this.props.value) // 0 输出和预期不一致，state虽然立即更新了，但没有重新渲染父组件的时候，this.props属性并没有立即更新。如果要立即更新this.props，则要放弃批处理(根据情况的不同，性能可能会有显著的下降)。 2.性能优化React 会依据不同的调用源，给不同的 setState() 调用分配不同的优先级。调用源包括事件处理、网络请求、动画等。假设你在一个聊天窗口，你正在输入消息，TextBox 组件中的 setState() 调用需要被立即应用。然而，在你输入过程中又收到了一条新消息。更好的处理方式或许是延迟渲染新的 MessageBubble 组件，从而让你的输入更加顺畅，而不是立即渲染新的 MessageBubble 组件阻塞线程，导致你输入抖动和延迟。 3.更多的可能性异步更新 state 是有可能实现下面这种设想的前提。假设你从一个页面导航到到另一个页面，你只需要简单的调用 setState() 去渲染一个新的页面，React “在幕后”开始渲染这个新的页面。想象一下，不需要你写任何的协调代码，如果这个更新花了比较长的时间，你可以展示一个加载动画，否则在新页面准备好后，让 React 执行一个无缝的切换。此外，在等待过程中，旧的页面依然可以交互，但是如果花费的时间比较长，你必须展示一个加载动画。 react状态管理 区分local state、global state、global store props实现状态共享 context API实现全局状态，例如userId、theme、language等 render function作为props的方式 react children方式 react高阶组件实现状态共享 redux、mobx状态管理 setState注意点 调用完，最新的值通过this.state通常是拿不到的 多次调用setState","tags":[{"name":"react","slug":"react","permalink":"https://sherrywu0917.github.io/tags/react/"},{"name":"setState","slug":"setState","permalink":"https://sherrywu0917.github.io/tags/setState/"}]},{"title":"JS栈内存堆内存","date":"2019-03-20T03:20:08.000Z","path":"2019/03/20/JS栈内存堆内存/","text":"JS栈内存堆内存栈存放简单变量，堆存放复杂对象，池存放常量(常量池，一般也归为栈)。 变量类型与内存的关系基本数据类型基本数据类型共有7种： String Number Boolean null undefined Symbol BigInt基本数据类型保存在栈内存中，因为基本数据类型占用空间小、大小固定，通过按值来访问，属于被频繁使用的数据。PS: 需要注意的是闭包中的基本数据类型变量不保存在栈内存中，而是保存在堆内存中。这个问题，我们后文再说。 引用数据类型Array,Function,Object…可以认为除了上文提到的基本数据类型以外，所有类型都是引用数据类型。引用数据类型存储在堆内存中，因为引用数据类型占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 栈内存和堆内存的优缺点 基本数据类型变量大小固定，并且操作简单容易，所以把它们放入栈中存储。 引用类型变量大小不固定，所以把它们分配给堆中，让他们申请空间的时候自己确定大小，这样把它们分开存储能够使得程序运行起来占用的内存最小。 栈内存由于它的特点，所以它的系统效率较高。 堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈。 栈内存和堆内存的垃圾回收 栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收 闭包和堆内存闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量。12345678function A() &#123; let a = 1; function B() &#123; console.log(a); &#125; return B;&#125;let res = A(); 函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。函数 A 弹出调用栈后，函数 A 中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。 内存回收标记清除算法标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。工作流程： 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。 从根部出发将能触及到的对象的标记清除。 那些还存在标记的变量被视为准备删除的变量。 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。 内存泄露排查 内存泄露：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。 JavaScript内存泄露垃圾回收语言的内存泄漏主因是不需要的引用。大部分垃圾回收语言用的算法称之为 Mark-and-sweep 。算法由以下几步组成： 垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）； 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。 四种常见的JavaScript内存泄漏类型： 意外的window全局变量 被遗忘的计时器或回调函数 脱离 DOM 的引用id为main的DOM节点虽然已经从文档中删除，但elements仍持有对该节点的引用，导致这块内存无法被回收。 闭包 实例分析浏览器performance切换到该tab下，勾选memory，并点击记录按钮，不断点击阅读下一章，持续一段时间。三种迹象显示出现了内存泄漏，图中的 Nodes（绿线）、Listeners（黄线）和 JS heap（蓝线）。Nodes、Listeners稳定增长，并未下降，这是个显著的信号。 浏览器 heap profile切换到memory tab下，等待页面刷新完成，点击take heap snapshot保存当前快照。切换到下一章节，重复之前操作，保存快照。选择Comparison，将快照与之前的进行对比，可以发现有的对象如content只增不减。仔细分析代码，发现Content组件中有注册事件代理，监听fontChange事件变化，作为一个SPA，EventProxy一直存在于内存中，每次创建新的content时候，都会给fontChange事件新注册一个回调方法，之前的回调方法一直保存在回调数组中，没有被回收，导致content组件也不能被正确回收：1234567891011121314151617const eventProxy = &#123; //... off: function(key) &#123; this.onObj[key] = []; this.oneObj[key] = []; &#125;, //...&#125;componentDidMount() &#123; EventProxy.on('fontChange', diff =&gt; this.handleFontChange(diff));&#125;componentWillUnmount() &#123; EventProxy.off('fontChange'); //Release memory this.listener &amp;&amp; window.removeEventListener('scroll', this.listener, false); //Release memory&#125; 调用EventProxy.off(&#39;fontChange&#39;)解除eventProxy对象对this.handleFontChange的引用，这样this对应的content的对象才能被正确回收；和removeEventListener一样的原理。1234567this.listener = () =&gt; &#123; if(this.contentWrap &amp;&amp; (window.pageYOffset &gt; this.contentWrap.offsetHeight / 2)) &#123; //... window.removeEventListener('scroll', this.listener, false); //Release memory(事件不一定被触发) &#125;&#125;window.addEventListener('scroll', this.listener, false) 虽然在this.listener内部有解除scroll事件监听的代码，但是要满足一定条件才会触发，所以在componentWillUnmount方法中也添加了removeEventListener，实现对scroll事件的解绑。 经过上面的优化后，再次对比，发现content对象可以被正常回收。 REFs: https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/","tags":[]},{"title":"打点实践总结","date":"2019-03-07T03:02:29.000Z","path":"2019/03/07/打点实践总结/","text":"beacon 请求方法均为POST，且不支持修改兼容性 https://caniuse.com/#search=beacon polyfill https://github.com/kronicker/sendbeacon-polyfill/blob/master/sendbeacon.js https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon 如何在 Web 关闭页面时发送 Ajax 请求 [译] 使用 Web Beacon API 记录活动 post请求content-type: application/jsonRequest Payload:{layouts: [“1”, “2”, “5”]} application/x-www-form-urlencodedQuery String ParameterssourceUuid:np_c3sEKMgU3Xau_Tl0fmsqyReIdKH9OXQpby_FSNhz__ppcy0EKQarticleUuid:np_eXoyZJwfsX-q8j5OLm0pyEbYGK0forceFollow:0isContinue:0forceAutoPurchase:1 multipart/form-data使用表单上传文件时，必须让 form 的 enctype 等于这个值。Content-Type: multipart/form-data; boundary=—-WebKitFormBoundaryBJIFBCE2CA2Fwbyl","tags":[]},{"title":"react-diff算法","date":"2019-03-02T02:19:17.000Z","path":"2019/03/02/react-diff算法/","text":"react v15的diff算法React diff 会帮助我们计算出Virtual DOM中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染，因此 Virtual DOM 与 diff 是保证 React 性能口碑的幕后推手。 React diff 前提 Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。-&gt; 所以，只比较同一层级的。tree diff 拥有相同类的两个组件会生成相似的树结构，反之生成不同的树结构。-&gt; component diff 对于同一层级的子节点，添加唯一key值区分。-&gt; element diffReact基于上述三大策略，将O(n^3) 复杂度的问题转换成 O(n) 。 tree diff通过updateDepth对Virtual DOM 树进行层级控制，只会对同一层级下的同一父节点的子节点进行比较。当出现跨层级的DOM移动操作时，会新建节点，不会去移动，所以React建议不进行DOM节点跨层级的操作。 component diff 如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。 对于同一类型的组件，允许用户通过shouldComponentUpdate()来判断组件是否diff，以及PureComponent的shouldComponentUpdate的shallowEqual element diff对于同一层级的节点，React diff提供了三种节点操作：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。使用设置唯一key的方式进行优化，首先对新集合的点进行遍历，对于已经存在的点，判断当前节点在老集合中的位置child._mountIndex是否小于lastIndex(表示访问过的节点在老集合中最右的位置)，若小于，说明该节点在新集合中的位置靠后，则移动该节点；反之，则不动。对于不存在的点，则创建该节点。新集合的点diff遍历完成后，需要再遍历老集合，删去老集合中存在但新集合中不存在的点。PS: 在遍历之前，会先更新节点的子元素和创建新元素，最终返回的就是待遍历的新集合 ##REFs:React 源码剖析系列 － 不可思议的 react diff Diffing 算法（reconciliation协调） 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态 对比不同类型的元素：当根节点为不同类型的元素时，React会拆卸原有的树并且建立起新的树。当拆卸一棵树时，React 会销毁 Counter 组件并且重新装载一个新的组件。 对比同一类型的DOM元素：React 会保留 DOM 节点，仅比对及更新有改变的属性 对比同类型的组件元素：当一个组件更新时，组件实例保持不变，这样 state 在跨越不同的渲染时保持一致 对子节点进行递归：当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。给子节点添加key值由于 React 依赖探索的算法，因此当以下假设没有得到满足，性能会有所损耗。 该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。 Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失。","tags":[{"name":"react","slug":"react","permalink":"https://sherrywu0917.github.io/tags/react/"},{"name":"diff","slug":"diff","permalink":"https://sherrywu0917.github.io/tags/diff/"}]},{"title":"react相关问题","date":"2019-01-29T07:38:28.000Z","path":"2019/01/29/react相关问题/","text":"什么是JSX?——浏览器是如何识别它的？JSX是facebook普及的一种标记语言，通过babel/TSC等工具会编译为React.createElementfunction。所以在React每个组件中，虽然没有显式用到React，但都需要import React from &#39;react&#39;。 JSX是如何区分React Component和HTML元素的？通过元素首字母的大小写，如果首字母大写，则认为是React组件，小写的话则会被认为是HTML元素。可以在online Babel compiler中试一下。123456789101112function hello() &#123; return &lt;div&gt;Hello world!&lt;/div&gt;;&#125;// after babel compilerfunction hello() &#123; return React.createElement( \"div\", null, \"Hello world!\" );&#125; 123456789101112function hello() &#123; return &lt;div&gt;Hello world!&lt;/div&gt;;&#125;// after babel compilerfunction hello() &#123; return React.createElement( Div, null, \"Hello world!\" );&#125; 此外，把一个组件赋给this.component并且写&lt;this.component /&gt;也会起作用。 react16生命周期Mounting constructor() static getDerivedStateFromProps() render() componentDidMount 子类必须在构造函数第一行执行super(props)，否则我们无法在构造函数里拿到this对象，因为子类的实例要通过父类的构造函数完成塑造，得到与父类实例相同的属性和方法。es6的继承是先将是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）不建议使用UNSAFE_componentWillMount()，因为它是在render之前执行，所以不会触发重新渲染。在该方法内调用setState会和constructor里的初始化state合并执行，应该放到constructor中去初始化。 Updating static getDerivedStateFromProps(nextProps, prevState) //会返回一个对象来更新当前的state对象 shouldComponentUpdate() render() getSnapshotBeforeUpdate(prevProps, prevState) 在dom更新前，可以捕获之前的滚动位置，便于在componentDidUpdate中去恢复 componentDidUpdate(prevProps, prevState, snapshot) 在dom更新后,snapshot的值是getSnapshotBeforeUpdate的返回值 不建议使用UNSAFE_componentWillReceiveProps()和UNSAFE_componentWillUpdate()，一次更新可能会调用多次。UNSAFE_componentWillReceiveProps()经常会带来bug和不一致的问题，例如在该方法中设置input值，当父组件更新的时候，用户的输入就会被置空。1234567891011121314151617class EmailInput extends Component &#123; state = &#123; email: this.props.email &#125;; render() &#123; return &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.email&#125; /&gt;; &#125; handleChange = event =&gt; &#123; this.setState(&#123; email: event.target.value &#125;); &#125;; componentWillReceiveProps(nextProps) &#123; // This will erase any local state updates! // Do not do this. this.setState(&#123; email: nextProps.email &#125;); &#125;&#125; Unmounting componentWillUnmount() getDerivedStateFromProps(nextProps, prevState)每次render之前都会被触发，例如在挂载时、接收到新的props、调用了setState和forceUpdate都会触发，与componentWillReceiveProps只在父组件rerender时会触发不一样。此外，getDerivedStateFromProps方法不建议经常使用，使用前想一想是否有替代方案。 错误捕获 static getDerivedStateFromError(error) componentDidCatch(error, info)错误边界(Error Boundaries) 仅可以捕获其子组件的错误。使用static getDerivedStateFromError()在抛出错误后渲染回退UI。 使用 componentDidCatch() 来记录错误信息。 异步加载React V16.6引入的新特性lazy，以及React-loadable库。 getDerivedStateFromProps应用加分题：数据获取为什么用 componentDidMount 而不是 constructor？你希望听到的两个原因会是：“在渲染发生之前数据不会存在” —— 虽然不是主要原因，但它向您显示该人员了解组件的处理方式; “在 React Fiber 中使用新的异步渲染……” —— 有人一直在努力学习。 r1: SSR模式下，componentWillMount在server端也是会被调用的，内容返回到client端后，componentWillMount会被第二次调用，如果在componentWillMount中处理数据获取则会被调用两次。 r2: 在componentWillMount中调用setState不会触发rerender，所以一般不会被用来获取数据。 r3: React16之后采用了Fiber架构，类似ComponentWillMount的生命周期钩子都有可能执行多次，所以不在这些生命周期中做有副作用的操作，比如请求数据。 r4: constructor用来初始化组件，作用应该保持纯粹，不应该引入数据获取这种有副作用的操作。 react事件注册分发事件注册的时候，react 把所有事件都委托到了document上，减少注册事件的数量，降低内存占用。事件被触发后： 冒泡到document处，找到触发的dom和对应的react component 当前触发的事件会被加入batchedUpdates批处理队列中 在事件队列中，事件分发的核心handleTopLevel保证了子元素在父元素前面（此处分析的是trapBubbledEvent）。 事件执行的时候，首先找到合适的plugin（v16版本有5种）构造对应的合成事件，第一次触发new 创建的事件对象会放到缓存池中，下次直接从对象池中取。 最后，就是拿到与事件相关的元素实例和回调函数。 onClickCapture如果想要注册捕获事件，可以使用onClickCapture。但React的合成事件都是统一注册在document元素上的，且只有冒泡阶段，但合成事件会区分捕获和冒泡两种类型，来保证合成事件的执行顺序。此外，原生事件的执行都会早于合成事件的执行，因为合成事件都要等到事件冒泡到document上，才会执行。执行顺序是：原生捕获事件 -&gt; 原生事件冒泡 -&gt; 合成事件捕获 -&gt; 合成事件冒泡 react 源码Component和PureComponent比较React组件继承了Component或者PureComponent，这两个父类的定义在ReactBaseClasses.js中。12345678910111213141516171819function ComponentDummy() &#123;&#125;ComponentDummy.prototype = Component.prototype;/** * Convenience component with default shallow equality check for sCU. */function PureComponent(props, context, updater) &#123; this.props = props; this.context = context; // If a component has string refs, we will assign a different object later. this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue;&#125;const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());pureComponentPrototype.constructor = PureComponent;// Avoid an extra prototype jump for these methods.Object.assign(pureComponentPrototype, Component.prototype);pureComponentPrototype.isPureReactComponent = true; 从源码上看PureComponent继承了Component，新增了isPureReactComponent变量。在shouldComponentUpdate函数中，可以看到如果isPureReactComponent为true，会shollow比较新旧props和state是否相等，都相等的话会返回false。而Component始终会返回true。12345if (type.prototype &amp;&amp; type.prototype.isPureReactComponent) &#123; return ( !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) );&#125; 在使用PureComponent时要注意： 尽量不要在render函数中给子组件绑定新的函数，如下面1&lt;ChildComponent onclick=&#123;() =&gt; this.handleClick()&#125;/&gt; 这样每次render都会创建一个新的函数，改变了子组件的props参数，使子组件重新渲染。 尽量不要在render方法内生成数据生成新的数据，例如新的list数组，也会带来不必要的重新渲染。1234let list = [xxx];...&#123;list.map(item =&gt; (&lt;LiItem value=&#123;item&#125;/&gt;))&#125;&lt;ChildComponent onclick=&#123;() =&gt; this.handleClick()&#125;/&gt; 因此相比于 Component ，PureComponent 有性能上的更大提升： 减少了组件无意义的重渲染（当 state 和 props 没有发生变化时），当结合 immutable 数据时其优更为明显； 隔离了父组件与子组件的状态变化； 若是数组和对象等引用类型，则要引用不同，才会渲染 如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间 key值的作用 提高diff的效率 避免就地复用 完全受控组件 &amp; 完全非受控组件为了避免外部props覆盖掉内部state的变化 完全受控组件：子组件没有state，值的获取和修改都交给父组件去处理 完全非受控组件：子组件维护自己的state，props值只用来初始化state，给子组件添加key值，当props发生变化的时候，修改子组件的key值，会重新创建一个子组件而不是更新已有的子组件","tags":[{"name":"react","slug":"react","permalink":"https://sherrywu0917.github.io/tags/react/"}]},{"title":"lottie实践","date":"2019-01-28T02:27:41.000Z","path":"2019/01/28/lottie实践/","text":"lottie简介 Lottie is a mobile library for Android and iOS that parses Adobe After Effects animations exported as json with Bodymovin and renders them natively on mobile and on the web! Lottie是一个库，可以解析使用AE制作的动画（需要用bodymovin导出为json格式），支持web、ios、android和react native。在web侧，lottie-web库可以解析导出的动画json文件，并将其以svg或者canvas的方式将动画绘制到我们页面中。关于lottie-web的详细信息，也可以参见https://github.com/airbnb/lottie-web。 lottie-web引用方式npm包12345678import lottie from 'lottie-web'lottie.loadAnimation(&#123; container: element, // the dom element that will contain the animation renderer: 'svg', loop: true, autoplay: true, path: 'data.json' // the path to the animation json&#125;); js外链多个版本的lottie库都可以从cdnjs-bodymovin找到12345678910&lt;script src=\"https://cdnjs.com/libraries/bodymovin\" /&gt;&lt;script&gt; bodymovin.loadAnimation(&#123; container: element, // the dom element that will contain the animation renderer: 'svg', loop: true, autoplay: true, path: 'data.json' // the path to the animation json &#125;);&lt;/script&gt; 通过外链引入的方式，既可以通过bodymovin去调用，也可以使用lottie变量，二者等价，都是js库提供的全局变量。 lottie-web实践lottie库文件比较大，gzip压缩后也有60k，再加上动画对应的json文件，直接引入会给项目代码增大不少体积，影响页面加载速度。 文件 大小 gzip后 lottie.js 513k 92k lottie.min.js 237k 60k lottie_light.js (lottie_web轻量版，仅支持svg渲染) 345k 60k lottie_lignt.min.js 144k 39k 所以，如果动画只需要支持svg渲染，则可以引入light版本的库文件，gzip压缩后缩减到39k。为了进一步降低影响，可以使用code splitting的方式，以async的方式异步加载js，这样就不会阻塞浏览器解析html、执行js脚本以及展示css布局。123456789import(/* webpackChunkName: \"lottie-light\" */ '../lib/lottie_light.min.js').then(() =&gt; &#123; window.lottie &amp;&amp; window.lottie.loadAnimation(&#123; container: this.headerDom, renderer: 'svg', loop: true, autoplay: true, animationData: require('../data/logo.json') &#125;);&#125;) 示例demo可以参见codepen上的lottie-logo，测试数据lottie_logo.json可以下载lottie logo json数据。","tags":[{"name":"lottie","slug":"lottie","permalink":"https://sherrywu0917.github.io/tags/lottie/"}]},{"title":"reading-record","date":"2018-11-18T02:49:49.000Z","path":"2018/11/18/reading-record/","text":"你的Tree-Shaking并没什么卵用Tree-Shaking作用：消除无用的js代码 与传统的DCE(dead code elimination)区别：DCE是消灭不可能执行的代码，而Tree-shaking更关注于消除没有用到的代码Tree-Shaking的原理 ES6模块依赖关系是确定的，和运行时的状态无关，可以进行可靠的静态分析，故而可以在编译时正确判断到底加载了什么代码。 es6 module可以进行tree-shaking，require不可以，因为commonJS规范是在运行时才确定依赖关系 分析程序流，判断哪些变量未被使用、引用，进而删除此代码tree-shaking对函数效果较好，但是不能消除无用的类，因为动态语言的特性，判断类的方法是否有被使用，比较困难。 但现实比较骨感，es6的代码经过babel和webpack编译打包后，产生的副作用(可能会改变外部变量)导致多余的代码并未被删掉。babel6在编译的时候，会调用_createClass方法，使用Object.defineProperty去定义类里面的方法，原因是因为在es6的特性中，类里面声明的方法是不可枚举的。所以设置{ &quot;loose&quot;: false }宽松模式，让babel编译的时候不必去严格遵循es6的特性。此外，UglifyJS不会进行程序流分析，所以在压缩的时候无法排除掉可能有副作用的代码，所以这部分代码还是会被打包进去。使用babel6/webpack打包可以考虑结合使用BabelMinifyWebpackPlugin，思路是先进行uglifyJS代码压缩，再去编译。 评论中指出：关于Person和Apple阐述Babel副作用的例子在Babel升级到Babel7之后确实已经不存在了，使用Babel7的正式版和Webpack4亲测。 http2.0 相比 1.0有哪些重大改进？ 多路复用多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。好处： 并行地在同一个 TCP 连接上。http2.0让所有数据流共用一个连接，有效地使用TCP连接，减少服务端的链接压力，内存占用更少，实现高带宽。 减少了TCP慢启动的时间。 可以变相的解决浏览器针对同一域名的请求限制阻塞问题。因为浏览器在同一时间针对同一域名下的请求有一定数量的限制，不同浏览器限制的数量不一样。 二进制分帧http2.0在应用层和传输层之间增加了一个二进制分帧层，在该层中，会将传输信息分割成更小的消息和帧。将http1.x的头部信息封装在到了HEADER frame，相应的Request Body封装到DATA frame中。好处：识别这3部分就要做协议解析，http1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑http2.0的协议解析决定采用二进制格式，实现方便且健壮。 首部压缩支持首部压缩，使用了HPACK算法，减少了传输的header大小。客户端和服务器维护同一张头信息表，头部字段都会存入该表，之后只需要传对应的索引即可，避免了header的重复传输。 服务端推送服务器可以向客户端推送可能需要的资源，对\b一个请求发送多个响应。 「如果客户端早已在缓存中有了一份 copy 怎么办？」一个推荐的解决方案是，客户端使用一个简洁的 Cache Digest 来告诉服务器，哪些已经在缓存中存在。 设置资源的优先级浏览器可以一次请求多个资源，指定一些优先级信息来帮助确定应该如何处理这些资源，然后等待服务器发回所有数据，而不是一次请求一个。如果浏览器和服务器都支持优先级，则应使用浏览器指定的规则并使用所有可用带宽来传递资源，而不会有资源之间的相互竞争。 支持http2.0的前提是使用了SSL/TLS9(安全传输层协议)，如果网站没有使用SSL/TLS，接入http2.0协议带来的性能提升大致可以被TLS带来的性能损耗所抵消。 http1.x线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被阻塞. http1.0每次TCP连接，只能提供一次request和response的响应，结束自动断开 http1.1支持长连接(Response Headers头中出现Connection:keep-alive)，但服务器对请求的响应是串行进行的，只有处理完上一次请求之后，才会去处理下一个请求。 https ssl安全协议：https在http的基础上增加了SSL(Secure Sockets Layer)层，对HTTP协议传输的数据进行加密 ca证书：https需要申请ca证书 端口：http端口80，https端口443 所属层：http基于应用层，https一般说是位于应用层和传输层之间https建立连接 服务器先从认证机构申请数字证书 浏览器访问网站，发送支持的加密协议 服务器筛选出合适的加密协议 服务器返回数字证书，证书中有密钥 浏览器利用内置的顶级证书验证CA证书的正确性，解析服务器返回的数字证书得到服务器的公钥。 浏览器生成一个对称加密的密钥，再使用服务器的公钥进行加密后，将加密后的密钥发送给服务器， 服务器使用私钥解密，得到对称加密的密钥，使用该密钥加密数据发送给浏览器端 浏览器端解密数据，SSL开始通信 websocket 全双工通信，可以在浏览器中使用 借用了http的协议完成握手，然后再转为WebSocket（基于TCP协议，但本身属于应用层协议） 建立长连接 OSI七层网络模型应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 TCP四层模型应用层 传输层（TCP/UDP） 网络层 数据链路层 https://www.mnot.net/talks/h2fe/https://www.w3ctech.com/topic/1563#tip7shardinghttps://juejin.im/post/5c1d9b8ae51d4559746922de xss攻击例如：http://xxx/search?keyword=&quot;&gt;alert(‘XSS’);1234&lt;input type=\"text\" value=\"&lt;%= getParameter(\"keyword\") %&gt;\"&gt;// 参数拼接后&lt;input type=\"text\" value=\"\"&gt;&lt;script&gt;alert('XSS');&lt;/script&gt;\"&gt; 跨站脚本攻击（Cross-site scripting），分为存储型(存储到数据库中)、反射型(网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器)和Dom型(前端浏览器拼接并执行)，需要前端处理的是Dom型。预防： 合适的HTML转义，完善的转义库需要针对上下文制定多种规则，例如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等等 利用模板引擎 开启模板引擎自带的 HTML 转义功能 避免内联事件 尽量不要使用 onLoad=”onload(‘‘)” 避免拼接 HTML 时刻保持警惕 在插入位置为 DOM 属性、链接等位置时 增加攻击难度，降低攻击后果 通过 CSP（Content Security Policy，禁止外域等等）、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果 主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞 可以手动拼接字符串jaVasCript:/*-/*/`/‘/“/**/(/ */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/–!&gt;\\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\\x3e`去检查 position:fixedposition:fixed 的元素将相对于屏幕视口（viewport）的位置来指定其位置。并且元素的位置在屏幕滚动时不会改变。但是当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。设置为position:fixed的元素，如果存在transform为非none的元素祖先时，会相对该元素去进行定位。因为transform设置为非none时，会创建一个堆叠上下文和包含块，会影响子元素的固定定位。不是所有的创建新的堆叠上下文都会影响fixed定位，在最新的Chrome浏览器下，只有下面3种还会影响： 设置了 transform-style: preserve-3d 的元素 perspective 值不为 none 的元素 在 will-change 中指定了任意 CSS 属性但不同浏览器表现不同，所以要具体问题具体分析。 vm wh显示器宽度: screen.width浏览器宽度: window.outerWidth网页宽度: window.innerWidth wm wh是相对与网页的宽高的，网页的宽为100vm，网页的高度为100vh 事件捕获 冒泡 对于非target节点则先执行捕获在执行冒泡 对于target节点则是先执行先注册的事件，无论冒泡还是捕获A超链接上的onclick事件会先于href执行，可以联想到通常会在click事件中去阻止冒泡或者默认事件。 http协议1xx 消息2xx 成功 3xx 重定向 301 Moved Permanently 永久重定向 在请求的 URL 已被移除时使用。响应的 Location 首部中应该包含 资源现在所处的 URL。 默认是缓存的 302 Found 临时重定向 与 301 状态码类似；但是，客户端应该使用 Location 首部给出的 URL 来临时定位资源。将来的请求仍应使用老的 URL。 默认不缓存，除非设置了Cache-Control或Expires 303 See Other 临时重定向 303 是为了区分302而存在的。 虽然 RFC 1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器在收到302响应时，直接使用GET方式访问在Location中规定的URI，而无视原先请求的方法。因此状态码303被添加了进来，用以明确服务器期待客户端进行何种反应。重定向到新地址时，客户端必须使用GET方法请求新地址。 307 Temporary Redirect 临时重定向 这个状态码和302相似，有一个唯一的区别是不允许将请求方法从post改为get。 默认不缓存，除非设置了Cache-Control或Expires 308 Permanent Redirect 永久重定向 此状态码类似于301（永久移动），但不允许更改从POST到GET的请求方法。 默认是缓存的 304 Not modified 4xx 客户端错误 400 Bad Request 请求出现语法错误。 401 Unauthorized 访问被拒绝，客户试图未经授权访问受密码保护的页面。 403 Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它 405 Method not allowed 5xx 服务端错误 500 Internal server error 服务器遇到了意料不到的情况，不能完成客户的请求 502 Bad gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 503 Service Unavailable 服务不可用，服务器由于维护或者负载过重未能应答。 504 Gateway timeout 网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。 浏览器渲染页面的过程请求加载页面的主要流程 输入URL 确认是否使用本地缓存 Expires: 服务器时间，客户端时间可能和服务器时间不一致，所以不准； cache-control:max-age=484200 在这个时间内缓存有效； DNS查询：根据域名查出IP地址 建立TCP连接，三次握手 发出HTTP请求 服务端响应 本地缓存过期后，向服务器询问缓存是否真的过期了，带上if-modified-since和Etag(Etag资源的实体标识，更准确)，如果缓存未过期，返回304 如果可以缓存，会被存储起来 客户端渲染 关闭或继续保持TCP连接，断开连接需要四次挥手(client:fin server: ack server: fin client: ack) 为什么断开连接需要四次挥手 client端发FIN报文 server端返回ACK确认（为什么没有一起返回FIN，因为server端此时可能还有数据需要发送，所以需要等server端把数据发送完毕后，再去发送FIN报文关闭连接） server端发FIN报文 client端返回ACK确认 call和apply的作用和区别 函数 改变方法执行的上下文 call是传多个参数，apply是传入参数数组应用 Array.prototype.slice.call([类数组])，将类数组如arguments、NodeList转为数组 应用Object.prototype.toString.call([obj])去判断具体的类型[object Type] Type可以为Boolean，String，Object，Array，Set等等 获取数组最大值，Math.prototype.max.apply(Math, [3, 4, 5]) 合并数组，Array.prototype.push.apply(arr1, arr2) 123456789(function() &#123; 'use strict'; return this;&#125;).call(null); // null(function() &#123; return this;&#125;).call(null); // 非严格模式下，null和undefined会被替换为全局变量，通常情况下是window this的指向 new, this指向的是创建的实例对象 call, apply, bind obj.foo() 默认绑定。如果在严格模式下，则绑定到 undefined，否则绑定到全局对象。 箭头函数没有自己的 this, 它的this继承于上一层代码块的this。 websocket 全双工通信webworker 多线程作用：可以另开子线程，处理复杂数据的计算注意点 同源限制：分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。 DOM 限制：Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。 通信联系：Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。 脚本限制：Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。 文件限制：Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。海量数据的渲染 setTimeout/requestAnimationFrame分批处理 虚拟滚动列表 跨域 JSONP: 利用script标签不受跨域的限制，只支持get请求 client端：构建script，发起跨域get请求，在url上拼接上参数和callback server端：响应请求，将结果作为callback的参数（需要对json对象序列化），并返回callback函数的代码： callback({params: xxx}) 序列化与反序列化：主要解决的是数据的一致性问题，数据需要序列化以后才能在服务端和客户端之间传输 浏览器会执行callback函数，并传递解析后json对象作为参数 代理请求方式解决接口跨域问题：node.js代理请求，nginx反向代理接口跨域 postMessage：允许与其他窗口（或iframe）互相通信 document.domain和iframe，如果两个页面的主域名相同，则还可以通过设置 document.domain 属性将它们认为是同源的。 父页面通过ifr.contentWindow就可以访问子页面的window，子页面通过window.parent或parent访问父页面的window location.hash + iframe跨域 使用CORS(Cross-origin resource sharing)协议: CORS需要浏览器和服务器同时支持。服务端设置 Access-Control-Allow-Origin：* ，客户端设置是否发送cookie，例如XMLHttpRequest的withCredentials，fetch请求的credentials: ‘same-origin’, mode: ‘cors’； 浏览器端会在Request Headers中新增一个origin字段 默认不发送cookie和http认证 服务器端设置Access-Control-Allow-Credentials：允许前端带认证cookie，启用此项后，上面的域名不能为’*’，必须指定具体的域名，否则浏览器会提示 区分简单请求和复杂请求，复杂请求在正式发出请求之前会有一次预检（预检有效期内只会发出一次预检）跨域资源共享标准（ cross-origin sharing standard ）允许在下列场景中使用跨域 HTTP 请求： 前文提到的由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。 eb 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。 WebGL 贴图 使用 drawImage 将 Images/video 画面绘制到 canvas 跨标签页通信 window.open 和 postMessage 当指定window.open的第二个name参数时，再次调用window.open(&#39;****&#39;, &#39;child&#39;)会使之前已经打开的同name子页面刷新 由于安全策略，异步请求之后再调用window.open会被浏览器阻止，不过可以通过句柄设置子页面的url即可实现类似效果12345678// 首先先开一个空白页const tab = window.open('about:blank')// 请求完成之后设置空白页的urlfetch(/* ajax */).then(() =&gt; &#123; tab.location.href = '**url**'; tab.postMessage('msg', '**origin**')&#125;) localStorage 与监听 window.onstorage，event对象包括key、oldValue、newValue等参数 cookie sessionStorage 借助server 判断是否是数组 [] instanceof Array [].proto == Array.prototype [].constructor == Array // constructor可以修改 Object.prototype.toString.call([]) == ‘[object Array]’ Array.isArray([]) 对于自定义的类A，修改了A.prototype后，修改原型之前创建的实例的原型链不会发生改变。123456function A()&#123;&#125;var a = new A();function B()&#123;&#125;A.prototype = B.prototype;a instanceof A //falsea.__proto__ == A.prototype //false 因为instanceof是在原型链上查找的，所以instanceof和proto判断实例的方式都是false 类数组 vs 数组类数组有arguments、Dom对象列表(NodeList)、带length属性的对象（如：{1: ‘mon’, 3: ‘wed’, length: 4}）类数组转成数组 Array.prototype.slice.call(arrayLike) […arrayLike] Array.from(arrayLike)转为数组后就可以使用数组众多的方法，例如map、filter、slice、join、reduce、sort等等。 let const 不存在变量提升 暂时性死区如果使用了let、const，则该区域会形成一个封闭的作用域，在变量tmp使用let声明之前使用，都会报错，但如果一个变量根本没有被声明，反而不会报错。 12345if (true) &#123; typeof tmp; // Uncaught ReferenceError: tmp is not defined typeof undeclared_var; //'undefined' let tmp;&#125; 不允许重复声明 块级作用域ES5中只有全局作用域和函数作用域，ES6新增了块级作用域，let和const只在声明的块级作用域中有效。 函数的执行上下文1、创建阶段【当函数被调用，但未执行任何其内部代码之前】 创建作用域链（Scope Chain） 创建顺序：函数的形参==&gt;&gt;函数声明==&gt;&gt;变量声明 求”this“的值 函数的声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值12345678910111213function foo3(a)&#123; var a = 10 function a()&#123;&#125; console.log(a)&#125;foo3(20) //'10' 创建变量的顺序是 形参a, function a()&#123;&#125;, var a;执行的顺序是 a=10; consolefunction foo3(a)&#123; var a function a()&#123;&#125; console.log(a)&#125;foo3(20) //'function a()&#123;&#125;' 创建变量的顺序是 形参a, function a()&#123;&#125;, var a;执行的顺序是 console 2、执行阶段 在当前上下文上运行/解释函数代码，并随着代码一行行执行指派变量的值。 BFC(Block Formatting Context)BFC是一个独立的渲染区域，内部的元素遵循一定的规则去布局，不会影响外部元素也不会被外部元素影响。 生成BFC 根元素 oveflow不为visible float不为none 绝对定位absolute和fixed flex元素和直接子元素 display: inline-block、table-cell、table-caption grid元素和直接子元素 display：table也认为可以生成BFC，其实这里的主要原因在于Table会默认生成一个匿名的table-cell，正是这个匿名的table-cell生成了BFC display 值为 flow-root 的元素 BFC布局规则 每个元素的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。（结合1、2，实现两栏布局|三栏布局） 同一个BFC中相邻的box在垂直方向上的margin会合并 （外边距折叠） 内部的box会在垂直方向上一个接一个放置 计算BFC的高度时，浮动元素也参与计算（可以参考清除浮动前，外部元素的高度没有被撑起来） 使用 清除浮动就是创建了一个新的BFC来包含浮动元素（oveflow:hidden/auto） 因为BFC的特性，内部元素不应该影响外部元素布局，所以将浮动元素包含进来 属于同一BFC的两块级元素的外边距会折叠 相邻元素之间 父元素与第一个或最后一个子元素 空的块级元素上下边距会折叠 cookie、sessionStorage与localStorage cookie 4k 设置过期时间 每次http请求都会带上cookie 设置httponly的无法被js读取 sessionStorage 5M 永久 仅在客户端 localStorage 5M 会话期间 仅在客户端 盒模型margin, border, padding，content IE的怪异盒模型 盒子的总宽度 = margin + css设置的width 对应box-sizing的border-box 标准盒模型 盒子的总宽度 = margin + border + padding + css设置的width 对应box-sizing的content-box应用：百分比的布局，在不同状态之间切换的button等 css选择器优先级 从高到低： 内联样式 ID 选择器（例如，#example） 类选择器 (例如，.example)，属性选择器（例如，[type=”radio”]）和伪类（例如，:hover，:first-child） 类型选择器 (例如，div)，伪元素（例如，::after ::before）(除了before和after其他常见的都是伪类) !important 例外规则：此声明将覆盖任何其他声明 flex弹性布局有水平的主轴和垂直的交叉轴 flex-direction flex-wrap 排列不下时如何换行 flex-flow: [direction] [wrap] justify-content align-Items align-content: 当有多根主轴时，即item不止一行的时候，多行在交叉轴上的对齐方式item的属性 order 布局顺序 flex-shrink: 收缩 默认为1，表示当空间不足时，item自动缩小 flex-grow: 延伸 默认为0，即当有多余空间时也不放大 flex-basis: 项目在主轴上占据的空间，默认为auto，优先级比width|height高 align-self: 允许item有自己独特的在交叉轴上的对齐方式，默认值为auto，与父元素的align-items的值一样 深拷贝的实现12345678910111213141516171819202122232425262728const toString = Object.prototype.toString;function deepClone(origin) &#123; let cloned = &#123;&#125; let cls = toString.call(origin) if(cls == '[object Date]') &#123; const Ctor = origin.constructor return new Ctor(origin); &#125; else if (cls == '[object Map]') &#123; origin.forEach((subValue, key) =&gt; &#123; result.set(key, deepClone(subValue)) &#125;) &#125; else if (cls == '[object Set]') &#123; origin.forEach((subValue) =&gt; &#123; cloned.add(deepClone(subValue)) &#125;) &#125; else if(typeof origin == 'object' || typeof origin == 'array') &#123; for(var key in origin) &#123; cloned[key] = deepClone(origin[key]); &#125; &#125; else &#123; cloned = origin; &#125; return cloned;&#125; babel原理及插件开发babel解析分为三步： 使用@babel/parser解析器，根据estree规范构造AST语法树 默认支持最新的ECMAScript规范（ES2017） JSX Flow TypeScript 转换AST 根据一定的规则转换、修改AST（babel插件或者预置的stage-0，1，2，3，jsx等） 使用@babel/generator将AST转为code stage-0 transform-do-expressions 支持在react的jsx语法中使用if/else语句 transform-function-bind 提供::去实现和bind一样的作用 stage-1 transform-class-constructor-call transform-export-extensions stage-2 syntax-dynamic-import 可以解析动态import语法 transform-class-properties 支持property（不在prototype上）和static的定义 transform-decorators stage-3 syntax-trailing-function-commas 允许参数后添加逗号 transform-object-reset-spread rest参数… 解构 transform-async-generator-functions transform-async-to-generator 支持async和await语法 transform-exponentiation-operator 通过**这个符号进行幂操作 webpack打包原理，loader原理webpack构建流程 合并shell的参数和config.js配置的参数 注册所有配置的插件，让插件监听webpack生命周期 从entry入口开始解析文件，构建AST语法树，递归查找依赖 根据loader配置的规则对文件进行处理 递归完后得到每个文件的最终结果 应用plugin插件扩展webpack的功能 最后根据entry配置生成chunk，输出chunk可以说一下持久化缓存的过程。从 webpack2 开始，已经内置了对 ES6、CommonJS、AMD 模块化语句的支持。但不包括新的ES6语法转为ES5代码，这部分工作还是留给了babel及其插件。 技术栈以及遇到的问题React + React-Router + Sass + Rem + Webpack打包问题 资源同步问题 gitsubtree 正文页历史滚动位置：正文页和从其他页面返回第一步都是onpopstate事件（只对pushState和replaceState的页面有效）拿到key值，但是从其他页面返回，页面会reload一下，reload之前（先判断key值是否存在于历史位置中）存下当前key值和posHistory[key]值，在页面reload后，再恢复位置。 微信url返回问题 二维码无法识别问题 代码分片 其他 polyfill引入方式 如何提高webpack打包速度 热更新或热替换 选择合适的devtool：sourceMap设置 babel-loader开启缓存 全局script标签引入react/react-dom等第三方库 DllPlugin和DllReferencePlugin动态链接库 提取公共代码 使用HappyPack多进程打包构建 优化打包文件路径配置，使用include和exclude ModuleConcatenationPlugin插件开启作用域提升：它将一些有联系的模块，放到一个闭包函数里面去，通过减少闭包函数数量从而加快JS的执行速度 noParse：有时不需要解析某些模块的依赖（这些模块并没有依赖，或者并根本就没有模块化） 异步加载 只引入模块中的一部分 如何提高UglifyJsPlugin的压缩速度 cache 设置缓存 parallel 开启多进程并行压缩 sourceMap 帮助定位问题，但是可以关闭提高压缩速度 promise错误catch问题 将原本的callback形式的函数Promise化，然后通过promise.then(xxx).catch()去捕获异步操作中抛出的错误。 在使用try/catch的时候，要配合async/await去使用，因为这样能保证异步函数的同步执行，这样能在try/catch方法中捕获异步函数中抛出的错误。 跟传统的try/catch代码块不同的是，如果没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 有一个提案Promise.try可以用来统一处理同步和异步请求，支持then和catch方法，catch可以捕获所有同步和异步的错误123Promise.try(() =&gt; database.users.get(&#123;id: userId&#125;)) .then(...) .catch(...) 方法 实例方法： then, catch, finally 静态方法： all, race, resolve, reject, allSettled Promise.resolve([xxx]) 接收的参数可以是Promise实例、thenable对象、原始值、空，可以用来实现async函数 allSettled是ES2020新增的，返回值状态始终是fulfilled12345678910111213const resolved = Promise.resolve(42);const rejected = Promise.reject(-1);const allSettledPromise = Promise.allSettled([resolved, rejected]);allSettledPromise.then(function (results) &#123; console.log(results);&#125;);// 只有allSettled会返回对应promises对象的status// [// &#123; status: 'fulfilled', value: 42 &#125;,// &#123; status: 'rejected', reason: -1 &#125;// ] Generator 函数与 Promise 的结合123456789101112131415161718192021222324252627282930313233function getFoo () &#123; return new Promise(function (resolve, reject)&#123; resolve('foo'); &#125;);&#125;const g = function* () &#123; try &#123; const foo = yield getFoo(); console.log('1:', foo); const bar = yield getFoo(); console.log('2', bar); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function run(generator) &#123; const gen = generator(); function step(result) &#123; if(result.done) &#123; return result.value; &#125; return result.value.then(function(v) &#123; return step(gen.next(v)); &#125;, function(e) &#123; return step(gen.throw(e)); &#125;); &#125; step(gen.next());&#125;run(g); JSbridge原理JavaScript 调用 Native 注入API: 客户端通过webview提供的API，向JavaScript的Context（window）中注入对象和方法，让JavaScript调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的 拦截 URL SCHEME: Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。（需要创建请求、耗时、url长度限制、参数不够直观）Native 调用 JavaScript WebView作为自组件存在于View/Activity中，直接调用相应的API：Native 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。JSBridge 接口实现 callback参考JSON机制： 当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 当前页面唯一 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。https://juejin.im/post/5abca877f265da238155b6bc html的font-size计算 wy: font值 / 100 = deviceWidth / 750 taobao： font值 r / 75 r = deviceWidth / 750 rest参数和扩展运算符123function push(array, ...items) &#123; //这个...是rest参数，将其他参数放到items数组中 array.push(...items); //这个...是扩展运算符，可以看作是rest的逆运算&#125; 任何 [Symbol.Iterator] 接口的对象，都可以用扩展运算符转为真正的数组。12var nodeList = document.querySelectorAll('div');var array = [...nodeList]; Symbol作用 属性名冲突 解构赋值解构赋值默认会调用Iterator 接口，除此之外扩展运算符、for…of循环、yield*、Map、set、Array.from、Promise.all、Promise.race等等任何接收数组为参数的场合，都调用了Iterator接口。12345678910111213141516171819202122//数组解构let [a, b, c] = [1, 2, 3];//对象结构let &#123;foo&#125; = &#123;foo: 1&#125;//字符串结构const [a, b, c, d, e] = 'hello';//数值和布尔值 会被转成对象let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true//函数参数的解构赋值function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 对象的遍历 for…in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。， Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 Object.getOwnPropertyNames(obj)：返回对象自身的所有可枚举+不可枚举的属性（但不包括Symbol属性）的键名。 Object.getOwnPropertySymbols(obj)：返回对象自身的所有Symbol属性的键名。 Reflect.ownKeys(obj)：返回对象自身的所有键名。 for of / for in可以中断 forEach 不能中断 map不能中断自身可枚举属性 用class A extends B创建的对象实例，可以返回A和B的所有属性attr，因为继承是父类先创建了this实例，然后子类修改this实例 getter在class中是不可枚举的，class的方法都是不可枚举的 getter在普通对象中是可枚举的，如var a = {get a(){ return 1;}}; 这个时候序列化也是可以拿到值的”{“a”:1}”JSON.stringify首先会调用toJSON方法，然后undefined、方法、Symbol等会被忽略，仅序列化自身可枚举的属性 具备Iterator接口的数据结构 Map Set Array String arguments NodeList TypedArray 对象不具备Iterator属性，所以不支持for…of..遍历因为对象key值顺序不定，此外有补充Map数据结构，可变因素很多：是否是原型链上的、是否可枚举、是否要包括Symbol属性。遍历顺序：先遍历出整数属性（integer properties，按照升序），然后其他属性按照创建时候的顺序遍历出来。123456789101112131415let codes = &#123; \"c\": \"China\", \"49\": \"Germany\", \"41\": \"Switzerland\", \"44\": \"Great Britain\", \"4.5\": \"Great Britain\", \"+5\": \"Great Britain\", \"-5\": \"Great Britain\", \"b\": \"British\", \"1\": \"USA\"&#125;;for(let code in codes) &#123; console.log(code); // 1, 41, 44, 49, c, 4.5, +5, -5, b&#125; Map和WeakMap的区别 WeakMap只能使用对象作为键名 WeakMap没有遍历操作因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。 WeakMap无法清空，即不支持clear方法 WeakMap只支持set、get、has、delete4个API Object和Map的区别 Object的key值都会默认转为string 1234567891011121314var object = &#123;&#125;;object[4] = 40;object[&#123;&#125;] = 100;object[NaN] = 50;object[Symbol.key] = 60; for(var key in object)&#123; console.log(typeof(key));&#125;//string//string//string//stringconsole.log(object);//&#123;4: 40, [object Object]: 100, NaN: 50, undefined: 60&#125; Map的键值不局限于字符串，可以是各种类型的值（包括对象） Object不具备Iterator属性，所以不支持for…of遍历 generator和yeild1234567891011121314function* f() &#123; yield 1; var n1 = yield 2; console.log(n1) var n2 = yield 3; console.log(n2) return 'end'&#125;var g = f();g.next(); // &#123;value: 1, done: false&#125;g.next(); // &#123;value: 2, done: false&#125;g.next(2); // 2 &#123;value: 3, done: false&#125;g.next(); // undefined &#123;value: 'end', done: true&#125; g.next(); // &#123;value: undefined, done: true&#125; 如果有return值，会将return语句后面的表达式的值，作为返回的对象的value属性值，但此时的遍历已经结束，done为true。for…of只会返回done为false的遍历值。yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。Generator函数只有在调用next()方法的时候，才会被执行。 按顺序完成异步操作promise123456789101112function logInOrder(urls) &#123; // 远程读取所有URL const textPromises = urls.map(url =&gt; &#123; return fetch(url).then(response =&gt; response.text()); &#125;); // 按次序输出 textPromises.reduce((chain, textPromise) =&gt; &#123; return chain.then(() =&gt; textPromise) .then(text =&gt; console.log(text)); &#125;, Promise.resolve());&#125; asynchttps://objcer.com/2017/10/12/async-await-with-forEach/顺序进行123456async function logInOrder(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125; 1234567891011121314async function logInOrder(urls) &#123; // 并发读取远程URL 并发执行，因为只有async函数内部是继发执行，外部不受影响 const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for..of循环内部使用了await，因此实现了按顺序输出。 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125; //Promise.all(textPromises).then(result =&gt; console.log(result)); 并发&#125; 内存泄露 定义：不再用到的内存没有及时释放，就叫做内存泄露。垃圾回收，如果一个变量的引用计数为0，则表示这个值不再用到了，因此可以将这块内存释放。 防止内存泄露 WeakMap和WeakSet 引用置为null 移除事件绑定 小心全局变量 小心闭包 常见的内存泄露场景 意外的全局变量 定时器的处理函数没有及时释放，没有调用clearInterval方法 脱离 DOM 的引用 闭包上下文绑定后没有被释放 Promise和setTimeout区别事件循环:同步任务VS异步任务当我们设置一个延迟函数的时候，当前脚本并不会阻塞，它只是会在浏览器的事件表中进行记录，程序会继续向下执行。当延迟的时间结束之后，会将回调函数添加至事件队列（task queue）中，事件队列拿到了任务过后便将任务压入执行栈（stack）当中，执行栈执行任务，输出 ‘setTimeout’。 如何判断结束？JS引擎的monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。由于 JS 是单线程的，同步执行任务会造成浏览器的阻塞，所以我们将 JS 分成一个又一个的任务，通过不停的循环来执行事件队列中的任务。这就使得当我们挂起某一个任务的时候可以去做一些其他的事情，而不需要等待这个任务执行完毕。所以事件循环的运行机制大致分为以下步骤： 检查事件队列是否为空，如果为空，则继续检查；如不为空，则执行 2； 取出事件队列的首部，压入执行栈； 执行任务； 检查执行栈，如果执行栈为空，则跳回第 1 步；如不为空，则继续检查； 宏任务和微任务 MacroTask: setTimeout, setInterval, setImmediate, I/O, 网络请求 MicroTask: process.nextTick, promise的then和catch, Object.observe, MutationObserverrequestAnimationFrameUI rendering 在某一个macrotask执行完后，在重新渲染与开始下一个宏任务之前，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。微任务会在执行栈执行完后立即执行，而宏任务要等到下一次的event loop才会被执行。 在node环境下，process.nextTick的优先级高于Promise，也就是说：在宏任务结束后会先执行微任务队列中的nextTickQueue，然后才会执行微任务中的Promise执行机制：一次事件循环过程： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染(规范允许浏览器自己选择是否更新视图，根据回流和重绘的规则？https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork) 渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）1234567891011121314151617181920setTimeout(() =&gt; &#123;console.log('test');&#125;, 1);setTimeout(() =&gt; &#123;console.log('test2');&#125;, 4);requestAnimationFrame(() =&gt; &#123; console.log('raf'); requestAnimationFrame(() =&gt; &#123; console.log('raf2'); &#125;);&#125;);// 输出的可能顺序 1// raf - 第一次raf 和 test的时间取决于当前帧还剩下的时间，如果&lt;=4ms则先执行raf// test// test2// raf2 - 下一次渲染之前有16ms的时间，可以执行两次宏任务// 输出的可能顺序 2// test - 第一次raf 和 test的时间取决于当前帧还剩下的时间，如果&gt;4ms则先执行test// raf// test2// raf2 - 下一次渲染之前有16ms的时间，可以执行两次宏任务 任务优先级 来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。 微任务队列优先级： process.nextTick &gt; Promise.then &gt; Object.observe(废弃属性) &gt; MutationObserver 宏任务队列优先级： setTimeout/setInterval&gt; 异步IO &gt; setImmediate对于 UI rendering 来说，浏览器会在每次清空微任务队列会根据实际情况触发。 REF:前端基础进阶（十二）：深入核心，详解事件循环机制这一次，彻底弄懂 JavaScript 执行机制 js实现new123456789function instance(Cls, ...params) &#123; let obj = Object.create(Cls.prototype); let res = Cls.apply(obj, params); //如果是非primitive类型的返回值，会return这个对象 if (typeof res === \"object\" || typeof res === \"function\") &#123; return res; &#125; return obj&#125; 闭包按值传递https://juejin.im/post/58cf180b0ce4630057d6727c#heading-1 相等操作符(==)相等操作符会对操作值进行隐式转换后进行比较： 如果一个操作值为布尔值，则在比较之前先将其转换为数值 //false == 0 true 如果一个操作值为字符串，另一个操作值为数值，则通过Number()函数将字符串转换为数值 //‘0’ == 0 true 如果一个操作值是对象，另一个不是，则调用对象的valueOf()方法，得到的结果按照前面的规则进行比较 //new Number(1) == 1 true null与undefined是相等的 //null == undefined true 如果一个操作值为NaN，则相等比较返回false //NaN == NaN false 如果两个操作值都是对象，则比较它们是不是指向同一个对象 //var a = {a: 1}; var b = {a: 1}; a == b; false Object.valueof()返回值为该对象的原始值,不同类型对象的valueOf()方法的返回值不同。 XMLHttpRequest readyState和status的状态1234567891011121314151617181920212223const ReadyState = &#123; UNSENT: 0, // Client has been created. open() not called yet. OPENED: 1, // open() has been called. HEADERS_RECEIVED: 2, // send() has been called, and headers and status are available. LOADING: 3, // Downloading; responseText holds partial data. DONE: 4, // The operation is complete.&#125;var oReq = new XMLHttpRequest();console.log('UNSENT', xhr.readyState); // readyState will be 0oReq.onprogress = function () &#123; console.log('LOADING', xhr.readyState); // readyState will be 3&#125;;oReq.onload = function reqListener() &#123; if(this.status === 200) &#123; var data = JSON.parse(this.responseText); console.log(data); &#125; console.log('DONE', xhr.readyState); // readyState will be 4&#125;oReq.open('get', './api/some.json', true);console.log('OPENED', xhr.readyState); // readyState will be 1oReq.send(); application/json; charset=utf-8和application/x-www-form-urlencoded; charset=utf-8的区别： application/json告诉webServer post请求传递的是JSON数据类型: 1&#123; Name : 'John Smith', Age: 23&#125; application/x-www-form-urlencoded告诉webServer post请求传递的数据会被拼接到url上 1Name=John+Smith&amp;Age=23 「前端进阶」高性能渲染十万条数据(时间分片) 性能关键：渲染耗时 分片渲染，一次渲染20条，在setTimeout或requestAnimationFrame回调中触发，requestAnimationFrame性能好于setTimeout 先append到documentFragment，直接append到document每次都会触发回流，并且会计算样式表（当然现在浏览器的优化已经做的很好了， 当append元素到document中后，没有访问 getComputedStyle 之类的方法时，现代浏览器也可以把样式表的计算推迟到脚本执行之后）。setTimeout 和闪屏现象 setTimeout的执行时间可能比设定的要晚。每次timeout后会将callback放到事件队列中，需要在当前主线程执行完成后才会去检查事件队列。 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而setTimeout只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致。在setTimeout中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象。 performance.timing在 Navigation Timing Level 2 草案中，已经废弃了 PerformanceTiming 接口，并且提供了新的接口 PerformanceNavigationTiming 代替其功能。为什么被废弃？因为 W3C 给我们提供了更全面、更强大的一个性能分析矩阵，比单一的 performance.timing 更加强大，能帮助我们从各个方面分析前端页面性能。 pushstate 和 popstate应用 回退缓存 回退挽留弹窗12345678910111213/** * onpopstate是在history.back之后调用的，这个时候event.state是返回后的history的状态，之前的state已经被pop出去了。 **/window.onpopstate = function(event) &#123; alert(\"location: \" + document.location + \", state: \" + JSON.stringify(event.state));&#125;;history.pushState(&#123;page: 1&#125;, \"title 1\", \"?page=1\");history.pushState(&#123;page: 2&#125;, \"title 2\", \"?page=2\");history.replaceState(&#123;page: 3&#125;, \"title 3\", \"?page=3\");history.back(); // alerts \"location: http://example.com/example.html?page=1, state: &#123;\"page\":1&#125;\"history.back(); // alerts \"location: http://example.com/example.html, state: nullhistory.go(2); // alerts \"location: http://example.com/example.html?page=3, state: &#123;\"page\":3&#125; preload vs Prefetchpreload 是一个声明式 fetch，可以强制浏览器在不阻塞 document 的 onload 事件的情况下请求资源。Prefetch 告诉浏览器这个资源将来可能需要，会在浏览器空闲的时候请求资源。 H5离线缓存ServiceWorker实现离线资源缓存：https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers参考示例https://github.com/mdn/sw-testcaches.open() 方法来创建了一个叫做 v1 的新的缓存，将会是我们的站点资源缓存的第一个版本。它返回了一个创建缓存的 promise，当它 resolved的时候，我们接着会调用在创建的缓存示例上的一个方法 addAll()，这个方法的参数是一个由一组相对于 origin 的 URL 组成的数组，这些 URL 就是你想缓存的资源的列表。123456789101112131415161718// 在install事件回调中添加站点资源缓存self.addEventListener('install', function(event) &#123; event.waitUntil( caches.open('v1').then(function(cache) &#123; return cache.addAll([ '/sw-test/', '/sw-test/index.html', '/sw-test/style.css', '/sw-test/app.js', '/sw-test/image-list.js', '/sw-test/star-wars-logo.jpg', '/sw-test/gallery/bountyHunters.jpg', '/sw-test/gallery/myLittleVader.jpg', '/sw-test/gallery/snowTroopers.jpg' ]); &#125;) );&#125;); 1234567891011121314151617// fetch事件监听资源请求self.addEventListener('fetch', function(event) &#123; event.respondWith( // 当命中缓存的时候，直接使用，如果没有命中缓存，去服务器进行网络请求，并把请求回来的资源放到缓存中 caches.match(event.request).then(function(resp) &#123; return resp || fetch(event.request).then(function(response) &#123; return caches.open('v1').then(function(cache) &#123; cache.put(event.request, response.clone()); return response; &#125;); &#125;); &#125;).catch(function() &#123; // 当请求没有匹配到缓存中的任何资源的时候，以及网络不可用的时候，兜底方案 return caches.match('/sw-test/gallery/myLittleVader.jpg'); &#125;) );&#125;);","tags":[]},{"title":"菜鸟优化之路-前端性能测试工具sitespeed.io","date":"2018-10-09T12:08:27.000Z","path":"2018/10/09/菜鸟优化之路-前端性能测试工具/","text":"制定优化目标度量标准 首次有效绘制（First Meaningful Paint，简称FMP，当主要内容呈现在页面上） 英雄渲染时间（Hero Rendering Times，度量用户体验的新指标，当用户最关心的内容渲染完成） 可交互时间（Time to Interactive，简称TTI，指页面布局已经稳定，关键的页面字体是可见的，并且主进程可用于处理用户输入，基本上用户可以点击UI并与其交互） 输入响应（Input responsiveness，界面响应用户输入所需的时间） 感知速度指数（Perceptual Speed Index，简称PSI，测量页面在加载过程中视觉上的变化速度，分数越低越好） 自定义指标，由业务需求和用户体验来决定。FMP与英雄渲染时间非常相似，但它们不一样的地方在于FMP不区分内容是否有用，不区分渲染出的内容是否是用户关心的。 设定目标基于RAIL模型去制定优化的目标，RAIL是一种以用户为中心的性能模型，主要从响应、动画、空闲、加载四个层面去衡量页面性能。1. 100 毫秒的响应时间 + 每秒60帧每帧动画应在少于 16 毫秒（理想情况下为 10 毫秒）内完成，从而达到每秒 60 帧（1 秒 ÷ 60 = 16.6毫秒）。保持乐观，明智地利用空闲时间。对于像动画这样的高压点，只要能，就不要做任何其它事情。预计输入延迟时间（Estimated Input Latency）应低于 50 毫秒。 2. 速度指数（SpeedIndex）小于 1250，可交互时间（Time-To-Interactive）在 3G 上小于 5 秒Speed Index是指获取可见页面加载的视觉进度，并计算内容绘制速度的总得分，分数越低，性能越好，具体的计算可参考speed-index。目标是在 1 秒内（在高速网络下）完成首次绘制（FMP），速度指数（SpeedIndex）低于 1250 毫秒。考虑速度基线是一台有着 3G 网络的，价格为 200 美元左右的 Android 手机（译注：国产千元机水平），那么可以以 400 毫秒 RTT 和 400kb/s 的传输速度进行网络模拟，以达成可交互时间（Time-To-Interactive）小于 5 秒，第二次打开的速度低于 2 秒。尽你所能地降低这些指标。 3. 核心块 = 15kb，关键文件 &lt; 170 kbHTML 的前 14~15kb 是最关键的核心块（chunk），也是整个文件中唯一可以在第一个 RTT 内被下载的部分。要实现上述目标，请设定关键文件的最大尺寸“预算”。170kb gzip 后的文件（原始文件尺寸 0.8~1mb），在普通手机上可能需要 1 秒才能解析和编译完成。 sitespeed.io工具Sitespeed.io是一个基于最佳实践以及一些加载时序等量化标准的开源工具，有助于开发者分析网页的加载速度和渲染性能。它拥有一套插件，如Coach、Broswertime、Chrome-HAR等，帮助sitespeed搜集浏览器debug状态下的数据，并基于网站最佳实践给出相应的打分和意见，最后把数据可视化展示。sitespeed.io评价网页的主要依据是：浏览器的网络请求和TimeLine中的Time Event。与webpageTest、PageSpeed Insights等只能测试线上站点不同，sitespeed.io可以测试本地运行的，以及测试环境绑定代理的站点。 安装可以直接安装sitespeed.io的npm包。12npm install -g sitespeed.ioyarn add global sitespeed.io 也可以使用docker或者git clone的方式安装，具体可参考npm-sitespeed.io。 安装遇到的问题在安装过程中有遇到一些问题，具体的问题和解决办法记录在这儿。1.修复npm安装时报VCBuild不存在的错误，参考stackoverflow给出的解决方案。1npm install --global --production windows-build-tools 2.Browser failed to start, could not find ...alto-saxophone\\vendor\\chromedriver.exe查看node-modules/alto-saxophone目录，发现该目录下对应的文件缺失，可以在该目录下运行npm run install命令手动安装chromedriver.exe。1npm run install 3.运行sitespeed.io报错12345$ sitespeed.io https://www.sitespeed.io/module.js:682 return process.dlopen(module, path._makeLong(filename));Error: The specified module could not be found.\\\\?\\C:\\Users\\hzwushuoshuo\\AppData\\Roaming\\npm\\node_modules\\sitespeed.io\\node_modules\\sharp\\build\\Release\\sharp.node 查看安装sitespeed.io的过程，发现在安装sharp包时报错UnhandledPromiseRejectionWarning，需要在admin模式下去安装文件。 运行1sitespeed.io -n 5 -v https://www.baidu.com 该命令将会在chrome浏览器下调起URL为https://www.baidu.com 5次。如果期望一次检测多个页面，可以继续拼接参数，如下所示。1sitespeed.io -n 5 -v https://www.baidu.com -v https://www.baidu.com/s?wd=test 生成的文件可以在sitespeed-result文件夹中查看。 运行结果打开sitespeed.io输出的html文件，可以查看Summary、Detailed Summary、Pages、Domains、Toplist和Assets六个维度的信息。SummarySummary是对网页性能数据的一个整体展示。站点得分主要根据页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标进行打分，每个核心指标考核的内容可以在help.html文件中查找。页面中的其他指标，如文件压缩、文件大小、请求数、缓存时间、请求状态码、首次渲染时间、前端渲染用时、页面加载用时、DNS解析时长等，这些指标都有详细的统计，而且不同等级用相应的颜色表示。 Detailed Summary点击左侧具体的指标，都可以在帮助文档中查看对该指标的解释。针对每个指标都计算除了最小(min)、最大(max)、平均值(mean)、中位数(median)和加载90%(p90)时的数据。 Pages如果一次测试多个页面，可以在Pagestab下面查看到不同的页面。点击某个页面的URL可以查看到页面的加载细节，包括资源请求的waterfall瀑布流图：在上图的coachTab下有页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标下各个细分项的得分，并给出了优化建议，如下图所示。 DomainsDomainstab下主要是对按域名统计，各个域名下的请求时间和请求数。 ToplistToplist会列出所有大的文件，包括JS、CSS、HTML和图片，此外还会列出所有慢的请求。 AssetsAssets显示了所有被加载资源的前20个，包括文件类型、last-modified时间、缓存时间、文件大小等数据。 REFS:2018 前端性能检查表嗨，送你一张Web性能优化地图好用的前端页面性能检测工具—sitespeed.io","tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://sherrywu0917.github.io/tags/前端性能优化/"},{"name":"sitespeed.io","slug":"sitespeed-io","permalink":"https://sherrywu0917.github.io/tags/sitespeed-io/"}]},{"title":"菜鸟优化之路-图片webp&lazyload","date":"2018-09-27T12:17:29.000Z","path":"2018/09/27/菜鸟优化之路-图片webp-lazyload/","text":"webp图片优化WebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。webp兼容性见下图其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。 检测浏览器是否支持webp格式方法1: canvas的toDataURL123456789function checkWebp() &#123; try&#123; return (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0); &#125;catch(err) &#123; return false; &#125; //or !![].map &amp;&amp; document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;&#125; 对比一下chrome和ie下document.createElement(&#39;canvas&#39;).toDataURL(&#39;image/webp&#39;)下的输出：1234//ie\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"//chrome\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\" 基于toDataURL的特性，如果请求的类型不被支持，默认返回data:image/png。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则toDataURL会返回&quot;data:,&quot;。)所以，只有支持webp格式的浏览器调用toDataURL(&#39;image/webp&#39;)后返回的字符串中才包含&#39;data:image/webp&#39;。上面提供了两种写法，其中!![].map主要是判断是否是IE9+，以免toDataURL方法会报错。 方法2: 图片onloadgoogle官网提供的，通过加载小的webp图片来判断是否支持该格式：1234567891011121314151617181920// check_webp_feature:// 'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.// 'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)function check_webp_feature(feature, callback) &#123; var kTestImages = &#123; lossy: \"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\", lossless: \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\", alpha: \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\", animation: \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\" &#125;; var img = new Image(); img.onload = function () &#123; var result = (img.width &gt; 0) &amp;&amp; (img.height &gt; 0); callback(feature, result); &#125;; img.onerror = function () &#123; callback(feature, false); &#125;; img.src = \"data:image/webp;base64,\" + kTestImages[feature];&#125; 上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。调用方法如下，可以在callback方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加webp相关的class都可以。123check_webp_feature('lossless',function(feature,result)&#123; alert(result); //true or false&#125;); 使用webp处理webp通常有两种方式 服务端处理，支持webp图片的浏览器会在请求头Accept中加上image/webp，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了； 前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型我们产品使用的是网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考https://www.163yun.com/help/documents/114078550521466880。其中，通过在url后拼接?imageView&amp;type=webp就可以获得对应的webp图片。 在线生成 智图 zhitu.isux.us 又拍云 www.upyun.com/webp CloudConvert cloudconvert.com/anything-to-webp iSparta isparta.github.io/index.html 图片lazyload图片lazyload是常见的性能优化的一种方式。如果页面图片数量较多，一次性加载比较耗时，还会导致页面卡顿，所以，建议根据需要去加载部门图片，待页面滚动时再加载下面的图片。可以使用一个轻量级的lazyload库，具体使用可以参考GitHub。通过npm安装vanilla-lazyload包，推荐的版本有：12npm install vanilla-lazyload@8.17.0npm install vanilla-lazyload@10.19.0 注意：10.x版本使用了IntersectionObserver API，IE和safari不支持，所有图片会一次性加载。简单粘贴一个示例：123&lt;img class=\"lazy\" alt=\"...\" data-src=\"../img/44721746JJ_15_a.jpg\" width=\"220\" height=\"280\"&gt; 1234import LazyLoad from \"vanilla-lazyload\";var myLazyLoad = new LazyLoad(&#123; elements_selector: \".lazy\"&#125;); 在线demo可以访问：https://www.andreaverlicchi.eu/lazyload/demos/container_single.htmlREFS:https://github.com/verlok/lazyloadhttps://www.haorooms.com/post/webp_bigpipehttps://www.zhangxinxu.com/php/microCodeDetail?id=3","tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://sherrywu0917.github.io/tags/前端性能优化/"},{"name":"webp","slug":"webp","permalink":"https://sherrywu0917.github.io/tags/webp/"}]},{"title":"函数式编程的应用","date":"2018-08-24T01:38:54.000Z","path":"2018/08/24/函数式编程的应用/","text":"react的render方法render()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法。保持render() 方法纯净使得组件更容易思考。","tags":[]},{"title":"菜鸟优化之路","date":"2018-08-08T08:21:21.000Z","path":"2018/08/08/菜鸟优化之路/","text":"DeviceTiming工具最近了解到DeviceTiming工具，可以帮助我们监测js在不同设备上的解析和执行时间，运行环境是在开发环境下。搬运下git上的安装、运行命令：1234567//安装git clone https://github.com/etsy/DeviceTiming.gitcd DeviceTimingnpm install//运行./devicetiming server /path/to/your/js 注意：devicetiming会改变被监控的js，要先备份好，不过有git记录的就不用担心了 运行了之后，用不同的设备访问开发环境下的站点，最后reloadhttp://localhost:8537/页面，可以看到不同设备对js的解析和执行时间，如下图所示：可以看到不同设备的ua信息，每个js的parse和exec时间。从上到下，三个设备分别是微信开发者工具、iphone、安卓机。从数据上看，安卓机parse和exec花费的时间最久，花费时间越长，用户的体验就会越差。该站点面向的用户中安卓机份额更高，how to optimize显得比较重要。 how to optimize尾部调用优化（TCO）尾调用概念就是在函数最后一步调用其他函数。12345678910111213function foo(x) &#123; return x;&#125;function bar(y) &#123; return foo( y + 1 ); // 尾部调用&#125;function baz() &#123; return 1 + bar( 40 ); // 不是尾部调用&#125;baz(); // 42 bar函数的最后一步是调用foo( y + 1 )，属于尾部调用；而在baz函数中，调用完bar(40)后，还有执行+ 1的操作，就不属于尾部调用了。 函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 如果函数g不是尾部调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。尾部调用优化，即只保留内层函数的调用记录，运用这一思想可以去优化递归，不需要再保存每次的调用记录，始终只存在一个调用记录，可以避免’栈溢出’。 动态加载组件代码分片当前端代码越来越复杂，代码体积越来越大时，考虑对加载的资源进行细粒度的分割，按需加载。webpack支持两种语法实现动态地加载模块： require.ensure给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。 1require.ensure(dependencies: String[], callback: function(require), chunkName: String) import调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。 1234import( /* webpackChunkName: \"my-chunk-name\" */ /* webpackMode: \"lazy\" (default)*/ 'path/to/module') -&gt; Promise webpackChunkName用来设置chunk的名字；webpackMode默认值是lazy，还有lazy-once、eager、weak。 按需加载的默认加载形式是async。 react动态加载组件在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。直接看代码：123456789101112131415161718192021222324252627282930313233343536373839import React, &#123;Component&#125; from 'react'/** * 异步加载模块 * @param &#123;[type]&#125; loadComponent [description] * @return &#123;[type]&#125; [description] */export const asyncComponent = loadComponent =&gt; ( class AsyncComponent extends Component &#123; state = &#123; Component: null, &#125; componentDidMount() &#123; if (this.hasLoadedComponent()) &#123; return; &#125; loadComponent() .then(module =&gt; module.default) .then((Component) =&gt; &#123; this.setState(&#123; Component &#125;); &#125;) .catch((err) =&gt; &#123; console.error(`Cannot load component in &lt;AsyncComponent /&gt;`); throw err; &#125;); &#125; hasLoadedComponent() &#123; return this.state.Component !== null; &#125; render() &#123; const &#123; Component &#125; = this.state; return (Component) ? &lt;Component &#123;...this.props&#125; /&gt; : null; &#125; &#125;); loadComponent参数代表import(‘module’)异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。如何调用：1export const AsyncBannerSwiper = asyncComponent(() =&gt; import(/* webpackChunkName: \"bannerSwiper\" */ './BannerSwiper.jsx')) 将BannerSwiper组件用asyncComponent封装下，就返回了一个异步加载的AsyncBannerSwiper组件，使用方法和其他组件完全一致。 publicPath动态设置项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。动态设置异步chunk的publicPath，在入口entry中设置webpack_public_path，打包配置文件中配置的publicPath不变。1__webpack_public_path__ = window.cdn || '/dist/'; webpack设置在webpack配置文件中，需要配置chunkFilename指定chunk的名字。1chunkFilename: '[name].js' 另外，注意webpack插件的配置：1234567new webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk idnew webpack.optimize.CommonsChunkPlugin(&#123; ... children: false, // 如果设置为 `true`，所有公共 chunk 的子模块都会被选择 ...&#125;),new ExtractTextPlugin(&#123;filename: 'css/[name].css?[contenthash:8]', allChunks: true&#125;), //从所有chunk中提取(默认情况下，它仅从initial chunk中提取) 分离前后对比使用webpack-bundle-analyzer分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K： 使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。 REFS:https://blog.csdn.net/qq20004604/article/details/79318253https://segmentfault.com/a/1190000009820646 持久化内存为了获取持久化内存，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。 moduleId VS chunkId看打包后的manifest.js，精简的源码如下所示：12345678910111213141516171819202122232425262728293031(function(modules) &#123; window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) &#123; var moduleId, result; for (moduleId in moreModules) &#123; if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123; // 将chunk中所包含的模块放入modules数组中 modules[moduleId] = moreModules[moduleId]; &#125; &#125; if (executeModules) &#123; for (i = 0; i &lt; executeModules.length; i++) &#123; result = __webpack_require__(executeModules[i]); &#125; &#125; return result; &#125;; var installedModules = &#123;&#125;; // 调用__webpack_require__(moduleId)时， //再将模块放入installedModules，用于保存已经加载过的模块 function __webpack_require__(moduleId) &#123; if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; var module = installedModules[moduleId] = &#123; exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); return module.exports; &#125;&#125;)([]); webpackJsonp方法接收三个参数chunkIds, moreModules, executeModules，分别属于chunkId和moduleId两种类型: chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。 module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前__webpack_require__加载的模块，同样使用数组下标作为moduleId。每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。 固化moduleId和chunkId 固化moduleId：HashedModuleIdsPlugin会根据文件的路径去生成hash，可以用在生成环境。开发环境可以使用NamedModulesPlugin，hash直接是模块的相对路径，更加清晰，便于debug。 固化chunkId：webpack中entry的唯一的，所以可以直接使用entry名作为chunkId，使用NamedChunksPlugin可以帮助我们达成该目标，如果是代码分离出的chunk可以使用/* webpackChunkName: &quot;bannerSwiper&quot; */指定chunk的名字，或者可以在NamedChunksPlugin插件中去配置。12new webpack.HashedModuleIdsPlugin(), //固化 module idnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id REFS:https://github.com/pigcan/blog/issues/9https://www.imooc.com/article/21538https://juejin.im/post/5a23b130f265da432003101ahttps://github.com/happylindz/blog/issues/6 cpu占比探测12345678910var data = []var tfunction pulse() &#123; t &amp;&amp; data.push(Date.now() - t) t = Date.now() setTimeout(pulse, 50)&#125;pulse() 就是每隔 50ms 打一下点。理想情况下，data 的值应该是1data = [50, 50, 50, 50, ...] 但实际情况，data会是1data = [51, 52, 50, 52, ...] cpu越忙，data的数据项会越大。这样，记录一系列 data 值，就可以绘制出 CPU 占比趋势图，和通过任务管理器看到的 CPU 趋势图非常接近。 上面只是原理说明，实际情况没这么简单。但很明显，通过这么一个简单的规律，就能实现用纯 JavaScript 来探测 CPU 占比。","tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://sherrywu0917.github.io/tags/前端性能优化/"}]},{"title":"JS函数式编程笔记(下)","date":"2018-07-13T03:20:08.000Z","path":"2018/07/13/JS函数式编程笔记(下)/","text":"示例应用声明式编程 命令式编程（imperative）：喜欢大量使用可变对象和指令，我们总是习惯于创建对象或者变量，并且修改它们的状态或者值，或者喜欢提供一系列指令，要求程序执行。 声明式编程（Declarative）：对于声明式的编程范式，你不在需要提供明确的指令操作，所有的细节指令将会更好的被程序库所封装，你要做的只是提出你要的要求，声明你的用意即可。与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。SQL是典型的声明式编程，明确指出想要什么(what)，而不是如何实现(how)。123456789// 命令式var makes = [];for (i = 0; i &lt; cars.length; i++) &#123; makes.push(cars[i].make);&#125;// 声明式var makes = cars.map(function(car)&#123; return car.make; &#125;); 上述命令式编程要求先声明一个数组，再去遍历，然后执行循环中具体的方法。使用map的版本是一个表达式，它对执行顺序没有要求,它指明的是做什么，不是怎么做。 REFS:声明式编程和命令式编程的比较 Hindley-Milner 类型签名 类型签名在写纯函数时所起的作用非常大，短短一行，就能暴露函数的行为和目的。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。JavaScript 也有一些类型检查工具，比如 Flow，或者它的静态类型方言 TypeScript 。 举个栗子123456// capitalize :: String -&gt; Stringvar capitalize = function(s)&#123; return toUpperCase(head(s)) + toLowerCase(tail(s));&#125;capitalize(\"smurf\");//=&gt; \"Smurf\" 从类型签名来看，capitalize方法接收了一个String，最终也返回了一个String。 对于柯里化后的函数，对类型的签名可以有不同的理解：1234// match :: Regex -&gt; String -&gt; [String]var match = curry(function(reg, s)&#123; return s.match(reg);&#125;); 一种思路是接收Regex和String两种类型参数，返回一个[String] 另一种思路是match :: Regex -&gt; (String -&gt; [String])，先接收了一个Regex参数，返回一个新的函数，该函数接收String并返回一个[String]。 再举个栗子1234// reduce :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; bvar reduce = curry(function(f, x, xs)&#123; return xs.reduce(f, x);&#125;); 约定俗成，a、b可以是任一种类型，但相同的字母a代表同一类型。其中(b -&gt; a -&gt; b)约定了函数的类型签名： b是传入f的累加器（初始值是括号后面的-&gt; b）; a是遍历[a]得到的currentValue; f返回的类型是b，最终reduce方法返回的类型也就是f的返回。类型签名的美妙之处在于明确告诉我们函数做了什么 缩小可能性范围大多数语言都有范型(也成为参数多态性)，其中函数是通过一个或多个抽象类型定义的。1// head :: [a] -&gt; a 引入了类型签名后，可以缩小head函数的可能范围，a可以是任意类型的参数，即多态性(polymorphism)，对于任意类型的参数都要支持[a] -&gt; a的映射，可以帮助我们缩小函数可能性的范围。我们甚至可以用[a] -&gt; a去到类型签名搜索引擎里面搜索我们需要的函数，详细移步到Hoogle去尝试，很有意思。 自由定理12// head :: [a] -&gt; acompose(f, head) == compose(head, map(f)); 等式左边说的是，先获取数组的头部，然后对它调用函数 f；等式右边说的是，先对数组中的每一个元素调用 f，然后再取其返回结果的头部。这两个表达式的作用是相等的，但是前者要快得多。可以得到一个普适的道理：如果你映射某个函数到列表上，然后对其应用 f，其等同于对映射应用 f。数学提供的这种形式化方法，可以帮助计算机去进行类似的代码优化。 类型约束1// sort :: Ord a =&gt; [a] -&gt; [a] 签名也可以把类型约束为一个特定的接口（interface），a必须是Ord对象，在强类型语言中，可以是一个自定义的接口。 特百惠容器为什么叫特百惠呢？因为特百惠是一个家居品品牌，代表产品是容器。12345var Container = function(x) &#123; this.__value = x;&#125;Container.of = function(x) &#123; return new Container(x); &#125;; 使用Container.of作为构造器，暂且认为它是把值放到容器里的一种方式。 第一个 functor容器中有了值之后，我们需要一种方式来操作容器中的值：1234// (a -&gt; b) -&gt; Container a -&gt; Container bContainer.prototype.map = function(f)&#123; return Container.of(f(this.__value))&#125; 这个map跟数组那个著名的map一样，除了前者的参数是Container a而后者是[a]。它们的使用方式也几乎一致：12345678910Container.of(2).map(function(two)&#123; return two + 2 &#125;)//=&gt; Container(4)Container.of(\"flamethrowers\").map(function(s)&#123; return s.toUpperCase() &#125;)//=&gt; Container(\"FLAMETHROWERS\")Container.of(\"bombs\").map(concat(' away')).map(_.prop('length'))//=&gt; Container(10) Container将值传给map后，通过f方法，我们可以对值进行任意操作，操作结束后再放入Container中并返回，这样就可以连续对容器中的值进行操作。这样一直调用map的形式，不就是前面提到的组合么。这里面起作用的数学魔法就是functor(函子): functor 是实现了map函数并遵守一些特定规则的容器类型。 为什么要使用functor这种方式来处理呢？ 即让容器自己去运用函数能给我们带来什么好处？书中给出的答案是抽象——对于函数运用的抽象。 薛定谔的 Maybe定义另外一个functor，同样实现了map函数的、类似容器的数据类型`Maybe’。123456789101112131415var Maybe = function(x) &#123; this.__value = x;&#125;Maybe.of = function(x) &#123; return new Maybe(x);&#125;Maybe.prototype.isNothing = function() &#123; return (this.__value === null || this.__value === undefined);&#125;Maybe.prototype.map = function(f) &#123; return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));&#125; Maybe和Container的不同点就是它新增了一个isNothing，在每次调用函数前，先检查它自己的值是否为空。 123456Maybe.of(\"Malkovich Malkovich\").map(match(/a/ig));//=&gt; this._value = match(/a/ig)(\"\"Malkovich Malkovich\"\")//=&gt; Maybe(['a', 'a'])Maybe.of(null).map(match(/a/ig));//=&gt; Maybe(null) 点记法（dot notation syntax）已经足够函数式了，但我们更想保持一种 pointfree 的风格。碰巧的是，map完全有能力以curry函数的方式来“代理”任何 functor，柯里化后就可以方便地使用compose了：1234// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f bvar map = curry(function(f, any_functor_at_all) &#123; return any_functor_at_all.map(f);&#125;); 结合前面提到的类型签名，首先约束了f是Functor类型，去掉类型约束后签名是(a -&gt; b) -&gt; f a -&gt; f b，可以看出传入的参数是一个函数f: (a -&gt; b)，一个functor: f a，最后返回一个functor: f b。这个方法可以帮助我们取出容器中的值，可以参考下面的例子：123456789101112// safeHead :: [a] -&gt; Maybe(a)var safeHead = function(xs) &#123; return Maybe.of(xs[0]); // this.__value = xs[0]&#125;;var streetName = compose(map(_.prop('street')), safeHead, _.prop('addresses'));streetName(&#123;addresses: []&#125;);// Maybe(null)streetName(&#123;addresses: [&#123;street: \"Shady Ln.\", number: 4201&#125;]&#125;);// Maybe(\"Shady Ln.\") safeHead返回了一个Maybe对象（eg2：Maybe({street: “Shady Ln.”, number: 4201})），要想对隐藏在Maybe容器中的值进行操作，需要借助map函数来操作，通过调用该对象的map函数，传入_.prop(&#39;street&#39;)函数，对this.__value进行操作，返回一个新的Maybe对象（eg2: Maybe(“Shady Ln.”)）。 “纯”错误处理Maybe实现了空和非空两种类型的分开处理，利用这种思想，我们可以对错误进行更友好、健壮地处理。用一个简单的例子示意一下：1234567891011121314151617181920212223var Left = function(x) &#123; this.__value = x;&#125;Left.of = function(x) &#123; return new Left(x);&#125;Left.prototype.map = function(f) &#123; return this;&#125;var Right = function(x) &#123; this.__value = x;&#125;Right.of = function(x) &#123; return new Right(x);&#125;Right.prototype.map = function(f) &#123; return Right.of(f(this.__value));&#125; 1234567891011121314var moment = require('moment');// getAge :: Date -&gt; User -&gt; Either(String, Number)var getAge = curry(function(now, user) &#123; var birthdate = moment(user.birthdate, 'YYYY-MM-DD'); if(!birthdate.isValid()) return Left.of(\"Birth date could not be parsed\"); return Right.of(now.diff(birthdate, 'years'));&#125;);getAge(moment(), &#123;birthdate: '2005-12-12'&#125;);// Right(9)getAge(moment(), &#123;birthdate: '20010704'&#125;);// Left(\"Birth date could not be parsed\") 其中Left用来处理错误状态，Right用来处理正常情况。 Old McDonald had Effects…在纯函数那一章，通过将不纯的函数包裹在另一个函数中，使得它看起来像个纯函数。类似的例子：123456// getFromStorage :: String -&gt; (_ -&gt; String)var getFromStorage = function(key) &#123; return function() &#123; return localStorage[key]; &#125;&#125; 这儿将getFromStorage改造成，相同的输入key总会对应相同的输出：一个从localStorage里取出某个特定元素的函数。（然而，感觉并没什么用啊= =） 1234567891011121314var IO = function(f) &#123; this.__value = f; //f总是一个函数&#125;IO.of = function(x) &#123; return new IO(function() &#123; return x; &#125;);&#125;IO.prototype.map = function(f) &#123; //这儿和Maybe.of(f(this.__value))实现效果一致 return new IO(_.compose(f, this.__value));&#125; IO(function(){ return x })仅仅是为了延迟执行，其实我们得到的是 IO(x)。 实际使用的时候：123456789101112131415161718192021////// 纯代码库: lib/params.js ///////// url :: IO Stringvar url = new IO(function() &#123; return window.location.href; &#125;);// toPairs = String -&gt; [[String]]var toPairs = compose(map(split('=')), split('&amp;'));// params :: String -&gt; [[String]]var params = compose(toPairs, last, split('?'));// findParam :: String -&gt; IO Maybe [String]var findParam = function(key) &#123; return map(compose(Maybe.of, filter(compose(eq(key), head)), params), url);&#125;;////// 非纯调用代码: main.js ///////// 调用 __value() 来运行它！findParam(\"searchTerm\").__value();// Maybe(['searchTerm', 'wafflehouse']) 本质上是将逻辑分成了纯代码库和非纯调用代码两部分，纯代码库最后生成的函数是唯一的，最后的风险都放在了调用者身上。__value的命名并不合理，__value的调用会触发前面已压栈的所有操作，替换为unsafePerformIO更能提醒用户它的变化无常。 functor 的概念来自于范畴学，并满足一些定律。12345// identitymap(id) === id;// compositioncompose(map(f), map(g)) === map(compose(f, g)); Monadpointed functorof方法并不是用来避免使用new关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。pointed functor就是实现了of方法的Functor。默认最小化上下文是什么？ TODO 混合比喻1234567891011121314151617181920212223242526// Support// ===========================var fs = require('fs');// readFile :: String -&gt; IO Stringvar readFile = function(filename) &#123; return new IO(function() &#123; return fs.readFileSync(filename, 'utf-8'); &#125;);&#125;;// print :: String -&gt; IO Stringvar print = function(x) &#123; return new IO(function() &#123; console.log(x); return x; &#125;);&#125;// Example// ===========================// cat :: IO (IO String)var cat = compose(map(print), readFile);cat(\".git/config\")// IO(IO(\"[core]\\nrepositoryformatversion = 0\\n\")) 最后返回了一个嵌套两层的IO对象，如果想要再次调用，对其中的值进行处理，则需要map(map(f))；像是穿着两套防护服在工作，很奇怪。123456789Maybe.prototype.join = function() &#123; return this.isNothing() ? Maybe.of(null) : this.__value;&#125;var mmo = Maybe.of(Maybe.of(\"nunchucks\"));// Maybe(Maybe(\"nunchucks\"))mmo.join();// Maybe(\"nunchucks\") 定义一个join方法，可以帮助我们简单地移除一层嵌套，在使用的时候，我们可以在每个map后面，都调用一次join方法，但是我们期望的不止如此。1234567// join :: Monad m =&gt; m (m a) -&gt; m avar join = function(mma)&#123; return mma.join(); &#125;// firstAddressStreet :: User -&gt; Maybe Streetvar firstAddressStreet = compose( join, map(safeProp('street')), join, map(safeHead), safeProp('addresses')); chain函数把map和join封装成chain函数，则firstAddressStreet方法可以改写成：123456789// chain :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m bvar chain = curry(function(f, m)&#123; return m.map(f).join(); // 或者 compose(join, map(f))(m)&#125;);// firstAddressStreet :: User -&gt; Maybe Streetvar firstAddressStreet = compose( chain(safeProp('street')), chain(safeHead), safeProp('addresses')); 简单说，Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。 REFS:图解 Monad","tags":[]},{"title":"JS函数式编程笔记(上)","date":"2018-07-02T11:20:49.000Z","path":"2018/07/02/JS函数式编程笔记(上)/","text":"一等公民的函数为啥说函数是一等公民？ 函数和其他对象一样，可以像对待任何其他数据类型一样对待它们——把它们存在数组里，当作参数传递，赋值给变量…等等。关键点在于，调用的时候没必要再去包裹一层多余的函数，因为二者是等价的。1234\\\\包裹了多余的函数var greeting = function(name) &#123;return hi(name);&#125;\\\\ 一等公民式的调用var greeting = hi; 一等公民函数调用的好处123456789101112//最初的函数httpGet('/post/2', function(json)&#123; return renderPost(json);&#125;);// 需要增加对err异常的处理，要处理的地方比较多httpGet('/post/2', function(json, err)&#123; return renderPost(json, err);&#125;);// 如果使用一等公民函数的形式，则其他的改动会少很多httpGet('/post/2', renderPost); 纯函数的好处 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。 函数的副作用slice和splice相比，slice是一种纯函数，splice会修改自身数据，在函数式编程中比较讨厌这种笨函数。另外，看这个例子： 123456// 不纯的var minimum = 21;var checkAge = function(age) &#123; return age &gt;= minimum;&#125;; checkAge依赖外部变量minimum，minimum发生变化的时候，会影响checkAge函数的返回结果，增加认知负荷。也可以调用Object.freeze({minimum: 21})将minimum变成一个不可变对象。 副作用是在计算过程中，系统状态的一种变化，或者是与外部世界进行的可观察的交互。也是滋生bug的温床。 追求“纯”的理由 可缓存性（Cacheable）可以通过延迟执行的方式把不纯的函数转换为纯函数：123var pureHttpCall = memoize(function(url, params)&#123; return function() &#123; return $.getJSON(url, params); &#125;&#125;); 之所以是纯函数，因为总是根据相同的输入返回相同的输出：同一个发送http请求的函数。 可移植性／自文档化（Portable / Self-Documenting）与环境无关；注入依赖或者通过参数传递。 Erlang 语言的作者 Joe Armstrong 说的这句话：“面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩…以及整个丛林”。 可测试性（Testable）Quickcheck——一个为函数式环境量身定制的测试工具 合理性（Reasonable）引用透明性:如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。 并行代码可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。 柯里化 在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。另一种理解是：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 例子123456789101112131415function add(a, b) &#123; return a + b;&#125;// 执行 add 函数，一次传入两个参数即可add(1, 2) // 3// 函数curryvar add = function(a) &#123; return function(b) &#123; return a + b; &#125;&#125;// 每次传入一个参数add(1)(2) // 3 核心思想可以借助Lodash 中的 curry 方法帮我们实现函数柯里化，核心思想是————比较多次接受的参数总数与函数定义时的入参数量，当接受参数的数量大于或等于被 Currying 函数的传入参数数量时，就返回计算结果，否则返回一个继续接受参数的函数。1234567891011121314function trueCurrying(fn, ...args) &#123; if (args.length &gt;= fn.length) &#123; return fn(...args) &#125; return function (...args2) &#123; return trueCurrying(fn, ...args, ...args2) &#125;&#125; 用处curry的用处十分广泛，给函数传入一些参数后，可以得到一些新的函数。例如下面的getChildren函数，传给柯里化后的map函数，会返回一个接收参数类型为数组的新函数。123456789101112var curry = require(&apos;lodash&apos;).curry;var map = curry(function(f, ary) &#123; return ary.map(f);&#125;);var getChildren = function(x) &#123; return x.childNodes;&#125;;var allTheChildren = map(getChildren);// 返回所有div的子节点allTheChildren(document.getElementsByTagName(&apos;div&apos;)) 代码组合简介12345var compose = function(f,g) &#123; return function(x) &#123; return f(g(x)); &#125;;&#125;; f和g是两个函数，通过组合方式返回一个新的函数，x就是在两个管道之间传输的值。举个例子，如果希望给send in the clowns加上!，并且转成大写，可以使用函数组合的方法来实现这个功能。123456var toUpperCase = function(x) &#123; return x.toUpperCase(); &#125;;var exclaim = function(x) &#123; return x + '!'; &#125;;var shout = compose(exclaim, toUpperCase);shout(\"send in the clowns\");//=&gt; \"SEND IN THE CLOWNS!\" compose使用主要特点有： - 代码的运行顺序是从右向左，创建了一个从右向左的数据流，初始函数一定放到参数的`最右面`； - `compose`的参数是函数，返回的也是一个函数； - 除了第一个函数的接受参数，其他函数的接受参数都是上一个函数的返回值，所以初始函数的参数是多元的，而其他函数的接受值是一元的； 结合律组合的概念来源于数学课本，满足组合的特性——结合律123// 结合律（associativity）var associative = compose(f, compose(g, h)) == compose(compose(f, g), h);// true 结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。例如可以进行下面的重构：123456789101112var loudLastUpper = compose(exclaim, toUpperCase, head, reverse);// 或var last = compose(head, reverse);var loudLastUpper = compose(exclaim, toUpperCase, last);// 或var last = compose(head, reverse);var angry = compose(exclaim, toUpperCase);var loudLastUpper = compose(angry, last);// 更多变种... pointfree Pointfree style means never having to say your data.通过管道把数据在接受单个参数的函数间传递，不需要去声明中间的变量。12345678910// 非 pointfree，因为提到了数据：namevar initials = function (name) &#123; return name.split(' ').map(compose(toUpperCase, head)).join('. ');&#125;;// pointfreevar initials = compose(join('. '), map(compose(toUpperCase, head)), split(' '));initials(\"hunter stockton thompson\");// 'H. S. T' pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。 组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。 PS: **Ramda 数据一律放在最后一个参数，理念是”function first，data last”; 库所有的函数都支持柯里化**，可以很好地实践FP。 REFS:使用JavaScript实现“真·函数式编程”Ramda 函数库参考教程","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://sherrywu0917.github.io/tags/函数式编程/"}]},{"title":"core-decorators源码简析——throttle","date":"2018-06-25T08:14:08.000Z","path":"2018/06/25/core-decorators源码简析——throttle/","text":"@throttle节流函数：函数节流能使得连续的函数执行，变为固定时间段间断地执行。 使用实例例如在监听窗口滚动事件时，稍微滚动一下，就会触发多次onscroll事件，去更新位置信息。如果onscroll事件是去进行dom操作，频繁地更新dom可能会导致低版本浏览器卡死。所以希望可以间隔一段时间，再去执行回调函数。应用throttle函数，设置wait时间为1000ms，可以保证回调函数至少每隔1000ms执行一次。1234567891011121314151617import &#123; throttle &#125; from 'core-decorators';class Scroller &#123; position = ''; @throttle(1000, &#123;leading: false&#125;) updatePosition() &#123; this.position = window.scrollY; &#125; bindEvent() &#123; window.onscroll = () =&gt; &#123; this.updatePosition() &#125;; &#125;&#125; 源码实现参数在调用的时候支持传入wait、options.leading、options.trailing三个参数： wait: 等待执行的时间，单位ms，默认值300 {leading}: 绑定的函数在节流开始前执行，默认值true，触发事件刚开始时执行回调 {trailing}: 绑定的函数在节流开始后执行，默认值true，触发事件结束时执行回调 具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function handleDescriptor(target, key, descriptor, [wait = DEFAULT_TIMEOUT, options = &#123;&#125;]) &#123; const callback = descriptor.value; if (typeof callback !== 'function') &#123; throw new SyntaxError('Only functions can be throttled'); &#125; if (options.leading !== false) &#123; options.leading = true &#125; if(options.trailing !== false) &#123; options.trailing = true &#125; return &#123; ...descriptor, value() &#123; // 同debounce，会返回this的Symbol('__core_decorators__')属性: 为Meta实例 const meta = metaFor(this); const &#123; throttleTimeoutIds, throttlePreviousTimestamps &#125; = meta; const timeout = throttleTimeoutIds[key]; // 上次函数执行时的时间戳 let previous = throttlePreviousTimestamps[key] || 0; const now = Date.now(); // options.trailing为true时，将待执行函数callback的参数赋值给meta.throttleTrailingArgs，保证在setTimeout回调函数中可以取到参数 if (options.trailing) &#123; meta.throttleTrailingArgs = arguments; &#125; // 第一次调用，并且leading参数为false时，将上次执行时间戳设为当前 // trailing为true时，leading为false，throttlePreviousTimestamps[key]始终被赋值为0 if (!previous &amp;&amp; options.leading === false) &#123; previous = now; &#125; // leading为false的时候，previous=now, remaining时间始终等于wait，始终不会在节流函数开始时执行回调函数 // leading为true的时候，第一次调用，previous为0，remaining为负值；再次调用，previous为上次回调执行时间，若距离上次执行时间已经等待了wait毫秒，则remaining&lt;=0 const remaining = wait - (now - previous); //&#123;leading: true&#125; remaining&lt;=0的时候，会在节流开始前执行callback函数 if (remaining &lt;= 0) &#123; clearTimeout(timeout); delete throttleTimeoutIds[key]; // 更新上次执行时间戳 throttlePreviousTimestamps[key] = now; // 执行回调函数 callback.apply(this, arguments); &#125; else if (!timeout &amp;&amp; options.trailing) &#123; // 当前没有timeout对象，并且trailing为true // &#123;trailing: true, leading: false&#125; 设置remaining = wait毫秒后去执行回调函数 // &#123;trailing: true, leading: true&#125; 第二次调用才会设置remaining=wait - (now - previous)毫秒后去执行回调函数 throttleTimeoutIds[key] = setTimeout(() =&gt; &#123; // 更新上次执行时间戳，leading为false，throttlePreviousTimestamps[key]始终被赋值为0 throttlePreviousTimestamps[key] = options.leading === false ? 0 : Date.now(); // 删掉timeout对象 delete throttleTimeoutIds[key]; // 执行回调函数 callback.apply(this, meta.throttleTrailingArgs); // 防止内存泄露 meta.throttleTrailingArgs = null; &#125;, remaining); &#125; &#125; &#125;;&#125; 结合了时间戳和定时器setTimeout两种方式来实现throttle函数: leading为true时，主要根据时间戳来记录上次执行时间，每次触发事件时，判断当前时间距离上次执行时间是否已经等待了wait毫秒，如果是，则立即执行 trailing为true时，主要通过setTimeout定时器来设定间隔某个时间段才去执行 leading为false，定时wait毫秒(从当前时间算起)后去执行 leading为true时，定时距离上次执行累计wait毫秒后去执行 每次执行都会记录下当前执行时间，用来控制时间间隔","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"core-decorators","slug":"core-decorators","permalink":"https://sherrywu0917.github.io/tags/core-decorators/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"decorators源码简析——debounce","slug":"decorators源码简析——debounce","permalink":"https://sherrywu0917.github.io/tags/decorators源码简析——debounce/"}]},{"title":"core-decorators源码简析——lazyInitialize","date":"2018-06-14T12:45:45.000Z","path":"2018/06/14/core-decorators源码简析——lazyInitialize/","text":"@lazyInitialize@lazyInitialize标记的作用是，只有在属性真正使用的时候才会去初始化。适用于一些在未来可能会被用到、也可能不会被用到的属性上。 使用实例下面是官网给出的例子，可以帮助我们理解该标记的作用。123456789101112131415161718192021import &#123; lazyInitialize &#125; from 'core-decorators';function createHugeBuffer() &#123; console.log('huge buffer created'); return new Array(1000000);&#125;class Editor &#123; @lazyInitialize hugeBuffer = createHugeBuffer();&#125;var editor = new Editor();// createHugeBuffer() has not been called yeteditor.hugeBuffer;// logs 'huge buffer created', now it has been callededitor.hugeBuffer;// already initialized and equals our buffer, so// createHugeBuffer() is not called again 源码123456789101112131415161718192021222324252627282930313233343536import &#123; decorate, createDefaultSetter &#125; from './private/utils';const &#123; defineProperty &#125; = Object;function handleDescriptor(target, key, descriptor) &#123; const &#123; configurable, enumerable, initializer, value &#125; = descriptor; return &#123; configurable, enumerable, get() &#123; // This happens if someone accesses the // property directly on the prototype if (this === target) &#123; return; &#125; const ret = initializer ? initializer.call(this) : value; defineProperty(this, key, &#123; configurable, enumerable, writable: true, value: ret &#125;); return ret; &#125;, set: createDefaultSetter(key) &#125;;&#125;export default function lazyInitialize(...args) &#123; return decorate(handleDescriptor, args);&#125; 在第一次调用editor.hugeBuffer时，真正的初始化发生在这两步：1234567const ret = initializer ? initializer.call(this) : value;defineProperty(this, key, &#123; configurable, enumerable, writable: true, value: ret&#125;); step1 其中initializer.call(this)中的this是调用该方法的对象，这儿是Editor的实例对象editor，通过call方法initializer方法的this指向editor。 initializer是一个返回createHugeBuffer()的函数，console.log(initializer)的输出如下所示:（什么情况下initializer不存在，取value值？）123ƒ initializer() &#123; return createHugeBuffer();&#125; step2 defineProperty重新赋值了key值对应的descriptor对象，将初始化后的值ret赋值给对应的value字段，应该是模拟了在类构造函数执行时，initializer返回的值作为属性的值，在类构造函数执行后，initializer属性被替换为value属性。 为什么需要defineProperty如果删除上面get方法的defineProperty，则editor.hugeBuffer每次都会调用get()方法，进而执行createHugeBuffer()方法，每次都会去重新初始化，所以在属性初始化完成后，需要对value赋值，替换掉initializer。123456//defineProperty(this, key, &#123;// configurable,// enumerable,// writable: true,// value: ret//&#125;);","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"core-decorators","slug":"core-decorators","permalink":"https://sherrywu0917.github.io/tags/core-decorators/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"lazyInitialize","slug":"lazyInitialize","permalink":"https://sherrywu0917.github.io/tags/lazyInitialize/"}]},{"title":"core-decorators源码简析——debounce","date":"2018-06-13T12:37:05.000Z","path":"2018/06/13/core-decorators源码简析——debounce/","text":"@debounce防抖动函数：当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数则将取消前一次并重新计算执行时间。 使用实例1234567891011121314151617import &#123; debounce &#125; from 'core-decorators';class Editor &#123; content = ''; @debounce(500) updateContent(content) &#123; this.content = content; &#125; bindEvent() &#123; document.getElementById('editor').oninput = e =&gt; &#123; this.updateContent(e.target.value) &#125; &#125;&#125; 1&lt;textarea id=\"editor\"&gt;&lt;/textarea&gt; 例如在监听id为editor的编辑器输入时，每次输入都会触发oninput事件，调用this.updateContent方法。为了防止频繁地更新content，可以对updateContent装饰debounce方法，在输入的过程中不会去更新this.content，直到输入完成500毫秒后，再去一次性更新content内容。 源码12345678910111213141516171819202122232425262728293031323334353637import &#123; metaFor &#125; from './private/utils';const DEFAULT_TIMEOUT = 300;function handleDescriptor(target, key, descriptor, [wait = DEFAULT_TIMEOUT, immediate = false]) &#123; const callback = descriptor.value; if (typeof callback !== 'function') &#123; throw new SyntaxError('Only functions can be debounced'); &#125; return &#123; ...descriptor, value() &#123; //返回this的Symbol('__core_decorators__')属性: 为Meta实例 const &#123; debounceTimeoutIds &#125; = metaFor(this); //已有的防抖函数调用 const timeout = debounceTimeoutIds[key]; //immediate为true且当前无timeout对象，多次调用的时候只在第一次调用时才去执行 const callNow = immediate &amp;&amp; !timeout; const args = arguments; clearTimeout(timeout); // 每次都覆盖之前的防抖函数，执行最后一次传入的callback函数 debounceTimeoutIds[key] = setTimeout(() =&gt; &#123; delete debounceTimeoutIds[key]; if (!immediate) &#123; callback.apply(this, args); &#125; &#125;, wait); if (callNow) &#123; //先执行再等待 callback.apply(this, args); &#125; &#125; &#125;;&#125; 调用参数在调用的时候支持传入wait和options.immediate两个参数： wait: 等待执行的时间，单位ms，默认值300 {immediate}: 绑定的函数是否先执行，默认值false，等待wait时间后再执行；传递的参数为true时先执行 Meta对象123const &#123; debounceTimeoutIds &#125; = metaFor(this);//这个时候只有debounceTimeoutIds被初始化了哦，因为用了lazyInitializeconsole.log(metaFor(this)) metaFor方法给当前实例增加了Symbol(&#39;__core_decorators__&#39;)属性，值为一个Meta对象。Meta类如下所示，包括debounce和throttle用到的一些属性：12345678910111213141516class Meta &#123; @lazyInitialize debounceTimeoutIds = &#123;&#125;; @lazyInitialize throttleTimeoutIds = &#123;&#125;; @lazyInitialize throttlePreviousTimestamps = &#123;&#125;; @lazyInitialize throttleTrailingArgs = null; @lazyInitialize profileLastRan = null;&#125; 使用了@lazyInitialize标记，可以使得每次只初始化被用到的属性，像debounce的时候只用到debounceTimeoutIds属性。console输出Meta对象，结构如图所示，可以看到只初始化了debounceTimeoutIds属性： debounceTimeout存储 当调用被@debounce标记的方法时：1 . setTimeout会延迟执行该函数，返回一个timeout对象；2 . 返回的timeout对象会被存储在debounceTimeoutIds[key]中（以updateContent方法为例，debounceTimeoutIds[key]这里的key值就是updateContent）；3 . 重复调用该方法会重新创建timeout对象，并覆盖之前的debounceTimeoutIds[key]（这里每次调用updateContent都会重新给debounceTimeoutIds[&#39;updateContent&#39;]赋值）； 123456setTimeout(() =&gt; &#123; delete debounceTimeoutIds[key]; if (!immediate) &#123; callback.apply(this, args); &#125; &#125;, wait); 执行的结果就是：每次都重新等待wait时间，再去执行callback方法，callback即是key值对应的方法。","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"core-decorators","slug":"core-decorators","permalink":"https://sherrywu0917.github.io/tags/core-decorators/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"decorators源码简析——debounce","slug":"decorators源码简析——debounce","permalink":"https://sherrywu0917.github.io/tags/decorators源码简析——debounce/"}]},{"title":"cmd小工具开发","date":"2018-05-31T02:02:52.000Z","path":"2018/05/31/cmd小工具开发/","text":"cmd项目初始化首先新建一个文件夹，并且初始化package.json，同时在bin文件夹下面创建入口文件index.js。1npm init #初始化'package.json'文件 index.js文件头部有#!/usr/bin/env node，叫做shebang)，指定脚本解释程序为node。package.json文件中bin字段配置了cmd命令将执行的js文件，如下所示：1234567891011121314&#123; \"name\": \"mkfile-cli\", \"version\": \"1.0.7\", \"main\": \"index.js\", \"bin\": &#123; \"mk\": \"bin/index.js\" &#125;, \"repository\": &#123; \"type\" : \"git\", \"url\" : \"https://xxx\" &#125;, \"author\": \"sherrywu\", \"license\": \"ISC\",&#125; 运行 可以运行node bin/index.js命令 通过npm link的方式 还可以通过npm install . -g安装到全局 cmd命令行工具开发commander.jsCommander是一个轻量级、强大的命令行开发框架，提供了封装好的API，帮助用户快速开发命令行工具。 安装：1npm install commander --save optionoption()方法的定义 option(flags, description, fn, defaultValue) flags : 自定义参数，格式为”-shortFlag, –longFlag null|&lt;value&gt;|[value]|&lt;value&gt;..&lt;value&gt;“ -shortFlag：”-“后面跟的是自定义参数的短标志，一般用longFlag的第一个字母(区分大小写) –longFlag ：”–”后面跟的是自定义参数的长标志，shortFlag和longFlag必须同时存在， null|&lt;value&gt;|[value]：有3种情况 null——可以不带参数 &lt;value&gt;——“&lt;&gt;”修饰，参数必须。 [value]——”[]“修饰, 参数可选。 description : 对flags参数的描述 fn &lt;Function|Mixed&gt; : 自定义处理参数的方法，如果传入的不是一个方法，会先判断是否为一个正则表达式，如果不是，则视为defaultValue（默认值）， defaultValue ：自定义参数默认值 返回值 ：commander对象 1234567program .version('1.0.1') .option('-n, --new &lt;filename&gt;', '创建文件') .parse(process.argv);if(program.new || program.n) &#123; console.log('文件名：' + (program.new || program.n))&#125; 通过mk -h可以查看帮助文档，-h 和 -V都是commander封装好的命令:123456789$ mk -h Usage: index [options] Options: -V, --version output the version number -n, --new &lt;filename&gt; 创建文件 -h, --help output usage information on事件监听此外还可以自定义help文档，通过监听–help触发定义的回调方法。12345678program.on('--help', function () &#123; console.log(' 自定义的例子:') console.log('') console.log(' 输出命令 mk -n test -k activityList') console.log(' 输出命令 mk --new test') console.log('')&#125;).parse(process.argv); program.parse 会解析命令行参数以及触发回调方法，因为nodejs的emit会立刻触发事件，所以将该方法放在命令及事件监听的最后面。 参数运行mk -n test -k activityList命令，可以通过program.n和program.k分别获得文件名’test’和模板key值’activityList’。 主要流程运行mk -n test -k activityList，读取mk.json文件中定义的模板,根据key值读取此次创建文件的模板来源： dir: 创建文件的目标位置 suffix: 文件后缀 tpl: 文件模板，模板内容可以自定义，使用的模板语法是nunjucks。123456789&#123; \"fileList\" : [ &#123;\"dir\": \"test/js\", \"suffix\": \"js\", \"tpl\": \"tpl/js.tpl\"&#125;, &#123;\"dir\": \"test/css\", \"suffix\": \"css\", \"tpl\": \"tpl/css.tpl\"&#125; ], \"activityList\" : [ &#123;\"dir\": \"activity/js\", \"suffix\": \"js\", \"tpl\": \"tpl/js.tpl\"&#125; ]&#125; npm包开发首先要npm adduser来注册个npm账号，如果已经有账号，可以使用npm login来登录。通过npm version &lt;update_type&gt;对版本进行管理，更新了版本号后发布：1npm publish 最终发布的npm包见mkfile-cli","tags":[]},{"title":"core-decorators源码简析——readonly","date":"2018-04-17T07:40:08.000Z","path":"2018/04/17/core-decorators源码简析——readonly/","text":"直接看源码，readonly.js代码非常简短，核心函数是handleDescriptor，通过修改描述对象descriptor的writable属性为false，将目标属性置为不可修改。12345678910import &#123; decorate &#125; from './private/utils';function handleDescriptor(target, key, descriptor) &#123; descriptor.writable = false; return descriptor;&#125;export default function readonly(...args) &#123; return decorate(handleDescriptor, args);&#125; 其中decorate函数定义在utils文件中，具体如下: 123456789101112131415161718192021222324252627export function isDescriptor(desc) &#123; if (!desc || !desc.hasOwnProperty) &#123; return false; &#125; const keys = ['value', 'initializer', 'get', 'set']; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; if (desc.hasOwnProperty(keys[i])) &#123; return true; &#125; &#125; return false;&#125;export function decorate(handleDescriptor, entryArgs) &#123; if (isDescriptor(entryArgs[entryArgs.length - 1])) &#123; console.log(entryArgs); console.log(entryArgs[entryArgs.length - 1].initializer); return handleDescriptor(...entryArgs, []); &#125; else &#123; return function () &#123; return handleDescriptor(...Array.prototype.slice.call(arguments), entryArgs); &#125;; &#125;&#125; 首先判断传过来的最后一个参数是否是descriptor对象，若该参数有[&#39;value&#39;, &#39;initializer&#39;, &#39;get&#39;, &#39;set&#39;]属性中的任一个，则认为是descriptor对象，直接调用handleDescriptor去处理。若所传最后一个参数不是descriptor对象，则返回一个匿名函数，可以接收额外的参数。 descriptor对象基本内容如下： configurable控制是否能删、修改descriptor本身。 writable控制是否能修改值value。 enumerable控制是否能枚举出属性。 value是该属性对应的值，可以是任何有效的JavaScript值（数值，对象，函数等）。 get和set控制访问属性的读和写逻辑。 其中，前三个属性是一定存在的，value和get/set属性不会并存。当装饰器作用于类属性时，descriptor将变成一个叫“类属性描述符”的东西，其区别在于没有value和get或set，且多出一个initializer属性，类型是函数，在类构造函数执行时，initializer返回的值作为属性的值，在类构造函数执行后，initializer属性被替换为value属性。 使用123456789class Meal &#123; @readonly // 或者@readonly() entree = 'steak';&#125;var dinner = new Meal();console.log('--------对象创建后----------')console.log(Object.getOwnPropertyDescriptors(dinner));dinner.entree = 'salmon'; 输出的descriptor前后对比：其中initializer函数内部即为return &#39;steak&#39;。同时会报错Uncaught TypeError: Cannot assign to read only property ‘entree’ of object ‘#‘，提示该属性只读。","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"core-decorators","slug":"core-decorators","permalink":"https://sherrywu0917.github.io/tags/core-decorators/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"readonly","slug":"readonly","permalink":"https://sherrywu0917.github.io/tags/readonly/"}]},{"title":"core-decorators源码简析——autobind","date":"2018-04-12T12:22:06.000Z","path":"2018/04/12/core-decorators源码简析——autobind/","text":"入口函数先看入口函数，通过export default暴露的autobind函数，通过...args形式的rest参数获取函数的多余参数，这儿是所有参数。通过decorator形式有两种调用方式： @autobind()，会返回一个匿名函数function (...argsClass) {return handle(argsClass);}，argsClass为最终decorator传入的参数，函数内部返回了handle函数；在修饰器外面再封装一层函数的方式，可以用于接收额外的参数； @autobind，args即为decorator传入的参数，直接调用handle函数 12345678910111213141516/** * 两种调用方式 * * 2. @autobind * @param &#123;...[type]&#125; args [description] * @return &#123;[type]&#125; [description] */export default function autobind(...args) &#123; if (args.length === 0) &#123; return function (...argsClass) &#123; return handle(argsClass); &#125;; &#125; else &#123; return handle(args); &#125;&#125; handle函数handle函数根据参数的长度去判断修饰类型，当args参数长度为1时，是对类的修饰，该参数即所要修饰的目标类；当长度为3时，是对方法的修饰，参数和Object.defineProperty的参数相对应target, name, descriptor:{value, configurable, enumerable, writable}。1234567function handle(args) &#123; if (args.length === 1) &#123; return autobindClass(...args); &#125; else &#123; return autobindMethod(...args); &#125;&#125; 对类的修饰 Object.getOwnPropertyDescriptors会以键值对的形式返回某对象属性的描述对象descriptor； getOwnKeys方法会返回一个数组，包含目标类原型对象上所有的属性的键名，包括不可枚举属性以及Symbol属性autobindClass遍历目标类原型上的所有方法，若某个属性对应的value类型是function并且属性不是constructor，则用Object.defineProperty对该属性进行重新赋值，调用autobindMethod实现对该方法的autobind； 1234567891011121314function autobindClass(klass) &#123; const descs = getOwnPropertyDescriptors(klass.prototype); const keys = getOwnKeys(descs); for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i]; const desc = descs[key]; if (typeof desc.value !== 'function' || key === 'constructor') &#123; continue; &#125; defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc)); &#125;&#125; getOwnKeys方法的实现如下所示：123456export const getOwnKeys = getOwnPropertySymbols ? function (object) &#123; return getOwnPropertyNames(object) .concat(getOwnPropertySymbols(object)); &#125; : getOwnPropertyNames; 其中getOwnPropertySymbols会返回包含对象所有Symbol属性的数组，getOwnPropertyNames会返回包含自身所有属性（不包括Symbol属性，但包括不可枚举属性）的数组。此外，Object.assign拷贝只会拷贝属性的值，并不会拷贝它的赋值方法set和取值方法get，结合Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))可以实现对象属性取值、赋值方法的拷贝。 对方法的修饰autobindMethod第一个参数是类的原型对象，第二个参数是要修饰的属性名，第三个参数是该属性的描述对象，它通过修改描述对象的get赋值方法，实现了对方法的自动绑定，返回修改后的descriptor。赋值方法内不同条件分别对应的调用场景为： this === target: 调用方式let method = Child.prototype.childMethod，this就是Child.prototype，不绑定直接return。 this.constructor !== constructor &amp;&amp; getPrototypeOf(this).constructor === constructor: 调用方式let method = Child.prototype.parentMethod，子类没有该方法，this.constructor是Child.prototype.constructor，constructor是Parent.prototype.constructor，二者不等，但是this.__proto__.constructor和Parent.prototype.constructor是相同的(在es6的继承中Child.prototype.__proto__ === Parent.prototype)，不绑定直接return。 this.constructor !== constructor &amp;&amp; key in this.constructor.prototype: 子类调用父类的方法，仍然绑定为子类的this；如果不做该判断，直接到下一步bind(fn, this);则父类的方法会覆盖子类，下次调用就只执行父类中的方法了。 其他：调用bind(fn, this)绑定上下文。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function autobindMethod(target, key, &#123; value: fn, configurable, enumerable &#125;) &#123; if (typeof fn !== 'function') &#123; throw new SyntaxError(`@autobind can only be used on functions, not: $&#123;fn&#125;`); &#125; const &#123; constructor &#125; = target; return &#123; configurable, enumerable, get() &#123; // Class.prototype.key lookup // Someone accesses the property directly on the prototype on which it is // actually defined on, i.e. Class.prototype.hasOwnProperty(key) if (this === target) &#123; return fn; &#125; console.log(target, key) // Class.prototype.key lookup // Someone accesses the property directly on a prototype but it was found // up the chain, not defined directly on it // i.e. Class.prototype.hasOwnProperty(key) == false &amp;&amp; key in Class.prototype // Object.getPrototypeOf作用： // 1. 用于获取一个实例对象的原型对象 // 2. Object.getPrototypeOf(ColorPoint) === Point 用来判断一个类是否继承了另一个类 if (this.constructor !== constructor &amp;&amp; getPrototypeOf(this).constructor === constructor) &#123; return fn; &#125; // Autobound method calling super.sameMethod() which is also autobound and so on. // this.constructor: Child constructor: Parent if (this.constructor !== constructor &amp;&amp; key in this.constructor.prototype) &#123; return getBoundSuper(this, fn); &#125; const boundFn = bind(fn, this); defineProperty(this, key, &#123; configurable: true, writable: true, // NOT enumerable when it's a bound method enumerable: false, value: boundFn &#125;); return boundFn; &#125;, set: createDefaultSetter(key) &#125;;&#125; 实际调用时的例子：12345678910111213141516171819202122232425262728293031323334353637383940@autobindclass Person &#123; constructor() &#123; &#125; getPerson() &#123; console.log('parent called, AWESOME METHOD'); return this; &#125;&#125;@autobindclass Man extends Person &#123; constructor() &#123; super(); &#125; getMan() &#123; return this; &#125;&#125;//四种方法分别对应上面列出的四种场景console.log('---Man.prototype.getMan---');let getProtoMan = Man.prototype.getMan;console.log(getProtoMan());console.log('---Man.prototype.getPerson---');let getProtoPerson = Man.prototype.getPerson;console.log(getProtoPerson());console.log('---man.getPerson---');let man = new Man();let getPerson = man.getPerson;console.log(getPerson() === man);console.log('---man.getMan---');let man2 = new Man();let getMan = man2.getMan;console.log(getMan() === man2); 输出结果如下图所示： getBoundSuper函数作用给子类Man添加一个方法getPerson，方法内通过super调用父类的getPerson方法，super.getPerson对应上述场景3；如果不调用getBoundSuper函数，子类的getPerson方法在执行super.getPerson时会被父类覆盖，会导致下面方法只有第一次会输出’parent called, AWESOME METHOD’和’child called, AWESOME CHILD METHOD’，其他四次则只输出’parent called, AWESOME METHOD’。12345678910111213141516171819202122@autobindclass Man extends Person &#123; constructor() &#123; super(); &#125; getPerson() &#123; console.log('child called, AWESOME CHILD METHOD'); super.getPerson(); return this; &#125; getMan() &#123; return this; &#125;&#125;for (var i = 0; i &lt; 5; ++i) &#123; console.log('invoking'); man.getPerson(); console.log('---');&#125; WeakMap的特性： 只能用对象obj作为key值 WeakMap的键名对应的对象不计入垃圾回收机制，如果对应的对象被清除，垃圾回收机制就会释放该对象所占用的内存，即WeakMap中的对应的键名对象和键值也会自动消失，不用手动删除适用场景：WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 通过getBoundSuper可以将父类方法绑定到子类this上，并且使用WeakMap存储已经绑定的方法，在mapStore中key值对应子类实例，不同的子类实例对应不同的WeakMap，若该子类被删除，对应的WeakMap对象也会被清除。123456789101112131415161718let mapStore;function getBoundSuper(obj, fn) &#123; if (!mapStore) &#123; mapStore = new WeakMap(); &#125; if (mapStore.has(obj) === false) &#123; mapStore.set(obj, new WeakMap()); &#125; const superStore = mapStore.get(obj); if (superStore.has(fn) === false) &#123; superStore.set(fn, bind(fn, obj)); &#125; return superStore.get(fn);&#125;","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"core-decorators","slug":"core-decorators","permalink":"https://sherrywu0917.github.io/tags/core-decorators/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"autobind","slug":"autobind","permalink":"https://sherrywu0917.github.io/tags/autobind/"}]},{"title":"继承&原型链","date":"2018-04-10T09:14:43.000Z","path":"2018/04/10/继承-原型链/","text":"基于proto和prototype的原型链关于__proto__属性，MDN上的解释如下： The proto property of Object.prototype is an accessor property (a getter function and a setter function) that exposes the internal [[Prototype]] (either an object or null) of the object through which it is accessed. 即是说，__proto__ 属性指向了实例对象的原型Constructor.prototype。 首先用一张图来总结__proto__和prototype的关系： 实例的__proto__123function Foo() &#123;&#125;var f1 = new Foo();f1.__proto__ == Foo.prototype; //true 通过new方法创建函数Foo的实例f1，f1.__proto__会指向Foo.prototype，进而继承Foo函数原型上的所有属性和方法。在JS中，只有函数有prototype属性，基于prototype可以去模拟实现类和继承。 函数原型和构造器123f1.constructor === Foo.prototype.constructor; //trueFoo.prototype.constructor === Foo; //truef1.constructor === Foo; //true f1是Foo的示例，它的constructor就是Foo函数原型对象中的constructor，而Foo函数原型上的constructor就指向函数本身。 对象的__proto__12345var one = &#123;x: 1&#125;;var two = new Object();one.__proto__ === Object.prototype // truetwo.__proto__ === Object.prototype // trueone.toString === one.__proto__.toString // true 不管是隐式还是显式创建的对象，对象的__proto__都是Object.prototype，Object实际上是一个js函数function Object(){}，所以拥有prototype属性。two = new Object()中Object是构造函数，所以two.__proto__就是Object.prototype。至于one，ES规范定义对象字面量的原型就是Object.prototype。123one.constructor === Object.prototype.constructor;Object.prototype.constructor === Object;one.constructor === Object; 函数的__proto__12Foo.constructor === Function; //trueFoo.__proto__ === Function.prototype; // true 函数Foo的构造函数是function Function(){}，所以函数Foo的__proto__都指向Function.prototype。1234Function.__proto__ === Function.prototype; // trueArray.__proto__ === Function.prototype; // trueObject.__proto__ === Function.prototype; // trueString.__proto__ === Function.prototype; // true 而Function本身就是函数，所以Function.__proto__就是Function.prototype，二者为同一对象。同理，Object/Array/String等等构造函数本质上和Function一样，均继承于Function.prototype。 Function.prototype的__proto__Function.prototype直接继承自Object.prototype，Function.prototype.__proto__就是Object.prototype，二者为同一对象。123Function.prototype.__proto__ === Object.prototype; //trueFunction.prototype instanceof Object; //trueFunction.prototype instanceof Function; //false 通过这点我们可以弄清继承的原型链：Object.prototype—&gt;Function.prototype—&gt;Function|Object|Array…。。综上所述可以得出：1Function.__proto__.__proto__ === Object.prototype; 所以Function是Object的实例1Function instanceof Object; //true 此外Object作为函数，继承了Function.prototype的方法，所以Object又是Function的实例。12Object.__proto__ === Function.prototype;Object instanceof Function; //true 哈哈，二者互为实例，这就是有名的鸡生蛋和蛋生鸡的关系。 Object.prototype的__proto__原型链的尽头（root）是Object.prototype。所有对象均从Object.prototype继承属性。1Object.prototype.__proto__ === null; //true REFS: 从__proto__和prototype来深入理解JS对象和原型链Javascript Object Layout es6继承class通过extends实现继承，比起es5基于原型链、借用构造函数实现继承方便很多。1234567891011121314151617class A &#123; constructor() &#123; this.x = 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125;&#125;let b = new B(); 上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。这是由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 set的时候，super为this子类实例 get的时候，super获取的是A.prototype 大多数浏览器的 ES5 实现之中，每一个对象都有proto属性，指向对应的构造函数的prototype属性。12function test()&#123;&#125;test.__proto__ = test.constructor.prototype es6中extends实现的继承，同时有prototype属性和proto属性，因此同时存在两条继承链。1234B.__proto__ === AB.prototype.__proto__ === A.prototype//对应es5实现B.prototype = new A() 实现继承的关键： 子类B.prototype的__proto__属性指向A.prototype，即B.prototype.__proto__ = A.prototype，表示将继承父类原型上的属性和方法; 子类B的__proto__属性总是指向父类A，即B.__proto__ = A，表示将继承父类的静态属性和方法。 这样的结果是因为，类的继承是按照下面的模式实现的。1234567891011class A &#123;&#125;class B &#123;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B(); Object.setPrototypeOf方法的实现，会将proto对象作为obj的原型。1234Object.setPrototypeOf = function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; 本质上，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。","tags":[{"name":"继承","slug":"继承","permalink":"https://sherrywu0917.github.io/tags/继承/"},{"name":"原型链","slug":"原型链","permalink":"https://sherrywu0917.github.io/tags/原型链/"}]},{"title":"npm转盘组件开发","date":"2018-02-09T06:39:53.000Z","path":"2018/02/09/npm转盘组件开发/","text":"准备工作在开始开发之前，首先要准备好node环境和npm账户，nodeJS基本都有安装好，要做的就是注册npm：1234$ npm adduserUsername: your namePassword: your passwordEmail: (this IS public) your email 查询当前账号或者登陆别的用户：12$ npm whoami$ npm login 包管理工具lerna项目组采用了lerna包管理工具，可以在一个仓库下管理多个npm包，基于monorepo理念。 Monorepo is a unified source code repository used by an organisation to host as much of its code as possible.Monorepo 它是一种管理 organisation 代码的方式，在这种方式下会摒弃原先一个 module 一个 repo 的方式，取而代之的是把所有的 modules 都放在一个 repo 内来管理。 lerna安装和初始化12npm install lerna -glerna init 初始化后，目录里面会自动生成/packages、lerna.json和package.json。执行lerna bootstrap会自动为项目进行npm install和npm link操作，npm的作用是边开发边试用，具体使用参考npm link。执行lerna publish可以发布版本。lerna有两种模式的管理方式，项目仓库选用默认的Fixed/Locked模式，在lerna.json里的version字段是本仓库版本，packages下的包的版本等于或者小于本仓库的版本有两种情况： 如果某个包的版本更新了，原版本是1.0.2，本仓库版本是1.0.9，则这个包的更新后的版本是1.0.10，而不是1.0.3 如果有个包引入了重大改动（BREAKING CHANGE）, 则所有的包的major version都会改变其中commit message的编写遵循Conventional Commits ，主要包括fix/feat/BREAKING CHANGE三种类型，以及对文档的修改docs:，或者其他style:, refactor:, perf:, test:, chore:。 组件开发定义组件配置项和方法组件对外暴露的类是PrizeWheel，该class的构造函数支持传入rotateSelector(将要旋转的元素对应的选择器)和config(转盘相关配置)两个参数，config中支持对奖项、旋转元素类型、转速等的配置。此外，该class提供了旋转到指定位置和终止旋转两个方法。初始化时，_countPrizeAngleMap方法会计算出每个奖项的目标角度。1234567891011121314151617_countPrizeAngleMap() &#123; const &#123;prizeQueue, rotator, inSector&#125; = this.config; let len = prizeQueue.length; prizeQueue.forEach( (level, index) =&gt; &#123; let diff = 0, targetAngle = 0; if(inSector) &#123; diff = - 360/len/2; &#125; if(rotator == 'pointer') &#123; //指针旋转 targetAngle = 360/len * (index + 0.5) + diff; &#125; else &#123; //转盘旋转 targetAngle = 360 - (360/len * (index + 0.5) + diff); &#125; this.prizeAngleMap.set(level, targetAngle); &#125;)&#125; prizeQueue是一个数组，对应转盘上的奖项队列，按照顺时针方向。rotator是旋转类型：’pointer’(Default) - 指针旋转、’wheel’ - 转盘旋转。inSector代表初始位置是否在扇区内：false(Default)、true，false代表与扇区的边缘线重合，true代表在扇区的正中位置。旋转的情况有四种(N从0开始计数)： 旋转的是指针，inSector为false：指针在边缘线，则第N个奖项的目标角度 = 每个扇区的角度 * (N + 0.5)； 旋转的是指针，inSector为true：指针在扇区中央，旋转的角度相对上一种少了半个扇区，则第N个奖项的目标角度 = 每个扇区的角度 (N + 0.5) - 每个扇区的角度 0.5； 旋转的是扇区，inSector为false(或true)：目标角度都是 = 360 - (指针旋转情况下的角度) 具体的转盘效果封装在了WheelEffect类中，该类的关键点是提供了一个缓动函数(参考的网上代码)：1function easing(t, b, c, d) &#123; return -c * ((t=t/d-1)*t*t*t - 1) + b; &#125; 其中参数含义： t: 当前动画已经持续的时间 b: 开始的角度 c: 一共要旋转的角度和 d: 动画要持续的时间间隔特定的时间去旋转该方法返回的角度，实现动效。 组件发布期望通过import PrizeWheel from &#39;nw-prize-wheel&#39;的方式引入组件，所以在prize-wheel.js中是这样export的：12export default class PrizeWheel &#123;&#125; 但在打包成js文件时，通过script标签嵌入，发现直接new PrizeWheel()报错，提示undefined，在网上找了一圈，发现需要另外新建一个index.js，在index.js中:1module.exports = require('./src/prize-wheel.js').default; webpack配置添加library和libraryTarget。123456output: &#123; path: __dirname + '/lib', filename: '[name].js', library: 'PrizeWheel', libraryTarget: 'this'&#125; 期望webpack提供诸如libraryTarget: &#39;default&#39;这样的配置来解决问题，但目前不支持，只能用上述方法来曲线救国。 组件API文档化1jsdoc2md --template readme.hbs --files src/prize-wheel.js &gt; readme.md 结合了jsdoc和jsdoc2md可以将自定义的模板和js注释生成一个API文档，具体的使用方式详见官网。 最终实现的组件详情nw-prize-wheel","tags":[{"name":"npm包","slug":"npm包","permalink":"https://sherrywu0917.github.io/tags/npm包/"},{"name":"组件开发","slug":"组件开发","permalink":"https://sherrywu0917.github.io/tags/组件开发/"}]},{"title":"IOS微信内二维码无法识别问题","date":"2018-02-06T03:41:42.000Z","path":"2018/02/06/IOS微信内二维码无法识别问题/","text":"","tags":[]},{"title":"decorator","date":"2018-01-16T14:02:37.000Z","path":"2018/01/16/decorator/","text":"REFS:http://taobaofed.org/blog/2015/11/16/es7-decorator/http://es6.ruanyifeng.com/#docs/decoratorhttp://raganwald.com/2015/06/26/decorators-in-es7.html","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"es7","slug":"es7","permalink":"https://sherrywu0917.github.io/tags/es7/"}]},{"title":"react高阶组件","date":"2017-10-30T09:39:56.000Z","path":"2017/10/30/react高阶组件/","text":"什么是高阶组件？官方文档指出，高阶组件（Higher-Order Components，简称HOC）是react中对组件逻辑进行重用的高级技术。但高阶组件本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。具体而言，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。先看一个典型的高阶组件：1234567891011121314151617// It's a function...function myHOC() &#123; // Which returns a function that takes a component... return function(WrappedComponent) &#123; // It creates a new wrapper component... class TheHOC extends React.Component &#123; render() &#123; // And it renders the component it was given return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; // Remember: it takes a component and returns a new component // Gotta return it here. return TheHOC; &#125;&#125; 使用高阶组件优化代码需求是要在网站的每个页面要添加签到请求和签到成功弹窗，显然，一般人都不会想着要在每个页面写一遍。首先，我想到的是引入一个React组件，但是要在每个页面的render方法里面添加该组件，需要改动所有页面对应组件的render方法，感觉比较繁琐且易出错。也可以通过js方法去动态创建签到成功弹窗，然后在每个页面里面引入该方法，不过同样需要改变组件内部方法，且不符合React项目风格。最后，发现高阶组件可以满足我的需求，既实现了功能又不污染原有组件。下面是简化版的签到高阶组件：1234567891011121314151617181920212223242526export const signHoc = ComposedComponent =&gt; class extends Component &#123; constructor(props) &#123; super(props) this.state = &#123;show: false, config: &#123;&#125;&#125; &#125; componentDidMount() &#123; if(!this.props.showSign) return; this.setState(&#123; show: true, config: &#123; title: '今日首次登录', content: `获赠&lt;em&gt;50&lt;/em&gt;阅点红包` &#125; &#125;) &#125; render() &#123; const &#123;show, config&#125; = this.state; const &#123;showSign, ...passThroughProps&#125; = this.props; return (&lt;div&gt; &lt;ComposedComponent &#123;...passThroughProps&#125; /&gt; &#123;show &amp;&amp; (&lt;MessageModal config=&#123;config&#125;/&gt;)&#125; &lt;/div&gt;); &#125;&#125;; 可以通过this.props获得传给WrappedComponent的props，在操作props的时候要确保不会破坏要传给WrappedComponent的props。在componentDidMount可以发起签到请求，此外可以根据props.showSign和签到结果决定是否显示签到组件等。当页面有其他弹窗的优先级大于签到弹窗时，props.showSign设为false，就可以控制签到弹窗是否显示。123456export default class WrappedComponent extends Component &#123; render() &#123; return false &#125;&#125;signHoc(WrappedComponent) 调用signHoc函数获得组合后的组件，也可以结合@decorator简化调用。123456@signHocexport default class WrappedComponent extends Component &#123; render() &#123; return false &#125;&#125; 结合Context API使用React 16.3引入了全新的Context API，主要提供的API有：React.createContext, Provider和Consumer，详见context。这儿记录下如何结合高阶组件和Context API去实现全局变量的设置，如主题theme。step1: 定义高阶组件，通过ThemeContext.Consumer获取变量并且传递给组件ComposedComponent。1234567891011export const ThemeContext = React.createContext(&#123; theme: localStorage.getItem('N_reader_theme') || 'light', changeTheme: () =&gt; &#123;&#125;&#125;);export const themeHoc = ComposedComponent =&gt; &#123; props =&gt; &#123; &lt;ThemeContext.Consumer&gt; &#123;(&#123;theme, changeTheme&#125;) =&gt; &lt;ComposedComponent &#123;...props&#125; theme=&#123;theme&#125; changeTheme=&#123;changeTheme&#125;/&gt;&#125; &lt;/ThemeContext.Consumer&gt; &#125;&#125; step2: 使用ThemeContext.Provider传递当前theme、changeTheme给整个子树，任何子组件都可以读到这些变量的值，不需要显式的通过props传递。12345678910111213141516171819import &#123;ThemeContext&#125; from 'themeHoc.js'export default class App extends Component &#123; changeTheme(theme) &#123; localStorage.setItem('N_reader_theme', theme); document.querySelector('body').className = document.querySelector('body').className.replace(/theme--\\w*/, 'theme--' + theme); this.setState(&#123; theme: theme &#125;) &#125; render() &#123; return ( &lt;ThemeContext.provider value=&#123;&#123;theme: this.state.theme, changeTheme: this.changeTheme&#125;&#125;&gt; &lt;Content /&gt; &lt;/ThemeContext.provider&gt; ) &#125;&#125; step3: 通过decorator的方式添加@themeHoc标记，Content组件可以直接从props中读取theme和changeTheme函数。12345678910111213import &#123;themeHoc&#125; from 'themeHoc.js'@themeHocexport default class Content extends Component &#123; render() &#123; return ( &lt;div theme=&#123;props.theme&#125;&gt; &lt;a href=\"javascript:;\" className=&#123;props.theme&#125; onClick=&#123;props.changeTheme.bind(this, 'blue')&#125;&gt;blue&lt;/a&gt; &lt;a href=\"javascript:;\" className=&#123;props.theme&#125; onClick=&#123;props.changeTheme.bind(this, 'yellow')&#125;&gt;yellow&lt;/a&gt; &lt;/div&gt; ) &#125;&#125; 公约最大化使用组合高阶组件可以接受一个或多个参数：123456//仅接收包裹组件一个参数const NavbarWithRouter = withRouter(Navbar);//接收包裹组件和额外的参数const CommentWithRelay = Relay.createContainer(Comment, config);//connect(commentListSelector, commentListActions)返回了一个高阶组件，最后作用于Comment组件const ConnectedComment = connect(commentSelector, commentActions)(Comment); 包装显示名字以便于调试高价组件创建的容器组件在React Developer Tools中的表现和其它的普通组件是一样的。为了便于调试，可以选择一个好的名字，确保能够识别出它是由高阶组件创建的新组件还是普通的组件。最常用的技术就是将包裹组件的名字包装在显示名字中。所以，如果你的高阶组件名字是 withSubscription，且包裹组件的显示名字是 CommentList，那么就是用 withSubscription(CommentList)这样的显示名字：123456789function withSubscription(WrappedComponent) &#123; class WithSubscription extends React.Component &#123;/* ... */&#125; WithSubscription.displayName = `WithSubscription($&#123;getDisplayName(WrappedComponent)&#125;)`; return WithSubscription;&#125;function getDisplayName(WrappedComponent) &#123; return WrappedComponent.displayName || WrappedComponent.name || 'Component';&#125; 注意事项静态方法需要被复制当你通过 HOC 创建组件的时候，原有组件被容器组件包裹。这意味着容器组件不含有原有组件的静态方法。1234567// 创建静态方法WrappedComponent.staticMethod = function() &#123;/*...*/&#125;// Now apply an HOCconst EnhancedComponent = enhance(WrappedComponent);// 新组件没有静态方法typeof EnhancedComponent.staticMethod === 'undefined' // true 为了解决这个问题，你需要在包裹之前把静态方法拷贝给容器组件：123456function enhance(WrappedComponent) &#123; class Enhance extends React.Component &#123;/*...*/&#125; // Must know exactly which method(s) to copy :( Enhance.staticMethod = WrappedComponent.staticMethod; return Enhance;&#125; 也可以使用 hoist-non-react-statics 来自动拷贝非原生 React 方法的静态方法。 ref不会被传递尽管高阶组件的约定是把所有的 props 传递给被包裹的组件，但它并不能传递 ref。那是因为 ref 实际上并不是 prop —— 就像 key 一样，它们会被 React 特殊对待。如果你给 HOC 传递了 ref，它将指向容器组件而不是被包裹的组件。如果一定要用到ref，可以将ref当做普通的props传递给组件：1234567891011121314151617function Field(&#123; inputRef, ...rest &#125;) &#123; return &lt;input ref=&#123;inputRef&#125; &#123;...rest&#125; /&gt;;&#125;// 将 Field 在高阶组件里包裹起来const EnhancedField = enhance(Field);// 在组件的 render 方法内..&lt;EnhancedField inputRef=&#123;(inputEl) =&gt; &#123; // This callback gets passed through as a regular prop this.inputEl = inputEl &#125;&#125;/&gt;// 在高阶组件中就可以访问组件实例和dom节点了...this.inputEl.focus();","tags":[{"name":"react","slug":"react","permalink":"https://sherrywu0917.github.io/tags/react/"},{"name":"高阶组件","slug":"高阶组件","permalink":"https://sherrywu0917.github.io/tags/高阶组件/"}]},{"title":"日常经验积累","date":"2017-10-19T03:28:58.000Z","path":"2017/10/19/日常经验积累/","text":"禁用复制功能123document.oncontextmenu = function() &#123; return false; &#125; //禁用鼠标右键功能document.body.oncopy = function() &#123; return false; &#125; //禁用复制功能document.onselectstart = function() &#123; return false; &#125; //禁用选择功能 UC浏览器问题UC浏览器会过滤掉top、test、ad、download等关键字uc浏览器判断到页面上文字居多时，会自动放大字体优化移动用户体验。添加以下头部可以禁用掉该优化 Font Boosting问题问题：字体的显示大小，与在CSS中指定的大小不一致。通过设置max-height: 999999px;或max-height: 100%;可以解决 ios&lt;10 js无法实现复制copy-to-clipboard-using-javascript-in-ios 移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行ios微信缓存问题问题：ios9系统下微信内(非必现)，从充值页回到正文页，正文页获取的余额没有刷新，发现get请求没有发出，应该是微信AJAX缓存的问题。可通过给ajax请求加时间戳的方式解决。参考：微信自带浏览器物理返回不刷新问题 奇怪现象：其他的ios系统下，请求也没有发出去，但是数据是正确的，可能和缓存快照有关系，正常的可能保存了这个页面上次运行的整个数据栈。 移动端滚动穿透问题完美解决方案1234body.modal-open &#123; position: fixed; width: 100%;&#125; 当打开modal的时候给body添加modal-open类，fixed让底部页面无法滚动，同时根据页面滚动位置设置top值。在关闭modal时，再让页面恢复之前的滚动状态。1234567891011121314151617181920/** * ModalHelper helpers resolve the modal scrolling issue on mobile devices * https://github.com/twbs/bootstrap/issues/15852 * requires document.scrollingElement polyfill https://github.com/yangg/scrolling-element */var ModalHelper = (function(bodyCls) &#123; var scrollTop; return &#123; afterOpen: function() &#123; scrollTop = document.scrollingElement.scrollTop; document.body.classList.add(bodyCls); document.body.style.top = -scrollTop + 'px'; &#125;, beforeClose: function() &#123; document.body.classList.remove(bodyCls); // scrollTop lost after set position:fixed, restore it back. document.scrollingElement.scrollTop = scrollTop; &#125; &#125;;&#125;)('modal-open'); 不简单的自适应高度输入框主要实现代码如下：12345678910111213textarea &#123; width: 100%; height: 92px; padding: 20px; line-height: 50px; resize: none; outline: none; border: 1px solid #ccc; background: #eee; font-size: 32px; box-sizing: border-box; overflow: hidden; //去掉滚动条&#125; 1&lt;textarea id=\"textarea\"&gt;&lt;/textarea&gt; 12345678910111213141516171819202122var $textarea = document.getElementById('textarea');var lastLength = 0;var lastHeight = 0;$textarea.addEventListener('input', function() &#123; var currentLength = $textarea.value.length; // 判断字数如果比之前少了，说明内容正在减少，需要清除高度样式，重新获取 if (currentLength &lt; lastLength) &#123; $textarea.style.height = ''; &#125; var currentHeight = $textarea.scrollHeight; // 如果内容高度发生了变化，再去设置高度值 if (lastHeight !== currentHeight || !$textarea.style.height) &#123; $textarea.style.height = currentHeight + 2 + 'px'; &#125; lastLength = currentLength; lastHeight = currentHeight;&#125;); 原理是检测textarea.scrollHeight属性变化，并随之设置textarea的高度。 参考：https://juejin.im/post/5b7653bde51d454dba70c0b1?utm_source=gold_browser_extension setTimeout(fun, 0)1234setTimeout(function () &#123; func1();&#125;, 0)func2(); func1和func2谁会先执行？很明显func2先执行；setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f,0)，那么会立刻执行吗？答案是不会。因为setTimeout运行机制说过，必须要等到当前脚本的同步任务和“任务队列”中已有的事件，全部处理完以后，才会执行setTimeout指定的任务。也就是说，setTimeout的真正作用是，在“任务队列”的现有事件的后面再添加一个事件，规定在指定时间执行某段代码。setTimeout添加的事件，会在下一次Event Loop执行。setTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务——脚本的同步任务和“任务队列”中已有的事件，一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。12345678910111213141516171819202122232425262728setTimeout(function() &#123; console.log(\"Timeout\");&#125;, 0);function a(x) &#123; console.log(\"a() 开始运行\"); b(x); console.log(\"a() 结束运行\");&#125;function b(y) &#123; console.log(\"b() 开始运行\"); console.log(\"传入的值为\" + y); console.log(\"b() 结束运行\");&#125;console.log(\"当前任务开始\");a(42);console.log(\"当前任务结束\");// 当前任务开始// a() 开始运行// b() 开始运行// 传入的值为42// b() 结束运行// a() 结束运行// 当前任务结束// Timeout 上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，最少是4毫秒。如果小于这个值，会被自动增加到4。这是为了防止多个setTimeout(f,0)语句连续执行，造成性能问题。利用setTimeout(func, 0)可以帮助我们： 调整函数运行顺序 分割耗时任务 0.5px边框1234567891011121314151617 .scale-1px &#123; position: relative; margin-bottom: 20px; border:none;&#125;.scale-1px:after &#123; content: ''; position: absolute; top: 0; left: 0; border: 1px solid #000; box-sizing: border-box; width: 200%; height: 200%; transform: scale(0.5); transform-origin: left top;&#125; ios系统上active不生效问题在iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。可以采用下面两种方式解决：1document.addEventListener(\"touchstart\", function() &#123;&#125;, false); 12&lt;body ontouchstart=\"\"&gt;&lt;/body&gt; beforeunload事件兼容问题：为了优化用户体验，新式浏览器会要求有交互才会触发beforeunload事件，例如新版本的chrome浏览器。PS: 从Firefox 4、 Chrome 51、Opera 38 和Safari 9.1开始，通用确认信息代替事件返回的字符串，即无法通过下面的方式自定义文案。1234567891011window.onbeforeunload = function (e) &#123; e = e || window.event; // 兼容IE8和Firefox 4之前的版本 if (e) &#123; e.returnValue = '关闭提示'; &#125; // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+ return '关闭提示';&#125;; HTML5规范中指出，在该事件中调用window.alert(), window.confirm(), 和 window.prompt()，会被忽略。详细的可参考MDN。 get请求没有bodyHTTP规范也不推荐这么做：下面来自 rfc7231 ： A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request. 打包配置 单一css并且无需css module的组件可以直接用babel命令行处理，css统一入口通过lessc打包，并且单独引入 如果需要处理css module，并且有多个css文件的，需要用webpack进行打包，配置如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// eslint-disable-next-line no-unused-varsconst webpack = require('webpack');const UglifyJsPlugin = require('uglifyjs-webpack-plugin');const path = require('path');const config = &#123; entry: './src/index.js', output: &#123; path: path.join(__dirname, '/dist'), filename: 'ctMobileLogin.umd.js', library: 'CtMobileLogin', globalObject: 'this', libraryTarget: 'umd', umdNamedDefine: true &#125;, resolve: &#123; extensions: ['.js', '.jsx', '.css', '.less'] &#125;, externals: &#123; react: &#123; root: 'React', commonjs2: 'react', commonjs: 'react', amd: 'react', umd: 'react', &#125;, 'react-dom': &#123; root: 'ReactDOM', commonjs2: 'react-dom', commonjs: 'react-dom', amd: 'react-dom', umd: 'react-dom', &#125; &#125;, module: &#123; rules: [&#123; test: /\\.(js|jsx)$/, exclude: /(node_modules)/, use: [&#123; loader: 'babel-loader', options: &#123; cacheDirectory: true, presets: ['@babel/preset-env'], plugins: ['@babel/plugin-transform-runtime'] &#125; &#125;] &#125;, &#123; test: /\\.(css|less)?$/, exclude: /node_modules/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; modules: true, &#125;, &#125;, &#123; loader: 'postcss-loader', options: &#123; plugins: [ require('autoprefixer')(&#123; browsers: ['IOS &gt;= 7.0', 'Android &gt;= 4.0'] &#125;) ] &#125; &#125;, &#123; loader: 'less-loader' &#125; ] &#125;, &#123; test: /\\.(css|less)?$/, include: /node_modules/, use: [ 'style-loader', &#123; loader: 'css-loader', &#125;, &#123; loader: 'postcss-loader', options: &#123; plugins: [ require('autoprefixer')(&#123; browsers: ['IOS &gt;= 7.0', 'Android &gt;= 4.0'] &#125;) ] &#125; &#125;, &#123; loader: 'less-loader' &#125; ] &#125;, &#123; test: /\\.(png|jpg|gif|svg|cur)?$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 2560, name: '[path][name].[ext]?[hash]' &#125; &#125;] &#125;] &#125;, // mode: 'development', // devtool: 'source-map', optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; uglifyOptions: &#123; // 删除注释 output: &#123; comments: false &#125;, // 删除console debugger 删除警告 compress: &#123; drop_debugger: false, pure_funcs: ['console.log']// 移除console &#125; &#125; &#125;) ] &#125;, plugins: [ ]&#125;;module.exports = config; 打包兼容ssr 对于puzzle加载的js还是采用老方式进行打包 对于import使用的js，直接打包css到js文件中在ssr阶段会报错，因为用的style-loader，改成MiniCssPlugin提取出css文件css打包修改完成后，发现fetch包被打包进来的是request，在ssr阶段还是会报错，最后通过将fetch包驾到perDep中，并且在webpack配置中添加externals解决该问题","tags":[{"name":"总结","slug":"总结","permalink":"https://sherrywu0917.github.io/tags/总结/"}]},{"title":"SASS使用二三事","date":"2017-08-28T10:15:21.000Z","path":"2017/08/28/sass应用/","text":"sass管理z-indexz-index的值和上下文有关系，在复杂布局中要跟踪z-index比较困难，z-index的取值范围很广，很容易出错，所以可以使用sass预处理器去统一管理。 定义浮层首先，我们可以借助sass 3.3引入的Map定义一个数据结构，key代表了不同浮层类型，value即对应的z-index值：123456789$z-layers: ( 'toast': 4000, 'modal': 3000, 'dropdown': 2000, 'mask': 1000, 'default': 1, 'below': -1, 'bottomless-pit': -10000); 定义函数123@function z($layer) &#123; @return map-get($z-layers, $layer);&#125; 使用了sass的map-get方法，如果$layer参数存在于$z-layers中，会返回对应的value值，如z(‘toast’)，返回对应的值为4000；若不存在于$z-layers中，则返回null。属性为null时，sass的编译不会输出。也可以借助map-has-key方法检查元素是否存在，对于不存在的元素使用@warn指令输出警告信息，方便我们在开发的时候发现问题。1234567@function z($layer) &#123; @if not map-has-key($z-layers, $layer) &#123; @warn \"No z-index found in $z-layers map for `#&#123;$layer&#125;`. Property omitted.\"; &#125; @return map-get($z-layers, $layer);&#125; 使用方法123456789//function方式.m-mask &#123; z-index: z('mask');&#125;//mixin方式.m-mask &#123; @include z('mask');&#125; 对于单个属性来说，建议采用function的定义方式，比起mixin方式，使用起来更加清晰、简单。 嵌套层级在层级关系比较多的情况下，单一层级可能无法满足我们的需求，如弹窗里面还有很多的层级关系时，这个时候，我们可以使用嵌套的层级定义方式，针对modal进行再扩展，对modal里面的元素进一步定义层级数值。1234567891011121314$z-layers: ( 'toast': 4000, 'modal': ( \"base\": 3200, \"close\": 3100, \"header\": 3050, \"footer\": 3000 ), 'dropdown': 2000, 'mask': 1000, 'default': 1, 'below': -1, 'bottomless-pit': -10000); 想要定义$z-layers中modal内部的层级关系，可以用嵌套的Map去设置，如上所示。要处理嵌套的层级关系，对应的z函数可以是：123456789101112131415161718192021@function map-has-nested-keys($map, $keys...) &#123; @each $key in $keys &#123; @if not map-has-key($map, $key) &#123; @return false; &#125; $map: map-get($map, $key); &#125; @return true;&#125;@function map-deep-get($map, $keys...) &#123; @each $key in $keys &#123; $map: map-get($map, $key); &#125; @return $map;&#125;@function z($layers...) &#123; @if not map-has-nested-keys($z-layers, $layers...) &#123; @warn \"No layer found for `#&#123;inspect($layers...)&#125;` in $z-layers map. Property omitted.\"; &#125; @return map-deep-get($z-layers, $layers...);&#125; 其中map-has-nested-keys方法可以检查元素是否存在于已经定义的$z-layers中： 若$keys只有一个值’toast’，@each只需要循环一次，在循环内，$map被赋值为’toast’对应的z-index值，最后返回true值； 若$keys有两个值’modal’和’base’，@each循环两次，第一次循环，先检查’modal’是否存在于$z-layers中，再将$map赋值为map-get($z-layers, ‘modal’)，即内部嵌套的modal的map，第二次循环先判断’base’是否存在于$map中，若不存在直接返回false，若存在$map被赋值为’base’对应的z-index值，最后返回true值；map-deep-get方法用于获得对应的z-index值，思路和map-has-nested-keys方法一致，只是前者返回true/false，后者返回$map值。具体的调用方式如下所示：12345678910111213141516171819.modal &#123; position: absolute; z-index: z(\"modal\", \"base\"); .close-button &#123; z-index: z(\"modal\", \"close\"); &#125; header &#123; z-index: z(\"modal\", \"header\"); &#125; footer &#123; z-index: z(\"modal\", \"footer\"); &#125;&#125;.toast &#123; z-index: z(\"toast\");&#125; 另一种z-index管理思路首先创建一个层级列表，在这个列表中，元素的出现顺序是从低到高，使用sass提供的index方法获取元素在$elements中的顺序，即为该元素的z-index值。12345$elements: project-covers, sorting-bar, modals, navigation;.project-cover &#123; z-index: index($elements, project-covers);&#125; 输出的z-index为1，与javascript不同，sass的索引值从1开始，就像css一样，css的:nth-child(n)中的n也是从1开始。123.project-cover &#123; z-index: 1;&#125; 个人觉得，这个方法更简单，适合于轻量级的项目，但灵活性不够好，取值范围受限于index值，对于嵌套的层级关系不友好，扩展性不好，对于较复杂项目更建议用前一种Map的形式来管理。 sass主题管理在项目开发中，涉及到不同主题的切换，例如在正文阅读时，有白天、黑夜、蓝色、黄色四种主题，不同主题配色不同，如果直接用css，结构复杂并且很难维护。利用scss提供的变量定义和方法，可以降低开发和维护成本。 sass管理颜色首先，sass可以对整个项目常用的一些颜色进行定义，例如本次项目通用的红色值为#ED6460，则可以在单独的文件_color.scss中定义该色值，其他scss文件通过@import引用。1234567$black: #24211F;$red: #ED6460;$blue: #60aaed;$border-gray: #ededed;$bg-gray: #f5f5f5;$btn-gray: #807A73; 主题定义首先，定义一个Map，记录不同的主题和与之关联的颜色，每个主题下细分了不同用途的色值。12345678910111213141516171819202122232425262728293031323334@import './color.scss';//主题base设置$theme: ( light: ( bg: #fff, //背景色 color: $black, //正文颜色 title: #A83A45, //章节标题颜色 link: #60AAED, //底部链接颜色 border: #ededed, //正文底部border颜色 themeBorder: #d8d8d8 //主题切换btn选中状态的border颜色 ), dark: ( …… ), blue: ( …… ), yellow: ( …… ));@each $name, $theme in $theme &#123; .theme--#&#123;$name&#125; &#123; color: map-get($theme, color); background-color: map-get($theme, bg); .m-main .content &#123; h1, h2 &#123; color: map-get($theme, title); &#125; &#125; .link &#123; color: map-get($theme, link); &#125; // ... 其他涉及主题配色的选择器 &#125;&#125; 通过@each去遍历Map，.theme–#{$name}编译后会生成.theme-light, .theme-dark等，在.theme–#{$name} 选择器内部，可以定义该主题下不同元素的样式，具体颜色可以通过map-get方法获得。对于button这种，在不同主题下颜色、边框、背景、active状态等都需要改变，可以单独定义。1234567891011121314151617181920212223$btn: ( light: ( color: $gray1, border: $gray0, bg: transparent, color-active: #fff, border-active: $red, bg-active: $red ), dark: ( …… ), blue: ( …… ), yellow: ( …… ),);@each $name, $theme in $btn &#123; .btn--#&#123;$name&#125; &#123; color: map-get($theme, color); border-color: map-get($theme, border); background-color: map-get($theme, bg); &#125; .btn--#&#123;$name&#125;:active, .btn--#&#123;$name&#125;-active &#123; color: map-get($theme, color-active); border-color: map-get($theme, border-active); background-color: map-get($theme, bg-active); &#125;&#125; 将主题颜色与其他不变的样式分离出来进行管理，所有的主题颜色维护在_theme.scss中，从而极大地提高了代码的可维护性。在切换主题的时候，只需要更换相应的类名，尤其在结合react开发时，theme变化时只需要重新setState一下就会重新渲染页面，十分方便。 定义通用样式可以通过sass提供的@mixin, @function等方式定义通用样式，如可以将实现单行\\多行文字截断效果的一组样式封装，用@mixin定义line-ellipsis方法，参数为行数和行高。传入行高是为了兼容不支持多行截断的浏览器，计算得出最大高度，防止样式错乱。其中行数的默认值为1，行高的默认值为1.5，可以使用@if,@else去判断行数，根据$num值去返回样式。12345678910111213141516@mixin line-ellipsis($num: 1, $lineH: 1.5)&#123; @if $num &gt; 1 &#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: $num; text-overflow: ellipsis; line-height: $lineH; max-height: $lineH * $num; overflow: hidden; &#125; @else &#123; white-space: nowrap; text-overflow: ellipsis; line-height: $lineH; overflow: hidden; &#125;&#125; 在使用的时候，通过@include方法引用，如下所示：1234567h3 &#123; @include line-ellipsis(); //默认单行截断&#125;.desc &#123; @include line-ellipsis(3, rem(38)); //3行截断&#125; desc这个类是多行截断，其中行高是rem(38)，调用了sass定义的px转rem的函数，是将38像素转为rem值。借助sass，可以方便地定义将像素转为rem。12345678@function rem($px, $base-font-size: 75px) &#123; @if (unitless($px)) &#123; //unitless(75) =&gt; true; unitless(75px) =&gt; false @return rem($px + 0px); &#125; @else if (unit($px) == rem) &#123; //unit(75px) =&gt; px; unitless(1rem) =&gt; rem @return $px; &#125; @return ($px / $base-font-size) * 1rem;&#125; 在rem()函数中设置了两个参数$px和$base-font-size，并且给$base-font-size设置了默认值75px。rem布局使用了淘宝的lib.flexible方案，所以默认值为75px。而且在rem()函数中使用了unitless去判断$px是否携带单位，若没带为true，否则为false。若$px没带单位，则通过+0px的方式带上px单位。若$px带单位，用unit获取$px带的单位，若是rem，则直接返回，其他的，与$base-font-size相除得到rem值。除此之外，可以结合项目需求定义更多的方法，如通用的button样式、适配浏览器分辨率、兼容性等等。 参考链接：Module: Sass::Script::FunctionsA Better Solution for Managing z-index with SassFriendlier colour names with Sass maps","tags":[{"name":"css","slug":"css","permalink":"https://sherrywu0917.github.io/tags/css/"},{"name":"sass","slug":"sass","permalink":"https://sherrywu0917.github.io/tags/sass/"}]},{"title":"项目开发record","date":"2017-07-27T01:38:34.000Z","path":"2017/07/27/分站开发总结/","text":"业务背景 已有的阅读产品经过多年的发展，功能已经稳定，但整体用户体量不高、用户活跃度不够，且存在UV和收益下降的趋势，无法达到部门收益的KPI；短期内，无法找到新的增长点，是为了提高收益，达成部门的KPI，迫切需要扩展新的业务线。 在当时公众号兴起繁荣的大环境下，渠道分销是一个很火的模式，公众号有着大量的用户流量，而我们可以提供海量的阅读资源，所以要解决的问题是如何通过公共号引流，所以我们期望有这样一个平台将资源和用户打通，可以给公众号的用户提供书籍阅读的功能，同时可以实现收益，最终实现和公众号平台的互利共生，这样公众号也乐于和我们合作，继而有一个累积的正向收益。基于上面两点，我们计划开发渠道小说分站，分站的整体包括： toA的内部结算系统、书籍编辑器等 toB的公众号平台 toC的H5阅读分站 实现前端目录结构基于React + React-Router + Sass开发的webpack打包的多页面应用，其中正文页面和搜索页面是基于React-Router开发的单页面应用。路由类型采用的是BrowserRouter，在移动端pushState/replaceState没有兼容问题，可以放心使用。如果是要兼容IE9及以下，则不能使用BrowserRouter，建议使用HashRouter。此外，使用BrowserRouter后，可以借助history的特性帮助我们实现记录每个页面的历史停留位置。 BrowserRouter与HashRouter主要区别 hashRouter不支持location.key 、location.state：刷新页面或者直接浏览器回退一步，再前进时，BrowserRouter的页面依然可以获取到state中的值，而在HashRouter页面中无法获取到state的值，因为HashRouter没有使用HTML5的History API，所以刷新路由后导致state值丢失。 12345678910111213141516171819202122232425|-- assets | |-- config //webpack编译 | |-- base.js //基础编译配置 | |-- dev.js //开发环境编译配置 | |-- dll.js //动态链接库编译配置 | |-- hot.js //热替换编译配置 | |-- prod.js //开发环境编译配置 | |-- util.js //定义配置相关的通用方法和变量 | |-- src //源码目录 | |-- component // 组件 | | |-- common //公共组件 | | |-- //其他子组件 | |-- entry //入口js，与静态html文件相对应 | |-- util //通用方法 | |-- image //图片资源 | |-- style //样式 | |-- template //html模板，动态生成html文件 | |-- mock.json // mock数据 |-- server_hot.js //实现热更新、拦截并处理前端请求(返回本地页面、mock数据，其他请求转发到服务端处理) ||-- dist //构建目录 其中，模板中是静态html文件，在没有添加后端路由的情况下，通过server_hot.js中的页面映射去访问前端页面，例如当匹配到路径/index时，返回index.html页面，结合mock数据，真正实现了前后端分离。1234567891011121314151617181920let templateMap = &#123; '/search': 'search.html', '/search/book': 'search.html', '/index': 'index.html', '/history': 'history.html', '/rank': 'rank.html', '/home/more': 'more.html', '/category': 'category.html', '/info': 'info.html', '/detail': 'detail.html', '/book/reader': 'reader.html', '/recharge': 'recharge.html', '/catalog': 'catalog.html'&#125;for (let mapItem in templateMap) &#123; app.get(mapItem, function(req, res) &#123; res.sendFile(__dirname + '/template/' + templateMap[mapItem]); &#125;);&#125; API转发后获取服务端数据失败的问题在使用http-proxy-middleware转发请求到后端时，发现有部分请求无法获得返回数据，首先可以确定的是请求被转发到后端了。调试发现后端会验证站点相关信息，在验证host的时候报错。猜测可能是请求转发后header里的host信息丢失，查询API发现可以设置option.headers，如下所示。12var proxyMiddleware = require('http-proxy-middleware');var apiProxy = proxyMiddleware('/api', &#123; target: 'http://ypxst.kuxuanbook.yuedu.163.com', headers: &#123;host: 'ypxst.kuxuanbook.yuedu.163.com'&#125;&#125;); 设置好host后，就可以正常获取接口返回数据了。 POST请求验证XSRF-TOKEN之前阅读常用的方式是后端写入freemarker模板或者通过异步接口获得，这次和后端约定统一放在cookie中。1234headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'X-XSRF-TOKEN': csrf_token&#125; 从cookie中读取token后封装在post接口中，写在headers里面，这样在使用的时候就直接调用post方法，无需关注token验证。 使用git subtree同步assets工程assets资源存在于novel-webapp-wap和novel-webapp-recharge两个工程下面，recharge工程下面用到的是充值页面，其他页面都在wap工程下，之所以分开为两个工程是因为涉及到支付，充值的域名需要是唯一的，而分站的域名很多。为了保证二者资源的同步，可以使用git subtree实现子工程的同步。12345# 获取远端novel-webapp-assets的更新git subtree pull --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash# 将本地assets更新推送到远端novel-webapp-assetsgit subtree push --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash webpack替换文件链接的资源通过给chunk filename添加[chunkhash]去有效地缓存文件，每次修改后生成新的chunkhash值，手动替换很麻烦，所以结合done plugin去完成html文件中资源名字的自动替换。stats记录了打包信息和相应的chunkhash值，其中assetsByChunkName包含了以chunkname作为key，filename作为值的对象，结构如下：1234567891011\"assetsByChunkName\": &#123; \"reader\": [ \"js/reader-60b54d52.js\", \"css/reader-60b54d52.css\" ], //... \"common\": [ \"js/common-a814792a.bundle.js\", \"css/common-a814792a.css\" ]&#125; 遍历stats对象中的entrypoints，这里的entrypoints的key值和html文件名一致、且一一对应的，根据key值读取可以读取对应的html文件，通过正则匹配的方式将对应的js、css文件替换为本次打包生成的文件。123456789101112131415161718192021222324252627282930function () &#123; this.plugin('done', function (stats) &#123; for(var key in stats.toJson().entrypoints) &#123; var htmlPath = path.join(ROOT_PATH, 'template', key + '.html'); var htmlContent = fs.readFileSync(htmlPath, 'utf8'); var keyJSRegExp = new RegExp('js\\/' + key + '(.*?)\\.js'); var keyCSSRegExp = new RegExp('css\\/' + key + '(.*?)\\.css'); var keyAssets = [].concat(stats.toJson().assetsByChunkName[key]); var commonAssets = [].concat(stats.toJson().assetsByChunkName['common']); var htmlOutput = ''; var keyJS = keyAssets.filter(path =&gt; path.endsWith('.js'))[0]; var keyCSS = keyAssets.filter(path =&gt; path.endsWith('.css'))[0]; if(keyJS) &#123; htmlOutput = htmlContent.replace(keyJSRegExp, keyJS); &#125; if(keyCSS) &#123; htmlOutput = htmlOutput.replace(keyCSSRegExp, keyCSS); &#125; var commonJS = commonAssets.filter(path =&gt; path.endsWith('.js'))[0]; var commonCSS = commonAssets.filter(path =&gt; path.endsWith('.css'))[0]; if(commonJS) &#123; htmlOutput = htmlOutput.replace(/js\\/common(.*?)\\.js/g, commonJS); &#125; if(commonCSS) &#123; htmlOutput = htmlOutput.replace(/css\\/common(.*?)\\.css/g, commonCSS); &#125; fs.writeFileSync(htmlPath, htmlOutput); &#125; &#125;);&#125; Refs:LOADING WEBPACK BUNDLES WITH HASH VALUE polyfill引入方式比较babel-core/babel-preset-*等插件可以将语法从 es6 转成 es5，但没有提供 api 的转码功能，如 Promise、Set、Map 等新增对象，Object.assign、Object.entries 等全局对象上的新增方法都不会转码， babel-runtime 和 babel-polyfill 就是为此而生。这两个模块功能几乎相同，就是转码新增 api，模拟 es6 环境，但实现方法完全不同。 babel-polyfill库babel-polyfill 的做法是将全局对象通通污染一遍，比如相应使用includes方法，会通过Array.prototype.includes() 的方式去注入污染原型。对于普通的业务代码没有关系，如果不在意略大的体积（min后86kb），推荐使用；但如果用在开发library，则不推荐使用，会污染该library使用者的环境。 babel-runtime库和babel-plugin-transform-runtime 插件babel-runtime 的做法是自己手动引入 helper 函数，const Promise = require(‘babel-runtime/core-js/promise’) 就可以引入 Promise，但是很不方便。借助babel-plugin-transform-runtime插件，可以帮助我们按需加载polyfill，这个模块会将我们的代码重写，如将 Promise 重写成 _Promise（只是打比方），然后引入_Promise helper 函数。此外，babel-runtime 不能转码实例方法，比如这样的代码：12'!!!'.repeat(3);'hello'.includes('h'); 这只能通过 babel-polyfill 来转码，因为 babel-polyfill 是直接在原型链上增加方法。 如果在开发library，为了避免污染使用者的环境，只能用 babel-runtime + babel-plugin-transform-runtime。虽然是业务开发，但是因为移动端比较介意babel-polyfill的体积，所以我还是选择了babel-runtime。 .babelrc中的相关配置12345678910&#123; \"plugins\": [ [\"transform-runtime\", &#123; \"helper\": false, //开启helper后，统一引用了helper \"polyfill\": true, //Map, Set, Promise,Object.assign等 \"regenerator\": true, //主要是实现generator/yeild，async/await \"moduleName\": \"babel-runtime\" &#125;] ]&#125; helper设为true时，会引入一些 helper 来代替每次都生成的通用函数，原来构建好的代码每个模块都有类似这种代码：123function _classCallCheck(instance, Constructor)...function _possibleConstructorReturn(self, call)...function _inherits(subClass, superClass)... 开启helper后123var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _inherits2 = require('babel-runtime/helpers/inherits'); 在v6.12.0 (2016-07-27) 后增加了 helper 的配置，原因是从 babel-runtime 里引入的 helper 依赖很多，全部都是兼容最底层的。比如 Object.create typeof 这种方法全部被重写了，会导致构建模块变大。开启polyfill后，Object.assign方法会被改写为__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()。regenerator设为true，使我们可以使用generator/yeild，async/await。如果你只需要用 regenerator，不需要 core-js 里面的 polyfill 那你就可以在 options 中把 polyfill 设为 false。 babel-preset-env插件 版本支持：babel 7.0beta版、babel-loader 8.0 beta版和babel-preset-env 2.0beta版1npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env --save-dev 首先需要安装babel-polyfill1npm install @babel/polyfill --save 配置”useBuiltIns”: false: 不对polyfills做任何操作 entry: 根据target中浏览器版本的支持，将polyfills拆分引入，仅引入有浏览器不支持的polyfill，通过import &#39;babel-polyfill&#39;方式在代码中一次性引入 usage(新)：检测代码中ES6/7/8等的使用情况，仅仅加载代码中用到的polyfills 这种方式配置非常方便，并且可以按需加载，后续会替换成该插件。 Refs:babel-preset-env按需加载polyfill——babel7的正确打开方式ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍再见，babel-preset-2015 记录正文页历史滚动位置在开发过程中，发现每次返回到历史页面时，都不是上次访问到的页面位置，而是重置到了顶部，react并没有去维护历史页面的滚动位置。所以我们需要手动去记录页面的历史滚动位置。 可能的方案 使用window的onpopstate、onload、onunload事件监听页面的前进、返回，利用command模式维护posUndoStack和posRedoStack栈，记录并保存页面的历史位置问题：结合了history.length去判断页面是前进、返回or新进了一个页面，但是当从b页面返回到a页面后，又点击进入了b页面后，history.length不变，链接不变，这个时候无法辨别浏览器的行为 react-router-scroll组件问题：基于react-router，基于router middleware实现的，使用的Router V4没有中间件的概念 基于history.location.key属性的实现问题：基于react-router 最终方案由于目前没有好的办法去记录所有页面的位置，而记录正文页阅读位置的需求最为必要，所以使用第三个方案，暂时忽略其他页面。使用BrowserRouter的页面支持location.key属性，这个location是react-router引用的history库中的location对象，每个页面有唯一标识的key值。 React-router官网: 使用 hash 的方式记录导航历史不支持 location.key，在以前的版本中，我们为这种行为提供了shim，但是仍有一些问题我们无法解决。 react-router使用的history库在createBrowserHistory时，会调用createKey方法创建页面的key值，key的长度默认为6，可以设置。123var createKey = function createKey() &#123; return Math.random().toString(36).substr(2, keyLength);&#125;; createBrowserHistory类中维护了一个数组allkeys，里面记录了所有页面的location.key。1var allKeys = [initialLocation.key]; 在SPA中的每个页面的history的state中则记录了该页面的key。1globalHistory.pushState(&#123; key: key, state: state &#125;, null, href); 在监听到popState事件后，会通过event拿到进入页面的state，里面记录了key值。123window.onpopstate = function(event) &#123; alert(state: \" + JSON.stringify(event.state));&#125;; 所以在页面返回、前进的时候，同一页面的location.key不变，据此可以在页面离开的时候，用key-value的形式保存当前key值和对应的滚动位置在sessionStorage中。页面离开的情况有：12345678//SPA页面内路由到其他章节componentWillReceiveProps(nextProps) &#123; posReserve.onLeave(this.props.location.key);&#125;//页面unloadwindow.onunload = () =&gt; &#123; posReserve.onLeave(this.props.location.key);&#125; 在页面前进、返回的时候，去sessionStorage中读取历史位置，并滚动页面到对应位置。 ios微信中SPA正文页返回问题问题1：正文内部返回白屏在IOS微信浏览器中阅读正文，返回上一章的时候期望显示上一章内容，但是会出现白屏的问题，需要上滑或者下滑页面，正文才会出现。在寻找解决方案的时候，发现Vue存在相似的问题： iOS Safari renders blank page ios 组件点返回白屏遮挡问题参考了其中的解决方案，在正文内容加载完成后通过js去触发scroll滚动，正文显示就恢复正常了。代码如下所示，尝试了下面两种方式，都可以解决问题。12345678componentDidMount() &#123; window.scrollTo(0, 1) window.scrollTo(0, 0) //或者 setTimeout(() =&gt; &#123; window.scrollTo(0, 0) &#125;, 100)&#125; 问题2: 从其他页面返回正文问题使用Preact的时候，从其他页面返回到正文页后，部分请求没有发出。在debug的时候发现正文页setState没有触发componentWillUpdate，不会rerender，setState的callback不被执行。当从Preact替换为React的时候，页面显示正常。 猜测1: 可能和preact的diff机制有关。因为’对一个虚拟DOM子树是否继续更新下去，如果它们的type, props,key都一样，或者它们的引用也一样，可能也会继续diff，官方还会比较context!!!!这个许多react-like没有考虑到。React-Router就非常依赖context对象进行多层的组件间传递‘。 猜测2: setState回调延后知乎问答‘如何看待 React 的替代框架 Preact’中蓝面小生和司徒正美的回答中列出了Preact存在的一些问题。 解决方案如果继续使用Preact可以通过reload页面解决问题，当从正文页跳转到其他页面时候，记录下当前页面的location.key在sessionStorage中，返回页面时在componentWillMount方法中判断当前key值是否存储在’N_reader_locKeys’，若存在，则说明是页面返回，reload页面，并且从’N_reader_locKeys’中删掉对应的key值。12345678910111213141516171819202122232425262728293031323334componentWillMount() &#123; let _key = this.props.location.key; let locKeys = sessionStorage.getItem('N_reader_locKeys'); if(isIos &amp;&amp; _key &amp;&amp; locKeys)&#123; sessionStorage.removeItem('N_reader_locKey') let index = locKeys.indexOf(_key); if(~index &amp;&amp; this.props.history.action === 'POP') &#123; sessionStorage.setItem('N_reader_locKeys', locKeys.slice(0, index) + locKeys.slice(index + _key.length + 1)); location.reload(); return false; &#125; &#125;&#125;//[IOS微信返回bug处理]记录所有点击跳到其他页面(结合href和isexternal值)bindEvent() &#123; document.addEventListener('click', e =&gt; &#123; let targetEle = e.target; if(targetEle.tagName.toLowerCase() === 'a') &#123; if(targetEle.href.indexOf('.do') !== -1 || (targetEle.getAttribute('isexternal') === 'true')) &#123; e.preventDefault(); let _key = this.props.location.key; let keys = sessionStorage.getItem('N_reader_locKeys') || ''; if(_key &amp;&amp; keys.indexOf(_key) === -1) &#123; keys += _key + ',' sessionStorage.setItem('N_reader_locKeys', keys); &#125; if(targetEle.href.indexOf('.do') !== -1) &#123; location.href = targetEle.href; &#125; &#125; &#125; &#125;)&#125; 鉴于在某ios9版本的iphone5s上正常打开正文一直会出现上述问题，且考虑逻辑的复杂性、未来的需求扩展，最终还是使用React替换了Preact。逻辑越复杂，Preact暴露的问题越多。 问题3：微信url地址问题在IOS微信中，使用history的replaceState、pushState，url栏不变，分享或者通过浏览器打开都还是之前的url。 详情从首页进入正文，通常只带sourceUuid不带articleUuid，在加载当前章节的时候期望通过history.replaceState去更新当前url为带articleUuid，这样当从下一章返回的时候，可以正确显示当前内容，不然会自动获取当前进度，无法显示正确章节。安卓可以正常返回，但ios微信返回的时候url还是不带articleUuid。 解决方案原因是使用H5的history API并不能改变url栏地址内容，分享或通过浏览器打开都是旧的地址，是ios微信的一个bug。改用react-router的history.replace去更新章节可以解决返回问题。原理是虽然地址栏不变，但通过location.href获得的是正确的地址，BrowserRouter单页面应用在切换页面的时候会从window.location中读取{pathname,search,hash}，创建自己的location对象，依据location对象去渲染页面。 Refs: H5 history.pushState 在微信内修改url后点击用safari打开/复制链接是修改之前的页面 lib.flexible方案使用淘宝lib.flexible的rem方案，会遇到一个问题：在ios微信内长按扫描二维码，会有无法识别二维码的问题。[微信已修复该问题] 微信识别二维码的原理机制这里采用的逻辑是截屏识别，当客户端发现用户在网页的img标签内进行长按操作时，会立刻截屏并且启动二维码识别算法。所以这里用于二维码识别的图片是截屏，而不是之前有人提到的img标签中的图片。 实践发现meta scale指定为1的时候，无该问题。问题产生的原因应该是：在iOS下，对于dpr(设备像素比)2和3的屏，用2倍和3倍的方案，其余的用1倍方案。使用高清屏方案后，viewport的scale值会设为1/dpr，页面发生了缩放，二维码的位置实际发生了偏移，因而微信无法准确识别出二维码。设备像素比 = 物理像素 / 设备独立像素； 物理像素：一个物理像素是显示器(手机屏幕)上最小的物理显示单元； 设备独立像素：设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。 在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。 为了解决二维码识别问题，在html中手动添加viewport的meta标签，这样页面就会根据已有的meta标签设置缩放比例，不会使用高清方案。不使用高清方案一个不好的地方是1px边框问题，不过可以通过伪元素搭配transform:scale(0.5)解决。123456789var metaEl = doc.querySelector('meta[name=\"viewport\"]');if (metaEl) &#123; console.warn('将根据已有的meta标签来设置缩放比例'); var match = metaEl.getAttribute('content').match(/initial\\-scale=([\\d\\.]+)/); if (match) &#123; scale = parseFloat(match[1]); dpr = parseInt(1 / scale); &#125;&#125; 1234567891011121314.method-list:after&#123; content: ''; position: absolute; top: 0; left: 0; width: 200%; height: 200%; border-bottom: 1px solid #E1E1E1; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0; box-sizing: border-box;;&#125;","tags":[{"name":"总结","slug":"总结","permalink":"https://sherrywu0917.github.io/tags/总结/"},{"name":"react","slug":"react","permalink":"https://sherrywu0917.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://sherrywu0917.github.io/tags/webpack/"}]},{"title":"css效果","date":"2017-06-30T11:44:13.000Z","path":"2017/06/30/css效果/","text":"仿古效果 CSS处理图像效果：仿古效果[https://www.w3cplus.com/css3/vintage-washout.html] 冲洗效果: 通过减轻暗色阴影和改变一些阴影的细节（改变暗色的细节），看上去就是在亮度的范围降低颜色对比度。 混合模式：lighten将lighten混合模式应用于一个重叠元素或者一个伪元素上。你可以在某个元素上使用background-blend-mode:lighten或者使用多个混合模式，也可以在覆盖元素上使用mix-blend-mode:lighten。建议使用多个背景。 应用使用@mixin 12345678910@mixin fade-it($img, $shadow: #536) &#123; background: url('#&#123;$img&#125;'), $shadow; background-blend-mode: lighten;&#125;.apply-base &#123; @include fade-it('1.jpg');&#125;.apply-unique-shade &#123; @include fade-it('2.jpg', #293e78);&#125; 编译后的css12345678.apply-base &#123; background: url('1.jpg'), #536; background-blend-mode: lighten;&#125;.apply-unique-shade &#123; background: url('2.jpg'), #293e78; background-blend-mode: lighten;&#125;","tags":[{"name":"css","slug":"css","permalink":"https://sherrywu0917.github.io/tags/css/"}]},{"title":"webpack配置","date":"2017-06-27T07:06:13.000Z","path":"2017/06/27/webpack配置/","text":"dll动态链接库优化打包为dll单独配置一个webpack.dll.config.js文件，在entry中引入你要打包到vendor的模块，通常是一些通用的不涉及业务的库。1234567891011121314151617var webpack = require('webpack');module.exports = &#123; entry: &#123;vendor: ['react', 'react-dom']&#125;, output: &#123; path: './dist', filename: '[name].bundle.js', library: '[name]' &#125;, plugins:[ new webpack.DllPlugin(&#123; path: './dist/[name]-manifest.json', name: '[name]', context: __dirname, &#125;) ]&#125; webpack.DllPlugin的选项中，path是manifest文件的输出路径；name是dll暴露的对象名，要跟output.library保持一致。执行webpack --config webpack.dll.config.js后会在dist文件夹下面生成vendor.manifest.json和vendor.bundle.js。其中vendor.manifest.json长这样： 123456789101112&#123; \"name\": \"vendor\", \"content\": &#123; \"./node_modules/react/react.js\": 1, \"./node_modules/react/lib/React.js\": 2, \"./node_modules/process/browser.js\": 3, \"./node_modules/object-assign/index.js\": 4, \"./node_modules/react/lib/ReactBaseClasses.js\": 5, \"./node_modules/react/lib/reactProdInvariant.js\": 6, \"./node_modules/react/lib/ReactNoopUpdateQueue.js\": 7, \"./node_modules/fbjs/lib/warning.js\": 8, ...... webpack将每个库进行了编号，之后dll user可以读取该文件，根据这个索引来引用。 之后，在webpack.config.js文件中添加DllReferencePlugin的插件配置。123456plugins:[ new webpack.DllReferencePlugin(&#123; context: __dirname,//需要与webpack.dll.config.js中DllPlugin上下文一致 manifest: require('./dist/vendor-manifest.json')//DllPlugin输出的manifest.json文件 &#125;)] 配置完成后，每次业务逻辑的修改只需要执行webpack --config webpack.config.js，不需要重复对dll进行打包，可以节约打包时间。 使用require.ensure分包123require.ensure([/*预加载模块*/], function(require) &#123; const Promise = require('es6-promise').Promise;&#125;, 'promise'); webpack会将es6-promise模块打包成promise.chunk.js(require.ensure的第三个参数和chunkFilename决定了打包后的文件名)。每个require.ensure会把前面数组里面的模块和内部require的模块都打包到一个文件内，异步加载。可以在ensure的[]数组中加入想要预加载的模块，也可以在function内部使用require.include对文件进行预加载。 webpack-dev-server热替换 webpack-dev-server 主要提供两个功能： 为静态文件提供服务 自动刷新和热替换(HMR) webpack-dev-server提供了两种自动刷新模式：iframe和inline，默认模式是iframe。inline方式会将webpack-dev-server客户端加入到webpack入口文件的配置中，配置方式有CLI和NodeJs API两种。 CLI方式1webpack-dev-server --env development --port=8081 --hot --inline Node.js API方式手动将webpack-dev-server客户端配置到webpack打包的入口文件中修改文件webpack.config.dev.js，添加webpack/hot/dev-server，添加插件HotModuleReplacementPlugin：1234567891011121314151617181920212223242526var webpack = require(\"webpack\");var webpackBase = require(\"./webpack.config.base.js\");var cfg = Object.assign(webpackBase, &#123; devtool: \"cheap-module-eval-source-map\"&#125;);//entryObject.getOwnPropertyNames((webpackBase.entry || &#123;&#125;)).map(function (name) &#123; cfg.entry[name] = [] //添加HMR文件 .concat(\"webpack/hot/dev-server\") .concat(\"webpack-dev-server/client?http://localhost:9390\") .concat(webpackBase.entry[name])&#125;);//pluginscfg.plugins = (webpackBase.plugins || []).concat( new webpack.optimize.OccurrenceOrderPlugin(), //添加HMR插件 new webpack.HotModuleReplacementPlugin(), new webpack.NoErrorsPlugin())module.exports = cfg; 根目录添加文件devServer.js，用于创建服务器实例12345678910111213141516171819202122var path = require(\"path\");var webpack = require(\"webpack\");var webpackDevServer = require(\"webpack-dev-server\");var webpackCfg = require(\"./webpack.config.dev.js\");var compiler = webpack(webpackCfg);//init servervar app = new webpackDevServer(compiler, &#123; //注意此处publicPath必填 publicPath: webpackCfg.output.publicPath, //HMR配置 hot:true&#125;);app.listen(9390, \"localhost\", function (err) &#123; if (err) &#123; console.log(err); &#125;&#125;);console.log(\"listen at http://localhost:9390\"); 修改package.json中scripts配置，通过执行devServer.js文件启动服务器：123\"scripts\":&#123; \"start\":\"node devServer.js\"&#125; 基础版webpack配置 开发环境下 123456789101112131415161718192021222324252627282930var webpack = require('webpack');var path = require('path');module.exports = &#123; entry: &#123;iread: \"./iread/src/index.js\", icartoons: \"./icartoons/src/index.js\"&#125;, output: &#123; path: \"./dist\", //资源文件引用的目录 publicPath: '../dist/', //相对于html中,指定资源文件引用的目录 filename: \"[name].bundle.js\", chunkFilename: '[name].chunk.js' &#125;, module: &#123; loaders: [ &#123; test: path.resolve('./','lib/zepto.js'), loader: \"exports?window.$!script\" &#125;, &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" &#125;, &#123; test: /\\.(png|jpg)$/, loader: \"url-loader\" &#125;, &#123; test: /.jsx?$/, loader: 'babel-loader',exclude: /node_modules/, query: &#123; presets: ['es2015', 'react'] &#125; &#125; ] &#125;, plugins:[ new webpack.ProvidePlugin(&#123; $: path.resolve('./','lib/zepto.js') &#125;), new webpack.DllReferencePlugin(&#123; context: __dirname,//需要与webpack.dll.config.js中DllPlugin上下文一致 manifest: require('./dist/vendor-manifest.json')//DllPlugin输出的manifest.json文件 &#125;) ]&#125; 生产环境下 12345678910111213141516171819202122232425262728293031323334var webpack = require('webpack');var path = require('path');module.exports = &#123; entry: &#123;iread: './iread/src/index.js', icartoons: './icartoons/src/index.js'&#125;, output: &#123; path: \"./dist\", filename: \"[name].bundle.min.js\" &#125;, module: &#123; loaders: [ &#123; test: path.resolve('./','lib/zepto.js'), loader: \"exports?window.$!script\" &#125;, &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" &#125;, &#123; test: /\\.(png|jpg)$/, loader: \"url-loader\" &#125;, &#123; test: /.jsx?$/, loader: 'babel-loader',exclude: /node_modules/, query: &#123; presets: ['es2015', 'react'] &#125; &#125; ] &#125;, plugins:[ new webpack.ProvidePlugin(&#123; $: path.resolve('./','lib/zepto.js') &#125;), new webpack.DefinePlugin(&#123; 'process.env': &#123; 'NODE_ENV': JSON.stringify('production') &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;","tags":[{"name":"webpack","slug":"webpack","permalink":"https://sherrywu0917.github.io/tags/webpack/"},{"name":"前端打包","slug":"前端打包","permalink":"https://sherrywu0917.github.io/tags/前端打包/"},{"name":"require","slug":"require","permalink":"https://sherrywu0917.github.io/tags/require/"}]},{"title":"web浏览器兼容性问题","date":"2017-06-15T12:19:58.000Z","path":"2017/06/15/web浏览器兼容性问题/","text":"IE的问题 IE中animate作用在body上会失效，使用$(‘html, body’) 123$('html, body').animate(&#123; scrollTop: offsetTop - $('#J_nav').height()&#125;, 500) $(‘body’).scrollTop()在IE中获得的值始终是0，使用$(document).scrollTop()可以获得正确的值 IE中通过offset获得的top值 = chrome浏览器offset的top值 + 该元素的paddingTop值。要获取元素offset值，需要兼容IE，如下： 1234567891011\\\\大于等于Ver版本的IE浏览器isGteIE(ver) &#123; let b = document.createElement('b'); b.innerHTML = '&lt;!--[if lte IE ' + ver + ']&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;'; return b.getElementsByTagName('i').length === 1;&#125;let offsetTop = $(target).offset().top;//IE8及以上, 修正offsetif(self.isGteIE(8)) &#123; offsetTop -= parseInt($(target).css('paddingTop'));&#125; 浏览器内核 浏览器 内核 IE Trident Safari webkit Chrome WebKit的分支—Chromium引擎 Chrome 28.0.1469.0版本之后 基于WebKit2—Blink引擎 Firefox Gecko内核 Opera Presto渲染引擎，2013年2月之后紧跟chrome引擎 浏览器市场份额http://www.netmarketshare.com/ 兼容IE8IE8不支持本地视频播放，要使用在线的为了让IE8兼容video标签，使用html5media123 &lt;!–[if lt IE 9]&gt; &lt;script src=\"http://api.html5media.info/1.1.8/html5media.min.js\"&gt;&lt;/script&gt;&lt;![endif]–&gt; 兼容IE8的图表库：highchartshttp://www.highcharts.com/demo需要使用1.x的jQuery版本","tags":[{"name":"兼容","slug":"兼容","permalink":"https://sherrywu0917.github.io/tags/兼容/"}]},{"title":"form表单实现文件的下载","date":"2017-06-15T12:19:22.000Z","path":"2017/06/15/form表单实现文件的下载/","text":"h5链接a增加download属性 download属性 想到最简单的下载文件的方式是1&lt;a href=\"large.jpg\"&gt;下载&lt;/a&gt; 但是实际效果是在浏览器直接浏览图片，而不是下载图片。如果我们希望点击“下载”链接下载图片，可以增加一个download属性。1&lt;a href=\"large.jpg\" download&gt;下载&lt;/a&gt; 通过download属性还可以指定下载图片的文件名，如果后缀一样，可以省略。1&lt;a href=\"large.jpg\" download=\"large_down.jpg\"&gt;下载&lt;/a&gt; download的兼容性 如果下载的资源是跨域的，在chrome浏览器下可以正常下载，在firefox浏览器下不支持跨域下载。要判断是否支持download属性，可以使用下面的代码：1var isSupportDownload = 'download' in document.createElement('a'); 兼容浏览器的下载方法 download属性不支持IE，要兼容IE可以通过JS创建一个iframe去下载，如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;a id='trigger' href=\"javascript:;\"&gt;下载&lt;/a&gt; &lt;a id='download' download='pic.jpg' style=\"display: none;\"&gt;下载&lt;/a&gt; &lt;/body&gt; &lt;script type=\"text/javascript\" src=\"http://yuedust.yuedu.126.net/js/jquery-1.8.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function download_pic() &#123; var codeurl='https://img4.cache.netease.com/news/2017/6/19/20170619094322c3136.jpg'; if(browserIsIe())&#123;//假如是ie浏览器 DownLoadReportIMG(codeurl); &#125;else&#123; $(\"#download\").attr('href', codeurl); document.getElementById(\"download\").click(); &#125; &#125; function DownLoadReportIMG(imgPathURL) &#123; //如果隐藏IFRAME不存在，则添加 if (!document.getElementById(\"IframeReportImg\")) $('&lt;iframe style=\"display:none;\" id=\"IframeReportImg\" name=\"IframeReportImg\" onload=\"DoSaveAsIMG();\" width=\"0\" height=\"0\" src=\"about:blank\"&gt;&lt;/iframe&gt;').appendTo(\"body\"); if (document.all.IframeReportImg.src != imgPathURL) &#123; //加载图片 document.all.IframeReportImg.src = imgPathURL; &#125; else &#123; //图片直接另存为 DoSaveAsIMG(); &#125; &#125; function DoSaveAsIMG() &#123; //跨域的话IE会提示没权限 if (document.all.IframeReportImg.src != \"about:blank\") window.frames.IframeReportImg.document.execCommand(\"SaveAs\"); &#125; //判断是否为ie浏览器 function browserIsIe() &#123; if (!!window.ActiveXObject || \"ActiveXObject\" in window) return true; else return false; &#125; document.getElementById(\"trigger\").onclick = function(e) &#123; e.preventDefault(); download_pic(); &#125;; &lt;/script&gt;&lt;/html&gt; form表单实现文件的下载1234567891011121314151617181920212223handleExport() &#123; const &#123; selectedRowKeys &#125; = this.state; let config = &#123; action: UserExportUrl, key: 'userIdArray[]' &#125; let iframe = document.createElement('iframe'); iframe.style.display = 'none'; let form = document.createElement('form'); form.action = config.action; form.method = 'post'; let input = document.createElement('input'); input.type = 'hidden'; input.name = config.key; input.setAttribute('value', selectedRowKeys.join(',')); form.appendChild(input); document.body.appendChild(iframe); iframe.contentWindow.document.body.appendChild(form); form.submit(); // window.open(UserExportUrl + '?userIdArray[]=' + selectedRowKeys.join(','));&#125; PS: 移动端H5几乎无法实现保存图片到本地，加download属性和加响应头的方式，微信和浏览器都无法保存图片，手机端的chrome和PC效果一致，真是一股清流。还是提示用户自己长按保存图片吧。","tags":[{"name":"下载","slug":"下载","permalink":"https://sherrywu0917.github.io/tags/下载/"},{"name":"兼容","slug":"兼容","permalink":"https://sherrywu0917.github.io/tags/兼容/"}]},{"title":"@font-face 引入外部字体","date":"2017-06-15T12:16:44.000Z","path":"2017/06/15/font-face-引入外部字体/","text":"字体是在页面中呈现内容不可缺少的重要元素，合适的字体能让内容更能抓住用户的注意力。 我们的追求是在多平台上呈现可预知的一致的文字效果给用户，但限于平台的字体支持，我们在使用一些不常见的字体时畏首畏脚。 长久以来，我们解决这个问题，一般都采用图片替换文字的方法。这个方法虽然简单，但是弊端不少： 图片体积一般比较大，如需半透明处理，体积会进一步增大 工作量增加不少 图片放大后可能会失真 随着CSS3的推广，一个通过@font-face自定义字体的技术进入大家的视线中。 这个技术目前正被大量应用于自定义图标的实现。但是很少用来实现自定义字体，尤其是中文字体。 这是因为中文包含很多汉字，所以字体文件的体积一般都比较大。如果用做自定义字体， 页面会先下载字体文件，然后再呈现页面，这会导致加载缓慢，用户的流量被浪费。 然而在我们使用字体时，基本上只用来呈现有限的文字，下载整个字体文件是多余的。 那我们是否可以精简字体文件，让它只包含指定文字的字体信息，来解决问题？答案是可以的。 webfont-pick就是这样一个工具，它使用起来非常简单： 123npm install webfont-pick -g# 更多选项请执行 webfont-pick --help 查看webfont-pick --font=/Library/Fonts/YuppySC-Regular.otf --text=&quot;你好，世界！&quot; -o ~/Desktop/webfont 执行上述命令后，只包含你好，世界！这六个汉字的自定义字体文件会出现在指定的目录，并且生成了一个示例页面，用来说明如何使用。 有了webfont-pick之后，不管是微软雅黑还是方正呐喊都可以放心的应用到页面中。 另外webfont-pick不只可以通过命令行调用，还可以通过程序调用，详情请参考项目主页。 注1: webfont-pick目前只支持解析WOFF, OTF, TTF格式的字体 注2: webfont-pick的想法来源于ICONFONT.cn 注3: webfont-pick的实现参考grunt-webfont 开发中遇到的问题中文字体应用到英文上会有问题，字体不是期望的那样。解决方案：英文单独使用英文字体，在设置font-family的时候引入中英文两种字体。12345678910111213141516171819202122232425262728@font-face&#123; font-family: \"MS-Mincho\"; src: url('../src/font/MS-Mincho.eot'); /* IE9*/ src: url('../src/font/MS-Mincho.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('../src/font/MS-Mincho.woff') format('woff'); /* chrome、firefox */&#125;@font-face&#123; font-family: \"ST-Regular\"; src: url('../src/font/st-regular.eot'); /* IE9*/ src: url('../src/font/st-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('../src/font/st-regular.woff') format('woff'); /* chrome、firefox */&#125;.banner-title &#123; font-size: 64px; color: #fff; line-height: 60px; margin-bottom: 20px; font-family: ST-Regular, MS-Mincho, sans-serif; // font-family: STSongti-SC-Regular; .en &#123; vertical-align: sub; letter-spacing: -28px; margin-right: -6px; &#125;&#125;","tags":[{"name":"css","slug":"css","permalink":"https://sherrywu0917.github.io/tags/css/"},{"name":"font-face","slug":"font-face","permalink":"https://sherrywu0917.github.io/tags/font-face/"}]},{"title":"ES6 学习","date":"2017-03-20T11:40:59.000Z","path":"2017/03/20/ES6-学习/","text":"from: http://es6.ruanyifeng.com let命令 let取代var, let仅在代码块中有效 for循环计数器适合用let let不存在变量提升 暂时性死区:ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 12345678910111213if (true) &#123; console.log(typeof a); // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError // Uncaught ReferenceError: Cannot access 'tmp' before initialization // at &lt;anonymous&gt;:3:7 // (anonymous) @ VM211:3 let tmp; // TDZ结束 console.log(tmp); // undefined &#125; 不允许重复声明 块级作用域（全局作用域、函数作用域） const命令 声明常量 顶层对象，在浏览器中指的是window对象 es6的var命令和function命令声明的全局变量依然是顶层对象的属性 let、const、class命令声明的全局变量不属于顶层对象的属性 数组的解构赋值 只要某种数据结构有Iterator接口，都可以采用数组形式的解构赋值 解构可以设置默认值 对象也可以解构，数组的解构是按次序排列，对象的解构要求变量名必须和对象的属性名相同 数值和布尔值的解构赋值比较特别，转为了对象 函数参数也可以解构赋值 用处： 交换变量的值 从函数返回多个值 函数参数的定义 提取JSON对象中的数据 函数参数的默认值 遍历map解构 ：任何部署了Iterator接口的对象，都可以用for…of循环遍历（Array,String,Set,Map） 输入模块的指定方法 Unicode表示字符，可以使用{} 模板字符串${} includes, startsWith, endsWith, repeat, padStart, padEnd 数值的扩展 isFinite() isNaN() 将parseInt()和parseFloat()方法移植到Number对象上，目的是减少全局性方法，使语言逐步模块化 isInteger() 新增了极小的常量Number.EPSILON 最大值Number.MAX_SAFE_INTEGER， 最小值Number.MAX_SAFE_INTEGER Number.isSafeInteger() 数组的扩展 from方法将类似数组的对象和可遍历的对象转为真正的数组123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; of方法将一组值转换为数组 函数的扩展 可以设置参数的默认值 函数的length属性返回没有指定默认值的参数个数 reset参数：用于获取函数的多余参数，形式为…变量名，代表一个数组 1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 扩展运算符…：好比reset参数的逆运算，将一个数组转为用逗号分隔的参数序列 替代数组的apply方法 12345678910111213// ES5的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f(...args); 合并数组 与解构赋值结合 函数的返回值 任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。 12var obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object 对于没有iterator接口的对象，使用…语法会报错 与React中的JSX扩展语法不同 函数的name属性 箭头函数=&gt; 函数绑定运算符是并排的两个双冒号（::），左边是对象，右边是一个函数，返回的还是原对象，可以采用链式写法 “尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存 对象的扩展Proxy和Refelct1var proxy = new Proxy(target, handler); new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler也是一个对象，用来定制拦截行为123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 用处 属性拦截 拦截过滤各种操作，如new/defineProperty/delete/getPrototypeOf等 私有属性模拟has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。1234567891011var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: 'foo', prop: 'foo' &#125;;var proxy = new Proxy(target, handler);'_prop' in proxy // false Promise对象12345678var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); resolve将Promise对象从Pending变成Resolvedreject将Promise对象从Pending变成Rejected12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); resolve和reject可以将参数传递给then方法里面的回调函数 Symbol对象属性123456var isMoving = Symbol(\"isMoving\");...if (element[isMoving]) &#123; smoothAnimations(element);&#125;element[isMoving] = true; symbol-keyed属性不能通过.操作符来访问，必须使用方括号的方式 判断：if (isMoving in element) 删除：delete element[isMoving] for…in、Object.keys(obj) 和 Object.getOwnPropertyNames(obj)只会遍历到以字符串作为键的属性 Object.getOwnPropertySymbols(obj)只会遍历所有的Symbol键 Reflect.ownKeys(obj)会返回对象的所有字符串和Symbol键 Class1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; this关键字代表实例对象。类的方法都是定义在prototype上，与传统的prototype实现的类一致。 123456class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是function，类本身就指向构造函数。 12345class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // trueB.prototype.constructor === B //true 在类的实例上调用方法，其实就是调用原型上的方法。所以b实例的constructor方法就是B类原型的constructor方法。prototype对象的constructor属性，直接指向“类”的本身。 12345678class Point &#123; &#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); 通过Object的assign方法可以一次向Point添加多个方法。 1234567891011121314class Point &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"] 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。Object.keys这儿用来判断是否可枚举。 注意点 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。 不存在变量提升。 static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，但可以被子类继承。 Set集合用最简洁的代码实现数组去重：ES6实现：1[...new Set([1,2,3,1,'a',1,'a'])] ES5实现：123[1,2,3,1,'a',1,'a'].filter(function(ele,index,array)&#123; return index===array.indexOf(ele)&#125;)","tags":[{"name":"es6","slug":"es6","permalink":"https://sherrywu0917.github.io/tags/es6/"},{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"}]},{"title":"H5开发踩到的坑","date":"2017-03-16T12:42:41.000Z","path":"2017/03/16/H5开发遇到的坑/","text":"某些安卓机上tap事件会触发两次某些安卓微信缓存严重，reload事件会失效解决方法 location.reload(forcedReload): 当取值为 true 时，将强制浏览器从服务器重新获取当前页面资源，而不是从浏览器的缓存中读取，如果取值为 false 或不传该参数时，浏览器则可能会从缓存中读取当前页面。 加时间戳 ios微信内音乐不能自动播放微信屏蔽了音乐自动播放，使用微信API：WeixinJSBridge，当getNetworkType事件被触发时去播放音乐。解决方法：12345if((/MicroMessenger/ig).test(window.navigator.userAgent) &amp;&amp; (typeof WeixinJSBridge != \"undefined\")) &#123; WeixinJSBridge.invoke('getNetworkType', &#123;&#125;, function(e) &#123; $('.j-audio')[0].play(); &#125;);&#125; 此外，在手机chrome和safiri中都不支持音乐自动播放，需要用户操作才能触发，基于节省流量的考虑。 ios 客户端内某些样式异常，导致图片没有展示本质上图片是被覆盖了，应该是z-index的异常 android软键盘弹出后遮住文本框解决办法是使用scrollIntoViewIfNeeded()1234567891011121314151617//通用型if(/Android [4-6]/.test(navigator.appVersion)) &#123; window.addEventListener(\"resize\", function() &#123; if(document.activeElement.tagName==\"INPUT\" || document.activeElement.tagName==\"TEXTAREA\") &#123; window.setTimeout(function() &#123; document.activeElement.scrollIntoViewIfNeeded(); &#125;, 0); &#125; &#125;)&#125;//直接针对某个元素document.getElementById('/*元素id*/').onclick = function(e) &#123; setTimeout(() =&gt; &#123; e.target.scrollIntoViewIfNeeded(); &#125;, 400);&#125;","tags":[{"name":"总结","slug":"总结","permalink":"https://sherrywu0917.github.io/tags/总结/"}]}]