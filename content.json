[{"title":"reading-record","date":"2019-03-18T02:49:49.000Z","path":"2019/03/18/reading-record/","text":"你的Tree-Shaking并没什么卵用 Tree-Shaking的原理 ES6的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码。 分析程序流，判断哪些变量未被使用、引用，进而删除此代码 但现实比较骨感，es6的代码经过babel和webpack编译打包后，产生的副作用(可能会改变外部变量)导致多余的代码并未被删掉。babel6在编译的时候，会调用_createClass方法，使用Object.defineProperty去定义类里面的方法，原因是因为在es6的特性中，类里面声明的方法是不可枚举的。所以设置{ &quot;loose&quot;: false }宽松模式，让babel编译的时候不必去严格遵循es6的特性。此外，UglifyJS不会进行程序流分析，所以在压缩的时候无法排除掉可能有副作用的代码，所以这部分代码还是会被打包进去。使用babel6/webpack打包可以考虑结合使用BabelMinifyWebpackPlugin，思路是先进行uglifyJS代码压缩，再去编译。 评论中指出：关于Person和Apple阐述Babel副作用的例子在Babel升级到Babel7之后确实已经不存在了，使用Babel7的正式版和Webpack4亲测。 http2.0 相比 1.0有哪些重大改进？ 多路复用多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在http1.0和1.1协议下，浏览器在同一时间针对同一域名下的请求有一定数量的限制。不同浏览器限制的数量不一样。 二进制分帧http2.0在应用层和传输层之间增加了一个二进制分帧层，在该层中，会将传输信息分割成更小的消息和帧。将http1.x的头部信息封装在到了HEADER frame，相应的Request Body封装到DATA frame中。http2.0让所有数据流共用一个连接，有效地使用TCP连接，减少服务端的链接压力，内存占用更少，实现高带宽。此外，减少了TCP慢启动的时间。 首部压缩支持首部压缩，使用了HPACK算法。 服务端推送服务器可以向客户端推送可能需要的资源，对\b一个请求发送多个响应。 「如果客户端早已在缓存中有了一份 copy 怎么办？」一个推荐的解决方案是，客户端使用一个简洁的 Cache Digest 来告诉服务器，哪些已经在缓存中存在。 设置资源的优先级浏览器可以一次请求多个资源，指定一些优先级信息来帮助确定应该如何处理这些资源，然后等待服务器发回所有数据，而不是一次请求一个。如果浏览器和服务器都支持优先级，则应使用浏览器指定的规则并使用所有可用带宽来传递资源，而不会有资源之间的相互竞争。 支持http2.0的前提是使用了SSL/TLS9(安全传输层协议)，如果网站没有使用SSL/TLS，接入http2.0协议带来的性能提升大致可以被TLS带来的性能损耗所抵消。https://www.mnot.net/talks/h2fe/https://www.w3ctech.com/topic/1563#tip7shardinghttps://juejin.im/post/5c1d9b8ae51d4559746922de xss攻击例如：http://xxx/search?keyword=&quot;&gt;alert(‘XSS’);1234&lt;input type=\"text\" value=\"&lt;%= getParameter(\"keyword\") %&gt;\"&gt;// 参数拼接后&lt;input type=\"text\" value=\"\"&gt;&lt;script&gt;alert('XSS');&lt;/script&gt;\"&gt; 跨站脚本攻击（Cross-site scripting），分为存储型(存储到数据库中)、反射型(网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器)和Dom型(前端浏览器拼接并执行)，需要前端处理的是Dom型。预防： 合适的HTML转义，完善的转义库需要针对上下文制定多种规则，例如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等等 利用模板引擎 开启模板引擎自带的 HTML 转义功能 避免内联事件 尽量不要使用 onLoad=”onload(‘‘)” 避免拼接 HTML 时刻保持警惕 在插入位置为 DOM 属性、链接等位置时 增加攻击难度，降低攻击后果 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果 主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞 可以手动拼接字符串jaVasCript:/*-/*/`/‘/“/**/(/ */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/–!&gt;\\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\\x3e`去检查 position:fixedposition:fixed 的元素将相对于屏幕视口（viewport）的位置来指定其位置。并且元素的位置在屏幕滚动时不会改变。但是当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。设置为position:fixed的元素，如果存在transform为非none的元素祖先时，会相对该元素去进行定位。因为transform设置为非none时，会创建一个堆叠上下文和包含块，会影响子元素的固定定位。不是所有的创建新的堆叠上下文都被影响fixed定位，在最新的Chrome浏览器下，只有下面3种还会影响： 设置了 transform-style: preserve-3d 的元素 perspective 值不为 none 的元素 在 will-change 中指定了任意 CSS 属性但不同浏览器表现不同，所以要具体问题具体分析。 vm wh显示器宽度: screen.width浏览器宽度: window.outerWidth网页宽度: window.innerWidth wm wh是相对与网页的宽高的，网页的宽为100vm，网页的高度为100vh","tags":[]},{"title":"Hello World","date":"2019-03-18T02:27:14.362Z","path":"2019/03/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"打点实践总结","date":"2019-03-07T03:02:29.000Z","path":"2019/03/07/打点实践总结/","text":"beacon 请求方法均为POST，且不支持修改兼容性 https://caniuse.com/#search=beacon polyfill https://github.com/kronicker/sendbeacon-polyfill/blob/master/sendbeacon.js https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon 如何在 Web 关闭页面时发送 Ajax 请求 [译] 使用 Web Beacon API 记录活动 post请求content-type: application/jsonRequest Payload:{layouts: [“1”, “2”, “5”]} application/x-www-form-urlencodedQuery String ParameterssourceUuid:np_c3sEKMgU3Xau_Tl0fmsqyReIdKH9OXQpby_FSNhz__ppcy0EKQarticleUuid:np_eXoyZJwfsX-q8j5OLm0pyEbYGK0forceFollow:0isContinue:0forceAutoPurchase:1 multipart/form-data使用表单上传文件时，必须让 form 的 enctype 等于这个值。Content-Type: multipart/form-data; boundary=—-WebKitFormBoundaryBJIFBCE2CA2Fwbyl","tags":[]},{"title":"react相关问题","date":"2019-01-29T07:38:28.000Z","path":"2019/01/29/react相关问题/","text":"什么是JSX?——浏览器是如何识别它的？JSX是facebook普及的一种标记语言，通过babel/TSC等工具会编译为React.createElementfunction。所以在React每个组件中，虽然没有显式用到React，但都需要import React from &#39;react&#39;。 JSX是如何区分React Component和HTML元素的？通过元素首字母的大小写，如果首字母大写，则认为是React组件，小写的话则会被认为是HTML元素。可以在online Babel compiler中试一下。123456789101112function hello() &#123; return &lt;div&gt;Hello world!&lt;/div&gt;;&#125;// after babel compilerfunction hello() &#123; return React.createElement( \"div\", null, \"Hello world!\" );&#125; 123456789101112function hello() &#123; return &lt;div&gt;Hello world!&lt;/div&gt;;&#125;// after babel compilerfunction hello() &#123; return React.createElement( Div, null, \"Hello world!\" );&#125; 此外，把一个组件赋给this.component并且写&lt;this.component /&gt;也会起作用。 react16生命周期Mounting constructor() static getDerivedStateFromProps() render() componentDidMount 不建议使用UNSAFE_componentWillMount() Updating static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 不建议使用UNSAFE_componentWillReceiveProps()和UNSAFE_componentWillUpdate()UNSAFE_componentWillReceiveProps()经常会带来bug和不一致的问题。 Unmounting componentWillUnmount() getDerivedStateFromProps(props, state)每次render之前都会被触发，与componentWillReceiveProps只在父组件rerender时会触发不一样。此外，getDerivedStateFromProps方法不建议经常使用，使用前想一想是否有替代方案。 加分题：数据获取为什么用 componentDidMount 而不是 constructor？你希望听到的两个原因会是：“在渲染发生之前数据不会存在” —— 虽然不是主要原因，但它向您显示该人员了解组件的处理方式; “在 React Fiber 中使用新的异步渲染……” —— 有人一直在努力学习。 r1: SSR模式下，componentWillMount在server端也是会被调用的，内容返回到client端后，componentWillMount会被第二次调用，如果在componentWillMount中处理数据获取则会被调用两次。 r2: 在componentWillMount中调用setState不会触发rerender，所以一般不会被用来获取数据。 r3: React16之后采用了Fiber架构，类似ComponentWillMount的生命周期钩子都有可能执行多次，所以不在这些生命周期中做有副作用的操作，比如请求数据。 r4: constructor用来初始化组件，作用应该保持纯粹，不应该引入数据获取这种有副作用的操作。 react fiber纤程fiber是纤程颗粒化的概念，一个线程可以包含多个Fiber，主要是对react更新机制的优化。React16之前的版本，更新组件会一直占用主线程，如果组件树过大，则可能会导致浏览器失去响应。在React16中加入的fiber可以将同步任务拆解，每次执行完一小片后，都会把控制权交还给react负责任务调度的模块，如果有优先级更高的任务，就先执行高优先级的任务。 拆什么首先，看React的渲染，包括两个阶段：调度阶段(reconciliation)和渲染阶段(commit)。 调度阶段react根据数据更新virtual DOM，再运用diff算法找到需要VDOM change。这一部分的工作是可以拆分的。 渲染阶段根据计算出的所有diff去一次性更新真实的DOM。组件比较庞大时，diff运算会比较耗时，不可控，所以需要拆分的是调度阶段。 怎么拆fiber tree的部分结构如下所示，将简单的数结构，变成了基于单链表的树结构。12345678910&#123; alternate: Fiber|null, //在fiber更新时克隆出的镜像fiber，对fiber的修改会标记在这个fiber上 nextEffect: Fiber | null, // 单链表结构，方便遍历 Fiber Tree 上有副作用的节点 pendingWorkPriority: PriorityLevel, // 标记子树上待更新任务的优先级 stateNode: any, // 管理 instance 自身的特性 return: Fiber|null, // 指向 Fiber Tree 中的父节点 child: Fiber|null, // 指向第一个子节点 sibling: Fiber|null, // 指向兄弟节点&#125; 执行顺序因为是单链表(A → B → C)的结构，所以在每次执行到某个节点(A → B)被中断后，下次可以从该节点(B → C)接着执行。requestIdleCallback会让一个低优先级的任务在空闲期被调用，而requestAnimationFrame会让一个高优先级的任务在下一个栈帧被调用，从而保证了主线程按照优先级执行 fiber 单元。 优先级顺序为：文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务。 因为react fiber机制，一个任务很可能执行到一半就被其他优先级更高的任务所替代，或者因为时间原因而被终止。当再次执行这个任务时，是从头开始执行一遍，就会导致组件的某些 will 生命周期可能被多次调用而影响性能。 REFs: [译]以面试官的角度来看React工作面试 浅析 React Fiber 浅谈React 16中的Fiber机制","tags":[]},{"title":"lottie实践","date":"2019-01-28T02:27:41.000Z","path":"2019/01/28/lottie实践/","text":"lottie简介 Lottie is a mobile library for Android and iOS that parses Adobe After Effects animations exported as json with Bodymovin and renders them natively on mobile and on the web! Lottie是一个库，可以解析使用AE制作的动画（需要用bodymovin导出为json格式），支持web、ios、android和react native。在web侧，lottie-web库可以解析导出的动画json文件，并将其以svg或者canvas的方式将动画绘制到我们页面中。关于lottie-web的详细信息，也可以参见https://github.com/airbnb/lottie-web。 lottie-web引用方式npm包12345678import lottie from 'lottie-web'lottie.loadAnimation(&#123; container: element, // the dom element that will contain the animation renderer: 'svg', loop: true, autoplay: true, path: 'data.json' // the path to the animation json&#125;); js外链多个版本的lottie库都可以从cdnjs-bodymovin找到12345678910&lt;script src=\"https://cdnjs.com/libraries/bodymovin\" /&gt;&lt;script&gt; bodymovin.loadAnimation(&#123; container: element, // the dom element that will contain the animation renderer: 'svg', loop: true, autoplay: true, path: 'data.json' // the path to the animation json &#125;);&lt;/script&gt; 通过外链引入的方式，既可以通过bodymovin去调用，也可以使用lottie变量，二者等价，都是js库提供的全局变量。 lottie-web实践lottie库文件比较大，gzip压缩后也有60k，再加上动画对应的json文件，直接引入会给项目代码增大不少体积，影响页面加载速度。 文件 大小 gzip后 lottie.js 513k 92k lottie.min.js 237k 60k lottie_light.js (lottie_web轻量版，仅支持svg渲染) 345k 60k lottie_lignt.min.js 144k 39k 所以，如果动画只需要支持svg渲染，则可以引入light版本的库文件，gzip压缩后缩减到39k。为了进一步降低影响，可以使用code splitting的方式，以async的方式异步加载js，这样就不会阻塞浏览器解析html、执行js脚本以及展示css布局。123456789import(/* webpackChunkName: \"lottie-light\" */ '../lib/lottie_light.min.js').then(() =&gt; &#123; window.lottie &amp;&amp; window.lottie.loadAnimation(&#123; container: this.headerDom, renderer: 'svg', loop: true, autoplay: true, animationData: require('../data/ribbon.json') &#125;);&#125;) 示例demo可以参见codepen上的ribbon-lottie，测试数据ribbon.json可以下载彩带json数据。","tags":[{"name":"lottie","slug":"lottie","permalink":"https://sherrywu0917.github.io/tags/lottie/"}]},{"title":"前端优化-蹒跚学步","date":"2018-12-24T01:38:54.000Z","path":"2018/12/24/优化之路/","text":"项目背景项目是基于React开发，webpack打包的多页面h5应用，其中部分页面又是基于React-router的SPA。开发的过程中，也一直在尝试对项目进行优化，这儿主要记录了对代码分片、持久化缓存和图片优化的处理。 优化之路漫漫，蹒跚而来。 动态加载组件Code splitting(代码分片)当前端代码越来越复杂，代码体积越来越大时，需要考虑对加载的资源进行细粒度的分割，按需加载。webpack支持两种语法实现动态地加载模块： require.ensure给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。 1require.ensure(dependencies: String[], callback: function(require), chunkName: String) import调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。 1234import( /* webpackChunkName: \"my-chunk-name\" */ /* webpackMode: \"lazy\" (default)*/ 'path/to/module') -&gt; Promise webpackChunkName用来设置chunk的名字；webpackMode默认值是lazy，还有lazy-once、eager、weak。按需加载的默认加载形式是async。 react动态加载组件在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。直接看代码：123456789101112131415161718192021222324252627282930313233343536373839import React, &#123;Component&#125; from 'react'/** * 异步加载模块 * @param &#123;[type]&#125; loadComponent [description] * @return &#123;[type]&#125; [description] */export const asyncComponent = loadComponent =&gt; ( class AsyncComponent extends Component &#123; state = &#123; Component: null, &#125; componentDidMount() &#123; if (this.hasLoadedComponent()) &#123; return; &#125; loadComponent() .then(module =&gt; module.default) .then((Component) =&gt; &#123; this.setState(&#123; Component &#125;); &#125;) .catch((err) =&gt; &#123; console.error(`Cannot load component in &lt;AsyncComponent /&gt;`); throw err; &#125;); &#125; hasLoadedComponent() &#123; return this.state.Component !== null; &#125; render() &#123; const &#123; Component &#125; = this.state; return (Component) ? &lt;Component &#123;...this.props&#125; /&gt; : null; &#125; &#125;); loadComponent参数代表import(‘module’)异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。如何调用：1export const AsyncBannerSwiper = asyncComponent(() =&gt; import(/* webpackChunkName: \"bannerSwiper\" */ './BannerSwiper.jsx')) 将BannerSwiper组件用asyncComponent封装下，就返回了一个异步加载的AsyncBannerSwiper组件，使用方法和其他组件完全一致。其中支持webpackChunkName去配置chunk的名字，不配置的情况下会默认生成[id].bundle.js。 publicPath动态设置项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。动态设置异步chunk的publicPath，在入口entry中设置webpack_public_path，打包配置文件中配置的publicPath不变。1__webpack_public_path__ = window.cdn || '/dist/'; webpack设置在webpack配置文件中，需要配置chunkFilename指定chunk的名字。1chunkFilename: '[name].js' 另外，注意webpack插件的配置：1234567new webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk idnew webpack.optimize.CommonsChunkPlugin(&#123; ... children: false, // 如果设置为 `true`，所有公共 chunk 的子模块都会被选择 ...&#125;),new ExtractTextPlugin(&#123;filename: 'css/[name].css?[contenthash:8]', allChunks: true&#125;), //从所有chunk中提取(默认情况下，它仅从initial chunk中提取) 分离前后对比使用webpack-bundle-analyzer分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K：使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。线上的资源又是开启了gzip压缩，体积就更小了。 持久化缓存为了获取持久化缓存，在配置webpack的output时，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。 moduleId VS chunkIdwebpack打包后会生成webpackJsonp等方法，用于加载chunk和module，精简的源码如下所示：123456789101112131415161718192021222324252627282930313233343536373839(function(modules) &#123; window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) &#123; var moduleId, result; for (moduleId in moreModules) &#123; //该chunk引用的所有模块 if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123; // 将chunk中所包含的模块放入modules数组中 modules[moduleId] = moreModules[moduleId]; &#125; &#125; if (executeModules) &#123; //入口module for (i = 0; i &lt; executeModules.length; i++) &#123; result = __webpack_require__(executeModules[i]); &#125; &#125; return result; &#125;; var installedModules = &#123;&#125;; // 调用__webpack_require__(moduleId)时， // 再将模块放入installedModules，用于保存已经加载过的模块 function __webpack_require__(moduleId) &#123; if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // Execute the module function: // 在执行的过程中，会递归调用`__webpack_require__`加载该模块引用的其他模块 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.l = true; return module.exports; &#125;&#125;)([]); webpackJsonp方法接收三个参数chunkIds, moreModules, executeModules，其中chunkIds属于chunkId，moreModules, executeModules都属于moduleId。 chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。 module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前__webpack_require__加载的模块，同样使用数组下标作为moduleId。每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。 固化过程初始状态以首页为例，打包后生成的index.js中会调用webpackJsonp方法，传入三个参数chunkIds, moreModules, executeModules。123456789webpackJsonp([4],&#123;/***/ 10:/***/ (function(module, exports, __webpack_require__) &#123;\"use strict\";eval(\"\");/***/ &#125;),/***/ 11:/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;\"use strict\";eval(\"/*actual code*/\");/***/ &#125;)//more code&#125;, [348]); 若此时新增一个页面，入口为”./src/entry/test.jsx”，打包后，会发现所有的js内容都发生了改变，以其中一个文件为例，发现是引用的moduleId发生了变化： 固化moduleId为了不影响其他文件，需要想办法将moduleId固定化，可以在webpack中配置NamedModulesPlugin，最新打包生成的index.js内部代码如下。和上面的代码比较，可以发现数字moduleId被替换成了文件的路径，这保证了moduleId的不变性。123456789webpackJsonp([4],&#123;/***/ \"./node_modules/babel-runtime/helpers/defineProperty.js\":/***/ (function(module, exports, __webpack_require__) &#123;\"use strict\";eval(\"\");/***/ &#125;),/***/ \"./node_modules/nw-detect/es/index.js\":/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;\"use strict\";eval(\"/*actual code*/\");/***/ &#125;)//more code&#125;, [\"./src/entry/index.jsx\"]); moduleId既然不会再变，那我们重新添加test页面，打包后是不是会只新增js呢？开心的是大部分js都没有改动，但发现还有两个js有变化，包括我们提取出的公共jscommon.bundle.js。对比下，发现文件的内容只有chunkId发生了变化： 固化chunkId再进一步，显然就是希望可以固化chunkId，webpack插件NamedChunksPlugin可以满足我们的需求，它使用webpack中唯一的entry名作为chunkId。配置好NamedChunksPlugin后，对比添加test页面前后js的变化，发现只有新增的js，已有的js都没有发生变化，注意到之前的common.bundle.js和forbidden.js发生改变的地方，代码分别如下：1234/******/ // objects to store loaded and loading chunks/******/ var installedChunks = &#123;/******/ \"common\": 0/******/ &#125;; 12webpackJsonp([\"forbidden\"],&#123; //other code chunkId都由数字变成了唯一的entry值，common对应CommonsChunkPlugin配置的name值。对于代码分离出的js，使用webpackChunkName设置chunkName，可以保证该jschunkId的稳定性。 生产环境下固化moduleId前文提到的NamedModulesPlugin，使用的是模块的相对路径，但因为相对路径偏长，生产环境更建议使用HashedModuleIdsPlugin，它会根据文件的路径去生成hash，打包后的文件更小。123webpackJsonp([\"index\"], &#123;\"+qWx\":function(e,t)&#123;e.exports=vendor&#125;,\"5AEV\" ...&#125;, [\"qwtH\"]); 最终在生产环境下需要配置下面的代码，就可以实现moduleId和chunkId的固定，使用户端的缓存更加持久。12new webpack.HashedModuleIdsPlugin(), //固化 module idnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id 图片优化图片的大小直接影响页面加载的速度，基础的优化操作有：对图片进行压缩、转base64减少http请求、使用srcset/sizes获取自适应图片等。这儿主要介绍如何结合webpack进行图片压缩，以及应用webp图片格式。 webpack loader图片压缩对图片进行压缩处理，可以选择的压缩工具有很多种，如压缩png、jpg的tinypng、智图，裁剪压缩gif的iLoveIMG；也可以安装psd的tinypng插件，以及pngquant、ImageAlpha、ImageOptim、Image Optimizer等其他压缩工具。打包压缩相比之下，配置loader或plugin打包压缩更加便捷，例如，配置好image-webpack-loader，在production模式下开启压缩，就可以在打包的时候自动压缩图片。 image-webpack-loader是基于imagemin去压缩PNG、JPEG、GIF、SVG和WEBP图片。针对不同的优化项，可以自定义参数以适配项目的需求。12345678910111213141516171819202122&#123; test: /\\.(png|jpg|gif)$/, use: [&#123; loader: 'url-loader', options: &#123; limit: 8192, name: 'image/[hash:8].[name].[ext]' &#125; &#125;, &#123; loader: 'image-webpack-loader', options: &#123; mozjpeg: &#123; progressive: true, quality: 65 &#125;, pngquant: &#123; quality: '65-90', speed: 3 &#125; &#125; &#125;]&#125; webpack也可以支持tinypng的打包压缩，如tinypng-webpack-plugin，使用了tinypng提供的API。但需要注意的是，使用tinypng需要申请key值，每个key值每个月可以免费压缩500张，超出部分就要付费了。 响应式图片可以通过@media、image-set或者js实现根据屏幕大小获取对应的图片，更方便的方式是使用和。 srcset相同尺寸不同分辨率12&lt;img src=\"pic.png?imageView&amp;thumbnail=202y284\" srcset=\"pic.png?imageView&amp;thumbnail=202y284 2x, pic.png?imageView&amp;thumbnail=303y426 3x\"&gt; 当分辨率为3x时，会使用3x对应的pic.png?imageView&amp;thumbnail=303y426图片。没有匹配到的、或者是不支持srcset属性的浏览器会正常加载src引用的图片。结合NOS提供的图片缩略功能，只需要上传一张图片，就可以实现不同分辨率下返回不同尺寸的图片。 sizes不同尺寸1234567&lt;img srcset=\"pic-320w.jpg 320w, pic-480w.jpg 480w, pic-800w.jpg 800w\" sizes=\"(max-width: 320px) 280px, (max-width: 480px) 440px, 800px\" src=\"pic-800w.jpg\"&gt; 当屏幕宽度为450px时，满足sizes定义的媒体查询(max-width: 480px) 440px，这时候图片宽度是440px，将从srcset中匹配最接近的宽度。注意不能直接把440px和480w去比较，因为srcset中的w值不是对应的像素值，而是图片真正的宽度。如在iphone8上，分辨率是2x，440px对应的图片宽度是880w，与880w最接近的是800w，所以会去加载图片’pic-800w.jpg’，而如果是在分别率为1x的设备上，则对应440w，与480w最接近，会去加载图片pic-480w.jpg。 picture12345&lt;picture&gt; &lt;source media=\"(max-width: 799px)\" srcset=\"elva-480w-close-portrait.jpg\"&gt; &lt;source media=\"(min-width: 800px)\" srcset=\"elva-800w.jpg\"&gt; &lt;img src=\"elva-800w.jpg\" alt=\"Chris standing up holding his daughter Elva\"&gt;&lt;/picture&gt; 会按顺序加载满足条件的第一个图片，保底需要定义一个img作为默认值，已经兼容不支持标签的浏览器。source同样支持srcset和sizes属性配置多个，此外还支持type去标识不同的图片类型。1234&lt;picture&gt; &lt;source type=\"image/webp\" srcset=\"snow.webp\"&gt; &lt;img src=\"snow.png\" alt=\"Hut in the snow\"&gt;&lt;/picture&gt; 如果支持webp格式的，会去加载snow.webp，否则会去加载默认的snow.png。 HTTP Client Hints通过http client hints，浏览器发起请求的时候，可以将DPR、Width、Viewport-Width等属性发送到Server端。Chrome46开始支持Accept-CH的配置：1&lt;meta http-equiv=\"Accept-CH\" content=\"DPR, Width, Viewport-Width\"&gt; 配置完成后，页面发送的请求头部都被包含下面信息：1234Accept: image/webp,image/apng,image/*,*/*;q=0.8DPR: 3Viewport-Width: 460Width: 230 其中Width属性不是每次都被带上，它是根据Image的sizes属性计算出来的，默认还会带上Accept属性，如果支持webp格式的图片，会包含’image/webp’。Server端可以根据这些属性的值返回期望的图片：宽度为690px的webp图片。响应头会包含Content-Type、Content-DPR、Vary属性，浏览器会基于Content-DPR的值去计算图片最终展示的宽度，保证宽度仍为230px。demo如下所示。 更详细的介绍，参见automating-resource-selection-with-client-hints webp图片WebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量。webp兼容性见下图其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。 检测浏览器是否支持webp格式方法1: canvas的toDataURL123456789function checkWebp() &#123; try&#123; return (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0); &#125;catch(err) &#123; return false; &#125; //or !![].map &amp;&amp; document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;&#125; 对比一下chrome和ie下document.createElement(&#39;canvas&#39;).toDataURL(&#39;image/webp&#39;)下的输出：1234//ie\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"//chrome\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\" 基于toDataURL的特性，如果请求的类型不被支持，默认返回data:image/png。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则toDataURL会返回&quot;data:,&quot;。)所以，只有支持webp格式的浏览器调用toDataURL(&#39;image/webp&#39;)后返回的字符串中才包含&#39;data:image/webp&#39;。上面提供了两种写法，其中!![].map主要是判断是否是IE9+，以免toDataURL方法会报错。 方法2: 图片onloadgoogle官网提供的，通过加载小的webp图片来判断是否支持该格式：1234567891011121314151617181920// check_webp_feature:// 'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.// 'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)function check_webp_feature(feature, callback) &#123; var kTestImages = &#123; lossy: \"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\", lossless: \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\", alpha: \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\", animation: \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\" &#125;; var img = new Image(); img.onload = function () &#123; var result = (img.width &gt; 0) &amp;&amp; (img.height &gt; 0); callback(feature, result); &#125;; img.onerror = function () &#123; callback(feature, false); &#125;; img.src = \"data:image/webp;base64,\" + kTestImages[feature];&#125; 上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。调用方法如下，可以在callback方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加webp相关的class都可以。123check_webp_feature('lossless',function(feature,result)&#123; alert(result); //true or false&#125;); 使用webp处理webp通常有两种方式： 服务端处理，支持webp图片的浏览器会在请求头Accept中加上image/webp，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了； 前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型开心的是，基于网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考https://www.163yun.com/help/documents/114078550521466880。其中，通过在url后拼接?imageView&amp;type=webp就可以获得对应的webp图片。 REFS响应式图片React（17）异步组件基于 webpack 的持久化缓存方案 https://www.imooc.com/article/21538听说你用webpack处理文件名的hash？简单易懂的 webpack 打包后 JS 的运行过程","tags":[]},{"title":"菜鸟优化之路-前端性能测试工具sitespeed.io","date":"2018-10-09T12:08:27.000Z","path":"2018/10/09/菜鸟优化之路-前端性能测试工具/","text":"制定优化目标度量标准 首次有效绘制（First Meaningful Paint，简称FMP，当主要内容呈现在页面上） 英雄渲染时间（Hero Rendering Times，度量用户体验的新指标，当用户最关心的内容渲染完成） 可交互时间（Time to Interactive，简称TTI，指页面布局已经稳定，关键的页面字体是可见的，并且主进程可用于处理用户输入，基本上用户可以点击UI并与其交互） 输入响应（Input responsiveness，界面响应用户输入所需的时间） 感知速度指数（Perceptual Speed Index，简称PSI，测量页面在加载过程中视觉上的变化速度，分数越低越好） 自定义指标，由业务需求和用户体验来决定。FMP与英雄渲染时间非常相似，但它们不一样的地方在于FMP不区分内容是否有用，不区分渲染出的内容是否是用户关心的。 设定目标基于RAIL模型去制定优化的目标，RAIL是一种以用户为中心的性能模型，主要从响应、动画、空闲、加载四个层面去衡量页面性能。1. 100 毫秒的响应时间 + 每秒60帧每帧动画应在少于 16 毫秒（理想情况下为 10 毫秒）内完成，从而达到每秒 60 帧（1 秒 ÷ 60 = 16.6毫秒）。保持乐观，明智地利用空闲时间。对于像动画这样的高压点，只要能，就不要做任何其它事情。预计输入延迟时间（Estimated Input Latency）应低于 50 毫秒。 2. 速度指数（SpeedIndex）小于 1250，可交互时间（Time-To-Interactive）在 3G 上小于 5 秒Speed Index是指获取可见页面加载的视觉进度，并计算内容绘制速度的总得分，分数越低，性能越好，具体的计算可参考speed-index。目标是在 1 秒内（在高速网络下）完成首次绘制（FMP），速度指数（SpeedIndex）低于 1250 毫秒。考虑速度基线是一台有着 3G 网络的，价格为 200 美元左右的 Android 手机（译注：国产千元机水平），那么可以以 400 毫秒 RTT 和 400kb/s 的传输速度进行网络模拟，以达成可交互时间（Time-To-Interactive）小于 5 秒，第二次打开的速度低于 2 秒。尽你所能地降低这些指标。 3. 核心块 = 15kb，关键文件 &lt; 170 kbHTML 的前 14~15kb 是最关键的核心块（chunk），也是整个文件中唯一可以在第一个 RTT 内被下载的部分。要实现上述目标，请设定关键文件的最大尺寸“预算”。170kb gzip 后的文件（原始文件尺寸 0.8~1mb），在普通手机上可能需要 1 秒才能解析和编译完成。 sitespeed.io工具Sitespeed.io是一个基于最佳实践以及一些加载时序等量化标准的开源工具，有助于开发者分析网页的加载速度和渲染性能。它拥有一套插件，如Coach、Broswertime、Chrome-HAR等，帮助sitespeed搜集浏览器debug状态下的数据，并基于网站最佳实践给出相应的打分和意见，最后把数据可视化展示。sitespeed.io评价网页的主要依据是：浏览器的网络请求和TimeLine中的Time Event。与webpageTest、PageSpeed Insights等只能测试线上站点不同，sitespeed.io可以测试本地运行的，以及测试环境绑定代理的站点。 安装可以直接安装sitespeed.io的npm包。12npm install -g sitespeed.ioyarn add global sitespeed.io 也可以使用docker或者git clone的方式安装，具体可参考npm-sitespeed.io。 安装遇到的问题在安装过程中有遇到一些问题，具体的问题和解决办法记录在这儿。1.修复npm安装时报VCBuild不存在的错误，参考stackoverflow给出的解决方案。1npm install --global --production windows-build-tools 2.Browser failed to start, could not find ...alto-saxophone\\vendor\\chromedriver.exe查看node-modules/alto-saxophone目录，发现该目录下对应的文件缺失，可以在该目录下运行npm run install命令手动安装chromedriver.exe。1npm run install 3.运行sitespeed.io报错12345$ sitespeed.io https://www.sitespeed.io/module.js:682 return process.dlopen(module, path._makeLong(filename));Error: The specified module could not be found.\\\\?\\C:\\Users\\hzwushuoshuo\\AppData\\Roaming\\npm\\node_modules\\sitespeed.io\\node_modules\\sharp\\build\\Release\\sharp.node 查看安装sitespeed.io的过程，发现在安装sharp包时报错UnhandledPromiseRejectionWarning，需要在admin模式下去安装文件。 运行1sitespeed.io -n 5 -v https://www.baidu.com 该命令将会在chrome浏览器下调起URL为https://www.baidu.com 5次。如果期望一次检测多个页面，可以继续拼接参数，如下所示。1sitespeed.io -n 5 -v https://www.baidu.com -v https://www.baidu.com/s?wd=test 生成的文件可以在sitespeed-result文件夹中查看。 运行结果打开sitespeed.io输出的html文件，可以查看Summary、Detailed Summary、Pages、Domains、Toplist和Assets六个维度的信息。SummarySummary是对网页性能数据的一个整体展示。站点得分主要根据页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标进行打分，每个核心指标考核的内容可以在help.html文件中查找。页面中的其他指标，如文件压缩、文件大小、请求数、缓存时间、请求状态码、首次渲染时间、前端渲染用时、页面加载用时、DNS解析时长等，这些指标都有详细的统计，而且不同等级用相应的颜色表示。 Detailed Summary点击左侧具体的指标，都可以在帮助文档中查看对该指标的解释。针对每个指标都计算除了最小(min)、最大(max)、平均值(mean)、中位数(median)和加载90%(p90)时的数据。 Pages如果一次测试多个页面，可以在Pagestab下面查看到不同的页面。点击某个页面的URL可以查看到页面的加载细节，包括资源请求的waterfall瀑布流图：在上图的coachTab下有页面性能（Performance）、可用性（Accessibility）和 Web最佳实践（Web Best Practice）三个核心指标下各个细分项的得分，并给出了优化建议，如下图所示。 DomainsDomainstab下主要是对按域名统计，各个域名下的请求时间和请求数。 ToplistToplist会列出所有大的文件，包括JS、CSS、HTML和图片，此外还会列出所有慢的请求。 AssetsAssets显示了所有被加载资源的前20个，包括文件类型、last-modified时间、缓存时间、文件大小等数据。 REFS:2018 前端性能检查表嗨，送你一张Web性能优化地图好用的前端页面性能检测工具—sitespeed.io","tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://sherrywu0917.github.io/tags/前端性能优化/"},{"name":"sitespeed.io","slug":"sitespeed-io","permalink":"https://sherrywu0917.github.io/tags/sitespeed-io/"}]},{"title":"菜鸟优化之路-图片webp&lazyload","date":"2018-09-27T12:17:29.000Z","path":"2018/09/27/菜鸟优化之路-图片webp-lazyload/","text":"webp图片优化WebP是由google开发的一种图片格式，优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。webp兼容性见下图其中chrome和opera支持得比较好，safari和firefox目前不支持，但已经在实验阶段。 检测浏览器是否支持webp格式方法1: canvas的toDataURL123456789function checkWebp() &#123; try&#123; return (document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0); &#125;catch(err) &#123; return false; &#125; //or !![].map &amp;&amp; document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;&#125; 对比一下chrome和ie下document.createElement(&#39;canvas&#39;).toDataURL(&#39;image/webp&#39;)下的输出：1234//ie\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAADGSURBVHhe7cExAQAAAMKg9U9tCF8gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAONUAv9QAAcDhjokAAAAASUVORK5CYII=\"//chrome\"data:image/webp;base64,UklGRrgAAABXRUJQVlA4WAoAAAAQAAAAKwEAlQAAQUxQSBIAAAABBxARERCQJP7/H0X0P+1/QwBWUDgggAAAAHANAJ0BKiwBlgA+bTaZSaQjIqEgKACADYlpbuF2sRtACewD32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99qwAAP7/1gAAAAAAAAAA\" 基于toDataURL的特性，如果请求的类型不被支持，默认返回data:image/png。（PS:canvas的默认宽高是300px,150px，如果canvas的宽或者高为0，则toDataURL会返回&quot;data:,&quot;。)所以，只有支持webp格式的浏览器调用toDataURL(&#39;image/webp&#39;)后返回的字符串中才包含&#39;data:image/webp&#39;。上面提供了两种写法，其中!![].map主要是判断是否是IE9+，以免toDataURL方法会报错。 方法2: 图片onloadgoogle官网提供的，通过加载小的webp图片来判断是否支持该格式：1234567891011121314151617181920// check_webp_feature:// 'feature' can be one of 'lossy', 'lossless', 'alpha' or 'animation'.// 'callback(feature, result)' will be passed back the detection result (in an asynchronous way!)function check_webp_feature(feature, callback) &#123; var kTestImages = &#123; lossy: \"UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\", lossless: \"UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==\", alpha: \"UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==\", animation: \"UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\" &#125;; var img = new Image(); img.onload = function () &#123; var result = (img.width &gt; 0) &amp;&amp; (img.height &gt; 0); callback(feature, result); &#125;; img.onerror = function () &#123; callback(feature, false); &#125;; img.src = \"data:image/webp;base64,\" + kTestImages[feature];&#125; 上面提供了几种webp的图片模式，如果浏览器支持webp，那么图片的宽高会大于0，从而返回true,否则返回false。调用方法如下，可以在callback方法中得到检测结果，进而去进一步处理：选择动态加载webp格式的图片，或者给全局添加webp相关的class都可以。123check_webp_feature('lossless',function(feature,result)&#123; alert(result); //true or false&#125;); 使用webp处理webp通常有两种方式 服务端处理，支持webp图片的浏览器会在请求头Accept中加上image/webp，服务器根据头信息返回webp或者其他格式的图片；但图片放在CDN服务器上，处理起来就很麻烦了； 前端先完成对是否支持webp格式的检测，再根据检测结果去选择请求的资源类型我们产品使用的是网易云提供的服务，通过修改参数就可以去获取不同格式的图片，具体可以参考https://www.163yun.com/help/documents/114078550521466880。其中，通过在url后拼接?imageView&amp;type=webp就可以获得对应的webp图片。 在线生成 智图 zhitu.isux.us 又拍云 www.upyun.com/webp CloudConvert cloudconvert.com/anything-to-webp iSparta isparta.github.io/index.html 图片lazyload图片lazyload是常见的性能优化的一种方式。如果页面图片数量较多，一次性加载比较耗时，还会导致页面卡顿，所以，建议根据需要去加载部门图片，待页面滚动时再加载下面的图片。可以使用一个轻量级的lazyload库，具体使用可以参考GitHub。通过npm安装vanilla-lazyload包，推荐的版本有：12npm install vanilla-lazyload@8.17.0npm install vanilla-lazyload@10.19.0 注意：10.x版本使用了IntersectionObserver API，IE和safari不支持，所有图片会一次性加载。简单粘贴一个示例：123&lt;img class=\"lazy\" alt=\"...\" data-src=\"../img/44721746JJ_15_a.jpg\" width=\"220\" height=\"280\"&gt; 1234import LazyLoad from \"vanilla-lazyload\";var myLazyLoad = new LazyLoad(&#123; elements_selector: \".lazy\"&#125;); 在线demo可以访问：https://www.andreaverlicchi.eu/lazyload/demos/container_single.htmlREFS:https://github.com/verlok/lazyloadhttps://www.haorooms.com/post/webp_bigpipehttps://www.zhangxinxu.com/php/microCodeDetail?id=3","tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://sherrywu0917.github.io/tags/前端性能优化/"},{"name":"webp","slug":"webp","permalink":"https://sherrywu0917.github.io/tags/webp/"}]},{"title":"函数式编程的应用","date":"2018-08-24T01:38:54.000Z","path":"2018/08/24/函数式编程的应用/","text":"react的render方法render()函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器交互。若需要和浏览器交互，将任务放在componentDidMount()阶段或其他的生命周期方法。保持render() 方法纯净使得组件更容易思考。","tags":[]},{"title":"菜鸟优化之路","date":"2018-08-08T08:21:21.000Z","path":"2018/08/08/菜鸟优化之路/","text":"DeviceTiming工具最近了解到DeviceTiming工具，可以帮助我们监测js在不同设备上的解析和执行时间，运行环境是在开发环境下。搬运下git上的安装、运行命令：1234567//安装git clone https://github.com/etsy/DeviceTiming.gitcd DeviceTimingnpm install//运行./devicetiming server /path/to/your/js 注意：devicetiming会改变被监控的js，要先备份好，不过有git记录的就不用担心了 运行了之后，用不同的设备访问开发环境下的站点，最后reloadhttp://localhost:8537/页面，可以看到不同设备对js的解析和执行时间，如下图所示：可以看到不同设备的ua信息，每个js的parse和exec时间。从上到下，三个设备分别是微信开发者工具、iphone、安卓机。从数据上看，安卓机parse和exec花费的时间最久，花费时间越长，用户的体验就会越差。该站点面向的用户中安卓机份额更高，how to optimize显得比较重要。 how to optimize尾部调用优化（TCO）尾调用概念就是在函数最后一步调用其他函数。12345678910111213function foo(x) &#123; return x;&#125;function bar(y) &#123; return foo( y + 1 ); // 尾部调用&#125;function baz() &#123; return 1 + bar( 40 ); // 不是尾部调用&#125;baz(); // 42 bar函数的最后一步是调用foo( y + 1 )，属于尾部调用；而在baz函数中，调用完bar(40)后，还有执行+ 1的操作，就不属于尾部调用了。 函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 如果函数g不是尾部调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。尾部调用优化，即只保留内层函数的调用记录，运用这一思想可以去优化递归，不需要再保存每次的调用记录，始终只存在一个调用记录，可以避免’栈溢出’。 动态加载组件代码分片当前端代码越来越复杂，代码体积越来越大时，考虑对加载的资源进行细粒度的分割，按需加载。webpack支持两种语法实现动态地加载模块： require.ensure给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。 1require.ensure(dependencies: String[], callback: function(require), chunkName: String) import调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。 1234import( /* webpackChunkName: \"my-chunk-name\" */ /* webpackMode: \"lazy\" (default)*/ 'path/to/module') -&gt; Promise webpackChunkName用来设置chunk的名字；webpackMode默认值是lazy，还有lazy-once、eager、weak。 按需加载的默认加载形式是async。 react动态加载组件在React项目中，期望将某个组件分离出去(如BannerSwiper轮播组件，不是每次都会被调用，并且使用了react-id-swiper包，体积较大)，可以封装一个异步组件来实现组件的动态加载。直接看代码：123456789101112131415161718192021222324252627282930313233343536373839import React, &#123;Component&#125; from 'react'/** * 异步加载模块 * @param &#123;[type]&#125; loadComponent [description] * @return &#123;[type]&#125; [description] */export const asyncComponent = loadComponent =&gt; ( class AsyncComponent extends Component &#123; state = &#123; Component: null, &#125; componentDidMount() &#123; if (this.hasLoadedComponent()) &#123; return; &#125; loadComponent() .then(module =&gt; module.default) .then((Component) =&gt; &#123; this.setState(&#123; Component &#125;); &#125;) .catch((err) =&gt; &#123; console.error(`Cannot load component in &lt;AsyncComponent /&gt;`); throw err; &#125;); &#125; hasLoadedComponent() &#123; return this.state.Component !== null; &#125; render() &#123; const &#123; Component &#125; = this.state; return (Component) ? &lt;Component &#123;...this.props&#125; /&gt; : null; &#125; &#125;); loadComponent参数代表import(‘module’)异步加载模块，加载成功后会调用then方法去设置组件。函数最后会返回一个React组件。如何调用：1export const AsyncBannerSwiper = asyncComponent(() =&gt; import(/* webpackChunkName: \"bannerSwiper\" */ './BannerSwiper.jsx')) 将BannerSwiper组件用asyncComponent封装下，就返回了一个异步加载的AsyncBannerSwiper组件，使用方法和其他组件完全一致。 publicPath动态设置项目的资源路径可能是启用了CDN，也可能是直接从站点获取，所以需要根据Server端的参数来设置异步加载chunk的publicPath。动态设置异步chunk的publicPath，在入口entry中设置webpack_public_path，打包配置文件中配置的publicPath不变。1__webpack_public_path__ = window.cdn || '/dist/'; webpack设置在webpack配置文件中，需要配置chunkFilename指定chunk的名字。1chunkFilename: '[name].js' 另外，注意webpack插件的配置：1234567new webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk idnew webpack.optimize.CommonsChunkPlugin(&#123; ... children: false, // 如果设置为 `true`，所有公共 chunk 的子模块都会被选择 ...&#125;),new ExtractTextPlugin(&#123;filename: 'css/[name].css?[contenthash:8]', allChunks: true&#125;), //从所有chunk中提取(默认情况下，它仅从initial chunk中提取) 分离前后对比使用webpack-bundle-analyzer分析打包后各个JS的组成部分，没有进行代码分离之前的可视化视图如下图：可以看到上图中的common.bundle.js，swiper.js模块大小占比一大半，swiper.js是react-id-swiper包引用到的资源，此时common.bundle.js的文件大小是172K： 使用前文提到的方式将BannerSwiper组件及其引用的react-id-swiper包分离出去后，各文件组成如下图所示：可以看到，分离出一个bannerSwiper.js之后，common.bundle.js的体积就精简了很多，由之前的172K缩减成了46K。 REFS:https://blog.csdn.net/qq20004604/article/details/79318253https://segmentfault.com/a/1190000009820646 持久化内存为了获取持久化内存，比起hash，chunkhash是更好的选择，它根据每个文件的内容来生成，文件内容不变，chunkhash就不会发生变化；而只要有一个文件发生变化，hash就会发生变化，所有文件公用同一个hash。 moduleId VS chunkId看打包后的manifest.js，精简的源码如下所示：12345678910111213141516171819202122232425262728293031(function(modules) &#123; window[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) &#123; var moduleId, result; for (moduleId in moreModules) &#123; if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123; // 将chunk中所包含的模块放入modules数组中 modules[moduleId] = moreModules[moduleId]; &#125; &#125; if (executeModules) &#123; for (i = 0; i &lt; executeModules.length; i++) &#123; result = __webpack_require__(executeModules[i]); &#125; &#125; return result; &#125;; var installedModules = &#123;&#125;; // 调用__webpack_require__(moduleId)时， //再将模块放入installedModules，用于保存已经加载过的模块 function __webpack_require__(moduleId) &#123; if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; var module = installedModules[moduleId] = &#123; exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); return module.exports; &#125;&#125;)([]); webpackJsonp方法接收三个参数chunkIds, moreModules, executeModules，分别属于chunkId和moduleId两种类型: chunk代表打包生成的js文件，一个chunkId对应一个打包好的js文件，默认情况下使用数组下标作为chunkId。 module对应着模块，可以简单理解为打包前每个js文件对应一个模块，也就是之前__webpack_require__加载的模块，同样使用数组下标作为moduleId。每次有其他JS文件内容发生变化，moduleId和chunkId都有可能发生变化，会影响common.bundle.js以及其他打包后的JS，想要缓存持久化，需要固化moduleId和chunkId。 固化moduleId和chunkId 固化moduleId：HashedModuleIdsPlugin会根据文件的路径去生成hash，可以用在生成环境。开发环境可以使用NamedModulesPlugin，hash直接是模块的相对路径，更加清晰，便于debug。 固化chunkId：webpack中entry的唯一的，所以可以直接使用entry名作为chunkId，使用NamedChunksPlugin可以帮助我们达成该目标，如果是代码分离出的chunk可以使用/* webpackChunkName: &quot;bannerSwiper&quot; */指定chunk的名字，或者可以在NamedChunksPlugin插件中去配置。12new webpack.HashedModuleIdsPlugin(), //固化 module idnew webpack.NamedChunksPlugin(), //固化 runtime 内以及在使用动态加载时分离出的 chunk 的 chunk id REFS:https://github.com/pigcan/blog/issues/9https://www.imooc.com/article/21538https://juejin.im/post/5a23b130f265da432003101ahttps://github.com/happylindz/blog/issues/6 内存泄露排查 内存泄露：应用程序不再需要占用内存的时候，由于某些原因，内存没有被操作系统或可用内存池回收。一些编程语言提供了语言特性，可以帮助开发者做此类事情。另一些则寄希望于开发者对内存是否需要清晰明了。JavaScript 是一种垃圾回收语言。垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。 JavaScript内存泄露垃圾回收语言的内存泄漏主因是不需要的引用。大部分垃圾回收语言用的算法称之为 Mark-and-sweep 。算法由以下几步组成： 垃圾回收器创建了一个“roots”列表。Roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）； 所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。 所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。 四种常见的JavaScript内存泄漏类型： 意外的window全局变量 被遗忘的计时器或回调函数 脱离 DOM 的引用 闭包 实例分析浏览器performance切换到该tab下，勾选memory，并点击记录按钮，不断点击阅读下一章，持续一段时间。三种迹象显示出现了内存泄漏，图中的 Nodes（绿线）、Listeners（黄线）和 JS heap（蓝线）。Nodes、Listeners稳定增长，并未下降，这是个显著的信号。 浏览器 heap profile切换到memory tab下，等待页面刷新完成，点击take heap snapshot保存当前快照。切换到下一章节，重复之前操作，保存快照。选择Comparison，将快照与之前的进行对比，可以发现有的对象如content只增不减。仔细分析代码，发现Content组件中有注册事件代理，监听fontChange事件变化，作为一个SPA，EventProxy一直存在于内存中，每次创建新的content时候，都会给fontChange事件新注册一个回调方法，之前的回调方法一直保存在回调数组中，没有被回收，导致content组件也不能被正确回收：1234567891011121314151617const eventProxy = &#123; //... off: function(key) &#123; this.onObj[key] = []; this.oneObj[key] = []; &#125;, //...&#125;componentDidMount() &#123; EventProxy.on('fontChange', diff =&gt; this.handleFontChange(diff));&#125;componentWillUnmount() &#123; EventProxy.off('fontChange'); //Release memory this.listener &amp;&amp; window.removeEventListener('scroll', this.listener, false); //Release memory&#125; 调用EventProxy.off(&#39;fontChange&#39;)解除eventProxy对象对this.handleFontChange的引用，这样this对应的content的对象才能被正确回收；和removeEventListener一样的原理。1234567this.listener = () =&gt; &#123; if(this.contentWrap &amp;&amp; (window.pageYOffset &gt; this.contentWrap.offsetHeight / 2)) &#123; //... window.removeEventListener('scroll', this.listener, false); //Release memory(事件不一定被触发) &#125;&#125;window.addEventListener('scroll', this.listener, false) 虽然在this.listener内部有解除scroll事件监听的代码，但是要满足一定条件才会触发，所以在componentWillUnmount方法中也添加了removeEventListener，实现对scroll事件的解绑。 经过上面的优化后，再次对比，发现content对象可以被正常回收。 REFs: https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/ cpu占比探测12345678910var data = []var tfunction pulse() &#123; t &amp;&amp; data.push(Date.now() - t) t = Date.now() setTimeout(pulse, 50)&#125;pulse() 就是每隔 50ms 打一下点。理想情况下，data 的值应该是1data = [50, 50, 50, 50, ...] 但实际情况，data会是1data = [51, 52, 50, 52, ...] cpu越忙，data的数据项会越大。这样，记录一系列 data 值，就可以绘制出 CPU 占比趋势图，和通过任务管理器看到的 CPU 趋势图非常接近。 上面只是原理说明，实际情况没这么简单。但很明显，通过这么一个简单的规律，就能实现用纯 JavaScript 来探测 CPU 占比。","tags":[{"name":"前端性能优化","slug":"前端性能优化","permalink":"https://sherrywu0917.github.io/tags/前端性能优化/"}]},{"title":"JS函数式编程笔记(下)","date":"2018-07-13T03:20:08.000Z","path":"2018/07/13/JS函数式编程笔记(下)/","text":"示例应用声明式编程 命令式编程（imperative）：喜欢大量使用可变对象和指令，我们总是习惯于创建对象或者变量，并且修改它们的状态或者值，或者喜欢提供一系列指令，要求程序执行。 声明式编程（Declarative）：对于声明式的编程范式，你不在需要提供明确的指令操作，所有的细节指令将会更好的被程序库所封装，你要做的只是提出你要的要求，声明你的用意即可。与命令式不同，声明式意味着我们要写表达式，而不是一步一步的指示。SQL是典型的声明式编程，明确指出想要什么(what)，而不是如何实现(how)。123456789// 命令式var makes = [];for (i = 0; i &lt; cars.length; i++) &#123; makes.push(cars[i].make);&#125;// 声明式var makes = cars.map(function(car)&#123; return car.make; &#125;); 上述命令式编程要求先声明一个数组，再去遍历，然后执行循环中具体的方法。使用map的版本是一个表达式，它对执行顺序没有要求,它指明的是做什么，不是怎么做。 REFS:声明式编程和命令式编程的比较 Hindley-Milner 类型签名 类型签名在写纯函数时所起的作用非常大，短短一行，就能暴露函数的行为和目的。因为类型是可以推断的，所以明确的类型签名并不是必要的；不过你完全可以写精确度很高的类型签名，也可以让它们保持通用、抽象。JavaScript 也有一些类型检查工具，比如 Flow，或者它的静态类型方言 TypeScript 。 举个栗子123456// capitalize :: String -&gt; Stringvar capitalize = function(s)&#123; return toUpperCase(head(s)) + toLowerCase(tail(s));&#125;capitalize(\"smurf\");//=&gt; \"Smurf\" 从类型签名来看，capitalize方法接收了一个String，最终也返回了一个String。 对于柯里化后的函数，对类型的签名可以有不同的理解：1234// match :: Regex -&gt; String -&gt; [String]var match = curry(function(reg, s)&#123; return s.match(reg);&#125;); 一种思路是接收Regex和String两种类型参数，返回一个[String] 另一种思路是match :: Regex -&gt; (String -&gt; [String])，先接收了一个Regex参数，返回一个新的函数，该函数接收String并返回一个[String]。 再举个栗子1234// reduce :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; bvar reduce = curry(function(f, x, xs)&#123; return xs.reduce(f, x);&#125;); 约定俗成，a、b可以是任一种类型，但相同的字母a代表同一类型。其中(b -&gt; a -&gt; b)约定了函数的类型签名： b是传入f的累加器（初始值是括号后面的-&gt; b）; a是遍历[a]得到的currentValue; f返回的类型是b，最终reduce方法返回的类型也就是f的返回。类型签名的美妙之处在于明确告诉我们函数做了什么 缩小可能性范围大多数语言都有范型(也成为参数多态性)，其中函数是通过一个或多个抽象类型定义的。1// head :: [a] -&gt; a 引入了类型签名后，可以缩小head函数的可能范围，a可以是任意类型的参数，即多态性(polymorphism)，对于任意类型的参数都要支持[a] -&gt; a的映射，可以帮助我们缩小函数可能性的范围。我们甚至可以用[a] -&gt; a去到类型签名搜索引擎里面搜索我们需要的函数，详细移步到Hoogle去尝试，很有意思。 自由定理12// head :: [a] -&gt; acompose(f, head) == compose(head, map(f)); 等式左边说的是，先获取数组的头部，然后对它调用函数 f；等式右边说的是，先对数组中的每一个元素调用 f，然后再取其返回结果的头部。这两个表达式的作用是相等的，但是前者要快得多。可以得到一个普适的道理：如果你映射某个函数到列表上，然后对其应用 f，其等同于对映射应用 f。数学提供的这种形式化方法，可以帮助计算机去进行类似的代码优化。 类型约束1// sort :: Ord a =&gt; [a] -&gt; [a] 签名也可以把类型约束为一个特定的接口（interface），a必须是Ord对象，在强类型语言中，可以是一个自定义的接口。 特百惠容器为什么叫特百惠呢？因为特百惠是一个家居品品牌，代表产品是容器。12345var Container = function(x) &#123; this.__value = x;&#125;Container.of = function(x) &#123; return new Container(x); &#125;; 使用Container.of作为构造器，暂且认为它是把值放到容器里的一种方式。 第一个 functor容器中有了值之后，我们需要一种方式来操作容器中的值：1234// (a -&gt; b) -&gt; Container a -&gt; Container bContainer.prototype.map = function(f)&#123; return Container.of(f(this.__value))&#125; 这个map跟数组那个著名的map一样，除了前者的参数是Container a而后者是[a]。它们的使用方式也几乎一致：12345678910Container.of(2).map(function(two)&#123; return two + 2 &#125;)//=&gt; Container(4)Container.of(\"flamethrowers\").map(function(s)&#123; return s.toUpperCase() &#125;)//=&gt; Container(\"FLAMETHROWERS\")Container.of(\"bombs\").map(concat(' away')).map(_.prop('length'))//=&gt; Container(10) Container将值传给map后，通过f方法，我们可以对值进行任意操作，操作结束后再放入Container中并返回，这样就可以连续对容器中的值进行操作。这样一直调用map的形式，不就是前面提到的组合么。这里面起作用的数学魔法就是functor(函子): functor 是实现了map函数并遵守一些特定规则的容器类型。 为什么要使用functor这种方式来处理呢？ 即让容器自己去运用函数能给我们带来什么好处？书中给出的答案是抽象——对于函数运用的抽象。 薛定谔的 Maybe定义另外一个functor，同样实现了map函数的、类似容器的数据类型`Maybe’。123456789101112131415var Maybe = function(x) &#123; this.__value = x;&#125;Maybe.of = function(x) &#123; return new Maybe(x);&#125;Maybe.prototype.isNothing = function() &#123; return (this.__value === null || this.__value === undefined);&#125;Maybe.prototype.map = function(f) &#123; return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));&#125; Maybe和Container的不同点就是它新增了一个isNothing，在每次调用函数前，先检查它自己的值是否为空。 123456Maybe.of(\"Malkovich Malkovich\").map(match(/a/ig));//=&gt; this._value = match(/a/ig)(\"\"Malkovich Malkovich\"\")//=&gt; Maybe(['a', 'a'])Maybe.of(null).map(match(/a/ig));//=&gt; Maybe(null) 点记法（dot notation syntax）已经足够函数式了，但我们更想保持一种 pointfree 的风格。碰巧的是，map完全有能力以curry函数的方式来“代理”任何 functor，柯里化后就可以方便地使用compose了：1234// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f bvar map = curry(function(f, any_functor_at_all) &#123; return any_functor_at_all.map(f);&#125;); 结合前面提到的类型签名，首先约束了f是Functor类型，去掉类型约束后签名是(a -&gt; b) -&gt; f a -&gt; f b，可以看出传入的参数是一个函数f: (a -&gt; b)，一个functor: f a，最后返回一个functor: f b。这个方法可以帮助我们取出容器中的值，可以参考下面的例子：123456789101112// safeHead :: [a] -&gt; Maybe(a)var safeHead = function(xs) &#123; return Maybe.of(xs[0]); // this.__value = xs[0]&#125;;var streetName = compose(map(_.prop('street')), safeHead, _.prop('addresses'));streetName(&#123;addresses: []&#125;);// Maybe(null)streetName(&#123;addresses: [&#123;street: \"Shady Ln.\", number: 4201&#125;]&#125;);// Maybe(\"Shady Ln.\") safeHead返回了一个Maybe对象（eg2：Maybe({street: “Shady Ln.”, number: 4201})），要想对隐藏在Maybe容器中的值进行操作，需要借助map函数来操作，通过调用该对象的map函数，传入_.prop(&#39;street&#39;)函数，对this.__value进行操作，返回一个新的Maybe对象（eg2: Maybe(“Shady Ln.”)）。 “纯”错误处理Maybe实现了空和非空两种类型的分开处理，利用这种思想，我们可以对错误进行更友好、健壮地处理。用一个简单的例子示意一下：1234567891011121314151617181920212223var Left = function(x) &#123; this.__value = x;&#125;Left.of = function(x) &#123; return new Left(x);&#125;Left.prototype.map = function(f) &#123; return this;&#125;var Right = function(x) &#123; this.__value = x;&#125;Right.of = function(x) &#123; return new Right(x);&#125;Right.prototype.map = function(f) &#123; return Right.of(f(this.__value));&#125; 1234567891011121314var moment = require('moment');// getAge :: Date -&gt; User -&gt; Either(String, Number)var getAge = curry(function(now, user) &#123; var birthdate = moment(user.birthdate, 'YYYY-MM-DD'); if(!birthdate.isValid()) return Left.of(\"Birth date could not be parsed\"); return Right.of(now.diff(birthdate, 'years'));&#125;);getAge(moment(), &#123;birthdate: '2005-12-12'&#125;);// Right(9)getAge(moment(), &#123;birthdate: '20010704'&#125;);// Left(\"Birth date could not be parsed\") 其中Left用来处理错误状态，Right用来处理正常情况。 Old McDonald had Effects…在纯函数那一章，通过将不纯的函数包裹在另一个函数中，使得它看起来像个纯函数。类似的例子：123456// getFromStorage :: String -&gt; (_ -&gt; String)var getFromStorage = function(key) &#123; return function() &#123; return localStorage[key]; &#125;&#125; 这儿将getFromStorage改造成，相同的输入key总会对应相同的输出：一个从localStorage里取出某个特定元素的函数。（然而，感觉并没什么用啊= =） 1234567891011121314var IO = function(f) &#123; this.__value = f; //f总是一个函数&#125;IO.of = function(x) &#123; return new IO(function() &#123; return x; &#125;);&#125;IO.prototype.map = function(f) &#123; //这儿和Maybe.of(f(this.__value))实现效果一致 return new IO(_.compose(f, this.__value));&#125; IO(function(){ return x })仅仅是为了延迟执行，其实我们得到的是 IO(x)。 实际使用的时候：123456789101112131415161718192021////// 纯代码库: lib/params.js ///////// url :: IO Stringvar url = new IO(function() &#123; return window.location.href; &#125;);// toPairs = String -&gt; [[String]]var toPairs = compose(map(split('=')), split('&amp;'));// params :: String -&gt; [[String]]var params = compose(toPairs, last, split('?'));// findParam :: String -&gt; IO Maybe [String]var findParam = function(key) &#123; return map(compose(Maybe.of, filter(compose(eq(key), head)), params), url);&#125;;////// 非纯调用代码: main.js ///////// 调用 __value() 来运行它！findParam(\"searchTerm\").__value();// Maybe(['searchTerm', 'wafflehouse']) 本质上是将逻辑分成了纯代码库和非纯调用代码两部分，纯代码库最后生成的函数是唯一的，最后的风险都放在了调用者身上。__value的命名并不合理，__value的调用会触发前面已压栈的所有操作，替换为unsafePerformIO更能提醒用户它的变化无常。 functor 的概念来自于范畴学，并满足一些定律。12345// identitymap(id) === id;// compositioncompose(map(f), map(g)) === map(compose(f, g)); Monadpointed functorof方法并不是用来避免使用new关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。pointed functor就是实现了of方法的Functor。默认最小化上下文是什么？ TODO 混合比喻1234567891011121314151617181920212223242526// Support// ===========================var fs = require('fs');// readFile :: String -&gt; IO Stringvar readFile = function(filename) &#123; return new IO(function() &#123; return fs.readFileSync(filename, 'utf-8'); &#125;);&#125;;// print :: String -&gt; IO Stringvar print = function(x) &#123; return new IO(function() &#123; console.log(x); return x; &#125;);&#125;// Example// ===========================// cat :: IO (IO String)var cat = compose(map(print), readFile);cat(\".git/config\")// IO(IO(\"[core]\\nrepositoryformatversion = 0\\n\")) 最后返回了一个嵌套两层的IO对象，如果想要再次调用，对其中的值进行处理，则需要map(map(f))；像是穿着两套防护服在工作，很奇怪。123456789Maybe.prototype.join = function() &#123; return this.isNothing() ? Maybe.of(null) : this.__value;&#125;var mmo = Maybe.of(Maybe.of(\"nunchucks\"));// Maybe(Maybe(\"nunchucks\"))mmo.join();// Maybe(\"nunchucks\") 定义一个join方法，可以帮助我们简单地移除一层嵌套，在使用的时候，我们可以在每个map后面，都调用一次join方法，但是我们期望的不止如此。1234567// join :: Monad m =&gt; m (m a) -&gt; m avar join = function(mma)&#123; return mma.join(); &#125;// firstAddressStreet :: User -&gt; Maybe Streetvar firstAddressStreet = compose( join, map(safeProp('street')), join, map(safeHead), safeProp('addresses')); chain函数把map和join封装成chain函数，则firstAddressStreet方法可以改写成：123456789// chain :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m bvar chain = curry(function(f, m)&#123; return m.map(f).join(); // 或者 compose(join, map(f))(m)&#125;);// firstAddressStreet :: User -&gt; Maybe Streetvar firstAddressStreet = compose( chain(safeProp('street')), chain(safeHead), safeProp('addresses')); 简单说，Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。 REFS:图解 Monad","tags":[]},{"title":"JS函数式编程笔记(上)","date":"2018-07-02T11:20:49.000Z","path":"2018/07/02/JS函数式编程笔记(上)/","text":"一等公民的函数为啥说函数是一等公民？ 函数和其他对象一样，可以像对待任何其他数据类型一样对待它们——把它们存在数组里，当作参数传递，赋值给变量…等等。关键点在于，调用的时候没必要再去包裹一层多余的函数，因为二者是等价的。1234\\\\包裹了多余的函数var greeting = function(name) &#123;return hi(name);&#125;\\\\ 一等公民式的调用var greeting = hi; 一等公民函数调用的好处123456789101112//最初的函数httpGet('/post/2', function(json)&#123; return renderPost(json);&#125;);// 需要增加对err异常的处理，要处理的地方比较多httpGet('/post/2', function(json, err)&#123; return renderPost(json, err);&#125;);// 如果使用一等公民函数的形式，则其他的改动会少很多httpGet('/post/2', renderPost); 纯函数的好处 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。 函数的副作用slice和splice相比，slice是一种纯函数，splice会修改自身数据，在函数式编程中比较讨厌这种笨函数。另外，看这个例子： 123456// 不纯的var minimum = 21;var checkAge = function(age) &#123; return age &gt;= minimum;&#125;; checkAge依赖外部变量minimum，minimum发生变化的时候，会影响checkAge函数的返回结果，增加认知负荷。也可以调用Object.freeze({minimum: 21})将minimum变成一个不可变对象。 副作用是在计算过程中，系统状态的一种变化，或者是与外部世界进行的可观察的交互。也是滋生bug的温床。 追求“纯”的理由 可缓存性（Cacheable）可以通过延迟执行的方式把不纯的函数转换为纯函数：123var pureHttpCall = memoize(function(url, params)&#123; return function() &#123; return $.getJSON(url, params); &#125;&#125;); 之所以是纯函数，因为总是根据相同的输入返回相同的输出：同一个发送http请求的函数。 可移植性／自文档化（Portable / Self-Documenting）与环境无关；注入依赖或者通过参数传递。 Erlang 语言的作者 Joe Armstrong 说的这句话：“面向对象语言的问题是，它们永远都要随身携带那些隐式的环境。你只需要一个香蕉，但却得到一个拿着香蕉的大猩猩…以及整个丛林”。 可测试性（Testable）Quickcheck——一个为函数式环境量身定制的测试工具 合理性（Reasonable）引用透明性:如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的，那么我们就说这段代码是引用透明的。 并行代码可以并行运行任意纯函数。因为纯函数根本不需要访问共享的内存，而且根据其定义，纯函数也不会因副作用而进入竞争态（race condition）。 柯里化 在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。另一种理解是：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 例子123456789101112131415function add(a, b) &#123; return a + b;&#125;// 执行 add 函数，一次传入两个参数即可add(1, 2) // 3// 函数curryvar add = function(a) &#123; return function(b) &#123; return a + b; &#125;&#125;// 每次传入一个参数add(1)(2) // 3 核心思想可以借助Lodash 中的 curry 方法帮我们实现函数柯里化，核心思想是————比较多次接受的参数总数与函数定义时的入参数量，当接受参数的数量大于或等于被 Currying 函数的传入参数数量时，就返回计算结果，否则返回一个继续接受参数的函数。1234567891011121314function trueCurrying(fn, ...args) &#123; if (args.length &gt;= fn.length) &#123; return fn(...args) &#125; return function (...args2) &#123; return trueCurrying(fn, ...args, ...args2) &#125;&#125; 用处curry的用处十分广泛，给函数传入一些参数后，可以得到一些新的函数。例如下面的getChildren函数，传给柯里化后的map函数，会返回一个接收参数类型为数组的新函数。123456789101112var curry = require(&apos;lodash&apos;).curry;var map = curry(function(f, ary) &#123; return ary.map(f);&#125;);var getChildren = function(x) &#123; return x.childNodes;&#125;;var allTheChildren = map(getChildren);// 返回所有div的子节点allTheChildren(document.getElementsByTagName(&apos;div&apos;)) 代码组合简介12345var compose = function(f,g) &#123; return function(x) &#123; return f(g(x)); &#125;;&#125;; f和g是两个函数，通过组合方式返回一个新的函数，x就是在两个管道之间传输的值。举个例子，如果希望给send in the clowns加上!，并且转成大写，可以使用函数组合的方法来实现这个功能。123456var toUpperCase = function(x) &#123; return x.toUpperCase(); &#125;;var exclaim = function(x) &#123; return x + '!'; &#125;;var shout = compose(exclaim, toUpperCase);shout(\"send in the clowns\");//=&gt; \"SEND IN THE CLOWNS!\" compose使用主要特点有： - 代码的运行顺序是从右向左，创建了一个从右向左的数据流，初始函数一定放到参数的`最右面`； - `compose`的参数是函数，返回的也是一个函数； - 除了第一个函数的接受参数，其他函数的接受参数都是上一个函数的返回值，所以初始函数的参数是多元的，而其他函数的接受值是一元的； 结合律组合的概念来源于数学课本，满足组合的特性——结合律123// 结合律（associativity）var associative = compose(f, compose(g, h)) == compose(compose(f, g), h);// true 结合律的一大好处是任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起。例如可以进行下面的重构：123456789101112var loudLastUpper = compose(exclaim, toUpperCase, head, reverse);// 或var last = compose(head, reverse);var loudLastUpper = compose(exclaim, toUpperCase, last);// 或var last = compose(head, reverse);var angry = compose(exclaim, toUpperCase);var loudLastUpper = compose(angry, last);// 更多变种... pointfree Pointfree style means never having to say your data.通过管道把数据在接受单个参数的函数间传递，不需要去声明中间的变量。12345678910// 非 pointfree，因为提到了数据：namevar initials = function (name) &#123; return name.split(' ').map(compose(toUpperCase, head)).join('. ');&#125;;// pointfreevar initials = compose(join('. '), map(compose(toUpperCase, head)), split(' '));initials(\"hunter stockton thompson\");// 'H. S. T' pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。 组合像一系列管道那样把不同的函数联系在一起，数据就可以也必须在其中流动——毕竟纯函数就是输入对输出，所以打破这个链条就是不尊重输出，就会让我们的应用一无是处。 PS: **Ramda 数据一律放在最后一个参数，理念是”function first，data last”; 库所有的函数都支持柯里化**，可以很好地实践FP。 REFS:使用JavaScript实现“真·函数式编程”Ramda 函数库参考教程","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://sherrywu0917.github.io/tags/函数式编程/"}]},{"title":"core-decorators源码简析——throttle","date":"2018-06-25T08:14:08.000Z","path":"2018/06/25/core-decorators源码简析——throttle/","text":"@throttle节流函数：函数节流能使得连续的函数执行，变为固定时间段间断地执行。 使用实例例如在监听窗口滚动事件时，稍微滚动一下，就会触发多次onscroll事件，去更新位置信息。如果onscroll事件是去进行dom操作，频繁地更新dom可能会导致低版本浏览器卡死。所以希望可以间隔一段时间，再去执行回调函数。应用throttle函数，设置wait时间为1000ms，可以保证回调函数至少每隔1000ms执行一次。1234567891011121314151617import &#123; throttle &#125; from 'core-decorators';class Scroller &#123; position = ''; @throttle(1000, &#123;leading: false&#125;) updatePosition() &#123; this.position = window.scrollY; &#125; bindEvent() &#123; window.onscroll = () =&gt; &#123; this.updatePosition() &#125;; &#125;&#125; 源码实现参数在调用的时候支持传入wait、options.leading、options.trailing三个参数： wait: 等待执行的时间，单位ms，默认值300 {leading}: 绑定的函数在节流开始前执行，默认值true，触发事件刚开始时执行回调 {trailing}: 绑定的函数在节流开始后执行，默认值true，触发事件结束时执行回调 具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function handleDescriptor(target, key, descriptor, [wait = DEFAULT_TIMEOUT, options = &#123;&#125;]) &#123; const callback = descriptor.value; if (typeof callback !== 'function') &#123; throw new SyntaxError('Only functions can be throttled'); &#125; if (options.leading !== false) &#123; options.leading = true &#125; if(options.trailing !== false) &#123; options.trailing = true &#125; return &#123; ...descriptor, value() &#123; // 同debounce，会返回this的Symbol('__core_decorators__')属性: 为Meta实例 const meta = metaFor(this); const &#123; throttleTimeoutIds, throttlePreviousTimestamps &#125; = meta; const timeout = throttleTimeoutIds[key]; // 上次函数执行时的时间戳 let previous = throttlePreviousTimestamps[key] || 0; const now = Date.now(); // options.trailing为true时，将待执行函数callback的参数赋值给meta.throttleTrailingArgs，保证在setTimeout回调函数中可以取到参数 if (options.trailing) &#123; meta.throttleTrailingArgs = arguments; &#125; // 第一次调用，并且leading参数为false时，将上次执行时间戳设为当前 // trailing为true时，leading为false，throttlePreviousTimestamps[key]始终被赋值为0 if (!previous &amp;&amp; options.leading === false) &#123; previous = now; &#125; // leading为false的时候，previous=now, remaining时间始终等于wait，始终不会在节流函数开始时执行回调函数 // leading为true的时候，第一次调用，previous为0，remaining为负值；再次调用，previous为上次回调执行时间，若距离上次执行时间已经等待了wait毫秒，则remaining&lt;=0 const remaining = wait - (now - previous); //&#123;leading: true&#125; remaining&lt;=0的时候，会在节流开始前执行callback函数 if (remaining &lt;= 0) &#123; clearTimeout(timeout); delete throttleTimeoutIds[key]; // 更新上次执行时间戳 throttlePreviousTimestamps[key] = now; // 执行回调函数 callback.apply(this, arguments); &#125; else if (!timeout &amp;&amp; options.trailing) &#123; // 当前没有timeout对象，并且trailing为true // &#123;trailing: true, leading: false&#125; 设置remaining = wait毫秒后去执行回调函数 // &#123;trailing: true, leading: true&#125; 第二次调用才会设置remaining=wait - (now - previous)毫秒后去执行回调函数 throttleTimeoutIds[key] = setTimeout(() =&gt; &#123; // 更新上次执行时间戳，leading为false，throttlePreviousTimestamps[key]始终被赋值为0 throttlePreviousTimestamps[key] = options.leading === false ? 0 : Date.now(); // 删掉timeout对象 delete throttleTimeoutIds[key]; // 执行回调函数 callback.apply(this, meta.throttleTrailingArgs); // 防止内存泄露 meta.throttleTrailingArgs = null; &#125;, remaining); &#125; &#125; &#125;;&#125; 结合了时间戳和定时器setTimeout两种方式来实现throttle函数: leading为true时，主要根据时间戳来记录上次执行时间，每次触发事件时，判断当前时间距离上次执行时间是否已经等待了wait毫秒，如果是，则立即执行 trailing为true时，主要通过setTimeout定时器来设定间隔某个时间段才去执行 leading为false，定时wait毫秒(从当前时间算起)后去执行 leading为true时，定时距离上次执行累计wait毫秒后去执行 每次执行都会记录下当前执行时间，用来控制时间间隔","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"core-decorators","slug":"core-decorators","permalink":"https://sherrywu0917.github.io/tags/core-decorators/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"decorators源码简析——debounce","slug":"decorators源码简析——debounce","permalink":"https://sherrywu0917.github.io/tags/decorators源码简析——debounce/"}]},{"title":"core-decorators源码简析——lazyInitialize","date":"2018-06-14T12:45:45.000Z","path":"2018/06/14/core-decorators源码简析——lazyInitialize/","text":"@lazyInitialize@lazyInitialize标记的作用是，只有在属性真正使用的时候才会去初始化。适用于一些在未来可能会被用到、也可能不会被用到的属性上。 使用实例下面是官网给出的例子，可以帮助我们理解该标记的作用。123456789101112131415161718192021import &#123; lazyInitialize &#125; from 'core-decorators';function createHugeBuffer() &#123; console.log('huge buffer created'); return new Array(1000000);&#125;class Editor &#123; @lazyInitialize hugeBuffer = createHugeBuffer();&#125;var editor = new Editor();// createHugeBuffer() has not been called yeteditor.hugeBuffer;// logs 'huge buffer created', now it has been callededitor.hugeBuffer;// already initialized and equals our buffer, so// createHugeBuffer() is not called again 源码123456789101112131415161718192021222324252627282930313233343536import &#123; decorate, createDefaultSetter &#125; from './private/utils';const &#123; defineProperty &#125; = Object;function handleDescriptor(target, key, descriptor) &#123; const &#123; configurable, enumerable, initializer, value &#125; = descriptor; return &#123; configurable, enumerable, get() &#123; // This happens if someone accesses the // property directly on the prototype if (this === target) &#123; return; &#125; const ret = initializer ? initializer.call(this) : value; defineProperty(this, key, &#123; configurable, enumerable, writable: true, value: ret &#125;); return ret; &#125;, set: createDefaultSetter(key) &#125;;&#125;export default function lazyInitialize(...args) &#123; return decorate(handleDescriptor, args);&#125; 在第一次调用editor.hugeBuffer时，真正的初始化发生在这两步：1234567const ret = initializer ? initializer.call(this) : value;defineProperty(this, key, &#123; configurable, enumerable, writable: true, value: ret&#125;); step1 其中initializer.call(this)中的this是调用该方法的对象，这儿是Editor的实例对象editor，通过call方法initializer方法的this指向editor。 initializer是一个返回createHugeBuffer()的函数，console.log(initializer)的输出如下所示:（什么情况下initializer不存在，取value值？）123ƒ initializer() &#123; return createHugeBuffer();&#125; step2 defineProperty重新赋值了key值对应的descriptor对象，将初始化后的值ret赋值给对应的value字段，应该是模拟了在类构造函数执行时，initializer返回的值作为属性的值，在类构造函数执行后，initializer属性被替换为value属性。 为什么需要defineProperty如果删除上面get方法的defineProperty，则editor.hugeBuffer每次都会调用get()方法，进而执行createHugeBuffer()方法，每次都会去重新初始化，所以在属性初始化完成后，需要对value赋值，替换掉initializer。123456//defineProperty(this, key, &#123;// configurable,// enumerable,// writable: true,// value: ret//&#125;);","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"core-decorators","slug":"core-decorators","permalink":"https://sherrywu0917.github.io/tags/core-decorators/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"lazyInitialize","slug":"lazyInitialize","permalink":"https://sherrywu0917.github.io/tags/lazyInitialize/"}]},{"title":"core-decorators源码简析——debounce","date":"2018-06-13T12:37:05.000Z","path":"2018/06/13/core-decorators源码简析——debounce/","text":"@debounce防抖动函数：当调用函数n秒后，才会执行该动作，若在这n秒内又调用该函数则将取消前一次并重新计算执行时间。 使用实例1234567891011121314151617import &#123; debounce &#125; from 'core-decorators';class Editor &#123; content = ''; @debounce(500) updateContent(content) &#123; this.content = content; &#125; bindEvent() &#123; document.getElementById('editor').oninput = e =&gt; &#123; this.updateContent(e.target.value) &#125; &#125;&#125; 1&lt;textarea id=\"editor\"&gt;&lt;/textarea&gt; 例如在监听id为editor的编辑器输入时，每次输入都会触发oninput事件，调用this.updateContent方法。为了防止频繁地更新content，可以对updateContent装饰debounce方法，在输入的过程中不会去更新this.content，直到输入完成500毫秒后，再去一次性更新content内容。 源码12345678910111213141516171819202122232425262728293031323334353637import &#123; metaFor &#125; from './private/utils';const DEFAULT_TIMEOUT = 300;function handleDescriptor(target, key, descriptor, [wait = DEFAULT_TIMEOUT, immediate = false]) &#123; const callback = descriptor.value; if (typeof callback !== 'function') &#123; throw new SyntaxError('Only functions can be debounced'); &#125; return &#123; ...descriptor, value() &#123; //返回this的Symbol('__core_decorators__')属性: 为Meta实例 const &#123; debounceTimeoutIds &#125; = metaFor(this); //已有的防抖函数调用 const timeout = debounceTimeoutIds[key]; //immediate为true且当前无timeout对象，多次调用的时候只在第一次调用时才去执行 const callNow = immediate &amp;&amp; !timeout; const args = arguments; clearTimeout(timeout); // 每次都覆盖之前的防抖函数，执行最后一次传入的callback函数 debounceTimeoutIds[key] = setTimeout(() =&gt; &#123; delete debounceTimeoutIds[key]; if (!immediate) &#123; callback.apply(this, args); &#125; &#125;, wait); if (callNow) &#123; //先执行再等待 callback.apply(this, args); &#125; &#125; &#125;;&#125; 调用参数在调用的时候支持传入wait和options.immediate两个参数： wait: 等待执行的时间，单位ms，默认值300 {immediate}: 绑定的函数是否先执行，默认值false，等待wait时间后再执行；传递的参数为true时先执行 Meta对象123const &#123; debounceTimeoutIds &#125; = metaFor(this);//这个时候只有debounceTimeoutIds被初始化了哦，因为用了lazyInitializeconsole.log(metaFor(this)) metaFor方法给当前实例增加了Symbol(&#39;__core_decorators__&#39;)属性，值为一个Meta对象。Meta类如下所示，包括debounce和throttle用到的一些属性：12345678910111213141516class Meta &#123; @lazyInitialize debounceTimeoutIds = &#123;&#125;; @lazyInitialize throttleTimeoutIds = &#123;&#125;; @lazyInitialize throttlePreviousTimestamps = &#123;&#125;; @lazyInitialize throttleTrailingArgs = null; @lazyInitialize profileLastRan = null;&#125; 使用了@lazyInitialize标记，可以使得每次只初始化被用到的属性，像debounce的时候只用到debounceTimeoutIds属性。console输出Meta对象，结构如图所示，可以看到只初始化了debounceTimeoutIds属性： debounceTimeout存储 当调用被@debounce标记的方法时：1 . setTimeout会延迟执行该函数，返回一个timeout对象；2 . 返回的timeout对象会被存储在debounceTimeoutIds[key]中（以updateContent方法为例，debounceTimeoutIds[key]这里的key值就是updateContent）；3 . 重复调用该方法会重新创建timeout对象，并覆盖之前的debounceTimeoutIds[key]（这里每次调用updateContent都会重新给debounceTimeoutIds[&#39;updateContent&#39;]赋值）； 123456setTimeout(() =&gt; &#123; delete debounceTimeoutIds[key]; if (!immediate) &#123; callback.apply(this, args); &#125; &#125;, wait); 执行的结果就是：每次都重新等待wait时间，再去执行callback方法，callback即是key值对应的方法。","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"core-decorators","slug":"core-decorators","permalink":"https://sherrywu0917.github.io/tags/core-decorators/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"decorators源码简析——debounce","slug":"decorators源码简析——debounce","permalink":"https://sherrywu0917.github.io/tags/decorators源码简析——debounce/"}]},{"title":"cmd小工具开发","date":"2018-05-31T02:02:52.000Z","path":"2018/05/31/cmd小工具开发/","text":"cmd项目初始化首先新建一个文件夹，并且初始化package.json，同时在bin文件夹下面创建入口文件index.js。1npm init #初始化'package.json'文件 index.js文件头部有#!/usr/bin/env node，叫做shebang)，指定脚本解释程序为node。package.json文件中bin字段配置了cmd命令将执行的js文件，如下所示：1234567891011121314&#123; \"name\": \"mkfile-cli\", \"version\": \"1.0.7\", \"main\": \"index.js\", \"bin\": &#123; \"mk\": \"bin/index.js\" &#125;, \"repository\": &#123; \"type\" : \"git\", \"url\" : \"https://xxx\" &#125;, \"author\": \"sherrywu\", \"license\": \"ISC\",&#125; 运行 可以运行node bin/index.js命令 通过npm link的方式 还可以通过npm install . -g安装到全局 cmd命令行工具开发commander.jsCommander是一个轻量级、强大的命令行开发框架，提供了封装好的API，帮助用户快速开发命令行工具。 安装：1npm install commander --save optionoption()方法的定义 option(flags, description, fn, defaultValue) flags : 自定义参数，格式为”-shortFlag, –longFlag null|&lt;value&gt;|[value]|&lt;value&gt;..&lt;value&gt;“ -shortFlag：”-“后面跟的是自定义参数的短标志，一般用longFlag的第一个字母(区分大小写) –longFlag ：”–”后面跟的是自定义参数的长标志，shortFlag和longFlag必须同时存在， null|&lt;value&gt;|[value]：有3种情况 null——可以不带参数 &lt;value&gt;——“&lt;&gt;”修饰，参数必须。 [value]——”[]“修饰, 参数可选。 description : 对flags参数的描述 fn &lt;Function|Mixed&gt; : 自定义处理参数的方法，如果传入的不是一个方法，会先判断是否为一个正则表达式，如果不是，则视为defaultValue（默认值）， defaultValue ：自定义参数默认值 返回值 ：commander对象 1234567program .version('1.0.1') .option('-n, --new &lt;filename&gt;', '创建文件') .parse(process.argv);if(program.new || program.n) &#123; console.log('文件名：' + (program.new || program.n))&#125; 通过mk -h可以查看帮助文档，-h 和 -V都是commander封装好的命令:123456789$ mk -h Usage: index [options] Options: -V, --version output the version number -n, --new &lt;filename&gt; 创建文件 -h, --help output usage information on事件监听此外还可以自定义help文档，通过监听–help触发定义的回调方法。12345678program.on('--help', function () &#123; console.log(' 自定义的例子:') console.log('') console.log(' 输出命令 mk -n test -k activityList') console.log(' 输出命令 mk --new test') console.log('')&#125;).parse(process.argv); program.parse 会解析命令行参数以及触发回调方法，因为nodejs的emit会立刻触发事件，所以将该方法放在命令及事件监听的最后面。 参数运行mk -n test -k activityList命令，可以通过program.n和program.k分别获得文件名’test’和模板key值’activityList’。 主要流程运行mk -n test -k activityList，读取mk.json文件中定义的模板,根据key值读取此次创建文件的模板来源： dir: 创建文件的目标位置 suffix: 文件后缀 tpl: 文件模板，模板内容可以自定义，使用的模板语法是nunjucks。123456789&#123; \"fileList\" : [ &#123;\"dir\": \"test/js\", \"suffix\": \"js\", \"tpl\": \"tpl/js.tpl\"&#125;, &#123;\"dir\": \"test/css\", \"suffix\": \"css\", \"tpl\": \"tpl/css.tpl\"&#125; ], \"activityList\" : [ &#123;\"dir\": \"activity/js\", \"suffix\": \"js\", \"tpl\": \"tpl/js.tpl\"&#125; ]&#125; npm包开发首先要npm adduser来注册个npm账号，如果已经有账号，可以使用npm login来登录。通过npm version &lt;update_type&gt;对版本进行管理，更新了版本号后发布：1npm publish 最终发布的npm包见mkfile-cli","tags":[]},{"title":"core-decorators源码简析——readonly","date":"2018-04-17T07:40:08.000Z","path":"2018/04/17/core-decorators源码简析——readonly/","text":"直接看源码，readonly.js代码非常简短，核心函数是handleDescriptor，通过修改描述对象descriptor的writable属性为false，将目标属性置为不可修改。12345678910import &#123; decorate &#125; from './private/utils';function handleDescriptor(target, key, descriptor) &#123; descriptor.writable = false; return descriptor;&#125;export default function readonly(...args) &#123; return decorate(handleDescriptor, args);&#125; 其中decorate函数定义在utils文件中，具体如下: 123456789101112131415161718192021222324252627export function isDescriptor(desc) &#123; if (!desc || !desc.hasOwnProperty) &#123; return false; &#125; const keys = ['value', 'initializer', 'get', 'set']; for (let i = 0, l = keys.length; i &lt; l; i++) &#123; if (desc.hasOwnProperty(keys[i])) &#123; return true; &#125; &#125; return false;&#125;export function decorate(handleDescriptor, entryArgs) &#123; if (isDescriptor(entryArgs[entryArgs.length - 1])) &#123; console.log(entryArgs); console.log(entryArgs[entryArgs.length - 1].initializer); return handleDescriptor(...entryArgs, []); &#125; else &#123; return function () &#123; return handleDescriptor(...Array.prototype.slice.call(arguments), entryArgs); &#125;; &#125;&#125; 首先判断传过来的最后一个参数是否是descriptor对象，若该参数有[&#39;value&#39;, &#39;initializer&#39;, &#39;get&#39;, &#39;set&#39;]属性中的任一个，则认为是descriptor对象，直接调用handleDescriptor去处理。若所传最后一个参数不是descriptor对象，则返回一个匿名函数，可以接收额外的参数。 descriptor对象基本内容如下： configurable控制是否能删、修改descriptor本身。 writable控制是否能修改值value。 enumerable控制是否能枚举出属性。 value是该属性对应的值，可以是任何有效的JavaScript值（数值，对象，函数等）。 get和set控制访问属性的读和写逻辑。 其中，前三个属性是一定存在的，value和get/set属性不会并存。当装饰器作用于类属性时，descriptor将变成一个叫“类属性描述符”的东西，其区别在于没有value和get或set，且多出一个initializer属性，类型是函数，在类构造函数执行时，initializer返回的值作为属性的值，在类构造函数执行后，initializer属性被替换为value属性。 使用123456789class Meal &#123; @readonly // 或者@readonly() entree = 'steak';&#125;var dinner = new Meal();console.log('--------对象创建后----------')console.log(Object.getOwnPropertyDescriptors(dinner));dinner.entree = 'salmon'; 输出的descriptor前后对比：其中initializer函数内部即为return &#39;steak&#39;。同时会报错Uncaught TypeError: Cannot assign to read only property ‘entree’ of object ‘#‘，提示该属性只读。","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"core-decorators","slug":"core-decorators","permalink":"https://sherrywu0917.github.io/tags/core-decorators/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"readonly","slug":"readonly","permalink":"https://sherrywu0917.github.io/tags/readonly/"}]},{"title":"core-decorators源码简析——autobind","date":"2018-04-12T12:22:06.000Z","path":"2018/04/12/core-decorators源码简析——autobind/","text":"入口函数先看入口函数，通过export default暴露的autobind函数，通过...args形式的rest参数获取函数的多余参数，这儿是所有参数。通过decorator形式有两种调用方式： @autobind()，会返回一个匿名函数function (...argsClass) {return handle(argsClass);}，argsClass为最终decorator传入的参数，函数内部返回了handle函数；在修饰器外面再封装一层函数的方式，可以用于接收额外的参数； @autobind，args即为decorator传入的参数，直接调用handle函数 12345678910111213141516/** * 两种调用方式 * * 2. @autobind * @param &#123;...[type]&#125; args [description] * @return &#123;[type]&#125; [description] */export default function autobind(...args) &#123; if (args.length === 0) &#123; return function (...argsClass) &#123; return handle(argsClass); &#125;; &#125; else &#123; return handle(args); &#125;&#125; handle函数handle函数根据参数的长度去判断修饰类型，当args参数长度为1时，是对类的修饰，该参数即所要修饰的目标类；当长度为3时，是对方法的修饰，参数和Object.defineProperty的参数相对应target, name, descriptor:{value, configurable, enumerable, writable}。1234567function handle(args) &#123; if (args.length === 1) &#123; return autobindClass(...args); &#125; else &#123; return autobindMethod(...args); &#125;&#125; 对类的修饰 Object.getOwnPropertyDescriptors会以键值对的形式返回某对象属性的描述对象descriptor； getOwnKeys方法会返回一个数组，包含目标类原型对象上所有的属性的键名，包括不可枚举属性以及Symbol属性autobindClass遍历目标类原型上的所有方法，若某个属性对应的value类型是function并且属性不是constructor，则用Object.defineProperty对该属性进行重新赋值，调用autobindMethod实现对该方法的autobind； 1234567891011121314function autobindClass(klass) &#123; const descs = getOwnPropertyDescriptors(klass.prototype); const keys = getOwnKeys(descs); for (let i = 0, l = keys.length; i &lt; l; i++) &#123; const key = keys[i]; const desc = descs[key]; if (typeof desc.value !== 'function' || key === 'constructor') &#123; continue; &#125; defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc)); &#125;&#125; getOwnKeys方法的实现如下所示：123456export const getOwnKeys = getOwnPropertySymbols ? function (object) &#123; return getOwnPropertyNames(object) .concat(getOwnPropertySymbols(object)); &#125; : getOwnPropertyNames; 其中getOwnPropertySymbols会返回包含对象所有Symbol属性的数组，getOwnPropertyNames会返回包含自身所有属性（不包括Symbol属性，但包括不可枚举属性）的数组。此外，Object.assign拷贝只会拷贝属性的值，并不会拷贝它的赋值方法set和取值方法get，结合Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))可以实现对象属性取值、赋值方法的拷贝。 对方法的修饰autobindMethod第一个参数是类的原型对象，第二个参数是要修饰的属性名，第三个参数是该属性的描述对象，它通过修改描述对象的get赋值方法，实现了对方法的自动绑定，返回修改后的descriptor。赋值方法内不同条件分别对应的调用场景为： this === target: 调用方式let method = Child.prototype.childMethod，this就是Child.prototype，不绑定直接return。 this.constructor !== constructor &amp;&amp; getPrototypeOf(this).constructor === constructor: 调用方式let method = Child.prototype.parentMethod，子类没有该方法，this.constructor是Child.prototype.constructor，constructor是Parent.prototype.constructor，二者不等，但是this.__proto__.constructor和Parent.prototype.constructor是相同的(在es6的继承中Child.prototype.__proto__ === Parent.prototype)，不绑定直接return。 this.constructor !== constructor &amp;&amp; key in this.constructor.prototype: 子类调用父类的方法，仍然绑定为子类的this；如果不做该判断，直接到下一步bind(fn, this);则父类的方法会覆盖子类，下次调用就只执行父类中的方法了。 其他：调用bind(fn, this)绑定上下文。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function autobindMethod(target, key, &#123; value: fn, configurable, enumerable &#125;) &#123; if (typeof fn !== 'function') &#123; throw new SyntaxError(`@autobind can only be used on functions, not: $&#123;fn&#125;`); &#125; const &#123; constructor &#125; = target; return &#123; configurable, enumerable, get() &#123; // Class.prototype.key lookup // Someone accesses the property directly on the prototype on which it is // actually defined on, i.e. Class.prototype.hasOwnProperty(key) if (this === target) &#123; return fn; &#125; console.log(target, key) // Class.prototype.key lookup // Someone accesses the property directly on a prototype but it was found // up the chain, not defined directly on it // i.e. Class.prototype.hasOwnProperty(key) == false &amp;&amp; key in Class.prototype // Object.getPrototypeOf作用： // 1. 用于获取一个实例对象的原型对象 // 2. Object.getPrototypeOf(ColorPoint) === Point 用来判断一个类是否继承了另一个类 if (this.constructor !== constructor &amp;&amp; getPrototypeOf(this).constructor === constructor) &#123; return fn; &#125; // Autobound method calling super.sameMethod() which is also autobound and so on. // this.constructor: Child constructor: Parent if (this.constructor !== constructor &amp;&amp; key in this.constructor.prototype) &#123; return getBoundSuper(this, fn); &#125; const boundFn = bind(fn, this); defineProperty(this, key, &#123; configurable: true, writable: true, // NOT enumerable when it's a bound method enumerable: false, value: boundFn &#125;); return boundFn; &#125;, set: createDefaultSetter(key) &#125;;&#125; 实际调用时的例子：12345678910111213141516171819202122232425262728293031323334353637383940@autobindclass Person &#123; constructor() &#123; &#125; getPerson() &#123; console.log('parent called, AWESOME METHOD'); return this; &#125;&#125;@autobindclass Man extends Person &#123; constructor() &#123; super(); &#125; getMan() &#123; return this; &#125;&#125;//四种方法分别对应上面列出的四种场景console.log('---Man.prototype.getMan---');let getProtoMan = Man.prototype.getMan;console.log(getProtoMan());console.log('---Man.prototype.getPerson---');let getProtoPerson = Man.prototype.getPerson;console.log(getProtoPerson());console.log('---man.getPerson---');let man = new Man();let getPerson = man.getPerson;console.log(getPerson() === man);console.log('---man.getMan---');let man2 = new Man();let getMan = man2.getMan;console.log(getMan() === man2); 输出结果如下图所示： getBoundSuper函数作用给子类Man添加一个方法getPerson，方法内通过super调用父类的getPerson方法，super.getPerson对应上述场景3；如果不调用getBoundSuper函数，子类的getPerson方法在执行super.getPerson时会被父类覆盖，会导致下面方法只有第一次会输出’parent called, AWESOME METHOD’和’child called, AWESOME CHILD METHOD’，其他四次则只输出’parent called, AWESOME METHOD’。12345678910111213141516171819202122@autobindclass Man extends Person &#123; constructor() &#123; super(); &#125; getPerson() &#123; console.log('child called, AWESOME CHILD METHOD'); super.getPerson(); return this; &#125; getMan() &#123; return this; &#125;&#125;for (var i = 0; i &lt; 5; ++i) &#123; console.log('invoking'); man.getPerson(); console.log('---');&#125; WeakMap的特性： 只能用对象obj作为key值 WeakMap的键名对应的对象不计入垃圾回收机制，如果对应的对象被清除，垃圾回收机制就会释放该对象所占用的内存，即WeakMap中的对应的键名对象和键值也会自动消失，不用手动删除适用场景：WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 通过getBoundSuper可以将父类方法绑定到子类this上，并且使用WeakMap存储已经绑定的方法，在mapStore中key值对应子类实例，不同的子类实例对应不同的WeakMap，若该子类被删除，对应的WeakMap对象也会被清除。123456789101112131415161718let mapStore;function getBoundSuper(obj, fn) &#123; if (!mapStore) &#123; mapStore = new WeakMap(); &#125; if (mapStore.has(obj) === false) &#123; mapStore.set(obj, new WeakMap()); &#125; const superStore = mapStore.get(obj); if (superStore.has(fn) === false) &#123; superStore.set(fn, bind(fn, obj)); &#125; return superStore.get(fn);&#125;","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"core-decorators","slug":"core-decorators","permalink":"https://sherrywu0917.github.io/tags/core-decorators/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"autobind","slug":"autobind","permalink":"https://sherrywu0917.github.io/tags/autobind/"}]},{"title":"继承&原型链","date":"2018-04-10T09:14:43.000Z","path":"2018/04/10/继承-原型链/","text":"基于proto和prototype的原型链关于__proto__属性，MDN上的解释如下： The proto property of Object.prototype is an accessor property (a getter function and a setter function) that exposes the internal [[Prototype]] (either an object or null) of the object through which it is accessed. 即是说，__proto__ 属性指向了实例对象的原型Constructor.prototype。 首先用一张图来总结__proto__和prototype的关系： 实例的__proto__123function Foo() &#123;&#125;var f1 = new Foo();f1.__proto__ == Foo.prototype; //true 通过new方法创建函数Foo的实例f1，f1.__proto__会指向Foo.prototype，进而继承Foo函数原型上的所有属性和方法。在JS中，只有函数有prototype属性，基于prototype可以去模拟实现类和继承。 函数原型和构造器123f1.constructor === Foo.prototype.constructor; //trueFoo.prototype.constructor === Foo; //truef1.constructor === Foo; //true f1是Foo的示例，它的constructor就是Foo函数原型对象中的constructor，而Foo函数原型上的constructor就指向函数本身。 对象的__proto__12345var one = &#123;x: 1&#125;;var two = new Object();one.__proto__ === Object.prototype // truetwo.__proto__ === Object.prototype // trueone.toString === one.__proto__.toString // true 不管是隐式还是显式创建的对象，对象的__proto__都是Object.prototype，Object实际上是一个js函数function Object(){}，所以拥有prototype属性。two = new Object()中Object是构造函数，所以two.__proto__就是Object.prototype。至于one，ES规范定义对象字面量的原型就是Object.prototype。123one.constructor === Object.prototype.constructor;Object.prototype.constructor === Object;one.constructor === Object; 函数的__proto__12Foo.constructor === Function; //trueFoo.__proto__ === Function.prototype; // true 函数Foo的构造函数是function Function(){}，所以函数Foo的__proto__都指向Function.prototype。1234Function.__proto__ === Function.prototype; // trueArray.__proto__ === Function.prototype; // trueObject.__proto__ === Function.prototype; // trueString.__proto__ === Function.prototype; // true 而Function本身就是函数，所以Function.__proto__就是Function.prototype，二者为同一对象。同理，Object/Array/String等等构造函数本质上和Function一样，均继承于Function.prototype。 Function.prototype的__proto__Function.prototype直接继承自Object.prototype，Function.prototype.__proto__就是Object.prototype，二者为同一对象。123Function.prototype.__proto__ === Object.prototype; //trueFunction.prototype instanceof Object; //trueFunction.prototype instanceof Function; //false 通过这点我们可以弄清继承的原型链：Object.prototype—&gt;Function.prototype—&gt;Function|Object|Array…。。综上所述可以得出：1Function.__proto__.__proto__ === Object.prototype; 所以Function是Object的实例1Function instanceof Object; //true 此外Object作为函数，继承了Function.prototype的方法，所以Object又是Function的实例。12Object.__proto__ === Function.prototype;Object instanceof Function; //true 哈哈，二者互为实例，这就是有名的鸡生蛋和蛋生鸡的关系。 Object.prototype的__proto__原型链的尽头（root）是Object.prototype。所有对象均从Object.prototype继承属性。1Object.prototype.__proto__ === null; //true REFS: 从__proto__和prototype来深入理解JS对象和原型链Javascript Object Layout es6继承class通过extends实现继承，比起es5基于原型链、借用构造函数实现继承方便很多。1234567891011121314151617class A &#123; constructor() &#123; this.x = 1; &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 &#125;&#125;let b = new B(); 上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。这是由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 set的时候，super为this子类实例 get的时候，super获取的是A.prototype 大多数浏览器的 ES5 实现之中，每一个对象都有proto属性，指向对应的构造函数的prototype属性。12function test()&#123;&#125;test.__proto__ = test.constructor.prototype es6中extends实现的继承，同时有prototype属性和proto属性，因此同时存在两条继承链。1234B.__proto__ === AB.prototype.__proto__ === A.prototype//对应es5实现B.prototype = new A() 实现继承的关键： 子类B.prototype的__proto__属性指向A.prototype，即B.prototype.__proto__ = A.prototype，表示将继承父类原型上的属性和方法; 子类B的__proto__属性总是指向父类A，即B.__proto__ = A，表示将继承父类的静态属性和方法。 这样的结果是因为，类的继承是按照下面的模式实现的。1234567891011class A &#123;&#125;class B &#123;&#125;// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B(); Object.setPrototypeOf方法的实现，会将proto对象作为obj的原型。1234Object.setPrototypeOf = function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; 本质上，class关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。","tags":[{"name":"继承","slug":"继承","permalink":"https://sherrywu0917.github.io/tags/继承/"},{"name":"原型链","slug":"原型链","permalink":"https://sherrywu0917.github.io/tags/原型链/"}]},{"title":"npm转盘组件开发","date":"2018-02-09T06:39:53.000Z","path":"2018/02/09/npm转盘组件开发/","text":"准备工作在开始开发之前，首先要准备好node环境和npm账户，nodeJS基本都有安装好，要做的就是注册npm：1234$ npm adduserUsername: your namePassword: your passwordEmail: (this IS public) your email 查询当前账号或者登陆别的用户：12$ npm whoami$ npm login 包管理工具lerna项目组采用了lerna包管理工具，可以在一个仓库下管理多个npm包，基于monorepo理念。 Monorepo is a unified source code repository used by an organisation to host as much of its code as possible.Monorepo 它是一种管理 organisation 代码的方式，在这种方式下会摒弃原先一个 module 一个 repo 的方式，取而代之的是把所有的 modules 都放在一个 repo 内来管理。 lerna安装和初始化12npm install lerna -glerna init 初始化后，目录里面会自动生成/packages、lerna.json和package.json。执行lerna bootstrap会自动为项目进行npm install和npm link操作，npm的作用是边开发边试用，具体使用参考npm link。执行lerna publish可以发布版本。lerna有两种模式的管理方式，项目仓库选用默认的Fixed/Locked模式，在lerna.json里的version字段是本仓库版本，packages下的包的版本等于或者小于本仓库的版本有两种情况： 如果某个包的版本更新了，原版本是1.0.2，本仓库版本是1.0.9，则这个包的更新后的版本是1.0.10，而不是1.0.3 如果有个包引入了重大改动（BREAKING CHANGE）, 则所有的包的major version都会改变其中commit message的编写遵循Conventional Commits ，主要包括fix/feat/BREAKING CHANGE三种类型，以及对文档的修改docs:，或者其他style:, refactor:, perf:, test:, chore:。 组件开发定义组件配置项和方法组件对外暴露的类是PrizeWheel，该class的构造函数支持传入rotateSelector(将要旋转的元素对应的选择器)和config(转盘相关配置)两个参数，config中支持对奖项、旋转元素类型、转速等的配置。此外，该class提供了旋转到指定位置和终止旋转两个方法。初始化时，_countPrizeAngleMap方法会计算出每个奖项的目标角度。1234567891011121314151617_countPrizeAngleMap() &#123; const &#123;prizeQueue, rotator, inSector&#125; = this.config; let len = prizeQueue.length; prizeQueue.forEach( (level, index) =&gt; &#123; let diff = 0, targetAngle = 0; if(inSector) &#123; diff = - 360/len/2; &#125; if(rotator == 'pointer') &#123; //指针旋转 targetAngle = 360/len * (index + 0.5) + diff; &#125; else &#123; //转盘旋转 targetAngle = 360 - (360/len * (index + 0.5) + diff); &#125; this.prizeAngleMap.set(level, targetAngle); &#125;)&#125; prizeQueue是一个数组，对应转盘上的奖项队列，按照顺时针方向。rotator是旋转类型：’pointer’(Default) - 指针旋转、’wheel’ - 转盘旋转。inSector代表初始位置是否在扇区内：false(Default)、true，false代表与扇区的边缘线重合，true代表在扇区的正中位置。旋转的情况有四种(N从0开始计数)： 旋转的是指针，inSector为false：指针在边缘线，则第N个奖项的目标角度 = 每个扇区的角度 * (N + 0.5)； 旋转的是指针，inSector为true：指针在扇区中央，旋转的角度相对上一种少了半个扇区，则第N个奖项的目标角度 = 每个扇区的角度 (N + 0.5) - 每个扇区的角度 0.5； 旋转的是扇区，inSector为false(或true)：目标角度都是 = 360 - (指针旋转情况下的角度) 具体的转盘效果封装在了WheelEffect类中，该类的关键点是提供了一个缓动函数(参考的网上代码)：1function easing(t, b, c, d) &#123; return -c * ((t=t/d-1)*t*t*t - 1) + b; &#125; 其中参数含义： t: 当前动画已经持续的时间 b: 开始的角度 c: 一共要旋转的角度和 d: 动画要持续的时间间隔特定的时间去旋转该方法返回的角度，实现动效。 组件发布期望通过import PrizeWheel from &#39;nw-prize-wheel&#39;的方式引入组件，所以在prize-wheel.js中是这样export的：12export default class PrizeWheel &#123;&#125; 但在打包成js文件时，通过script标签嵌入，发现直接new PrizeWheel()报错，提示undefined，在网上找了一圈，发现需要另外新建一个index.js，在index.js中:1module.exports = require('./src/prize-wheel.js').default; webpack配置添加library和libraryTarget。123456output: &#123; path: __dirname + '/lib', filename: '[name].js', library: 'PrizeWheel', libraryTarget: 'this'&#125; 期望webpack提供诸如libraryTarget: &#39;default&#39;这样的配置来解决问题，但目前不支持，只能用上述方法来曲线救国。 组件API文档化1jsdoc2md --template readme.hbs --files src/prize-wheel.js &gt; readme.md 结合了jsdoc和jsdoc2md可以将自定义的模板和js注释生成一个API文档，具体的使用方式详见官网。 最终实现的组件详情nw-prize-wheel","tags":[{"name":"npm包","slug":"npm包","permalink":"https://sherrywu0917.github.io/tags/npm包/"},{"name":"组件开发","slug":"组件开发","permalink":"https://sherrywu0917.github.io/tags/组件开发/"}]},{"title":"IOS微信内二维码无法识别问题","date":"2018-02-06T03:41:42.000Z","path":"2018/02/06/IOS微信内二维码无法识别问题/","text":"","tags":[]},{"title":"decorator","date":"2018-01-16T14:02:37.000Z","path":"2018/01/16/decorator/","text":"REFS:http://taobaofed.org/blog/2015/11/16/es7-decorator/http://es6.ruanyifeng.com/#docs/decoratorhttp://raganwald.com/2015/06/26/decorators-in-es7.html","tags":[{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"},{"name":"decorator","slug":"decorator","permalink":"https://sherrywu0917.github.io/tags/decorator/"},{"name":"es7","slug":"es7","permalink":"https://sherrywu0917.github.io/tags/es7/"}]},{"title":"react高阶组件","date":"2017-10-30T09:39:56.000Z","path":"2017/10/30/react高阶组件/","text":"什么是高阶组件？官方文档指出，高阶组件（Higher-Order Components，简称HOC）是react中对组件逻辑进行重用的高级技术。但高阶组件本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。具体而言，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。先看一个典型的高阶组件：1234567891011121314151617// It's a function...function myHOC() &#123; // Which returns a function that takes a component... return function(WrappedComponent) &#123; // It creates a new wrapper component... class TheHOC extends React.Component &#123; render() &#123; // And it renders the component it was given return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; // Remember: it takes a component and returns a new component // Gotta return it here. return TheHOC; &#125;&#125; 使用高阶组件优化代码需求是要在网站的每个页面要添加签到请求和签到成功弹窗，显然，一般人都不会想着要在每个页面写一遍。首先，我想到的是引入一个React组件，但是要在每个页面的render方法里面添加该组件，需要改动所有页面对应组件的render方法，感觉比较繁琐且易出错。也可以通过js方法去动态创建签到成功弹窗，然后在每个页面里面引入该方法，不过同样需要改变组件内部方法，且不符合React项目风格。最后，发现高阶组件可以满足我的需求，既实现了功能又不污染原有组件。下面是简化版的签到高阶组件：1234567891011121314151617181920212223242526export const signHoc = ComposedComponent =&gt; class extends Component &#123; constructor(props) &#123; super(props) this.state = &#123;show: false, config: &#123;&#125;&#125; &#125; componentDidMount() &#123; if(!this.props.showSign) return; this.setState(&#123; show: true, config: &#123; title: '今日首次登录', content: `获赠&lt;em&gt;50&lt;/em&gt;阅点红包` &#125; &#125;) &#125; render() &#123; const &#123;show, config&#125; = this.state; const &#123;showSign, ...passThroughProps&#125; = this.props; return (&lt;div&gt; &lt;ComposedComponent &#123;...passThroughProps&#125; /&gt; &#123;show &amp;&amp; (&lt;MessageModal config=&#123;config&#125;/&gt;)&#125; &lt;/div&gt;); &#125;&#125;; 可以通过this.props获得传给WrappedComponent的props，在操作props的时候要确保不会破坏要传给WrappedComponent的props。在componentDidMount可以发起签到请求，此外可以根据props.showSign和签到结果决定是否显示签到组件等。当页面有其他弹窗的优先级大于签到弹窗时，props.showSign设为false，就可以控制签到弹窗是否显示。123456export default class WrappedComponent extends Component &#123; render() &#123; return false &#125;&#125;signHoc(WrappedComponent) 调用signHoc函数获得组合后的组件，也可以结合@decorator简化调用。123456@signHocexport default class WrappedComponent extends Component &#123; render() &#123; return false &#125;&#125; 结合Context API使用React 16.3引入了全新的Context API，主要提供的API有：React.createContext, Provider和Consumer，详见context。这儿记录下如何结合高阶组件和Context API去实现全局变量的设置，如主题theme。step1: 定义高阶组件，通过ThemeContext.Consumer获取变量并且传递给组件ComposedComponent。1234567891011export const ThemeContext = React.createContext(&#123; theme: localStorage.getItem('N_reader_theme') || 'light', changeTheme: () =&gt; &#123;&#125;&#125;);export const themeHoc = ComposedComponent =&gt; &#123; props =&gt; &#123; &lt;ThemeContext.Consumer&gt; &#123;(&#123;theme, changeTheme&#125;) =&gt; &lt;ComposedComponent &#123;...props&#125; theme=&#123;theme&#125; changeTheme=&#123;changeTheme&#125;/&gt;&#125; &lt;/ThemeContext.Consumer&gt; &#125;&#125; step2: 使用ThemeContext.Provider传递当前theme、changeTheme给整个子树，任何子组件都可以读到这些变量的值，不需要显式的通过props传递。12345678910111213141516171819import &#123;ThemeContext&#125; from 'themeHoc.js'export default class App extends Component &#123; changeTheme(theme) &#123; localStorage.setItem('N_reader_theme', theme); document.querySelector('body').className = document.querySelector('body').className.replace(/theme--\\w*/, 'theme--' + theme); this.setState(&#123; theme: theme &#125;) &#125; render() &#123; return ( &lt;ThemeContext.provider value=&#123;&#123;theme: this.state.theme, changeTheme: this.changeTheme&#125;&#125;&gt; &lt;Content /&gt; &lt;/ThemeContext.provider&gt; ) &#125;&#125; step3: 通过decorator的方式添加@themeHoc标记，Content组件可以直接从props中读取theme和changeTheme函数。12345678910111213import &#123;themeHoc&#125; from 'themeHoc.js'@themeHocexport default class Content extends Component &#123; render() &#123; return ( &lt;div theme=&#123;props.theme&#125;&gt; &lt;a href=\"javascript:;\" className=&#123;props.theme&#125; onClick=&#123;props.changeTheme.bind(this, 'blue')&#125;&gt;blue&lt;/a&gt; &lt;a href=\"javascript:;\" className=&#123;props.theme&#125; onClick=&#123;props.changeTheme.bind(this, 'yellow')&#125;&gt;yellow&lt;/a&gt; &lt;/div&gt; ) &#125;&#125; 公约最大化使用组合高阶组件可以接受一个或多个参数：123456//仅接收包裹组件一个参数const NavbarWithRouter = withRouter(Navbar);//接收包裹组件和额外的参数const CommentWithRelay = Relay.createContainer(Comment, config);//connect(commentListSelector, commentListActions)返回了一个高阶组件，最后作用于Comment组件const ConnectedComment = connect(commentSelector, commentActions)(Comment); 包装显示名字以便于调试高价组件创建的容器组件在React Developer Tools中的表现和其它的普通组件是一样的。为了便于调试，可以选择一个好的名字，确保能够识别出它是由高阶组件创建的新组件还是普通的组件。最常用的技术就是将包裹组件的名字包装在显示名字中。所以，如果你的高阶组件名字是 withSubscription，且包裹组件的显示名字是 CommentList，那么就是用 withSubscription(CommentList)这样的显示名字：123456789function withSubscription(WrappedComponent) &#123; class WithSubscription extends React.Component &#123;/* ... */&#125; WithSubscription.displayName = `WithSubscription($&#123;getDisplayName(WrappedComponent)&#125;)`; return WithSubscription;&#125;function getDisplayName(WrappedComponent) &#123; return WrappedComponent.displayName || WrappedComponent.name || 'Component';&#125; 注意事项静态方法需要被复制当你通过 HOC 创建组件的时候，原有组件被容器组件包裹。这意味着容器组件不含有原有组件的静态方法。1234567// 创建静态方法WrappedComponent.staticMethod = function() &#123;/*...*/&#125;// Now apply an HOCconst EnhancedComponent = enhance(WrappedComponent);// 新组件没有静态方法typeof EnhancedComponent.staticMethod === 'undefined' // true 为了解决这个问题，你需要在包裹之前把静态方法拷贝给容器组件：123456function enhance(WrappedComponent) &#123; class Enhance extends React.Component &#123;/*...*/&#125; // Must know exactly which method(s) to copy :( Enhance.staticMethod = WrappedComponent.staticMethod; return Enhance;&#125; 也可以使用 hoist-non-react-statics 来自动拷贝非原生 React 方法的静态方法。 ref不会被传递尽管高阶组件的约定是把所有的 props 传递给被包裹的组件，但它并不能传递 ref。那是因为 ref 实际上并不是 prop —— 就像 key 一样，它们会被 React 特殊对待。如果你给 HOC 传递了 ref，它将指向容器组件而不是被包裹的组件。如果一定要用到ref，可以将ref当做普通的props传递给组件：1234567891011121314151617function Field(&#123; inputRef, ...rest &#125;) &#123; return &lt;input ref=&#123;inputRef&#125; &#123;...rest&#125; /&gt;;&#125;// 将 Field 在高阶组件里包裹起来const EnhancedField = enhance(Field);// 在组件的 render 方法内..&lt;EnhancedField inputRef=&#123;(inputEl) =&gt; &#123; // This callback gets passed through as a regular prop this.inputEl = inputEl &#125;&#125;/&gt;// 在高阶组件中就可以访问组件实例和dom节点了...this.inputEl.focus();","tags":[{"name":"react","slug":"react","permalink":"https://sherrywu0917.github.io/tags/react/"},{"name":"高阶组件","slug":"高阶组件","permalink":"https://sherrywu0917.github.io/tags/高阶组件/"}]},{"title":"日常经验积累","date":"2017-10-19T03:28:58.000Z","path":"2017/10/19/日常经验积累/","text":"禁用复制功能123document.oncontextmenu = function() &#123; return false; &#125; //禁用鼠标右键功能document.body.oncopy = function() &#123; return false; &#125; //禁用复制功能document.onselectstart = function() &#123; return false; &#125; //禁用选择功能 UC浏览器问题UC浏览器会过滤掉top、test、ad、download等关键字uc浏览器判断到页面上文字居多时，会自动放大字体优化移动用户体验。添加以下头部可以禁用掉该优化 Font Boosting问题问题：字体的显示大小，与在CSS中指定的大小不一致。通过设置max-height: 999999px;或max-height: 100%;可以解决 ios&lt;10 js无法实现复制copy-to-clipboard-using-javascript-in-ios 移动端无法实现保存图片到本地，除了移动端chrome和pc表现一致，其他都不行ios微信缓存问题问题：ios9系统下微信内(非必现)，从充值页回到正文页，正文页获取的余额没有刷新，发现get请求没有发出，应该是微信AJAX缓存的问题。可通过给ajax请求加时间戳的方式解决。参考：微信自带浏览器物理返回不刷新问题 奇怪现象：其他的ios系统下，请求也没有发出去，但是数据是正确的，可能和缓存快照有关系，正常的可能保存了这个页面上次运行的整个数据栈。 移动端滚动穿透问题完美解决方案1234body.modal-open &#123; position: fixed; width: 100%;&#125; 当打开modal的时候给body添加modal-open类，fixed让底部页面无法滚动，同时根据页面滚动位置设置top值。在关闭modal时，再让页面恢复之前的滚动状态。1234567891011121314151617181920/** * ModalHelper helpers resolve the modal scrolling issue on mobile devices * https://github.com/twbs/bootstrap/issues/15852 * requires document.scrollingElement polyfill https://github.com/yangg/scrolling-element */var ModalHelper = (function(bodyCls) &#123; var scrollTop; return &#123; afterOpen: function() &#123; scrollTop = document.scrollingElement.scrollTop; document.body.classList.add(bodyCls); document.body.style.top = -scrollTop + 'px'; &#125;, beforeClose: function() &#123; document.body.classList.remove(bodyCls); // scrollTop lost after set position:fixed, restore it back. document.scrollingElement.scrollTop = scrollTop; &#125; &#125;;&#125;)('modal-open'); 不简单的自适应高度输入框主要实现代码如下：12345678910111213textarea &#123; width: 100%; height: 92px; padding: 20px; line-height: 50px; resize: none; outline: none; border: 1px solid #ccc; background: #eee; font-size: 32px; box-sizing: border-box; overflow: hidden; //去掉滚动条&#125; 1&lt;textarea id=\"textarea\"&gt;&lt;/textarea&gt; 12345678910111213141516171819202122var $textarea = document.getElementById('textarea');var lastLength = 0;var lastHeight = 0;$textarea.addEventListener('input', function() &#123; var currentLength = $textarea.value.length; // 判断字数如果比之前少了，说明内容正在减少，需要清除高度样式，重新获取 if (currentLength &lt; lastLength) &#123; $textarea.style.height = ''; &#125; var currentHeight = $textarea.scrollHeight; // 如果内容高度发生了变化，再去设置高度值 if (lastHeight !== currentHeight || !$textarea.style.height) &#123; $textarea.style.height = currentHeight + 2 + 'px'; &#125; lastLength = currentLength; lastHeight = currentHeight;&#125;); 原理是检测textarea.scrollHeight属性变化，并随之设置textarea的高度。 参考：https://juejin.im/post/5b7653bde51d454dba70c0b1?utm_source=gold_browser_extension setTimeout(fun, 0)1234setTimeout(function () &#123; func1();&#125;, 0)func2(); func1和func2谁会先执行？很明显func2先执行；setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f,0)，那么会立刻执行吗？答案是不会。因为setTimeout运行机制说过，必须要等到当前脚本的同步任务和“任务队列”中已有的事件，全部处理完以后，才会执行setTimeout指定的任务。也就是说，setTimeout的真正作用是，在“任务队列”的现有事件的后面再添加一个事件，规定在指定时间执行某段代码。setTimeout添加的事件，会在下一次Event Loop执行。setTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务——脚本的同步任务和“任务队列”中已有的事件，一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。12345678910111213141516171819202122232425262728setTimeout(function() &#123; console.log(\"Timeout\");&#125;, 0);function a(x) &#123; console.log(\"a() 开始运行\"); b(x); console.log(\"a() 结束运行\");&#125;function b(y) &#123; console.log(\"b() 开始运行\"); console.log(\"传入的值为\" + y); console.log(\"b() 结束运行\");&#125;console.log(\"当前任务开始\");a(42);console.log(\"当前任务结束\");// 当前任务开始// a() 开始运行// b() 开始运行// 传入的值为42// b() 结束运行// a() 结束运行// 当前任务结束// Timeout 上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，最少是4毫秒。如果小于这个值，会被自动增加到4。这是为了防止多个setTimeout(f,0)语句连续执行，造成性能问题。利用setTimeout(func, 0)可以帮助我们： 调整函数运行顺序 分割耗时任务 0.5px边框1234567891011121314151617 .scale-1px &#123; position: relative; margin-bottom: 20px; border:none;&#125;.scale-1px:after &#123; content: ''; position: absolute; top: 0; left: 0; border: 1px solid #000; box-sizing: border-box; width: 200%; height: 200%; transform: scale(0.5); transform-origin: left top;&#125; ios系统上active不生效问题在iOS系统的移动设备中，需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。可以采用下面两种方式解决：1document.addEventListener(\"touchstart\", function() &#123;&#125;, false); 12&lt;body ontouchstart=\"\"&gt;&lt;/body&gt; beforeunload事件兼容问题：为了优化用户体验，新式浏览器会要求有交互才会触发beforeunload事件，例如新版本的chrome浏览器。PS: 从Firefox 4、 Chrome 51、Opera 38 和Safari 9.1开始，通用确认信息代替事件返回的字符串，即无法通过下面的方式自定义文案。1234567891011window.onbeforeunload = function (e) &#123; e = e || window.event; // 兼容IE8和Firefox 4之前的版本 if (e) &#123; e.returnValue = '关闭提示'; &#125; // Chrome, Safari, Firefox 4+, Opera 12+ , IE 9+ return '关闭提示';&#125;; HTML5规范中指出，在该事件中调用window.alert(), window.confirm(), 和 window.prompt()，会被忽略。详细的可参考MDN。","tags":[{"name":"总结","slug":"总结","permalink":"https://sherrywu0917.github.io/tags/总结/"}]},{"title":"SASS使用二三事","date":"2017-08-28T10:15:21.000Z","path":"2017/08/28/sass应用/","text":"sass管理z-indexz-index的值和上下文有关系，在复杂布局中要跟踪z-index比较困难，z-index的取值范围很广，很容易出错，所以可以使用sass预处理器去统一管理。 定义浮层首先，我们可以借助sass 3.3引入的Map定义一个数据结构，key代表了不同浮层类型，value即对应的z-index值：123456789$z-layers: ( 'toast': 4000, 'modal': 3000, 'dropdown': 2000, 'mask': 1000, 'default': 1, 'below': -1, 'bottomless-pit': -10000); 定义函数123@function z($layer) &#123; @return map-get($z-layers, $layer);&#125; 使用了sass的map-get方法，如果$layer参数存在于$z-layers中，会返回对应的value值，如z(‘toast’)，返回对应的值为4000；若不存在于$z-layers中，则返回null。属性为null时，sass的编译不会输出。也可以借助map-has-key方法检查元素是否存在，对于不存在的元素使用@warn指令输出警告信息，方便我们在开发的时候发现问题。1234567@function z($layer) &#123; @if not map-has-key($z-layers, $layer) &#123; @warn \"No z-index found in $z-layers map for `#&#123;$layer&#125;`. Property omitted.\"; &#125; @return map-get($z-layers, $layer);&#125; 使用方法123456789//function方式.m-mask &#123; z-index: z('mask');&#125;//mixin方式.m-mask &#123; @include z('mask');&#125; 对于单个属性来说，建议采用function的定义方式，比起mixin方式，使用起来更加清晰、简单。 嵌套层级在层级关系比较多的情况下，单一层级可能无法满足我们的需求，如弹窗里面还有很多的层级关系时，这个时候，我们可以使用嵌套的层级定义方式，针对modal进行再扩展，对modal里面的元素进一步定义层级数值。1234567891011121314$z-layers: ( 'toast': 4000, 'modal': ( \"base\": 3200, \"close\": 3100, \"header\": 3050, \"footer\": 3000 ), 'dropdown': 2000, 'mask': 1000, 'default': 1, 'below': -1, 'bottomless-pit': -10000); 想要定义$z-layers中modal内部的层级关系，可以用嵌套的Map去设置，如上所示。要处理嵌套的层级关系，对应的z函数可以是：123456789101112131415161718192021@function map-has-nested-keys($map, $keys...) &#123; @each $key in $keys &#123; @if not map-has-key($map, $key) &#123; @return false; &#125; $map: map-get($map, $key); &#125; @return true;&#125;@function map-deep-get($map, $keys...) &#123; @each $key in $keys &#123; $map: map-get($map, $key); &#125; @return $map;&#125;@function z($layers...) &#123; @if not map-has-nested-keys($z-layers, $layers...) &#123; @warn \"No layer found for `#&#123;inspect($layers...)&#125;` in $z-layers map. Property omitted.\"; &#125; @return map-deep-get($z-layers, $layers...);&#125; 其中map-has-nested-keys方法可以检查元素是否存在于已经定义的$z-layers中： 若$keys只有一个值’toast’，@each只需要循环一次，在循环内，$map被赋值为’toast’对应的z-index值，最后返回true值； 若$keys有两个值’modal’和’base’，@each循环两次，第一次循环，先检查’modal’是否存在于$z-layers中，再将$map赋值为map-get($z-layers, ‘modal’)，即内部嵌套的modal的map，第二次循环先判断’base’是否存在于$map中，若不存在直接返回false，若存在$map被赋值为’base’对应的z-index值，最后返回true值；map-deep-get方法用于获得对应的z-index值，思路和map-has-nested-keys方法一致，只是前者返回true/false，后者返回$map值。具体的调用方式如下所示：12345678910111213141516171819.modal &#123; position: absolute; z-index: z(\"modal\", \"base\"); .close-button &#123; z-index: z(\"modal\", \"close\"); &#125; header &#123; z-index: z(\"modal\", \"header\"); &#125; footer &#123; z-index: z(\"modal\", \"footer\"); &#125;&#125;.toast &#123; z-index: z(\"toast\");&#125; 另一种z-index管理思路首先创建一个层级列表，在这个列表中，元素的出现顺序是从低到高，使用sass提供的index方法获取元素在$elements中的顺序，即为该元素的z-index值。12345$elements: project-covers, sorting-bar, modals, navigation;.project-cover &#123; z-index: index($elements, project-covers);&#125; 输出的z-index为1，与javascript不同，sass的索引值从1开始，就像css一样，css的:nth-child(n)中的n也是从1开始。123.project-cover &#123; z-index: 1;&#125; 个人觉得，这个方法更简单，适合于轻量级的项目，但灵活性不够好，取值范围受限于index值，对于嵌套的层级关系不友好，扩展性不好，对于较复杂项目更建议用前一种Map的形式来管理。 sass主题管理在项目开发中，涉及到不同主题的切换，例如在正文阅读时，有白天、黑夜、蓝色、黄色四种主题，不同主题配色不同，如果直接用css，结构复杂并且很难维护。利用scss提供的变量定义和方法，可以降低开发和维护成本。 sass管理颜色首先，sass可以对整个项目常用的一些颜色进行定义，例如本次项目通用的红色值为#ED6460，则可以在单独的文件_color.scss中定义该色值，其他scss文件通过@import引用。1234567$black: #24211F;$red: #ED6460;$blue: #60aaed;$border-gray: #ededed;$bg-gray: #f5f5f5;$btn-gray: #807A73; 主题定义首先，定义一个Map，记录不同的主题和与之关联的颜色，每个主题下细分了不同用途的色值。12345678910111213141516171819202122232425262728293031323334@import './color.scss';//主题base设置$theme: ( light: ( bg: #fff, //背景色 color: $black, //正文颜色 title: #A83A45, //章节标题颜色 link: #60AAED, //底部链接颜色 border: #ededed, //正文底部border颜色 themeBorder: #d8d8d8 //主题切换btn选中状态的border颜色 ), dark: ( …… ), blue: ( …… ), yellow: ( …… ));@each $name, $theme in $theme &#123; .theme--#&#123;$name&#125; &#123; color: map-get($theme, color); background-color: map-get($theme, bg); .m-main .content &#123; h1, h2 &#123; color: map-get($theme, title); &#125; &#125; .link &#123; color: map-get($theme, link); &#125; // ... 其他涉及主题配色的选择器 &#125;&#125; 通过@each去遍历Map，.theme–#{$name}编译后会生成.theme-light, .theme-dark等，在.theme–#{$name} 选择器内部，可以定义该主题下不同元素的样式，具体颜色可以通过map-get方法获得。对于button这种，在不同主题下颜色、边框、背景、active状态等都需要改变，可以单独定义。1234567891011121314151617181920212223$btn: ( light: ( color: $gray1, border: $gray0, bg: transparent, color-active: #fff, border-active: $red, bg-active: $red ), dark: ( …… ), blue: ( …… ), yellow: ( …… ),);@each $name, $theme in $btn &#123; .btn--#&#123;$name&#125; &#123; color: map-get($theme, color); border-color: map-get($theme, border); background-color: map-get($theme, bg); &#125; .btn--#&#123;$name&#125;:active, .btn--#&#123;$name&#125;-active &#123; color: map-get($theme, color-active); border-color: map-get($theme, border-active); background-color: map-get($theme, bg-active); &#125;&#125; 将主题颜色与其他不变的样式分离出来进行管理，所有的主题颜色维护在_theme.scss中，从而极大地提高了代码的可维护性。在切换主题的时候，只需要更换相应的类名，尤其在结合react开发时，theme变化时只需要重新setState一下就会重新渲染页面，十分方便。 定义通用样式可以通过sass提供的@mixin, @function等方式定义通用样式，如可以将实现单行\\多行文字截断效果的一组样式封装，用@mixin定义line-ellipsis方法，参数为行数和行高。传入行高是为了兼容不支持多行截断的浏览器，计算得出最大高度，防止样式错乱。其中行数的默认值为1，行高的默认值为1.5，可以使用@if,@else去判断行数，根据$num值去返回样式。12345678910111213141516@mixin line-ellipsis($num: 1, $lineH: 1.5)&#123; @if $num &gt; 1 &#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: $num; text-overflow: ellipsis; line-height: $lineH; max-height: $lineH * $num; overflow: hidden; &#125; @else &#123; white-space: nowrap; text-overflow: ellipsis; line-height: $lineH; overflow: hidden; &#125;&#125; 在使用的时候，通过@include方法引用，如下所示：1234567h3 &#123; @include line-ellipsis(); //默认单行截断&#125;.desc &#123; @include line-ellipsis(3, rem(38)); //3行截断&#125; desc这个类是多行截断，其中行高是rem(38)，调用了sass定义的px转rem的函数，是将38像素转为rem值。借助sass，可以方便地定义将像素转为rem。12345678@function rem($px, $base-font-size: 75px) &#123; @if (unitless($px)) &#123; //unitless(75) =&gt; true; unitless(75px) =&gt; false @return rem($px + 0px); &#125; @else if (unit($px) == rem) &#123; //unit(75px) =&gt; px; unitless(1rem) =&gt; rem @return $px; &#125; @return ($px / $base-font-size) * 1rem;&#125; 在rem()函数中设置了两个参数$px和$base-font-size，并且给$base-font-size设置了默认值75px。rem布局使用了淘宝的lib.flexible方案，所以默认值为75px。而且在rem()函数中使用了unitless去判断$px是否携带单位，若没带为true，否则为false。若$px没带单位，则通过+0px的方式带上px单位。若$px带单位，用unit获取$px带的单位，若是rem，则直接返回，其他的，与$base-font-size相除得到rem值。除此之外，可以结合项目需求定义更多的方法，如通用的button样式、适配浏览器分辨率、兼容性等等。 参考链接：Module: Sass::Script::FunctionsA Better Solution for Managing z-index with SassFriendlier colour names with Sass maps","tags":[{"name":"css","slug":"css","permalink":"https://sherrywu0917.github.io/tags/css/"},{"name":"sass","slug":"sass","permalink":"https://sherrywu0917.github.io/tags/sass/"}]},{"title":"项目开发record","date":"2017-07-27T01:38:34.000Z","path":"2017/07/27/分站开发总结/","text":"前端目录结构基于React + React-Router + Sass开发的webpack打包的多页面应用，其中正文页面和搜索页面是基于React-Router开发的单页面应用。路由类型采用的是BrowserRouter，在移动端pushState/replaceState没有兼容问题，可以放心使用。如果是要兼容IE9及以下，则不能使用BrowserRouter，建议使用HashRouter。此外，使用BrowserRouter后，可以借助history的特性帮助我们实现记录每个页面的历史停留位置。12345678910111213141516171819202122232425|-- assets | |-- config //webpack编译 | |-- base.js //基础编译配置 | |-- dev.js //开发环境编译配置 | |-- dll.js //动态链接库编译配置 | |-- hot.js //热替换编译配置 | |-- prod.js //开发环境编译配置 | |-- util.js //定义配置相关的通用方法和变量 | |-- src //源码目录 | |-- component // 组件 | | |-- common //公共组件 | | |-- //其他子组件 | |-- entry //入口js，与静态html文件相对应 | |-- util //通用方法 | |-- image //图片资源 | |-- style //样式 | |-- template //html模板，动态生成html文件 | |-- mock.json // mock数据 |-- server_hot.js //实现热更新、拦截并处理前端请求(返回本地页面、mock数据，其他请求转发到服务端处理) ||-- dist //构建目录 其中，模板中是静态html文件，在没有添加后端路由的情况下，通过server_hot.js中的页面映射去访问前端页面，例如当匹配到路径/index时，返回index.html页面，结合mock数据，真正实现了前后端分离。1234567891011121314151617181920let templateMap = &#123; '/search': 'search.html', '/search/book': 'search.html', '/index': 'index.html', '/history': 'history.html', '/rank': 'rank.html', '/home/more': 'more.html', '/category': 'category.html', '/info': 'info.html', '/detail': 'detail.html', '/book/reader': 'reader.html', '/recharge': 'recharge.html', '/catalog': 'catalog.html'&#125;for (let mapItem in templateMap) &#123; app.get(mapItem, function(req, res) &#123; res.sendFile(__dirname + '/template/' + templateMap[mapItem]); &#125;);&#125; API转发后获取服务端数据失败的问题在使用http-proxy-middleware转发请求到后端时，发现有部分请求无法获得返回数据，首先可以确定的是请求被转发到后端了。调试发现后端会验证站点相关信息，在验证host的时候报错。猜测可能是请求转发后header里的host信息丢失，查询API发现可以设置option.headers，如下所示。12var proxyMiddleware = require('http-proxy-middleware');var apiProxy = proxyMiddleware('/api', &#123; target: 'http://ypxst.kuxuanbook.yuedu.163.com', headers: &#123;host: 'ypxst.kuxuanbook.yuedu.163.com'&#125;&#125;); 设置好host后，就可以正常获取接口返回数据了。 POST请求验证XSRF-TOKEN之前阅读常用的方式是后端写入freemarker模板或者通过异步接口获得，这次和后端约定统一放在cookie中。1234headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'X-XSRF-TOKEN': csrf_token&#125; 从cookie中读取token后封装在post接口中，写在headers里面，这样在使用的时候就直接调用post方法，无需关注token验证。 使用git subtree同步assets工程assets资源存在于novel-webapp-wap和novel-webapp-recharge两个工程下面，recharge工程下面用到的是充值页面，其他页面都在wap工程下，之所以分开为两个工程是因为涉及到支付，充值的域名需要是唯一的，而分站的域名很多。为了保证二者资源的同步，可以使用git subtree实现子工程的同步。12345# 获取远端novel-webapp-assets的更新git subtree pull --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash# 将本地assets更新推送到远端novel-webapp-assetsgit subtree push --prefix=src/main/webapp/assets ssh://git@g.hz.netease.com:22222/novel/novel-webapp-assets.git master --squash webpack替换文件链接的资源通过给chunk filename添加[chunkhash]去有效地缓存文件，每次修改后生成新的chunkhash值，手动替换很麻烦，所以结合done plugin去完成html文件中资源名字的自动替换。stats记录了打包信息和相应的chunkhash值，其中assetsByChunkName包含了以chunkname作为key，filename作为值的对象，结构如下：1234567891011\"assetsByChunkName\": &#123; \"reader\": [ \"js/reader-60b54d52.js\", \"css/reader-60b54d52.css\" ], //... \"common\": [ \"js/common-a814792a.bundle.js\", \"css/common-a814792a.css\" ]&#125; 遍历stats对象中的entrypoints，这里的entrypoints的key值和html文件名一致、且一一对应的，根据key值读取可以读取对应的html文件，通过正则匹配的方式将对应的js、css文件替换为本次打包生成的文件。123456789101112131415161718192021222324252627282930function () &#123; this.plugin('done', function (stats) &#123; for(var key in stats.toJson().entrypoints) &#123; var htmlPath = path.join(ROOT_PATH, 'template', key + '.html'); var htmlContent = fs.readFileSync(htmlPath, 'utf8'); var keyJSRegExp = new RegExp('js\\/' + key + '(.*?)\\.js'); var keyCSSRegExp = new RegExp('css\\/' + key + '(.*?)\\.css'); var keyAssets = [].concat(stats.toJson().assetsByChunkName[key]); var commonAssets = [].concat(stats.toJson().assetsByChunkName['common']); var htmlOutput = ''; var keyJS = keyAssets.filter(path =&gt; path.endsWith('.js'))[0]; var keyCSS = keyAssets.filter(path =&gt; path.endsWith('.css'))[0]; if(keyJS) &#123; htmlOutput = htmlContent.replace(keyJSRegExp, keyJS); &#125; if(keyCSS) &#123; htmlOutput = htmlOutput.replace(keyCSSRegExp, keyCSS); &#125; var commonJS = commonAssets.filter(path =&gt; path.endsWith('.js'))[0]; var commonCSS = commonAssets.filter(path =&gt; path.endsWith('.css'))[0]; if(commonJS) &#123; htmlOutput = htmlOutput.replace(/js\\/common(.*?)\\.js/g, commonJS); &#125; if(commonCSS) &#123; htmlOutput = htmlOutput.replace(/css\\/common(.*?)\\.css/g, commonCSS); &#125; fs.writeFileSync(htmlPath, htmlOutput); &#125; &#125;);&#125; Refs:LOADING WEBPACK BUNDLES WITH HASH VALUE polyfill引入方式比较babel-core/babel-preset-*等插件可以将语法从 es6 转成 es5，但没有提供 api 的转码功能，如 Promise、Set、Map 等新增对象，Object.assign、Object.entries 等全局对象上的新增方法都不会转码， babel-runtime 和 babel-polyfill 就是为此而生。这两个模块功能几乎相同，就是转码新增 api，模拟 es6 环境，但实现方法完全不同。 babel-polyfill库babel-polyfill 的做法是将全局对象通通污染一遍，比如相应使用includes方法，会通过Array.prototype.includes() 的方式去注入污染原型。对于普通的业务代码没有关系，如果不在意略大的体积（min后86kb），推荐使用；但如果用在开发library，则不推荐使用，会污染该library使用者的环境。 babel-runtime库和babel-plugin-transform-runtime 插件babel-runtime 的做法是自己手动引入 helper 函数，const Promise = require(‘babel-runtime/core-js/promise’) 就可以引入 Promise，但是很不方便。借助babel-plugin-transform-runtime插件，可以帮助我们按需加载polyfill，这个模块会将我们的代码重写，如将 Promise 重写成 _Promise（只是打比方），然后引入_Promise helper 函数。此外，babel-runtime 不能转码实例方法，比如这样的代码：12'!!!'.repeat(3);'hello'.includes('h'); 这只能通过 babel-polyfill 来转码，因为 babel-polyfill 是直接在原型链上增加方法。 如果在开发library，为了避免污染使用者的环境，只能用 babel-runtime + babel-plugin-transform-runtime。虽然是业务开发，但是因为移动端比较介意babel-polyfill的体积，所以我还是选择了babel-runtime。 .babelrc中的相关配置12345678910&#123; \"plugins\": [ [\"transform-runtime\", &#123; \"helper\": false, //开启helper后，统一引用了helper \"polyfill\": true, //Map, Set, Promise,Object.assign等 \"regenerator\": true, //主要是实现generator/yeild，async/await \"moduleName\": \"babel-runtime\" &#125;] ]&#125; helper设为true时，会引入一些 helper 来代替每次都生成的通用函数，原来构建好的代码每个模块都有类似这种代码：123function _classCallCheck(instance, Constructor)...function _possibleConstructorReturn(self, call)...function _inherits(subClass, superClass)... 开启helper后123var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');var _inherits2 = require('babel-runtime/helpers/inherits'); 在v6.12.0 (2016-07-27) 后增加了 helper 的配置，原因是从 babel-runtime 里引入的 helper 依赖很多，全部都是兼容最底层的。比如 Object.create typeof 这种方法全部被重写了，会导致构建模块变大。开启polyfill后，Object.assign方法会被改写为__WEBPACK_IMPORTED_MODULE_1_babel_runtime_core_js_object_assign___default()。regenerator设为true，使我们可以使用generator/yeild，async/await。如果你只需要用 regenerator，不需要 core-js 里面的 polyfill 那你就可以在 options 中把 polyfill 设为 false。 babel-preset-env插件 版本支持：babel 7.0beta版、babel-loader 8.0 beta版和babel-preset-env 2.0beta版1npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env --save-dev 首先需要安装babel-polyfill1npm install @babel/polyfill --save 配置”useBuiltIns”: false: 不对polyfills做任何操作 entry: 根据target中浏览器版本的支持，将polyfills拆分引入，仅引入有浏览器不支持的polyfill，通过import &#39;babel-polyfill&#39;方式在代码中一次性引入 usage(新)：检测代码中ES6/7/8等的使用情况，仅仅加载代码中用到的polyfills 这种方式配置非常方便，并且可以按需加载，后续会替换成该插件。 Refs:babel-preset-env按需加载polyfill——babel7的正确打开方式ES6 + Webpack + React + Babel 如何在低版本浏览器上愉快的玩耍再见，babel-preset-2015 记录正文页历史滚动位置在开发过程中，发现每次返回到历史页面时，都不是上次访问到的页面位置，而是重置到了顶部，react并没有去维护历史页面的滚动位置。所以我们需要手动去记录页面的历史滚动位置。 可能的方案 使用window的onpopstate、onload、onunload事件监听页面的前进、返回，利用command模式维护posUndoStack和posRedoStack栈，记录并保存页面的历史位置问题：结合了history.length去判断页面是前进、返回or新进了一个页面，但是当从b页面返回到a页面后，又点击进入了b页面后，history.length不变，链接不变，这个时候无法辨别浏览器的行为 react-router-scroll组件问题：基于react-router，基于router middleware实现的，使用的Router V4没有中间件的概念 基于history.location.key属性的实现问题：基于react-router 最终方案由于目前没有好的办法去记录所有页面的位置，而记录正文页阅读位置的需求最为必要，所以使用第三个方案，暂时忽略其他页面。使用BrowserRouter的页面支持location.key属性，这个location是react-router引用的history库中的location对象，每个页面有唯一标识的key值。 React-router官网: 使用 hash 的方式记录导航历史不支持 location.key，在以前的版本中，我们为这种行为提供了shim，但是仍有一些问题我们无法解决。 react-router使用的history库在createBrowserHistory时，会调用createKey方法创建页面的key值，key的长度默认为6，可以设置。123var createKey = function createKey() &#123; return Math.random().toString(36).substr(2, keyLength);&#125;; createBrowserHistory类中维护了一个数组allkeys，里面记录了所有页面的location.key。1var allKeys = [initialLocation.key]; 在SPA中的每个页面的history的state中则记录了该页面的key。1globalHistory.pushState(&#123; key: key, state: state &#125;, null, href); 在监听到popState事件后，会通过event拿到进入页面的state，里面记录了key值。123window.onpopstate = function(event) &#123; alert(state: \" + JSON.stringify(event.state));&#125;; 所以在页面返回、前进的时候，同一页面的location.key不变，据此可以在页面离开的时候，用key-value的形式保存当前key值和对应的滚动位置在sessionStorage中。页面离开的情况有：12345678//SPA页面内路由到其他章节componentWillReceiveProps(nextProps) &#123; posReserve.onLeave(this.props.location.key);&#125;//页面unloadwindow.onunload = () =&gt; &#123; posReserve.onLeave(this.props.location.key);&#125; 在页面前进、返回的时候，去sessionStorage中读取历史位置，并滚动页面到对应位置。 ios微信中SPA正文页返回问题问题1：正文内部返回白屏在IOS微信浏览器中阅读正文，返回上一章的时候期望显示上一章内容，但是会出现白屏的问题，需要上滑或者下滑页面，正文才会出现。在寻找解决方案的时候，发现Vue存在相似的问题： iOS Safari renders blank page ios 组件点返回白屏遮挡问题参考了其中的解决方案，在正文内容加载完成后通过js去触发scroll滚动，正文显示就恢复正常了。代码如下所示，尝试了下面两种方式，都可以解决问题。12345678componentDidMount() &#123; window.scrollTo(0, 1) window.scrollTo(0, 0) //或者 setTimeout(() =&gt; &#123; window.scrollTo(0, 0) &#125;, 100)&#125; 问题2: 从其他页面返回正文问题使用Preact的时候，从其他页面返回到正文页后，部分请求没有发出。在debug的时候发现正文页setState没有触发componentWillUpdate，不会rerender，setState的callback不被执行。当从Preact替换为React的时候，页面显示正常。 猜测1: 可能和preact的diff机制有关。因为’对一个虚拟DOM子树是否继续更新下去，如果它们的type, props,key都一样，或者它们的引用也一样，可能也会继续diff，官方还会比较context!!!!这个许多react-like没有考虑到。React-Router就非常依赖context对象进行多层的组件间传递‘。 猜测2: setState回调延后知乎问答‘如何看待 React 的替代框架 Preact’中蓝面小生和司徒正美的回答中列出了Preact存在的一些问题。 解决方案如果继续使用Preact可以通过reload页面解决问题，当从正文页跳转到其他页面时候，记录下当前页面的location.key在sessionStorage中，返回页面时在componentWillMount方法中判断当前key值是否存储在’N_reader_locKeys’，若存在，则说明是页面返回，reload页面，并且从’N_reader_locKeys’中删掉对应的key值。12345678910111213141516171819202122232425262728293031323334componentWillMount() &#123; let _key = this.props.location.key; let locKeys = sessionStorage.getItem('N_reader_locKeys'); if(isIos &amp;&amp; _key &amp;&amp; locKeys)&#123; sessionStorage.removeItem('N_reader_locKey') let index = locKeys.indexOf(_key); if(~index &amp;&amp; this.props.history.action === 'POP') &#123; sessionStorage.setItem('N_reader_locKeys', locKeys.slice(0, index) + locKeys.slice(index + _key.length + 1)); location.reload(); return false; &#125; &#125;&#125;//[IOS微信返回bug处理]记录所有点击跳到其他页面(结合href和isexternal值)bindEvent() &#123; document.addEventListener('click', e =&gt; &#123; let targetEle = e.target; if(targetEle.tagName.toLowerCase() === 'a') &#123; if(targetEle.href.indexOf('.do') !== -1 || (targetEle.getAttribute('isexternal') === 'true')) &#123; e.preventDefault(); let _key = this.props.location.key; let keys = sessionStorage.getItem('N_reader_locKeys') || ''; if(_key &amp;&amp; keys.indexOf(_key) === -1) &#123; keys += _key + ',' sessionStorage.setItem('N_reader_locKeys', keys); &#125; if(targetEle.href.indexOf('.do') !== -1) &#123; location.href = targetEle.href; &#125; &#125; &#125; &#125;)&#125; 鉴于在某ios9版本的iphone5s上正常打开正文一直会出现上述问题，且考虑逻辑的复杂性、未来的需求扩展，最终还是使用React替换了Preact。逻辑越复杂，Preact暴露的问题越多。 问题3：微信url地址问题在IOS微信中，使用history的replaceState、pushState，url栏不变，分享或者通过浏览器打开都还是之前的url。 详情从首页进入正文，通常只带sourceUuid不带articleUuid，在加载当前章节的时候期望通过history.replaceState去更新当前url为带articleUuid，这样当从下一章返回的时候，可以正确显示当前内容，不然会自动获取当前进度，无法显示正确章节。安卓可以正常返回，但ios微信返回的时候url还是不带articleUuid。 解决方案原因是使用H5的history API并不能改变url栏地址内容，分享或通过浏览器打开都是旧的地址，是ios微信的一个bug。改用react-router的history.replace去更新章节可以解决返回问题。原理是虽然地址栏不变，但通过location.href获得的是正确的地址，BrowserRouter单页面应用在切换页面的时候会从window.location中读取{pathname,search,hash}，创建自己的location对象，依据location对象去渲染页面。 Refs: H5 history.pushState 在微信内修改url后点击用safari打开/复制链接是修改之前的页面 lib.flexible方案使用淘宝lib.flexible的rem方案，会遇到一个问题：在ios微信内长按扫描二维码，会有无法识别二维码的问题。[微信已修复该问题] 微信识别二维码的原理机制这里采用的逻辑是截屏识别，当客户端发现用户在网页的img标签内进行长按操作时，会立刻截屏并且启动二维码识别算法。所以这里用于二维码识别的图片是截屏，而不是之前有人提到的img标签中的图片。 实践发现meta scale指定为1的时候，无该问题。问题产生的原因应该是：在iOS下，对于dpr(设备像素比)2和3的屏，用2倍和3倍的方案，其余的用1倍方案。使用高清屏方案后，viewport的scale值会设为1/dpr，页面发生了缩放，二维码的位置实际发生了偏移，因而微信无法准确识别出二维码。设备像素比 = 物理像素 / 设备独立像素； 物理像素：一个物理像素是显示器(手机屏幕)上最小的物理显示单元； 设备独立像素：设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。在普通屏幕下，1个css像素 对应 1个物理像素(1:1)。 在retina 屏幕下，1个css像素对应 4个物理像素(1:4)。 为了解决二维码识别问题，在html中手动添加viewport的meta标签，这样页面就会根据已有的meta标签设置缩放比例，不会使用高清方案。不使用高清方案一个不好的地方是1px边框问题，不过可以通过伪元素搭配transform:scale(0.5)解决。123456789var metaEl = doc.querySelector('meta[name=\"viewport\"]');if (metaEl) &#123; console.warn('将根据已有的meta标签来设置缩放比例'); var match = metaEl.getAttribute('content').match(/initial\\-scale=([\\d\\.]+)/); if (match) &#123; scale = parseFloat(match[1]); dpr = parseInt(1 / scale); &#125;&#125; 1234567891011121314.method-list:after&#123; content: ''; position: absolute; top: 0; left: 0; width: 200%; height: 200%; border-bottom: 1px solid #E1E1E1; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: 0 0; transform-origin: 0 0; box-sizing: border-box;;&#125;","tags":[{"name":"总结","slug":"总结","permalink":"https://sherrywu0917.github.io/tags/总结/"},{"name":"webpack","slug":"webpack","permalink":"https://sherrywu0917.github.io/tags/webpack/"},{"name":"react","slug":"react","permalink":"https://sherrywu0917.github.io/tags/react/"}]},{"title":"css效果","date":"2017-06-30T11:44:13.000Z","path":"2017/06/30/css效果/","text":"仿古效果 CSS处理图像效果：仿古效果[https://www.w3cplus.com/css3/vintage-washout.html] 冲洗效果: 通过减轻暗色阴影和改变一些阴影的细节（改变暗色的细节），看上去就是在亮度的范围降低颜色对比度。 混合模式：lighten将lighten混合模式应用于一个重叠元素或者一个伪元素上。你可以在某个元素上使用background-blend-mode:lighten或者使用多个混合模式，也可以在覆盖元素上使用mix-blend-mode:lighten。建议使用多个背景。 应用使用@mixin 12345678910@mixin fade-it($img, $shadow: #536) &#123; background: url('#&#123;$img&#125;'), $shadow; background-blend-mode: lighten;&#125;.apply-base &#123; @include fade-it('1.jpg');&#125;.apply-unique-shade &#123; @include fade-it('2.jpg', #293e78);&#125; 编译后的css12345678.apply-base &#123; background: url('1.jpg'), #536; background-blend-mode: lighten;&#125;.apply-unique-shade &#123; background: url('2.jpg'), #293e78; background-blend-mode: lighten;&#125;","tags":[{"name":"css","slug":"css","permalink":"https://sherrywu0917.github.io/tags/css/"}]},{"title":"webpack配置","date":"2017-06-27T07:06:13.000Z","path":"2017/06/27/webpack配置/","text":"dll动态链接库优化打包为dll单独配置一个webpack.dll.config.js文件，在entry中引入你要打包到vendor的模块，通常是一些通用的不涉及业务的库。1234567891011121314151617var webpack = require('webpack');module.exports = &#123; entry: &#123;vendor: ['react', 'react-dom']&#125;, output: &#123; path: './dist', filename: '[name].bundle.js', library: '[name]' &#125;, plugins:[ new webpack.DllPlugin(&#123; path: './dist/[name]-manifest.json', name: '[name]', context: __dirname, &#125;) ]&#125; webpack.DllPlugin的选项中，path是manifest文件的输出路径；name是dll暴露的对象名，要跟output.library保持一致。执行webpack --config webpack.dll.config.js后会在dist文件夹下面生成vendor.manifest.json和vendor.bundle.js。其中vendor.manifest.json长这样： 123456789101112&#123; \"name\": \"vendor\", \"content\": &#123; \"./node_modules/react/react.js\": 1, \"./node_modules/react/lib/React.js\": 2, \"./node_modules/process/browser.js\": 3, \"./node_modules/object-assign/index.js\": 4, \"./node_modules/react/lib/ReactBaseClasses.js\": 5, \"./node_modules/react/lib/reactProdInvariant.js\": 6, \"./node_modules/react/lib/ReactNoopUpdateQueue.js\": 7, \"./node_modules/fbjs/lib/warning.js\": 8, ...... webpack将每个库进行了编号，之后dll user可以读取该文件，根据这个索引来引用。 之后，在webpack.config.js文件中添加DllReferencePlugin的插件配置。123456plugins:[ new webpack.DllReferencePlugin(&#123; context: __dirname,//需要与webpack.dll.config.js中DllPlugin上下文一致 manifest: require('./dist/vendor-manifest.json')//DllPlugin输出的manifest.json文件 &#125;)] 配置完成后，每次业务逻辑的修改只需要执行webpack --config webpack.config.js，不需要重复对dll进行打包，可以节约打包时间。 使用require.ensure分包123require.ensure([/*预加载模块*/], function(require) &#123; const Promise = require('es6-promise').Promise;&#125;, 'promise'); webpack会将es6-promise模块打包成promise.chunk.js(require.ensure的第三个参数和chunkFilename决定了打包后的文件名)。每个require.ensure会把前面数组里面的模块和内部require的模块都打包到一个文件内，异步加载。可以在ensure的[]数组中加入想要预加载的模块，也可以在function内部使用require.include对文件进行预加载。 webpack-dev-server热替换 webpack-dev-server 主要提供两个功能： 为静态文件提供服务 自动刷新和热替换(HMR) webpack-dev-server提供了两种自动刷新模式：iframe和inline，默认模式是iframe。inline方式会将webpack-dev-server客户端加入到webpack入口文件的配置中，配置方式有CLI和NodeJs API两种。 CLI方式1webpack-dev-server --env development --port=8081 --hot --inline Node.js API方式手动将webpack-dev-server客户端配置到webpack打包的入口文件中修改文件webpack.config.dev.js，添加webpack/hot/dev-server，添加插件HotModuleReplacementPlugin：1234567891011121314151617181920212223242526var webpack = require(\"webpack\");var webpackBase = require(\"./webpack.config.base.js\");var cfg = Object.assign(webpackBase, &#123; devtool: \"cheap-module-eval-source-map\"&#125;);//entryObject.getOwnPropertyNames((webpackBase.entry || &#123;&#125;)).map(function (name) &#123; cfg.entry[name] = [] //添加HMR文件 .concat(\"webpack/hot/dev-server\") .concat(\"webpack-dev-server/client?http://localhost:9390\") .concat(webpackBase.entry[name])&#125;);//pluginscfg.plugins = (webpackBase.plugins || []).concat( new webpack.optimize.OccurrenceOrderPlugin(), //添加HMR插件 new webpack.HotModuleReplacementPlugin(), new webpack.NoErrorsPlugin())module.exports = cfg; 根目录添加文件devServer.js，用于创建服务器实例12345678910111213141516171819202122var path = require(\"path\");var webpack = require(\"webpack\");var webpackDevServer = require(\"webpack-dev-server\");var webpackCfg = require(\"./webpack.config.dev.js\");var compiler = webpack(webpackCfg);//init servervar app = new webpackDevServer(compiler, &#123; //注意此处publicPath必填 publicPath: webpackCfg.output.publicPath, //HMR配置 hot:true&#125;);app.listen(9390, \"localhost\", function (err) &#123; if (err) &#123; console.log(err); &#125;&#125;);console.log(\"listen at http://localhost:9390\"); 修改package.json中scripts配置，通过执行devServer.js文件启动服务器：123\"scripts\":&#123; \"start\":\"node devServer.js\"&#125; 基础版webpack配置 开发环境下 123456789101112131415161718192021222324252627282930var webpack = require('webpack');var path = require('path');module.exports = &#123; entry: &#123;iread: \"./iread/src/index.js\", icartoons: \"./icartoons/src/index.js\"&#125;, output: &#123; path: \"./dist\", //资源文件引用的目录 publicPath: '../dist/', //相对于html中,指定资源文件引用的目录 filename: \"[name].bundle.js\", chunkFilename: '[name].chunk.js' &#125;, module: &#123; loaders: [ &#123; test: path.resolve('./','lib/zepto.js'), loader: \"exports?window.$!script\" &#125;, &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" &#125;, &#123; test: /\\.(png|jpg)$/, loader: \"url-loader\" &#125;, &#123; test: /.jsx?$/, loader: 'babel-loader',exclude: /node_modules/, query: &#123; presets: ['es2015', 'react'] &#125; &#125; ] &#125;, plugins:[ new webpack.ProvidePlugin(&#123; $: path.resolve('./','lib/zepto.js') &#125;), new webpack.DllReferencePlugin(&#123; context: __dirname,//需要与webpack.dll.config.js中DllPlugin上下文一致 manifest: require('./dist/vendor-manifest.json')//DllPlugin输出的manifest.json文件 &#125;) ]&#125; 生产环境下 12345678910111213141516171819202122232425262728293031323334var webpack = require('webpack');var path = require('path');module.exports = &#123; entry: &#123;iread: './iread/src/index.js', icartoons: './icartoons/src/index.js'&#125;, output: &#123; path: \"./dist\", filename: \"[name].bundle.min.js\" &#125;, module: &#123; loaders: [ &#123; test: path.resolve('./','lib/zepto.js'), loader: \"exports?window.$!script\" &#125;, &#123; test: /\\.css$/, loader: \"style-loader!css-loader\" &#125;, &#123; test: /\\.(png|jpg)$/, loader: \"url-loader\" &#125;, &#123; test: /.jsx?$/, loader: 'babel-loader',exclude: /node_modules/, query: &#123; presets: ['es2015', 'react'] &#125; &#125; ] &#125;, plugins:[ new webpack.ProvidePlugin(&#123; $: path.resolve('./','lib/zepto.js') &#125;), new webpack.DefinePlugin(&#123; 'process.env': &#123; 'NODE_ENV': JSON.stringify('production') &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;","tags":[{"name":"webpack","slug":"webpack","permalink":"https://sherrywu0917.github.io/tags/webpack/"},{"name":"前端打包","slug":"前端打包","permalink":"https://sherrywu0917.github.io/tags/前端打包/"},{"name":"require","slug":"require","permalink":"https://sherrywu0917.github.io/tags/require/"}]},{"title":"web浏览器兼容性问题","date":"2017-06-15T12:19:58.000Z","path":"2017/06/15/web浏览器兼容性问题/","text":"IE的问题 IE中animate作用在body上会失效，使用$(‘html, body’) 123$('html, body').animate(&#123; scrollTop: offsetTop - $('#J_nav').height()&#125;, 500) $(‘body’).scrollTop()在IE中获得的值始终是0，使用$(document).scrollTop()可以获得正确的值 IE中通过offset获得的top值 = chrome浏览器offset的top值 + 该元素的paddingTop值。要获取元素offset值，需要兼容IE，如下： 1234567891011\\\\大于等于Ver版本的IE浏览器isGteIE(ver) &#123; let b = document.createElement('b'); b.innerHTML = '&lt;!--[if lte IE ' + ver + ']&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;'; return b.getElementsByTagName('i').length === 1;&#125;let offsetTop = $(target).offset().top;//IE8及以上, 修正offsetif(self.isGteIE(8)) &#123; offsetTop -= parseInt($(target).css('paddingTop'));&#125; 浏览器内核 浏览器 内核 IE Trident Safari webkit Chrome WebKit的分支—Chromium引擎 Chrome 28.0.1469.0版本之后 基于WebKit2—Blink引擎 Firefox Gecko内核 Opera Presto渲染引擎，2013年2月之后紧跟chrome引擎 浏览器市场份额http://www.netmarketshare.com/ 兼容IE8IE8不支持本地视频播放，要使用在线的为了让IE8兼容video标签，使用html5media123 &lt;!–[if lt IE 9]&gt; &lt;script src=\"http://api.html5media.info/1.1.8/html5media.min.js\"&gt;&lt;/script&gt;&lt;![endif]–&gt; 兼容IE8的图表库：highchartshttp://www.highcharts.com/demo需要使用1.x的jQuery版本","tags":[{"name":"兼容","slug":"兼容","permalink":"https://sherrywu0917.github.io/tags/兼容/"}]},{"title":"form表单实现文件的下载","date":"2017-06-15T12:19:22.000Z","path":"2017/06/15/form表单实现文件的下载/","text":"h5链接a增加download属性 download属性 想到最简单的下载文件的方式是1&lt;a href=\"large.jpg\"&gt;下载&lt;/a&gt; 但是实际效果是在浏览器直接浏览图片，而不是下载图片。如果我们希望点击“下载”链接下载图片，可以增加一个download属性。1&lt;a href=\"large.jpg\" download&gt;下载&lt;/a&gt; 通过download属性还可以指定下载图片的文件名，如果后缀一样，可以省略。1&lt;a href=\"large.jpg\" download=\"large_down.jpg\"&gt;下载&lt;/a&gt; download的兼容性 如果下载的资源是跨域的，在chrome浏览器下可以正常下载，在firefox浏览器下不支持跨域下载。要判断是否支持download属性，可以使用下面的代码：1var isSupportDownload = 'download' in document.createElement('a'); 兼容浏览器的下载方法 download属性不支持IE，要兼容IE可以通过JS创建一个iframe去下载，如下所示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;a id='trigger' href=\"javascript:;\"&gt;下载&lt;/a&gt; &lt;a id='download' download='pic.jpg' style=\"display: none;\"&gt;下载&lt;/a&gt; &lt;/body&gt; &lt;script type=\"text/javascript\" src=\"http://yuedust.yuedu.126.net/js/jquery-1.8.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function download_pic() &#123; var codeurl='https://img4.cache.netease.com/news/2017/6/19/20170619094322c3136.jpg'; if(browserIsIe())&#123;//假如是ie浏览器 DownLoadReportIMG(codeurl); &#125;else&#123; $(\"#download\").attr('href', codeurl); document.getElementById(\"download\").click(); &#125; &#125; function DownLoadReportIMG(imgPathURL) &#123; //如果隐藏IFRAME不存在，则添加 if (!document.getElementById(\"IframeReportImg\")) $('&lt;iframe style=\"display:none;\" id=\"IframeReportImg\" name=\"IframeReportImg\" onload=\"DoSaveAsIMG();\" width=\"0\" height=\"0\" src=\"about:blank\"&gt;&lt;/iframe&gt;').appendTo(\"body\"); if (document.all.IframeReportImg.src != imgPathURL) &#123; //加载图片 document.all.IframeReportImg.src = imgPathURL; &#125; else &#123; //图片直接另存为 DoSaveAsIMG(); &#125; &#125; function DoSaveAsIMG() &#123; //跨域的话IE会提示没权限 if (document.all.IframeReportImg.src != \"about:blank\") window.frames.IframeReportImg.document.execCommand(\"SaveAs\"); &#125; //判断是否为ie浏览器 function browserIsIe() &#123; if (!!window.ActiveXObject || \"ActiveXObject\" in window) return true; else return false; &#125; document.getElementById(\"trigger\").onclick = function(e) &#123; e.preventDefault(); download_pic(); &#125;; &lt;/script&gt;&lt;/html&gt; form表单实现文件的下载1234567891011121314151617181920212223handleExport() &#123; const &#123; selectedRowKeys &#125; = this.state; let config = &#123; action: UserExportUrl, key: 'userIdArray[]' &#125; let iframe = document.createElement('iframe'); iframe.style.display = 'none'; let form = document.createElement('form'); form.action = config.action; form.method = 'post'; let input = document.createElement('input'); input.type = 'hidden'; input.name = config.key; input.setAttribute('value', selectedRowKeys.join(',')); form.appendChild(input); document.body.appendChild(iframe); iframe.contentWindow.document.body.appendChild(form); form.submit(); // window.open(UserExportUrl + '?userIdArray[]=' + selectedRowKeys.join(','));&#125; PS: 移动端H5几乎无法实现保存图片到本地，加download属性和加响应头的方式，微信和浏览器都无法保存图片，手机端的chrome和PC效果一致，真是一股清流。还是提示用户自己长按保存图片吧。","tags":[{"name":"下载","slug":"下载","permalink":"https://sherrywu0917.github.io/tags/下载/"},{"name":"兼容","slug":"兼容","permalink":"https://sherrywu0917.github.io/tags/兼容/"}]},{"title":"@font-face 引入外部字体","date":"2017-06-15T12:16:44.000Z","path":"2017/06/15/font-face-引入外部字体/","text":"字体是在页面中呈现内容不可缺少的重要元素，合适的字体能让内容更能抓住用户的注意力。 我们的追求是在多平台上呈现可预知的一致的文字效果给用户，但限于平台的字体支持，我们在使用一些不常见的字体时畏首畏脚。 长久以来，我们解决这个问题，一般都采用图片替换文字的方法。这个方法虽然简单，但是弊端不少： 图片体积一般比较大，如需半透明处理，体积会进一步增大 工作量增加不少 图片放大后可能会失真 随着CSS3的推广，一个通过@font-face自定义字体的技术进入大家的视线中。 这个技术目前正被大量应用于自定义图标的实现。但是很少用来实现自定义字体，尤其是中文字体。 这是因为中文包含很多汉字，所以字体文件的体积一般都比较大。如果用做自定义字体， 页面会先下载字体文件，然后再呈现页面，这会导致加载缓慢，用户的流量被浪费。 然而在我们使用字体时，基本上只用来呈现有限的文字，下载整个字体文件是多余的。 那我们是否可以精简字体文件，让它只包含指定文字的字体信息，来解决问题？答案是可以的。 webfont-pick就是这样一个工具，它使用起来非常简单： 123npm install webfont-pick -g# 更多选项请执行 webfont-pick --help 查看webfont-pick --font=/Library/Fonts/YuppySC-Regular.otf --text=&quot;你好，世界！&quot; -o ~/Desktop/webfont 执行上述命令后，只包含你好，世界！这六个汉字的自定义字体文件会出现在指定的目录，并且生成了一个示例页面，用来说明如何使用。 有了webfont-pick之后，不管是微软雅黑还是方正呐喊都可以放心的应用到页面中。 另外webfont-pick不只可以通过命令行调用，还可以通过程序调用，详情请参考项目主页。 注1: webfont-pick目前只支持解析WOFF, OTF, TTF格式的字体 注2: webfont-pick的想法来源于ICONFONT.cn 注3: webfont-pick的实现参考grunt-webfont 开发中遇到的问题中文字体应用到英文上会有问题，字体不是期望的那样。解决方案：英文单独使用英文字体，在设置font-family的时候引入中英文两种字体。12345678910111213141516171819202122232425262728@font-face&#123; font-family: \"MS-Mincho\"; src: url('../src/font/MS-Mincho.eot'); /* IE9*/ src: url('../src/font/MS-Mincho.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('../src/font/MS-Mincho.woff') format('woff'); /* chrome、firefox */&#125;@font-face&#123; font-family: \"ST-Regular\"; src: url('../src/font/st-regular.eot'); /* IE9*/ src: url('../src/font/st-regular.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('../src/font/st-regular.woff') format('woff'); /* chrome、firefox */&#125;.banner-title &#123; font-size: 64px; color: #fff; line-height: 60px; margin-bottom: 20px; font-family: ST-Regular, MS-Mincho, sans-serif; // font-family: STSongti-SC-Regular; .en &#123; vertical-align: sub; letter-spacing: -28px; margin-right: -6px; &#125;&#125;","tags":[{"name":"css","slug":"css","permalink":"https://sherrywu0917.github.io/tags/css/"},{"name":"font-face","slug":"font-face","permalink":"https://sherrywu0917.github.io/tags/font-face/"}]},{"title":"ES6 学习","date":"2017-03-20T11:40:59.000Z","path":"2017/03/20/ES6-学习/","text":"from: http://es6.ruanyifeng.com let命令 let取代var, let仅在代码块中有效 for循环计数器适合用let let不存在变量提升 暂时性死区 不允许重复声明 块级作用域（全局作用域、函数作用域） const命令 声明常量 顶层对象，在浏览器中指的是window对象 es6的var命令和function命令声明的全局变量依然是顶层对象的属性 let、const、class命令声明的全局变量不属于顶层对象的属性 数组的解构赋值 只要某种数据结构有Iterator接口，都可以采用数组形式的解构赋值 解构可以设置默认值 对象也可以解构，数组的解构是按次序排列，对象的解构要求变量名必须和对象的属性名相同 数值和布尔值的解构赋值比较特别，转为了对象 函数参数也可以解构赋值 用处： 交换变量的值 从函数返回多个值 函数参数的定义 提取JSON对象中的数据 函数参数的默认值 遍历map解构 ：任何部署了Iterator接口的对象，都可以用for…of循环遍历（Array,String,Set,Map） 输入模块的指定方法 Unicode表示字符，可以使用{} 模板字符串${} includes, startsWith, endsWith, repeat, padStart, padEnd 数值的扩展 isFinite() isNaN() 将parseInt()和parseFloat()方法移植到Number对象上，目的是减少全局性方法，使语言逐步模块化 isInteger() 新增了极小的常量Number.EPSILON 最大值Number.MAX_SAFE_INTEGER， 最小值Number.MAX_SAFE_INTEGER Number.isSafeInteger() 数组的扩展 from方法将类似数组的对象和可遍历的对象转为真正的数组123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; of方法将一组值转换为数组 函数的扩展 可以设置参数的默认值 函数的length属性返回没有指定默认值的参数个数 reset参数：用于获取函数的多余参数，形式为…变量名，代表一个数组 1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 扩展运算符…：好比reset参数的逆运算，将一个数组转为用逗号分隔的参数序列 替代数组的apply方法 12345678910111213// ES5的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f(...args); 合并数组 与解构赋值结合 函数的返回值 任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。 12var obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object 对于没有iterator接口的对象，使用…语法会报错 与React中的JSX扩展语法不同 函数的name属性 箭头函数=&gt; 函数绑定运算符是并排的两个双冒号（::），左边是对象，右边是一个函数，返回的还是原对象，可以采用链式写法 “尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存 对象的扩展Proxy和Refelct1var proxy = new Proxy(target, handler); new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler也是一个对象，用来定制拦截行为123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 用处 属性拦截 拦截过滤各种操作，如new/defineProperty/delete/getPrototypeOf等 私有属性模拟has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。1234567891011var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: 'foo', prop: 'foo' &#125;;var proxy = new Proxy(target, handler);'_prop' in proxy // false Promise对象12345678var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); resolve将Promise对象从Pending变成Resolvedreject将Promise对象从Pending变成Rejected12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); resolve和reject可以将参数传递给then方法里面的回调函数 Symbol对象属性123456var isMoving = Symbol(\"isMoving\");...if (element[isMoving]) &#123; smoothAnimations(element);&#125;element[isMoving] = true; symbol-keyed属性不能通过.操作符来访问，必须使用方括号的方式 判断：if (isMoving in element) 删除：delete element[isMoving] for…in、Object.keys(obj) 和 Object.getOwnPropertyNames(obj)只会遍历到以字符串作为键的属性 Object.getOwnPropertySymbols(obj)只会遍历所有的Symbol键 Reflect.ownKeys(obj)会返回对象的所有字符串和Symbol键 Class1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; this关键字代表实例对象。类的方法都是定义在prototype上，与传统的prototype实现的类一致。 123456class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是function，类本身就指向构造函数。 12345class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // trueB.prototype.constructor === B //true 在类的实例上调用方法，其实就是调用原型上的方法。所以b实例的constructor方法就是B类原型的constructor方法。prototype对象的constructor属性，直接指向“类”的本身。 12345678class Point &#123; &#125;Object.assign(Point.prototype, &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;); 通过Object的assign方法可以一次向Point添加多个方法。 1234567891011121314class Point &#123; constructor(x, y) &#123; // ... &#125; toString() &#123; // ... &#125;&#125;Object.keys(Point.prototype)// []Object.getOwnPropertyNames(Point.prototype)// [\"constructor\",\"toString\"] 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。Object.keys这儿用来判断是否可枚举。 Set集合用最简洁的代码实现数组去重：ES6实现：1[...new Set([1,2,3,1,'a',1,'a'])] ES5实现：123[1,2,3,1,'a',1,'a'].filter(function(ele,index,array)&#123; return index===array.indexOf(ele)&#125;)","tags":[{"name":"es6","slug":"es6","permalink":"https://sherrywu0917.github.io/tags/es6/"},{"name":"js","slug":"js","permalink":"https://sherrywu0917.github.io/tags/js/"}]},{"title":"H5开发踩到的坑","date":"2017-03-16T12:42:41.000Z","path":"2017/03/16/H5开发遇到的坑/","text":"某些安卓机上tap事件会触发两次某些安卓微信缓存严重，reload事件会失效解决方法 location.reload(forcedReload): 当取值为 true 时，将强制浏览器从服务器重新获取当前页面资源，而不是从浏览器的缓存中读取，如果取值为 false 或不传该参数时，浏览器则可能会从缓存中读取当前页面。 加时间戳 ios微信内音乐不能自动播放微信屏蔽了音乐自动播放，使用微信API：WeixinJSBridge，当getNetworkType事件被触发时去播放音乐。解决方法：12345if((/MicroMessenger/ig).test(window.navigator.userAgent) &amp;&amp; (typeof WeixinJSBridge != \"undefined\")) &#123; WeixinJSBridge.invoke('getNetworkType', &#123;&#125;, function(e) &#123; $('.j-audio')[0].play(); &#125;);&#125; 此外，在手机chrome和safiri中都不支持音乐自动播放，需要用户操作才能触发，基于节省流量的考虑。 ios 客户端内某些样式异常，导致图片没有展示本质上图片是被覆盖了，应该是z-index的异常 android软键盘弹出后遮住文本框解决办法是使用scrollIntoViewIfNeeded()1234567891011121314151617//通用型if(/Android [4-6]/.test(navigator.appVersion)) &#123; window.addEventListener(\"resize\", function() &#123; if(document.activeElement.tagName==\"INPUT\" || document.activeElement.tagName==\"TEXTAREA\") &#123; window.setTimeout(function() &#123; document.activeElement.scrollIntoViewIfNeeded(); &#125;, 0); &#125; &#125;)&#125;//直接针对某个元素document.getElementById('/*元素id*/').onclick = function(e) &#123; setTimeout(() =&gt; &#123; e.target.scrollIntoViewIfNeeded(); &#125;, 400);&#125;","tags":[{"name":"总结","slug":"总结","permalink":"https://sherrywu0917.github.io/tags/总结/"}]},{"title":"Hello bingxin","date":"2017-03-16T12:42:41.000Z","path":"2017/03/16/Hello-bingxin/","text":"cmd小工具开发总结","tags":[]}]