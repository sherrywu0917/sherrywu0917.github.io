<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>lying fox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="lying fox">
<meta property="og:url" content="https://sherrywu0917.github.io/page/2/index.html">
<meta property="og:site_name" content="lying fox">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lying fox">
  
    <link rel="alternate" href="/atom.xml" title="lying fox" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lying fox</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://sherrywu0917.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-渲染&amp;EventLoop_new" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/02/渲染&EventLoop_new/" class="article-date">
  <time datetime="2021-08-02T03:28:58.000Z" itemprop="datePublished">2021-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/02/渲染&EventLoop_new/">浏览器进程&amp;EventLoop</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h2><h3 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h3><p><img src="https://developers.google.com/web/updates/images/inside-browser/part1/browser-arch.png" alt="image"></p>
<p><font color="#666" size="2">浏览器单进程和多进程的架构</font><br>每新开一个tab页，就会新增一个独立的浏览器进程，分配相应的CPU和内存。需要注意的是不同的浏览器有不同的优化机制，例如chrome可能会将某些进程合并，所以每一个Tab标签对应一个进程并不一定是绝对的。</p>
<h3 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h3><p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9614085650/aca8/658d/0939/cc340fa364785cb52c177a0c98220762.png" alt="image"><br>每一个独立的浏览器进程包括：<br>
        
          </p><p class="article-more-link">
            <a href="/2021/08/02/渲染&EventLoop_new/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://sherrywu0917.github.io/2021/08/02/渲染&EventLoop_new/" data-id="clsshtuxa002jwqrtaqw0uban" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/eventloop/">eventloop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/渲染/">渲染</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-themisRecord问题录制上报" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/02/themisRecord问题录制上报/" class="article-date">
  <time datetime="2021-07-02T04:12:12.000Z" itemprop="datePublished">2021-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/themisRecord问题录制上报/">themisRecord问题录制上报</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为了对用户在使用中遇到的相关问题及时给予反馈，尽快定位并解决用户遇到的使用问题。我们设计实现了问题上报工具，主要包括录制和展示两部分：</p>
<ul>
<li>ThemisRecord插件: 上报用户 uid、用户权限、API 请求&amp;结果、错误堆栈、录屏</li>
<li>展示平台：显示录屏回放、用户、请求和错误堆栈信息</li>
</ul>
<p>本文主要介绍ThemisRecord问题一键上报插件的实现原理。如何接入和使用详见<a href="https://music-cms.hz.netease.com/themis/plugins/record" target="_blank" rel="noopener">ThemisRecord接入使用文档</a>。<br><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9768133317/b5d2/0140/e564/c0d698968e2e158486c1cf207733a129.png" alt="image"></p>
<h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><p>问题一键上报插件的主要流程如下图所示，在录屏期间，插件需要分别收集用户账号信息、API请求数据、错误堆栈信息和录屏信息，并将数据上传到NOS和倾听平台。<br><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/9761905867/46b6/f1cf/8cb9/3e3ee413e0530ad767093af874e3f7ae.png" alt="image"></p>
        
          <p class="article-more-link">
            <a href="/2021/07/02/themisRecord问题录制上报/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://sherrywu0917.github.io/2021/07/02/themisRecord问题录制上报/" data-id="clsshtuws001pwqrtayi3326d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/diff/">diff</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTML渲染和资源加载" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/16/HTML渲染和资源加载/" class="article-date">
  <time datetime="2021-03-16T12:42:41.000Z" itemprop="datePublished">2021-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/16/HTML渲染和资源加载/">HTML渲染和资源加载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="渲染树构建、布局及绘制"><a href="#渲染树构建、布局及绘制" class="headerlink" title="渲染树构建、布局及绘制"></a>渲染树构建、布局及绘制</h3><ol>
<li>处理HTML标记并生成DOM树</li>
<li>处理CSS标记并生成CSSOM树</li>
<li>将DOM树和CSSOM树合成渲染树：<ul>
<li>从 DOM 树的根节点开始遍历每个可见节点（会忽略“display: none”的元素）</li>
<li>对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们</li>
<li>发射可见节点，连同其内容和计算的样式</li>
</ul>
</li>
<li>根据渲染树来<strong>布局</strong>，以计算每个节点的几何信息：计算它们在设备视口内的确切位置和大小<ul>
<li>输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素</li>
</ul>
</li>
<li><strong>绘制</strong>：将渲染树中的每个节点转换成屏幕上的实际像素<ul>
<li>绘制这一个过程应该是：RenderLayers渲染层 -&gt; GraphicsLayer图形层（GPU）</li>
<li>特殊的合成层，例如translate3d、will-change等<ul>
<li>3D transforms：translate3d、translateZ 等</li>
<li>video、canvas、iframe 等元素</li>
<li>通过 Element.animate() 实现的 opacity 动画转换</li>
<li>通过 СSS 动画实现的 opacity 动画转换</li>
<li>position: fixed</li>
<li>具有 will-change 属性</li>
<li>对 opacity、transform、filter、backdropfilter 应用了 animation 或者 transition<br>结论：CSS解析和DOM解析是可以并行的，二者完成后再去执行DOM渲染，但是CSS解析会阻塞JS的执行，JS的执行会阻塞DOM的解析。所以，要将CSS放在头部，JS资源放在尾部。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="回流Reflow和重绘Repaint"><a href="#回流Reflow和重绘Repaint" class="headerlink" title="回流Reflow和重绘Repaint"></a>回流Reflow和重绘Repaint</h3><h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4><ul>
<li>页面初次渲染</li>
<li>添加或者删除可见的 dom 元素</li>
<li>元素尺寸、位置、内容发生改变</li>
<li>浏览器窗口大小改变</li>
<li>元素字体大小变化</li>
<li>激活 CSS 伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft （元素可视区域的宽度）</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft （元素包括滚动条的宽度）</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft （元素的实际宽度）</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()  ({x,y,width,height,left,right,top,bottom} 其中right和bottom分别指元素相对于页面左边、上面的距离;使用document.documentElement.scrollTop和window.pageYOffset获取页面滚动的距离，window.pageYOffset IE9以下不兼容；scrollTop是该元素到视口可见内容顶部的距离，如果该元素没有垂直方向的滚动条，则该值始终为0。)</li>
<li>scrollTo()</li>
</ul>
</li>
</ul>
<h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><ul>
<li>background color visibility border-style border-radius设置等</li>
</ul>
<h4 id="获取宽高的不同方式"><a href="#获取宽高的不同方式" class="headerlink" title="获取宽高的不同方式"></a>获取宽高的不同方式</h4><pre><code>- screen.height 屏幕的高度
- screen.availHeight 浏览器窗口在屏幕上可占用的最大高度
- window.outerHeight window.innerHeight 浏览器的高度包括导航栏/不包括导航栏
- element.clientWidth offsetWidth scrollWidth  针对元素的，其中offsetTop和offsetLeft是相对于position为非static的父元素offsetParent，
</code></pre><h4 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h4><ul>
<li><strong>避免频繁操作样式</strong>，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。</li>
<li><strong>避免频繁操作DOM</strong>，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中（virtual dom思想）。</li>
<li>也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li><strong>缓存布局信息</strong>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它<strong>脱离文档流</strong>，否则会引起父元素及后续元素频繁回流。</li>
<li><strong>分离读写操作</strong></li>
</ul>
<h4 id="渲染队列"><a href="#渲染队列" class="headerlink" title="渲染队列"></a>渲染队列</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = <span class="string">'10px'</span>;</span><br><span class="line">div.style.top = <span class="string">'10px'</span>;</span><br><span class="line">div.style.width = <span class="string">'10px'</span>;</span><br><span class="line">div.style.height = <span class="string">'10px'</span>;</span><br></pre></td></tr></table></figure>
<p>理论上会发生4次回流，但是实际上只会发生1次回流，因为浏览器的渲染队列机制。当我们修改了元素的几何属性时，导致浏览器的回流或重绘时，会将操作放到渲染队列中，然后在达到一定数量或者一定时间时一次性统一渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">div.style.left = <span class="string">'10px'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetLeft);</span><br><span class="line"></span><br><span class="line">div.style.top = <span class="string">'10px'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetTop);</span><br><span class="line"></span><br><span class="line">div.style.width = <span class="string">'20px'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetWidth);</span><br><span class="line"></span><br><span class="line">div.style.height = <span class="string">'20px'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetHeight);</span><br></pre></td></tr></table></figure></p>
<p>会触发四次回流和重绘，因为在调用<code>offsetLeft</code>相关属性的时候，如果渲染队列中有数据的话，会先触发回流，因为在这样才能保证取到的数据的准确性。</p>
<h4 id="为什么在DOMContentLoaded事件中添加动画不成功？"><a href="#为什么在DOMContentLoaded事件中添加动画不成功？" class="headerlink" title="为什么在DOMContentLoaded事件中添加动画不成功？"></a><a href="https://stackoverflow.com/questions/42891628/why-dont-transitions-on-svg-work-on-domcontentloaded-without-delay" target="_blank" rel="noopener">为什么在DOMContentLoaded事件中添加动画不成功？</a></h4><p>DOMContentLoaded MDN上的定义：</p>
<blockquote>
<p>it fires when the DOM has been parsed, but before the CSSOM has been (and thus before styles have been applied)<br>在CSSOM ready之前，所以此时css样式一定没有渲染<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">! <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 查询offsetTop属性，强行触发回流和重绘</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.body.offsetTop; <span class="comment">// force a CSS repaint</span></span><br><span class="line">      <span class="keyword">var</span> logo2 = <span class="built_in">document</span>.querySelector(<span class="string">"svg"</span>);</span><br><span class="line">      logo2.classList.add(<span class="string">'start'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. setTimeout or raf(() =&gt; raf(() =&gt; &#123;&#125;))</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="改变阻塞模式：defer-与-async"><a href="#改变阻塞模式：defer-与-async" class="headerlink" title="改变阻塞模式：defer 与 async"></a>改变阻塞模式：defer 与 async</h3><p> async 与 defer 属性对inline script是无效的。</p>
<blockquote>
<p>MDN async: For classic scripts, if the async attribute is present, then the classic script will be fetched in parallel to parsing and evaluated as soon as it is available.</p>
</blockquote>
<blockquote>
<p>MDN defer: This Boolean attribute is set to indicate to a browser that the script is meant to be executed after the document has been parsed, but before firing DOMContentLoaded. The defer attribute should only be used on external scripts.</p>
</blockquote>
<h5 id="async文件"><a href="#async文件" class="headerlink" title="async文件"></a>async文件</h5><ul>
<li>加载好就会立即执行—无论此刻是HTML解析阶段还是DOMContentLoaded触发之后，但会阻塞load事件。</li>
<li>script中代码的执行顺序不定。</li>
<li>执行顺序：一定会在页面的load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。 </li>
</ul>
<h5 id="defer文件"><a href="#defer文件" class="headerlink" title="defer文件"></a>defer文件</h5><ul>
<li>载入JavaScript文件时不阻塞HTML的解析，执行阶段被放到HTML标签解析完成之后</li>
<li>不改变script中代码的执行顺序</li>
<li><p>执行顺序：在其他没有添加defer属性的script之后执行，在DOMContentLoaded事件之前</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.createElement(<span class="string">"script"</span>).async); <span class="comment">// true 动态创建的script默认是异步的。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> style = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">style.rel = <span class="string">"stylesheet"</span>; </span><br><span class="line">style.href = <span class="string">"index.css"</span>;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(style); <span class="comment">// 阻塞？ 已知的是，Chrome 中已经不会阻塞渲染，Firefox、IE 在以前是阻塞的。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sherrywu0917.github.io/2021/03/16/HTML渲染和资源加载/" data-id="clsshtuvt0003wqrts2ln5oaz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/load/">load</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/渲染/">渲染</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-hooks原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/02/react-hooks原理/" class="article-date">
  <time datetime="2020-12-02T04:12:12.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/02/react-hooks原理/">react-hooks原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>TODO:</p>
<blockquote>
<p><a href="https://juejin.cn/post/6944863057000529933" target="_blank" rel="noopener">https://juejin.cn/post/6944863057000529933</a><br><a href="https://www.reddit.com/r/reactjs/comments/v5ypd9/goodbye_useeffect_reactathon_2022/" target="_blank" rel="noopener">https://www.reddit.com/r/reactjs/comments/v5ypd9/goodbye_useeffect_reactathon_2022/</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sherrywu0917.github.io/2020/12/02/react-hooks原理/" data-id="clsshtuwm001awqrt2n3ku9yd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hook/">hook</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-mobx使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/02/react-mobx使用/" class="article-date">
  <time datetime="2020-12-02T04:12:12.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/02/react-mobx使用/">react-mobx使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ol>
<li><p>封装可观察对象——observable</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = observable(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>依赖收集——派生derivation：</p>
<ol>
<li>computed表达式</li>
<li>when、autorun、reaction的第一个入参函数</li>
<li>observer组件的render方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.a);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>推导——Action触发 derivation 的重新执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.a = <span class="number">2</span>; <span class="comment">// console 2</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><h4 id="利用Object-defineProperty方法，劫持了Observable对象的get-和set-方法。"><a href="#利用Object-defineProperty方法，劫持了Observable对象的get-和set-方法。" class="headerlink" title="利用Object.defineProperty方法，劫持了Observable对象的get()和set()方法。"></a>利用Object.defineProperty方法，劫持了Observable对象的get()和set()方法。</h4><ul>
<li>在访问Observable对象的时候，会调用get()方法，注册监听。如何绑定依赖：<ul>
<li>Observable对象调用<code>reportObserved(this)</code>，先将其添加到derivation监听者的可观察对象数组中observing[]</li>
<li>derivation对象调用<code>bindDependencies</code>，遍历<code>observing[]</code>，将自身实例添加到observable对象的监听者数组中observers_</li>
<li>至此，建立了双向依赖</li>
</ul>
</li>
<li>在修改Observable对象的时候，会调用set()方法，这个时候会触发监听<ul>
<li>Observable对象发生变化，会遍历监听者数组observers_，触发更新<h4 id="observe方法"><a href="#observe方法" class="headerlink" title="observe方法"></a>observe方法</h4></li>
</ul>
</li>
<li>显示调用addListener绑定依赖，在set()中调用notifyListeners触发更新<h4 id="class组件如何做到reactive"><a href="#class组件如何做到reactive" class="headerlink" title="class组件如何做到reactive"></a>class组件如何做到reactive</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeComponentReactive</span>(<span class="params">render: any</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isUsingStaticRendering() === <span class="literal">true</span>) <span class="keyword">return</span> render.call(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If props are shallowly modified, react will render anyway,</span></span><br><span class="line"><span class="comment">     * so atom.reportChanged() should not result in yet another re-render</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setHiddenProp(<span class="keyword">this</span>, skipRenderKey, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * forceUpdate will re-assign this.props. We don't want that to cause a loop,</span></span><br><span class="line"><span class="comment">     * so detect these changes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    setHiddenProp(<span class="keyword">this</span>, isForcingUpdateKey, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> initialName = getDisplayName(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">const</span> baseRender = render.bind(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> isRenderingPending = <span class="literal">false</span></span><br><span class="line">    <span class="comment">//  Reaction的两个参数(name, onInvalidate)</span></span><br><span class="line">    <span class="keyword">const</span> reaction = <span class="keyword">new</span> Reaction(<span class="string">`<span class="subst">$&#123;initialName&#125;</span>.render()`</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRenderingPending) &#123;</span><br><span class="line">            <span class="comment">// N.B. Getting here *before mounting* means that a component constructor has side effects (see the relevant test in misc.js)</span></span><br><span class="line">            <span class="comment">// This unidiomatic React usage but React will correctly warn about this so we continue as usual</span></span><br><span class="line">            <span class="comment">// See #85 / Pull #44</span></span><br><span class="line">            isRenderingPending = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>[mobxIsUnmounted] !== <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> hasError = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    setHiddenProp(<span class="keyword">this</span>, isForcingUpdateKey, <span class="literal">true</span>)</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>[skipRenderKey]) Component.prototype.forceUpdate.call(<span class="keyword">this</span>)</span><br><span class="line">                    hasError = <span class="literal">false</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    setHiddenProp(<span class="keyword">this</span>, isForcingUpdateKey, <span class="literal">false</span>)</span><br><span class="line">                    <span class="keyword">if</span> (hasError) reaction.dispose()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    reaction[<span class="string">"reactComponent"</span>] = <span class="keyword">this</span></span><br><span class="line">    reactiveRender[mobxAdminProperty] = reaction</span><br><span class="line">    <span class="keyword">this</span>.render = reactiveRender</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reactiveRender</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        isRenderingPending = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> exception = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">let</span> rendering = <span class="literal">undefined</span></span><br><span class="line">        <span class="comment">// 调用Reaction.prototype.track方法</span></span><br><span class="line">        reaction.track(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// step1: 修改globalState$$1.allowStateChanges的值为false，并将之前的值保存在prev字段中，</span></span><br><span class="line">                <span class="comment">// step2: 执行baseRender()方法，结果为res</span></span><br><span class="line">                <span class="comment">// step3: 恢复globalState$$1.allowStateChanges值为prev</span></span><br><span class="line">                <span class="comment">// step4: 返回res结果，赋值给rendering</span></span><br><span class="line">                rendering = _allowStateChanges(<span class="literal">false</span>, baseRender)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                exception = e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> (exception) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rendering</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reactiveRender.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>reaction.track</code>流程关键代码：<br>// 调用trackDerivedFunction方法，进一步去收集依赖，注册观察者<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line">Reaction$$<span class="number">1.</span>prototype.track = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    startBatch$$<span class="number">1</span>(); <span class="comment">// globalState$$1.inbatch++ </span></span><br><span class="line">    <span class="keyword">var</span> notify = isSpyEnabled$$<span class="number">1</span>(); <span class="comment">// !!globalState$$1.spyListeners.length</span></span><br><span class="line">    <span class="keyword">var</span> startTime;</span><br><span class="line">    <span class="keyword">if</span> (notify) &#123; <span class="comment">// spy监听所有mobx中的事件（深层监听），log作用</span></span><br><span class="line">        startTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        spyReportStart$$<span class="number">1</span>(&#123;</span><br><span class="line">            name: <span class="keyword">this</span>.name,</span><br><span class="line">            type: <span class="string">"reaction"</span></span><br><span class="line">        &#125;); <span class="comment">// 触发globalState$$1.spyListeners[i][event] </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._isRunning = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> result = trackDerivedFunction$$<span class="number">1</span>(<span class="keyword">this</span>, fn, <span class="literal">undefined</span>);</span><br><span class="line">    <span class="keyword">this</span>._isRunning = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>._isTrackPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isDisposed) &#123;</span><br><span class="line">        <span class="comment">// disposed during last run. Clean up everything that was bound after the dispose call.</span></span><br><span class="line">        clearObserving$$<span class="number">1</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isCaughtException$$<span class="number">1</span>(result))</span><br><span class="line">        <span class="keyword">this</span>.reportExceptionInDerivation(result.cause);</span><br><span class="line">    <span class="keyword">if</span> (notify) &#123; <span class="comment">// spy监听所有mobx中的事件（深层监听），log作用</span></span><br><span class="line">        spyReportEnd$$<span class="number">1</span>(&#123;</span><br><span class="line">            time: <span class="built_in">Date</span>.now() - startTime</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查globalState$$1.pendingUnobservations数组中的observable对象是否还有观察者，即observers的长度是否为0</span></span><br><span class="line">    <span class="comment">// 若为0，将该对象变成unobserve</span></span><br><span class="line">    endBatch$$<span class="number">1</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the provided function `f` and tracks which observables are being accessed.</span></span><br><span class="line"><span class="comment"> * The tracking information is stored on the `derivation` object and the derivation is registered</span></span><br><span class="line"><span class="comment"> * as observer of any of the accessed observables.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// derivation是Reaction 或者 ComputedValue</span></span><br><span class="line"><span class="comment">// f是render、等方法</span></span><br><span class="line"><span class="comment">// 执行f方法，收集依赖</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trackDerivedFunction$$1</span>(<span class="params">derivation, f, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// pre allocate array allocation + room for variation in deps</span></span><br><span class="line">    <span class="comment">// array will be trimmed by bindDependencies</span></span><br><span class="line">    changeDependenciesStateTo0$$<span class="number">1</span>(derivation);</span><br><span class="line">    derivation.newObserving = <span class="keyword">new</span> <span class="built_in">Array</span>(derivation.observing.length + <span class="number">100</span>);</span><br><span class="line">    derivation.unboundDepsCount = <span class="number">0</span>;</span><br><span class="line">    derivation.runId = ++globalState$$<span class="number">1.</span>runId;</span><br><span class="line">    <span class="comment">// 为什么prevTracking?</span></span><br><span class="line">    <span class="keyword">var</span> prevTracking = globalState$$<span class="number">1.</span>trackingDerivation;</span><br><span class="line">    globalState$$<span class="number">1.</span>trackingDerivation = derivation;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (globalState$$<span class="number">1.</span>disableErrorBoundaries === <span class="literal">true</span>) &#123;</span><br><span class="line">        result = f.call(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = f.call(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            result = <span class="keyword">new</span> CaughtException$$<span class="number">1</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    globalState$$<span class="number">1.</span>trackingDerivation = prevTracking;</span><br><span class="line">    bindDependencies(derivation);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何收集依赖？</span></span><br><span class="line"><span class="comment">// - 在访问Observable对象的时候，会调用get()方法，注册监听。如何绑定依赖：</span></span><br><span class="line"><span class="comment">// - Observable对象的get方法中会调用`this.reportObserved()`，先将其添加到derivation观察者的可观察对象数组newObserving[]</span></span><br><span class="line"><span class="comment">// array对象如何收集依赖？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reportObserved$$1</span>(<span class="params">observable$$<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> derivation = globalState$$<span class="number">1.</span>trackingDerivation;</span><br><span class="line">    <span class="keyword">if</span> (derivation !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Simple optimization, give each derivation run an unique id (runId)</span></span><br><span class="line"><span class="comment">         * Check if last time this observable was accessed the same runId is used</span></span><br><span class="line"><span class="comment">         * if this is the case, the relation is already known</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (derivation.runId !== observable$$<span class="number">1.</span>lastAccessedBy) &#123;</span><br><span class="line">            observable$$<span class="number">1.</span>lastAccessedBy = derivation.runId;</span><br><span class="line">            derivation.newObserving[derivation.unboundDepsCount++] = observable$$<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!observable$$<span class="number">1.</span>isBeingObserved) &#123;</span><br><span class="line">                observable$$<span class="number">1.</span>isBeingObserved = <span class="literal">true</span>;</span><br><span class="line">                observable$$<span class="number">1.</span>onBecomeObserved();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (observable$$<span class="number">1.</span>observers.length === <span class="number">0</span> &amp;&amp; globalState$$<span class="number">1.</span>inBatch &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        queueForUnobservation$$<span class="number">1</span>(observable$$<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * diffs newObserving with observing.</span></span><br><span class="line"><span class="comment"> * update observing to be newObserving with unique observables</span></span><br><span class="line"><span class="comment"> * notify observers that become observed/unobserved</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// - derivation对象调用`bindDependencies`，diff newObserving和old observing，</span></span><br><span class="line"><span class="comment">// 1. 对于old observing中不在NewObserving中的数组，移除derivation对该对象的监听</span></span><br><span class="line"><span class="comment">// 2. 给新增的observing，给derivation添加对每个对象的监听，将derivation添加到observable对象的监听者数组中observers_</span></span><br><span class="line"><span class="comment">// - 至此，建立了双向依赖</span></span><br><span class="line"><span class="comment">// - 在修改Observable对象的时候，会调用set()方法，这个时候会触发监听</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindDependencies</span>(<span class="params">derivation</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// invariant(derivation.dependenciesState !== IDerivationState.NOT_TRACKING, "INTERNAL ERROR bindDependencies expects derivation.dependenciesState !== -1");</span></span><br><span class="line">    <span class="keyword">var</span> prevObserving = derivation.observing;</span><br><span class="line">    <span class="keyword">var</span> observing = (derivation.observing = derivation.newObserving);</span><br><span class="line">    <span class="keyword">var</span> lowestNewObservingDerivationState = exports.IDerivationState.UP_TO_DATE;</span><br><span class="line">    <span class="comment">// Go through all new observables and check diffValue: (this list can contain duplicates):</span></span><br><span class="line">    <span class="comment">//   0: first occurrence, change to 1 and keep it</span></span><br><span class="line">    <span class="comment">//   1: extra occurrence, drop it</span></span><br><span class="line">    <span class="keyword">var</span> i0 = <span class="number">0</span>, l = derivation.unboundDepsCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> dep = observing[i];</span><br><span class="line">        <span class="keyword">if</span> (dep.diffValue === <span class="number">0</span>) &#123;</span><br><span class="line">            dep.diffValue = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 保证observing被观察者数组中前i0个都是新增的</span></span><br><span class="line">            <span class="keyword">if</span> (i0 !== i)</span><br><span class="line">                observing[i0] = dep;</span><br><span class="line">            i0++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Upcast is 'safe' here, because if dep is IObservable, `dependenciesState` will be undefined,</span></span><br><span class="line">        <span class="comment">// not hitting the condition</span></span><br><span class="line">        <span class="keyword">if</span> (dep.dependenciesState &gt; lowestNewObservingDerivationState) &#123;</span><br><span class="line">            lowestNewObservingDerivationState = dep.dependenciesState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    observing.length = i0;</span><br><span class="line">    derivation.newObserving = <span class="literal">null</span>; <span class="comment">// newObserving shouldn't be needed outside tracking (statement moved down to work around FF bug, see #614)</span></span><br><span class="line">    <span class="comment">// Go through all old observables and check diffValue: (it is unique after last bindDependencies)</span></span><br><span class="line">    <span class="comment">//   0: it's not in new observables, unobserve it</span></span><br><span class="line">    <span class="comment">//   1: it keeps being observed, don't want to notify it. change to 0</span></span><br><span class="line">    l = prevObserving.length;</span><br><span class="line">    <span class="keyword">while</span> (l--) &#123;</span><br><span class="line">        <span class="keyword">var</span> dep = prevObserving[l];</span><br><span class="line">        <span class="keyword">if</span> (dep.diffValue === <span class="number">0</span>) &#123;</span><br><span class="line">            removeObserver$$<span class="number">1</span>(dep, derivation);</span><br><span class="line">        &#125;</span><br><span class="line">        dep.diffValue = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Go through all new observables and check diffValue: (now it should be unique)</span></span><br><span class="line">    <span class="comment">//   0: it was set to 0 in last loop. don't need to do anything.</span></span><br><span class="line">    <span class="comment">//   1: it wasn't observed, let's observe it. set back to 0</span></span><br><span class="line">    <span class="comment">// 处理新增的observing，添加监听</span></span><br><span class="line">    <span class="keyword">while</span> (i0--) &#123;</span><br><span class="line">        <span class="keyword">var</span> dep = observing[i0];</span><br><span class="line">        <span class="keyword">if</span> (dep.diffValue === <span class="number">1</span>) &#123;</span><br><span class="line">            dep.diffValue = <span class="number">0</span>;</span><br><span class="line">            addObserver$$<span class="number">1</span>(dep, derivation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Some new observed derivations may become stale during this derivation computation</span></span><br><span class="line">    <span class="comment">// so they have had no chance to propagate staleness (#916)</span></span><br><span class="line">    <span class="keyword">if</span> (lowestNewObservingDerivationState !== exports.IDerivationState.UP_TO_DATE) &#123;</span><br><span class="line">        derivation.dependenciesState = lowestNewObservingDerivationState;</span><br><span class="line">        derivation.onBecomeStale();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何触发依赖</span></span><br><span class="line"><span class="comment">// - set的时候，先检查值是否发生了更新，如果更新了，就触发`this.reportChanged`方法，</span></span><br><span class="line"><span class="comment">// - 如果有显示调用observe添加的，则hasListeners为true，也会触发notifyListeners</span></span><br><span class="line">    Atom$$<span class="number">1.</span>prototype.reportChanged = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        startBatch$$<span class="number">1</span>();</span><br><span class="line">        propagateChanged$$<span class="number">1</span>(<span class="keyword">this</span>);</span><br><span class="line">        endBatch$$<span class="number">1</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> current propagation mechanism will in case of self reruning autoruns behave unexpectedly</span></span><br><span class="line"><span class="comment"> * It will propagate changes to observers from previous run</span></span><br><span class="line"><span class="comment"> * It's hard or maybe impossible (with reasonable perf) to get it right with current approach</span></span><br><span class="line"><span class="comment"> * Hopefully self reruning autoruns aren't a feature people should depend on</span></span><br><span class="line"><span class="comment"> * Also most basic use cases should be ok</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Called by Atom when its value changes</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">propagateChanged$$1</span>(<span class="params">observable$$<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// invariantLOS(observable, "changed start");</span></span><br><span class="line">    <span class="keyword">if</span> (observable$$<span class="number">1.</span>lowestObserverState === exports.IDerivationState.STALE)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    observable$$<span class="number">1.</span>lowestObserverState = exports.IDerivationState.STALE;</span><br><span class="line">    <span class="keyword">var</span> observers = observable$$<span class="number">1.</span>observers;</span><br><span class="line">    <span class="keyword">var</span> i = observers.length;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">var</span> d = observers[i];</span><br><span class="line">        <span class="keyword">if</span> (d.dependenciesState === exports.IDerivationState.UP_TO_DATE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d.isTracing !== TraceMode$$<span class="number">1.</span>NONE) &#123;</span><br><span class="line">                logTraceInfo(d, observable$$<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            d.onBecomeStale();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改derivation的状态，后面的shouldCompute$$1需要根据该状态判断是否需要更新</span></span><br><span class="line">        d.dependenciesState = exports.IDerivationState.STALE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// invariantLOS(observable, "changed end");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用derivation的onBecomeStale方法 -&gt; runReactions$$1</span></span><br><span class="line">    Reaction$$<span class="number">1.</span>prototype.onBecomeStale = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.schedule();</span><br><span class="line">    &#125;;</span><br><span class="line">    Reaction$$<span class="number">1.</span>prototype.schedule = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>._isScheduled) &#123;</span><br><span class="line">            <span class="keyword">this</span>._isScheduled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 将当前需要更新的reaction添加到pendingReactions数组中</span></span><br><span class="line">            globalState$$<span class="number">1.</span>pendingReactions.push(<span class="keyword">this</span>);</span><br><span class="line">            runReactions$$<span class="number">1</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Magic number alert!</span></span><br><span class="line"><span class="comment"> * Defines within how many times a reaction is allowed to re-trigger itself</span></span><br><span class="line"><span class="comment"> * until it is assumed that this is gonna be a never ending loop...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 批量更新reaction，在更新reaction的时候，可能会有新的reaction被触发。</span></span><br><span class="line"><span class="comment">// 加了一个单次限制，最多100个reaction一起批量更新</span></span><br><span class="line"><span class="keyword">var</span> MAX_REACTION_ITERATIONS = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> reactionScheduler = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123; <span class="keyword">return</span> f(); &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReactions$$1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Trampolining, if runReactions are already running, new reactions will be picked up</span></span><br><span class="line">    <span class="keyword">if</span> (globalState$$<span class="number">1.</span>inBatch &gt; <span class="number">0</span> || globalState$$<span class="number">1.</span>isRunningReactions)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    reactionScheduler(runReactionsHelper);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runReactionsHelper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    globalState$$<span class="number">1.</span>isRunningReactions = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> allReactions = globalState$$<span class="number">1.</span>pendingReactions;</span><br><span class="line">    <span class="keyword">var</span> iterations = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// While running reactions, new reactions might be triggered.</span></span><br><span class="line">    <span class="comment">// Hence we work with two variables and check whether</span></span><br><span class="line">    <span class="comment">// we converge to no remaining reactions after a while.</span></span><br><span class="line">    <span class="keyword">while</span> (allReactions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++iterations === MAX_REACTION_ITERATIONS) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">"Reaction doesn't converge to a stable state after "</span> + MAX_REACTION_ITERATIONS + <span class="string">" iterations."</span> +</span><br><span class="line">                (<span class="string">" Probably there is a cycle in the reactive function: "</span> + allReactions[<span class="number">0</span>]));</span><br><span class="line">            allReactions.splice(<span class="number">0</span>); <span class="comment">// clear reactions</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> remainingReactions = allReactions.splice(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = remainingReactions.length; i &lt; l; i++)</span><br><span class="line">            remainingReactions[i].runReaction();</span><br><span class="line">    &#125;</span><br><span class="line">    globalState$$<span class="number">1.</span>isRunningReactions = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * internal, use schedule() if you intend to kick off a reaction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 调用runReaction去更新</span></span><br><span class="line">Reaction$$<span class="number">1.</span>prototype.runReaction = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isDisposed) &#123;</span><br><span class="line">        startBatch$$<span class="number">1</span>();</span><br><span class="line">        <span class="keyword">this</span>._isScheduled = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 根据derivation.lowestObserverState判断下是否需要更新</span></span><br><span class="line">        <span class="keyword">if</span> (shouldCompute$$<span class="number">1</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>._isTrackPending = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 触发new Reaction实例时传入的onInvalidate方法</span></span><br><span class="line">                <span class="comment">// 对于Reaction组件是调用Component.prototype.forceUpdate方法去强制更新</span></span><br><span class="line">                <span class="keyword">this</span>.onInvalidate();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>._isTrackPending &amp;&amp; isSpyEnabled$$<span class="number">1</span>()) &#123;</span><br><span class="line">                    <span class="comment">// onInvalidate didn't trigger track right away..</span></span><br><span class="line">                    spyReport$$<span class="number">1</span>(&#123;</span><br><span class="line">                        name: <span class="keyword">this</span>.name,</span><br><span class="line">                        type: <span class="string">"scheduled-reaction"</span></span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">this</span>.reportExceptionInDerivation(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        endBatch$$<span class="number">1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array数组依赖的收集，Object.defineProperty，属性是</span></span><br><span class="line"><span class="comment">// 对于数据的操作，是基于ObservableArray的实例上面，ObservableArray该类自定义的一些方法被触发后，</span></span><br><span class="line"><span class="comment">// 【spliceWithArray -&gt; notifyArraySplice ｜ 或者直接触发】 -&gt; reportChanged &amp;&amp; notifyListeners</span></span><br><span class="line"><span class="keyword">var</span> ENTRY_0 = createArrayEntryDescriptor(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrayEntryDescriptor</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.get(index);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function (value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.set(index, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrayBufferItem</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// obj的key值都会被转成string，可以通过arr[index]直接获取</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(ObservableArray$$<span class="number">1.</span>prototype, <span class="string">""</span> + index, createArrayEntryDescriptor(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="useStaticRendering"><a href="#useStaticRendering" class="headerlink" title="useStaticRendering"></a>useStaticRendering</h3><p>我们知道可以通过使用@observer，将react组件转换成一个监听者(Reactions)，这样在被监听的应用状态变量(Observable)有更新时，react组件就会重新渲染。而对于服务端的React组件，我们只需要它被渲染一次，而不需要组件监听模型的状态。事实上，如果服务端React组件像客户端组件一样监听模型的状态变化，就会造成严重的内存泄漏问题。官方提供了useStaticRendering方法，用于避免mobx服务端渲染的内存泄漏问题; 该方法只需要在server启动时设置一次。</p>
<h3 id="与Redux的区别"><a href="#与Redux的区别" class="headerlink" title="与Redux的区别"></a>与Redux的区别</h3><p>REDUX的好处</p>
<ul>
<li>通过action,reducer来完成应用的数据流管理，逻辑简单清晰</li>
<li>reducer函数式的设计，让我们代码变得可观测，可回溯</li>
<li>action的设计，特别适用于多数据联动的场景<br>REDUX的弊端</li>
<li>啰嗦代码太多</li>
<li>reducer无复用性</li>
<li>性能优化太繁琐(当然可以引入immutable来解决，但是是不是又增加了学习成本,应用的复杂度和代码量呢)</li>
<li>app state和store state的划分</li>
<li>脏检查，参考<a href="https://tech.youzan.com/mobx_vs_redux/" target="_blank" rel="noopener">https://tech.youzan.com/mobx_vs_redux/</a></li>
</ul>
<ol>
<li><strong>store数量</strong>：redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中</li>
<li><strong>普通对象vsobservable对象</strong>：redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存数据，数据变化后自动处理响应的操作</li>
<li><strong>状态是否可变</strong>：redux使用不可变状态，这意味着状态是<code>只读</code>的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是<code>可变</code>的，可以直接对其进行修改</li>
<li><strong>函数式</strong>：mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用</li>
<li><strong>是否可追溯</strong>：mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</li>
</ol>
<p>场景辨析:<br>基于以上区别,我们可以简单得分析一下两者的不同使用场景.<br>mobx更适合<strong>数据不复杂的应用</strong>: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力不从心.<br>redux适合有<strong>回溯需求的应用</strong>: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操作，由于redux不可变的特性，天然支持这些操作.<br>mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.<br>当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用mobx作为组件局部状态管理器来用.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sherrywu0917.github.io/2020/12/02/react-mobx使用/" data-id="clsshtuwq001hwqrtl2crw3ct" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/diff/">diff</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-Fiber" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/02/react-Fiber/" class="article-date">
  <time datetime="2020-07-02T04:12:12.000Z" itemprop="datePublished">2020-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/02/react-Fiber/">react fiber纤程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="react-v16的diff算法"><a href="#react-v16的diff算法" class="headerlink" title="react v16的diff算法"></a>react v16的diff算法</h2><blockquote>
<p>React Fiber 是对React核心算法的重新实现，是React团队花费了2年的研究成果。<br>核心特性<strong>增量式渲染</strong>：the ability to split rendering work into chunks and spread it out over multiple frames.</p>
</blockquote>
<h3 id="0-react-element结构"><a href="#0-react-element结构" class="headerlink" title="0. react element结构"></a>0. react element结构</h3><p>React 元素（elements）是设计好的 plain object：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $$<span class="keyword">typeof</span>:  <span class="built_in">Symbol</span>(react.element), <span class="comment">// React会检测该属性，避免xss攻击 </span></span><br><span class="line">  key: <span class="literal">null</span>,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  ref: <span class="literal">null</span>,</span><br><span class="line">  type: <span class="built_in">String</span> | <span class="built_in">Object</span> | <span class="built_in">Function</span>, <span class="comment">// 元素类型，string，function</span></span><br><span class="line">  _owner: FiberNode, <span class="comment">// 所属React Component</span></span><br><span class="line">  _store: &#123; <span class="attr">validated</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了避免用户模拟JSON注入xss攻击，React 0.14 修复手段是用 Symbol 标记每个 React 元素（element）：因为服务器返回的序列化JSON不支持 Symbol 类型（<strong>JSON.stringify后，symbol属性和方法会被抛弃</strong>）。所以即使服务器存在用JSON作为文本返回安全漏洞，JSON 里也不包含 Symbol.for(‘react.element’)。React 会检测 element.$$typeof，如果元素丢失或者无效，会拒绝处理该元素。<br>特意用 Symbol.for() 的好处是 Symbols 通用于 iframes 和 workers 等环境中。<br>一个很有趣的点：如果浏览器不支持 Symbols 怎么办？React仍然会加上 $$typeof 字段以保证一致性，但只是设置一个数字而已 —— 0xeac7。为什么？因为 0xeac7 看起来有点像 「React」</p>
<h3 id="1-react-fiber纤程"><a href="#1-react-fiber纤程" class="headerlink" title="1. react fiber纤程"></a>1. react fiber纤程</h3><p>React Fiber 是一种基于浏览器的<strong>单线程调度算法</strong>。</p>
<ul>
<li>一种将 recocilation （递归 diff），拆分成无数个小任务的算法；</li>
<li>它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。</li>
<li>划分任务的优先级<br>fiber是纤程颗粒化的概念，一个线程可以包含多个Fiber，主要是对react更新机制的优化。React16之前的版本，更新组件会一直占用主线程，如果组件树过大，则可能会导致浏览器失去响应。在React16中加入的fiber可以将同步任务拆解，每次执行完一小片后，都会把控制权交还给react负责任务调度的模块，如果有优先级更高的任务，就先执行高优先级的任务。</li>
</ul>
<h4 id="1-1-解决问题"><a href="#1-1-解决问题" class="headerlink" title="1.1 解决问题"></a>1.1 解决问题</h4><p>JavaScript 是单线程运行的，，同时只能做一件事情，这个和 DOS 的单任务操作系统一样的，事情只能一件一件的干。要是前面有一个傻叉任务长期霸占CPU，后面什么事情都干不了，浏览器会呈现卡死的状态，这样的用户体验就会非常差。</p>
<h5 id="对于’前端框架‘来说，解决这种问题有三个方向"><a href="#对于’前端框架‘来说，解决这种问题有三个方向" class="headerlink" title="对于’前端框架‘来说，解决这种问题有三个方向:"></a>对于’前端框架‘来说，解决这种问题有三个方向:</h5><p>1️⃣ 优化每个任务，让它有多快就多快。挤压CPU运算量 （Vue）<br>2️⃣ 快速响应用户，让用户觉得够快，不能阻塞用户的交互 (React FiberNode)<br>3️⃣ 尝试 Worker 多线程<br>React 会递归比对VirtualDOM树，找出需要变动的节点，然后同步更新它们, 一气呵成。这个过程 React 称为 Reconcilation(协调)。在 Reconcilation 期间，React 会霸占着浏览器资源，一则会导致用户触发的事件得不到响应, 二则会导致掉帧，用户可以感知到这些卡顿。<br>协调是CPU密集型的操作，浏览器的渲染树构建、布局、绘制、资源加载(例如HTML解析)、事件响应、脚本执行都可以看作是进程，我们需要通过某些调度策略合理地分配CPU资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。<br><strong>所以 React 通过Fiber 架构，让自己的Reconcilation 过程变成可被中断。 ‘适时’地让出CPU执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:</strong></p>
<ul>
<li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操作，可以得到更好的用户体验。</li>
<li>给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对reflow进行修正</li>
</ul>
<h4 id="1-2-requestIdleCallback"><a href="#1-2-requestIdleCallback" class="headerlink" title="1.2 requestIdleCallback"></a>1.2 requestIdleCallback</h4><p>requestIdleCallback：让浏览器在’有空’的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行, 为了不耽误事，我们最好在这个时间范围内执行完毕。<br>浏览器在一帧内可能会做执行下列任务，而且它们的执行顺序基本是固定的:</p>
<ul>
<li>处理用户输入事件</li>
<li>Javascript执行</li>
<li>requestAnimationFrame 调用 (会在下一次渲染之前调用)</li>
<li>render Tree构建</li>
<li>布局 Layout</li>
<li>绘制 Paint<br>理想的一帧时间是 16ms (1000ms / 60)，如果浏览器处理完上述的任务(布局和绘制之后)，还有盈余时间，浏览器就会调用 requestIdleCallback 的回调。<br>但是在浏览器繁忙的时候，可能不会有盈余时间，这时候requestIdleCallback回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间。<br><strong>所以setState触发的diff会在浏览器空闲的时候执行，即setState是批量触发的机制</strong></li>
</ul>
<h5 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h5><ul>
<li>Immediate(-1) - 这个优先级的任务会同步执行, 或者说要马上执行且不能中断</li>
<li>UserBlocking(250ms) 这些任务一般是用户交互的结果, 需要即时得到反馈</li>
<li>Normal (5s) 应对哪些不需要立即感受到的任务，例如网络请求</li>
<li>Low (10s) 这些任务可以放后，但是最终应该得到执行. 例如分析通知</li>
<li>Idle (没有超时时间) 一些没有必要做的任务 (e.g. 比如隐藏的内容), 可能会被饿死</li>
</ul>
<h4 id="1-3-一个执行单元"><a href="#1-3-一个执行单元" class="headerlink" title="1.3 一个执行单元"></a>1.3 一个执行单元</h4><p><strong>将它视作一个执行单元，每次执行完一个’执行单元’, React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去.</strong><br>执行过程是：</p>
<ol>
<li><p>假设用户调用 setState 更新组件, 这个待更新的任务会先放入队列中, 然后通过 requestIdleCallback 请求浏览器调度：   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setState的时候可以将要更新的component instance放到一个队列里，即Fiber节点，Fiber执行单元里面也有state变更相关信息</span></span><br><span class="line">updateQueue.push(updateTask);</span><br><span class="line">requestIdleCallback(performWork, &#123;timeout&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在浏览器有空闲或者超时了就会调用performWork来执行任务：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1️⃣ performWork 会拿到一个Deadline，表示剩余时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2️⃣ 循环取出updateQueue中的任务(这边应该是以Fiber为单位)</span></span><br><span class="line">  <span class="keyword">while</span> (updateQueue.length &gt; <span class="number">0</span> &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    workLoop(deadline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3️⃣ 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度</span></span><br><span class="line">  <span class="keyword">if</span> (updateQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    requestIdleCallback(performWork);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>workLoop 的工作大概猜到了，它会从更新队列(updateQueue)中弹出更新任务来执行，每执行完一个‘执行单元‘，就检查一下剩余时间是否充足，如果充足就进行执行下一个执行单元，反之则停止执行，保存现场，等下一次有执行权时恢复。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前的处理现场</span></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork: Fiber | <span class="literal">undefined</span> <span class="comment">// 保存下一个需要处理的工作单元</span></span><br><span class="line"><span class="keyword">let</span> topWork: Fiber | <span class="literal">undefined</span>        <span class="comment">// 保存第一个工作单元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline: IdleDeadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span></span><br><span class="line">  <span class="keyword">if</span> (nextUnitOfWork == <span class="literal">null</span>) &#123;</span><br><span class="line">    nextUnitOfWork = topWork = getNextUnitOfWork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 🔴 每执行完一个Fiber执行单元，检查一次剩余时间</span></span><br><span class="line">  <span class="comment">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME) &#123;</span><br><span class="line">    <span class="comment">// 下文我们再看performUnitOfWork，DFS遍历：子节点-&gt;兄弟节点-&gt;父节点 </span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(nextUnitOfWork, topWork);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提交工作，下文会介绍</span></span><br><span class="line">  <span class="keyword">if</span> (pendingCommit) &#123;</span><br><span class="line">    commitAllWork(pendingCommit);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-4-Fiber节点"><a href="#1-4-Fiber节点" class="headerlink" title="1.4 Fiber节点"></a>1.4 Fiber节点</h4><p>每个 VirtualDOM 节点内部现在使用 Fiber表示，Fiber的部分结构如下所示，<strong>将简单的树结构，变成了基于单链表的树结构</strong>。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    alternate: FiberNode|null, // 替身：指向旧树中的节点</span><br><span class="line">    effectTag: SideEffectTag, // 标识当前节点的副作用类型，例如节点更新、删除、移动</span><br><span class="line">    nextEffect: FiberNode | null, // 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来</span><br><span class="line">    pendingWorkPriority: PriorityLevel, // 一个数字，标记子树上待更新任务的优先级</span><br><span class="line"></span><br><span class="line">    type: any, // Fiber 类型信息</span><br><span class="line">    stateNode: any, // 管理 instance 自身的特性，function组件值为null</span><br><span class="line">    return: FiberNode|null, // 指向 Fiber Tree 中的父节点</span><br><span class="line">    child: FiberNode|null, // 指向第一个子节点</span><br><span class="line">    sibling: FiberNode|null, // 指向兄弟节点</span><br><span class="line"></span><br><span class="line">    pendingProps: &#123;&#125;, // pendingProps在执行开始时设置，并在结束时设置memoizedProps。</span><br><span class="line">    memoizedProps: &#123;&#125;, // 当输入的pendingProps等于memoizedProps时，它表示fiber的先前输出可以重复使用，从而防止不必要的工作。</span><br><span class="line">    memoizedState: &#123;&#125;, // 组件实例的 state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-5-执行顺序"><a href="#1-5-执行顺序" class="headerlink" title="1.5 执行顺序"></a>1.5 执行顺序</h4><p>来看看 performUnitOfWork 的实现, 它其实就是一个深度优先的遍历：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>fiber 当前需要处理的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>topWork 本次更新的根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber: Fiber, topWork: Fiber</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 对该节点进行处理</span></span><br><span class="line">  beginWork(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果存在子节点，那么下一个待处理的就是子节点</span></span><br><span class="line">  <span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">    <span class="keyword">return</span> fiber.child;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有子节点了，上溯查找兄弟节点</span></span><br><span class="line">  <span class="keyword">let</span> temp = fiber;</span><br><span class="line">  <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">    completeWork(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到顶层节点了, 退出</span></span><br><span class="line">    <span class="keyword">if</span> (temp === topWork) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到，下一个要处理的就是兄弟节点</span></span><br><span class="line">    <span class="keyword">if</span> (temp.sibling) &#123;</span><br><span class="line">      <span class="keyword">return</span> temp.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有, 继续上溯</span></span><br><span class="line">    temp = temp.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为是单链表(A → B → C)的结构，所以在每次执行到某个节点(A → B)被中断后，下次可以从该节点(B → C)接着执行。<br>requestIdleCallback会让一个低优先级的任务在空闲期被调用，而requestAnimationFrame会让一个高优先级的任务在下一个栈帧被调用，从而保证了主线程按照优先级执行 fiber 单元。</p>
<blockquote>
<p>优先级顺序为：文本框输入 &gt; 本次调度结束需完成的任务 &gt; 动画过渡 &gt; 交互反馈 &gt; 数据更新 &gt; 不会显示但以防将来会显示的任务。</p>
</blockquote>
<p>因为react fiber机制，一个任务很可能执行到一半就被其他优先级更高的任务所替代，或者因为时间原因而被终止。当再次执行这个任务时，是从头开始执行一遍，就会导致组件的某些 will 生命周期可能被多次调用而影响性能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">fiber: Fiber</span>): <span class="title">Fiber</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.tag === WorkTag.HostComponent) &#123;</span><br><span class="line">    <span class="comment">// 宿主节点diff</span></span><br><span class="line">    diffHostComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.ClassComponent) &#123;</span><br><span class="line">    <span class="comment">// 类组件节点diff</span></span><br><span class="line">    diffClassComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.tag === WorkTag.FunctionComponent) &#123;</span><br><span class="line">    <span class="comment">// 函数组件节点diff</span></span><br><span class="line">    diffFunctionalComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ... 其他类型节点，省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-6-副作用的收集和提交"><a href="#1-6-副作用的收集和提交" class="headerlink" title="1.6 副作用的收集和提交"></a>1.6 副作用的收集和提交</h4><p>将所有打了 Effect 标记的节点串联起来，收集完成后再提交。<br>在<code>completeUnitOfWork ——&gt; completeWork</code>方法中遍历fiber节点，将标记了EffectTag的节点通过nextEffect串联起来</p>
<h4 id="1-7-两个阶段的拆分"><a href="#1-7-两个阶段的拆分" class="headerlink" title="1.7 两个阶段的拆分"></a>1.7 两个阶段的拆分</h4><p>首先，看React的渲染，包括两个阶段：协调阶段(reconciliation)和提交(渲染)阶段(commit)。</p>
<ol>
<li>调度阶段react根据数据更新virtual DOM，再运用diff算法找到需要VDOM change。这一部分的工作是可以拆分的。</li>
</ol>
<ul>
<li>constructor</li>
<li>componentWillMount 废弃</li>
<li>componentWillReceiveProps 废弃</li>
<li>static getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate 废弃</li>
<li>render</li>
</ul>
<ol start="2">
<li>提交阶段根据计算出的所有diff去一次性更新真实的DOM。</li>
</ol>
<ul>
<li>getSnapshotBeforeUpdate() 严格来说，这个是在进入 commit 阶段前调用</li>
<li>componentDidMount</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount<br>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。<br>需要注意的是：因为协调阶段可能被中断、恢复，甚至重做，⚠️React 协调阶段的生命周期钩子可能会被调用多次!, 例如 componentWillMount 可能会被调用两次。<br>因此建议 协调阶段的生命周期钩子不要包含副作用. 索性 React 就废弃了这部分可能包含副作用的生命周期方法，例如componentWillMount、componentWillUpdate. v17后我们就不能再用它们了, 所以现有的应用应该尽快迁移.</li>
</ul>
<p>Reconciliation完成后，会有一个旧树和一个WIP树，对于需要变更的节点，都打上了’标签’。在提交阶段，React 就会将这些打上标签的节点应用变更。</p>
<h4 id="1-8-双缓冲技术"><a href="#1-8-双缓冲技术" class="headerlink" title="1.8 双缓冲技术"></a>1.8 双缓冲技术</h4><p>WIP树就是一个缓冲，它在Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React会克隆复用旧树中的子树。另外一个重要的场景就是异常的处理。<br><strong>你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交(commit)阶段‘的提交一词的来源吧？</strong></p>
<h3 id="中断和恢复"><a href="#中断和恢复" class="headerlink" title="中断和恢复"></a>中断和恢复</h3><p><strong>到目前为止：⚠️更新任务还是串行执行的，我们只是将整个过程碎片化了. 对于那些需要优先处理的更新任务还是会被阻塞</strong><br><strong>但React Fiber已经实现了分片执行</strong><br><strong>实际情况是，在 React 得到控制权后，应该优先处理高优先级的任务。</strong>也就是说中断时正在处理的任务，在恢复时会让位给高优先级任务，原本中断的任务可能会被放弃或者重做。 =》 下一步是<strong>启用 Concurrent 模式（实验版本）</strong>: 开启Concurrent 模式后，之前 deprecated 的生命周期方法就彻底不能用了。<br><strong>Concurrent 模式通过使渲染可中断来修复此基本限制。</strong><br>(React Fiber 实际上非常复杂，不管执行的过程怎样拆分、以什么顺序执行，最重要的是保证状态的一致性和视图的一致性，这给了 React 团队很大的考验，以致于现在都没有正式release出来。?)</p>
<h4 id="Concurrent-Mode"><a href="#Concurrent-Mode" class="headerlink" title="Concurrent Mode"></a>Concurrent Mode</h4><ul>
<li>快速响应用户操作和输入，提升用户交互体验</li>
<li>让动画更加流畅，通过调度，可以让应用保持高帧率</li>
<li>利用好I/O 操作空闲期或者CPU空闲期，进行一些预渲染。比如离屏(offscreen)不可见的内容，优先级最低，可以让 React 等到CPU空闲时才去渲染这部分内容。这和浏览器的preload等预加载技术差不多。?</li>
<li>用Suspense 降低加载状态(load state)的优先级，减少闪屏。 比如数据很快返回时，可以不必显示加载状态，而是直接显示出来，避免闪屏；如果超时没有返回才显式加载状态。?</li>
</ul>
<p>REFs:</p>
<ul>
<li><a href="https://juejin.im/post/5dadc6045188255a270a0f85#heading-5" target="_blank" rel="noopener">这可能是最通俗的 React Fiber(时间分片) 打开方式</a></li>
<li><a href="https://juejin.im/post/5bca74cfe51d450e9163351b" target="_blank" rel="noopener">[译]以面试官的角度来看React工作面试</a></li>
<li><a href="https://juejin.im/post/5be969656fb9a049ad76931f" target="_blank" rel="noopener">浅析 React Fiber</a></li>
<li><a href="https://tech.youzan.com/react-fiber/" target="_blank" rel="noopener">浅谈React 16中的Fiber机制</a></li>
<li><a href="https://github.com/acdlite/react-fiber-architecture" target="_blank" rel="noopener">React Fiber Architecture</a></li>
<li><a href="https://my.oschina.net/u/4088983/blog/4545968" target="_blank" rel="noopener">从 0 实现 React 系列(一)：React 的架构设计</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sherrywu0917.github.io/2020/07/02/react-Fiber/" data-id="clsshtuwn001cwqrtocmcsdyd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/diff/">diff</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-animejs动画" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/27/animejs动画/" class="article-date">
  <time datetime="2019-12-27T03:26:12.000Z" itemprop="datePublished">2019-12-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/27/animejs动画/">animejs动画入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>anime.js是一个灵活的轻量JavaScript动画库，支持CSS属性、JS对象、DOM属性和SVG。压缩后仅6.2K，且不依赖任何第三方库，加载迅速。在<a href="https://github.com/juliangarnier/anime" target="_blank" rel="noopener">git</a>上Usedby数量8.5k, Star数量为37.5k。此外，anime遵从MIT开源协议,可应用于各种商业网站或app而无需付费。</p>
<h3 id="简单的浮动动画"><a href="#简单的浮动动画" class="headerlink" title="简单的浮动动画"></a>简单的浮动动画</h3><p>首先看一个简单的示例，实现了气泡的上下浮动动画，效果详见<a href="https://codepen.io/sherrywu0917/pen/yLyoNQj" target="_blank" rel="noopener">浮动动画</a>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> floatAnimation = anime(&#123;</span><br><span class="line">    targets: <span class="string">'.bubble'</span>,</span><br><span class="line">    translateY: <span class="number">20</span>, <span class="comment">// --&gt; '20px'</span></span><br><span class="line">    duration: <span class="number">600</span>,</span><br><span class="line">    loop: <span class="literal">true</span>,</span><br><span class="line">    direction: <span class="string">'alternate'</span>,</span><br><span class="line">    easing: <span class="string">'easeInOutSine'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>其中各个属性代表的含义如下：</p>
<ul>
<li><code>targets</code>代表动画的目标对象，这边的值是css选择器，也可以是dom元素、数组，或是JS对象；</li>
<li><code>translateY</code>代表将要发生动画的属性，不带单位的时候，默认单位为px，此外还支持其他多种赋值方式：<ol>
<li>百分比：<code>translateY: &#39;100%&#39;</code></li>
<li>相对数值：<code>translateY: { value: &#39;*=2.5&#39;,duration: 1000}</code>，相对于translateY的初始值去计算</li>
<li>设置初始值：<code>translateY: [100, 250]</code>，设置数组的形式，会将translateY的初始值设置为100px，并且从100px移动到250px</li>
<li>函数：<code>translateY: function(target, index, targetsLength) {return (targetsLength - index) * 50;}</code>, target为当前动画目标元素，index为动画目标的索引，targetsLength为总动画目标数</li>
</ol>
</li>
<li><code>duration</code>代表动画的持续时间，单位为毫秒；</li>
<li><code>loop</code>定义了动画是否需要循环，默认值为false；</li>
<li><code>direction</code>的意义和animation-direction属性一致，定义是否应该轮流反向播放动画，可选的值有正向动画<code>normal</code>、反向动画<code>reverse</code>和往返动画<code>alternate</code>；</li>
<li><code>easing</code>定义了动画缓动函数，和css3中的animation-timing-function意义一致，设置该参数时可以参考该网站<a href="https://easings.net/en" target="_blank" rel="noopener">Easing Functions Cheat Sheet</a>去选择合适的缓动函数。</li>
</ul>
<h3 id="点击触发抖动动画，结束后恢复浮动"><a href="#点击触发抖动动画，结束后恢复浮动" class="headerlink" title="点击触发抖动动画，结束后恢复浮动"></a>点击触发抖动动画，结束后恢复浮动</h3><p>基于上面的漂浮动画，新增一个小功能：点击小球的时候，小球左右抖动，抖动结束后，恢复浮动动画。具体效果参见<a href="https://codepen.io/sherrywu0917/pen/yLyoNQj" target="_blank" rel="noopener">抖动动画</a>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shakeAnimation = anime(&#123;</span><br><span class="line">    targets: <span class="string">'.bubble'</span>,</span><br><span class="line">    keyframes: [</span><br><span class="line">        &#123; <span class="attr">translateX</span>: <span class="string">'25px'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">translateX</span>: <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">translateX</span>: <span class="string">'-25px'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">translateX</span>: <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">translateX</span>: <span class="string">'15px'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">translateX</span>: <span class="number">0</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">translateX</span>: <span class="string">'-15px'</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">translateX</span>: <span class="number">0</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    duration: <span class="number">600</span>,</span><br><span class="line">    delay: <span class="number">300</span>,</span><br><span class="line">    endDelay: <span class="number">500</span>,</span><br><span class="line">    easing: <span class="string">'linear'</span>,</span><br><span class="line">    begin: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        floatAnimation.pause();</span><br><span class="line">    &#125;,</span><br><span class="line">    complete: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        floatAnimation.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这组动画的实现有几个关键点，<strong>关键帧</strong>-<code>keyframes</code>、<strong>延迟设置</strong>-<code>delay</code>、<code>endDelay</code>，<strong>事件函数</strong><code>begin</code>、<code>complete</code>以及<strong>动画控制方法</strong><code>play</code>和<code>pause</code>。<br>其中，<code>keyframes</code>是用数组定义的关键帧，和animation中用@keyframes实现动画的方式基本一致，如果关键帧内没有指定duration，则每个关键帧的持续时间将等于动画总持续时间除以关键帧数。<br><code>delay</code>和<code>endDelay</code>用来设置动画的延迟时间，完整的动画过程是：</p>
<ol>
<li>先触发begin事件，暂停floatAnimation；</li>
<li>过了delay设置的300ms后，开始执行keyframes定义的抖动动画，持续时间是600ms；</li>
<li>抖动动画结束后500ms，会触发complete事件，floatAnimation会恢复执行。<br>从start事件被触发到complete事件被触发，整个动画持续的时间为300 + 600 + 500 = 1400ms。<br><code>play</code>和<code>pause</code>方法用来控制动画的执行和暂停，animejs还提供了<code>restart</code>和<code>reverse</code>方法去控制动画的重新开始和反转，如果期望动画跳转到某个特定时间，可以使用<code>seek</code>方法去设置跳转时间。</li>
</ol>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>animejs从3.x版本开始不兼容webkitTransform属性，默认只支持transform属性，在一些低版本的手机上使用，例如ios8手机上，会遇到一些动画不生效的问题。如果需要兼容这些机型，可以给animejs库增加对webkitTrannsform属性的支持，手动修改源码，重新publish一个支持webkitTransform属性的npm包。<br>首先使用了animejs源码提供的<code>getCSSValue</code>方法去检测浏览器是否支持transform属性，对于不支持的，使用webkitTransform属性去替换，具体的修改可以参考下图。<br><img src="/image/webkit-anime.png" width="800px"><br><code>getCSSValue</code>方法的实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCSSValue</span>(<span class="params">el, prop, unit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (prop <span class="keyword">in</span> el.style) &#123;</span><br><span class="line">    <span class="keyword">var</span> uppercasePropName = prop.replace(<span class="regexp">/([a-z])([A-Z])/g</span>, <span class="string">'$1-$2'</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">var</span> value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> unit ? convertPxToUnit(el, value, unit) : value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键是<code>prop in el.style</code>的判断，对于不支持transform属性的值，会直接返回undefined，支持该属性的会返回属性值，没有设置过transform值的默认会返回一个字符串’none’或者’0’。<br>修改后重新发布了<a href="https://www.npmjs.com/package/webkit-animejs" target="_blank" rel="noopener">webkit-animejs</a>，有需要的可以直接使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sherrywu0917.github.io/2019/12/27/animejs动画/" data-id="clsshtuw3000cwqrtrdioex8u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-表单和post参数总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/26/表单和post参数总结/" class="article-date">
  <time datetime="2019-11-26T08:50:01.000Z" itemprop="datePublished">2019-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/26/表单和post参数总结/">表单和post参数总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>post请求下的content-type类型:</p>
<h3 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a>application/json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Request Payload:</span><br><span class="line">&#123;layouts: [&quot;1&quot;, &quot;2&quot;, &quot;5&quot;]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Query String Parameters</span><br><span class="line">sourceUuid:np_c3sEKMgU3Xau_Tl0fmsqyReIdKH9OXQpby_FSNhz__ppcy0EKQ</span><br><span class="line">articleUuid:np_eXoyZJwfsX-q8j5OLm0pyEbYGK0</span><br><span class="line">forceFollow:0</span><br><span class="line">isContinue:0</span><br><span class="line">forceAutoPurchase:1</span><br></pre></td></tr></table></figure>
<h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>使用表单上传文件时，必须让 form 的 enctype 等于这个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryBJIFBCE2CA2Fwbyl</span><br></pre></td></tr></table></figure></p>
<h3 id="text-xml"><a href="#text-xml" class="headerlink" title="text/xml"></a>text/xml</h3><p>例如XML-RPC请求。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">methodCall</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>examples.getStateName<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">params</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">i4</span>&gt;</span>41<span class="tag">&lt;/<span class="name">i4</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">methodCall</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>get请求的content-type只有application/x-www-form-urlencoded这一种。</p>
<p>form表单中action带有参数</p>
<ol>
<li>get表单请求<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"get"</span> <span class="attr">action</span>=<span class="string">"/somePage.html?param1=foo&amp;param2=foo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"param2"</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"param3"</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终得到的参数是：<br>Query String Parameters<br>param2: bar<br>param3: bar<br>get请求的表单在拼接参数的时候，会丢掉action指定的URL中带上的参数。</p>
<ol start="2">
<li>post表单请求：<br>enctype属性默认值是’application/x-www-form-urlencoded’，还支持’multipart/form-data’和’text/plain’<h4 id="application-x-www-form-urlencoded-1"><a href="#application-x-www-form-urlencoded-1" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/somePage.html?param1=foo&amp;param2=foo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"param2"</span> <span class="attr">value</span>=<span class="string">"bar"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"param3"</span> <span class="attr">value</span>=<span class="string">"baz"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终得到的参数是：<br>Query String Parameters<br>param1: foo<br>param2: foo</p>
<p>Form Data<br>param2: bar<br>param3: baz</p>
<h4 id="text-plain"><a href="#text-plain" class="headerlink" title="text/plain"></a>text/plain</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/somePage.html?param1=foo&amp;param2=foo"</span> <span class="attr">enctype</span>=<span class="string">"text/plain"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"param2"</span> <span class="attr">value</span>=<span class="string">"bar"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"param3"</span> <span class="attr">value</span>=<span class="string">"baz"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最终得到的参数是：<br>Query String Parameters<br>param1: foo<br>param2: foo</p>
<p>Request Payload<br>param2=bar<br>param3=baz</p>
<h3 id="fetch的get、post请求参数"><a href="#fetch的get、post请求参数" class="headerlink" title="fetch的get、post请求参数"></a>fetch的get、post请求参数</h3><ul>
<li>get，拼接到url上</li>
<li>post，参数放到body中<code>{body: JSON.stringify({p1: 1})}</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sherrywu0917.github.io/2019/11/26/表单和post参数总结/" data-id="clsshtuxg002zwqrtkdhmkpvk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-代码实现Record" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/代码实现Record/" class="article-date">
  <time datetime="2019-04-03T01:38:54.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/代码实现Record/">代码实现Record</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance</span>(<span class="params">Cls, ...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    Cls.apply(obj, params);</span><br><span class="line">    <span class="comment">// for(var key in Cls.prototype) &#123;</span></span><br><span class="line">    <span class="comment">//     obj[key] = Cls.prototype[key];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    obj[<span class="string">'__proto__'</span>] = Cls.prototype;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterStr</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(char !== <span class="string">'b'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(char === <span class="string">'c'</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> len = stack.length;</span><br><span class="line">                <span class="keyword">if</span>(stack[len <span class="number">-1</span>] === <span class="string">'a'</span>) &#123;</span><br><span class="line">                    stack.splice(len<span class="number">-2</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.push(char)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(char)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出0 1 2 3 4 5</span></span><br><span class="line"><span class="comment">//https://juejin.im/post/58cf180b0ce4630057d6727c#heading-1</span></span><br><span class="line"><span class="keyword">var</span> tasks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">        tasks.push(<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, j);</span><br><span class="line">                    resolve();</span><br><span class="line">                &#125;, <span class="number">1000</span> * j);  <span class="comment">// 这里修改 0~4 的定时器时间</span></span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出0 1 2 3 4 5</span></span><br><span class="line"><span class="keyword">var</span> tasks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    tasks.push(<span class="function">(<span class="params">(j</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, j);</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;, <span class="number">1000</span> * j);  <span class="comment">// 这里修改 0~4 的定时器时间</span></span><br><span class="line">        &#125;))(i)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出0 1 2 3 4 5</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">timeountMS</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, timeountMS);</span><br><span class="line">&#125;);</span><br><span class="line">(<span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>, i);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组</span></span><br><span class="line"><span class="keyword">var</span> arr = [ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>] ] ] ], <span class="number">10</span>];</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))).sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (a - b))</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://sherrywu0917.github.io/2019/04/03/代码实现Record/" data-id="clsshtux40027wqrta7yacfr7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-优化之路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/优化之路/" class="article-date">
  <time datetime="2019-04-03T01:38:54.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/优化之路/">前端优化-蹒跚学步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h1><p>项目是基于React开发，webpack打包的多页面h5应用，其中部分页面又是基于React-router的SPA。开发的过程中，也一直在尝试对项目进行优化，这儿主要记录了对<code>代码分片</code>、<code>持久化缓存</code>和<code>图片优化</code>的处理。</p>
<p>优化之路漫漫，蹒跚而来。</p>
<hr>
<h1 id="动态加载组件"><a href="#动态加载组件" class="headerlink" title="动态加载组件"></a>动态加载组件</h1><h2 id="Code-splitting-代码分片"><a href="#Code-splitting-代码分片" class="headerlink" title="Code splitting(代码分片)"></a>Code splitting(代码分片)</h2><p>当前端代码越来越复杂，代码体积越来越大时，需要考虑对加载的资源进行细粒度的分割，按需加载。<br>webpack支持两种语法实现动态地加载模块：</p>
<ul>
<li><p><a href="https://webpack.js.org/api/module-methods/#require-ensure" target="_blank" rel="noopener">require.ensure</a><br>给定 dependencies 参数，将其对应的文件拆分到一个单独的 bundle 中，此 bundle 会被异步加载。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies: <span class="built_in">String</span>[], <span class="attr">callback</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require</span>), <span class="title">chunkName</span>: <span class="title">String</span>)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://webpack.js.org/api/module-methods/#import-" target="_blank" rel="noopener">import</a><br>调用 import() 之处，被作为分离的模块起点，意思是，被请求的模块和它引用的所有子模块，会分离到一个单独的 chunk 中。会返回一个Promise对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="comment">/* webpackChunkName: "my-chunk-name" */</span></span><br><span class="line">  <span class="comment">/* webpackMode: "lazy" (default)*/</span></span><br><span class="line">  <span class="string">'path/to/module'</span>) -&gt; <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>webpackChunkName</code>用来设置chunk的名字；<code>webpackMode</code>默认值是<code>lazy</code>，还有<code>lazy-once</code>、<code>eager</code>、<code>weak</code>。按需加载的默认加载形式是async。<br>
        
          </p><p class="article-more-link">
            <a href="/2019/04/03/优化之路/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://sherrywu0917.github.io/2019/04/03/优化之路/" data-id="clsshtux8002gwqrt82ndncdm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSR/">SSR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Themis，CMS体验度量方案/">Themis，CMS体验度量方案</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/autobind/">autobind</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/core-decorators/">core-decorators</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/decorator/">decorator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/decorators源码简析——debounce/">decorators源码简析——debounce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/diff/">diff</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/echarts/">echarts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es7/">es7</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eventloop/">eventloop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/font-face/">font-face</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hook/">hook</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lazyInitialize/">lazyInitialize</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/load/">load</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/loader/">loader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lottie/">lottie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm包/">npm包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/readonly/">readonly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/require/">require</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sass/">sass</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setState/">setState</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sitespeed-io/">sitespeed.io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webp/">webp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/下载/">下载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/兼容/">兼容</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数式编程/">函数式编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端性能优化/">前端性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端打包/">前端打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原型链/">原型链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/总结/">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/渲染/">渲染</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组件开发/">组件开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合式继承/">组合式继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/继承/">继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/角度渐变/">角度渐变</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/高阶组件/">高阶组件</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/SSR/" style="font-size: 10px;">SSR</a> <a href="/tags/Themis，CMS体验度量方案/" style="font-size: 10px;">Themis，CMS体验度量方案</a> <a href="/tags/autobind/" style="font-size: 10px;">autobind</a> <a href="/tags/core-decorators/" style="font-size: 15.71px;">core-decorators</a> <a href="/tags/css/" style="font-size: 12.86px;">css</a> <a href="/tags/decorator/" style="font-size: 17.14px;">decorator</a> <a href="/tags/decorators源码简析——debounce/" style="font-size: 11.43px;">decorators源码简析——debounce</a> <a href="/tags/diff/" style="font-size: 14.29px;">diff</a> <a href="/tags/echarts/" style="font-size: 10px;">echarts</a> <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/es7/" style="font-size: 10px;">es7</a> <a href="/tags/eventloop/" style="font-size: 11.43px;">eventloop</a> <a href="/tags/font-face/" style="font-size: 10px;">font-face</a> <a href="/tags/hook/" style="font-size: 10px;">hook</a> <a href="/tags/js/" style="font-size: 18.57px;">js</a> <a href="/tags/lazyInitialize/" style="font-size: 10px;">lazyInitialize</a> <a href="/tags/load/" style="font-size: 10px;">load</a> <a href="/tags/loader/" style="font-size: 10px;">loader</a> <a href="/tags/lottie/" style="font-size: 10px;">lottie</a> <a href="/tags/npm包/" style="font-size: 10px;">npm包</a> <a href="/tags/react/" style="font-size: 20px;">react</a> <a href="/tags/readonly/" style="font-size: 10px;">readonly</a> <a href="/tags/require/" style="font-size: 10px;">require</a> <a href="/tags/sass/" style="font-size: 10px;">sass</a> <a href="/tags/setState/" style="font-size: 10px;">setState</a> <a href="/tags/sitespeed-io/" style="font-size: 10px;">sitespeed.io</a> <a href="/tags/webp/" style="font-size: 10px;">webp</a> <a href="/tags/webpack/" style="font-size: 14.29px;">webpack</a> <a href="/tags/下载/" style="font-size: 10px;">下载</a> <a href="/tags/兼容/" style="font-size: 11.43px;">兼容</a> <a href="/tags/函数式编程/" style="font-size: 10px;">函数式编程</a> <a href="/tags/前端性能优化/" style="font-size: 12.86px;">前端性能优化</a> <a href="/tags/前端打包/" style="font-size: 10px;">前端打包</a> <a href="/tags/原型链/" style="font-size: 10px;">原型链</a> <a href="/tags/总结/" style="font-size: 12.86px;">总结</a> <a href="/tags/插件/" style="font-size: 10px;">插件</a> <a href="/tags/渲染/" style="font-size: 12.86px;">渲染</a> <a href="/tags/组件开发/" style="font-size: 10px;">组件开发</a> <a href="/tags/组合式继承/" style="font-size: 10px;">组合式继承</a> <a href="/tags/继承/" style="font-size: 11.43px;">继承</a> <a href="/tags/角度渐变/" style="font-size: 10px;">角度渐变</a> <a href="/tags/高阶组件/" style="font-size: 10px;">高阶组件</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/02/19/rrweb原理&录屏上报实践/">rrweb带你还原问题现场</a>
          </li>
        
          <li>
            <a href="/2024/02/19/react相关问题V2/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/02/19/module引入方式/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/02/19/js_roadmap/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/11/02/webpack-loader总结/">webpack-loader总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 Sherry<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>